---
title: RK3588 SDK
toc: true
authors:
  - EndlessPeak
date: 2024-07-01
hidden: false
draft: false
weight: 1
description: 本文记录了关于 ATK-DLRK3588 SDK 的相关内容。
---

## SDK
### SDK Content
RK3588 平台上的SDK(Software Development Kit)软件开发套件主要分为两类：
1. 瑞芯微原厂提供的SDK 
2. 开发板销售商提供的SDK

目前，ATK-DLRK3588开发板提供的SDK属于后者，它集成了：
1. Linux Kernel 5.10
2. U-Boot 2017.09
3. Rootfs
4. RK Development tool
5. Documentation

### ATK-DLRK3588 SDK
获取该SDK需要Linux环境，下以Ubuntu环境说明获取步骤，但实际上操作方法并不仅限于Ubuntu Linux。

> 注意版本：
> 正点原子官方使用的是 Ubuntu 20.04，事实上我测试了Ubuntu 24.04也没有问题，只需要一些额外的操作。

1. 安装SDK依赖
2. 配置Git
3. 解包SDK的版本控制文件（repo）
4. 同步repo

### SDK Dependency
需要安装如下依赖：
```bash
sudo apt update 
sudo apt install git ssh make gcc libssl-dev liblz4-tool expect \
expect-dev g++ patchelf chrpath gawk texinfo chrpath diffstat \
binfmt-support qemu-user-static live-build bison flex fakeroot \
cmake gcc-multilib g++-multilib unzip device-tree-compiler ncurses-dev \
bzip2 expat gpgv2 cpp-aarch64-linux-gnu libgmp-dev \
libmpc-dev bc python-is-python3 python2
```

说明如下：
#### APT & APT-GET
关于 `apt` 和 `apt-get`：
1. 原来使用 `apt-get` 来安装，但在 ubuntu 16.04 以后，更推荐使用 `apt` 直接安装；
2. 下列情况必须需要使用 `apt-get`:
   1. 使用 `dist-upgrade` 智能处理依赖关系，完成升级；
   2. 使用 `dselect-upgrade` 

#### Python2
关于 `python2`：
1. 在 ubuntu 24.04 软件仓库中不再提供 python2 的安装
2. 手动安装 python2 步骤如下：
   ```bash
   wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz
   tar -zxvf Python-2.7.9.tgz -C .
   ./configure --enable-optimizations # 配置编译环境，启用优化选项
   sudo make altinstall # altinstall 不会创建名为 python 的符号链接
   ```

### Git Configuration
使用 repo 之前需要用户配置自己的 git 信息:

```bash
git config --global user.name "your name"
git config --global user.email "your email"
git config --global --list # 检查一下配置
```

### Checkout Source
先将压缩包复制到指定位置，然后解包并检出源码。
```bash
cp atk-rk3588_linux_release_v1.0_20240601.tgz /path/to/location
tar -zxvf atk-rk3588_linux_release_v1.0_20240601.tgz -C atk-rk3588_linux_sdk
cd atk-rk3588_linux_sdk
.repo/repo/repo sync -l -j 16
# 最终的 repo 实际上是 python 脚本，如果不能直接解释，也可以手动指定解释器：
python .repo/repo/repo sync -l -j 16
```
## SDK Develop
### SDK Compile
#### Auto Compile
以下将SDK所在的目录称为`$SDK_DIR`，与SDK里脚本定义的变量保持一致。
第一次同步SDK后建议自动编译一次SDK，目的是：
1. 指定板级生成文件 `alientek_rk3588_defconfig` ，它将生成配置文件到`$SDK_DIR/.config`。
2. 编译生成下列镜像文件（不支持单独编译生成）：
   1. `misc.img` 烧录到 misc 分区，可用于 bootloader 到 recovery 或其他分区
   2. `oem.img` 给厂家使用
   3. `parameter.txt` 分区表文件，RK开发工具据此创建分区
      该文件可以直接从 `$SDK_DIR/device/rockchip/.chips/rk3588/parameter.txt` 拷贝
   4. `userdata.img` 给最终用户使用
3. 编译生成下列镜像文件（支持单独编译生成）：
   1. `MiniLoaderAll.bin` 最先运行的 Loader 代码
      1. 由 TPL 和 SPL 两部分组成
      2. TPL 运行在 SRAM，主要用于初始化 DDR，
      3. SPL 运行在 DDR，主要负责加载、引导 uboot.img
   2. `uboot.img` FIT格式镜像，包括：
      1. trust 镜像 (ARM Trusted Firmware + OP-TEE OS)
      2. u-boot 镜像
      3. u-boot 设备树二进制(DTB,Device Tree Blob,下同)
   3. `boot.img` FIT 格式镜像，包括：
      1. 内核镜像
      2. 内核设备树二进制
      3. 资源镜像 resource.img 包含设备树二进制、启动 logo 等资源
   4. `rootfs.img` 正常启动模式下对应的根文件系统 rootfs
   5. `recovery.img`
4. 将上述所有镜像合成为 `update.img`

> 编译前记得把提供的 `dl.tgz` 解压到 `buildroot` 中的 `dl` 文件夹中，因为 buildroot 依赖很多第三方软件，现场下载速度较慢，而且有少数软件网址已失效。

步骤如下：
```bash
./build.sh lunch
./build.sh all
```
#### Sperate Compile
能够支持单独编译的有三部分:
1. `uboot`
   执行命令 `./build.sh uboot` 生成 `uboot.img`
2. `kernel`
   1. 编译内核 `./build.sh kernel` 生成 `boot.img`
   2. 编译恢复分区 `./build.sh recovery` 生成 `recovery.img`
3. `rootfs`
   1. 官方支持的根文件系统包括 `buildroot` 和 `debian`
   2. 官方提供了 `yocto` 但不建议使用
   3. 可以自行制作基于linux发行版的根文件系统

最终可以执行`./build.sh updateimg`将所有的镜像打包成整体 `update.img`，但我认为这个功能并不适合开发。

### SDK Clean
在 SDK 根目录下执行如下命令可对整个 SDK 进行清理:
```bash
./build.sh cleanall
```
也可执行如下命令对各模块进行清理:
```bash
./build.sh clean:loader # 清理 U-Boot
./build.sh clean:kernel # 清理 Linux 内核
./build.sh clean:recovery # 清理 recovery
./build.sh clean:rootfs # 清理 rootfs
```

### SDK Configuration
配置 SDK 分为四个部分：
1. 对 SDK 进行板级配置
2. 对 Uboot 进行配置
3. 对 Kernel 进行配置
4. 对 Rootfs 进行配置

#### SDK Board Configuration
1. 在 `$SDK_DIR` 根目录下执行 `make menuconfig` 即可配置
2. 配置后保存位置在 `$SDK_DIR/output/.config` 处。
3. 正点原子文档描述配置后执行 `make saveddefconfig`，将配置保存到当前目录下 
   1. 个人感觉没用，因为 `make menuconfig` 读取的是 `$SDK_DIR/output/.config`
   2. 除非去替换 `$CHIP_DIR/defconfig` 文件

#### Kernel Configuration
内核配置需要注意：
1. 下列操作会**重新**生成 `.config` 文件
   1. 在上级目录 `$SDK_DIR` 中执行 `./build.sh kernel` 
   2. 在本级目录 `$SDK_DIR/kernel` 中执行 `./make.sh board=ATK_DLRK3588`
2. 如需配置内核后编译，有两种办法：
   1. 在 `$SDK_DIR/kernel` 目录中编译（我没试过）
   2. 用生成好的配置替换 `$SDK_DIR/kernel/arch/arm64/configs/rockchip_linux_defconfig` ，然后再编译
3. 其他注意事项：
   1. 默认不开启 exfat 文件系统支持，需要打开
   2. 注意架构，配置时执行 `make ARCH=arm64 menuconfig` 否则生成的内核无法运行

#### External Device
有一些不包含在内核驱动中的设备需要驱动，为此需要提供对应的内核模块，如：
1. `$SDK_DIR/external/rkwifibt/drivers/rtl8733bu/8733bu.ko`
2. ...

问：如何知道我需要哪些内核模块？

答：
1. 编译 `buildroot` 并挂载生成的镜像 `rootfs.img` ，从 `/lib/modules` 中将所有内核模块拷贝出来
2. 当然也可以看明白 `external` 中是怎么编译这些模块的，然后手动编译它们并拷贝到指定位置
3. 这些模块可以在配置内核时指明以模块形式加载，也可以手动放到系统中指定的路径 `/lib/modules` ，然后每次开机手动用 `insmod` 或脚本加载。
4. 也可以写一个脚本查找 `$SDK_DIR` 中编译了哪些模块
   ```bash
   #!/bin/bash

   # 检查是否提供了输入目录参数
   if [ -z "$1" ]; then
       echo "Usage: $0 <input_directory>"
       exit 1
   fi

   # 设置输入目录变量
   input_directory="$1"

   # 检查输入目录是否存在
   if [ ! -d "$input_directory" ]; then
       echo "Error: Directory $input_directory does not exist."
       exit 1
   fi

   # 查找并打印所有以 .ko 结尾的文件
   find "$input_directory" -type f -name "*.ko" -print
   ```
5. 如果需要排除 kernel 目录中的模块，可以修改脚本为：
   ```bash
   #!/bin/bash

   # 检查是否提供了输入目录参数
   if [ -z "$1" ]; then
       echo "Usage: $0 <input_directory> [exclude_directories]"
       echo "Example: $0 /path/to/dir '/path/to/exclude1 /path/to/exclude2'"
       exit 1
   fi
   
   # 设置输入目录变量
   input_directory="$1"
   exclude_directories=()
   
   # 检查是否提供了排除目录参数
   if [ ! -z "$2" ]; then
       IFS=' ' read -r -a exclude_directories <<< "$2"
   fi
   
   # 检查输入目录是否存在
   if [ ! -d "$input_directory" ]; then
       echo "Error: Directory $input_directory does not exist."
       exit 1
   fi
   
   # 构建find命令
   find_cmd="find \"$input_directory\" -type d \( "
   
   # 添加排除目录
   for dir in "${exclude_directories[@]}"; do
       find_cmd+=" -path \"$dir\" -o"
   done
   
   # 移除最后的 -o 并完成命令
   find_cmd="${find_cmd% -o} \) -prune -o -type f -name \"*.ko\" -print"
   
   # 运行find命令
   eval $find_cmd
   ```