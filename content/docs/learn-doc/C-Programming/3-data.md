---
title: 3-数据
---

# 数据

## 内容概览

**关键字**:int,short,long,unsigned,char,float,double

**运算符**:sizeof()

**数据类型**:整型，浮点型

**函数**:printf(),scanf()

## 变量与常量

**数据**，即承载信息的数字和字符。

有些数据类型在程序使用之前已经预先设定好了，在程序的生命周期中没有变化，称为**常量**。

其他数据类型在程序运行期间可能会改变或被赋值，称为**变量**。

C语言通过识别基本的数据类型来区分和使用它们。

**常量识别：**如果数据是常量，编译器一般通过用户书写的形式来识别类型。如，42是整数，42.100是浮点数。

**变量声明：**使用数据类型关键字指明数据为何种数据类型。

基本数据类型均属于关键字。

- `int`关键字表示基本的整数类型
- `long`、`short`、`unsigned`和C90新增的`signed`用于提供基本整数类型的变式
  - 例如`unsigned short int`和`long long int`等。
- `char`关键字用于指定字母和其他字符（如，#、$、%和*）。
  - `char`类型也可以表示较小的整数。用`float`、`double`和`long double`表示带小数点的数。

**注意**

通常单个数据类型关键字表示的是有符号数据类型。

`int`表示的是`signed int`，`char`表示的是`signed char`，`float`和`double`同理，分别表示的是`signed float`和`signed double`。不过在实际应用中必须注意，仅整型数据可增加`signed`和`unsigned`修饰符，实型数据不能加。

`char`类型用于存储字符，但是实际上存储的是“较小”的整数，由于该数据类型占1个字节，共8 bit位；它最高位为符号位，0表示正，1表示负，故容易得到最大表示值为0111 1111；最小值为1111 1111。换算成十进制为$-2^{7}$~$2^{7}-1$ ，即$-128$~$127$

**归纳**

对于有符号数据类型，设占$k$个字节，$n=8k$，则该数据类型表示范围为$-2^{n-1}$~$2^{n-1}-1$

**易错点：值溢出**

若有代码 `char a=128;printf("a=%d", a);`问输出的值？

若改为`char a=127`、`char a=255`、`char a=256`，输出又是多少？

解答：

1.  `char a=127`时输出`a=127`;
2. `char a=128`时输出`a=-128`;
3. `char a=255`时输出`a=-1`;
4. `char a=255`时输出`a=0`。

注意C90和C99标准增加的内容如下：

- `_Bool`类型表示布尔值
- `_Complex`类型表示复数
- `_Imaginary`表示虚数。

| K&R 关键字 | C90标准新增 | C99标准新增 |
| ---------- | ----------- | ----------- |
| int        | signed      | _Bool       |
| long       | void        | _Complex    |
| short      |             | _Imaginary  |
| unsigned   |             |             |
| char       |             |             |
| float      |             |             |
| double     |             |             |

## 整数与浮点数

**整数**：没有小数部分的数。计算机以二进制存储整数。

**浮点数**：类似数学中的实数。在一个整数值后面加上一个小数点，该数就成为一个浮点值。

**科学计数法**：使用E表示使用科学计数法，E后面的数字表示10的乘方数。

浮点数和整数的储存方案不同，计算机把浮点数分成**符号部分**、**小数部分**和**指数部分**来表示，而且将它们分开储存。因此，虽然7.0和7在数值上相同，但是它们的储存方式不同。在十进制下7.0可以表示为0.7E1，它们都是浮点数。其中0.7是小数部分，1是指数部分。

**易错点：整数与浮点数的精度**

由于在任何区间内都存在无穷多个实数，所以浮点数不能表示区间内所有的值。

通常，计算机存储的浮点数只是实际值的近似值，例如浮点数7.0由于存储的时候按照0.7和1分别存储，0.7在转换为二进制小数时是无限循环小数，舍去循环部分时它的实际储存值可能为0.69999，因此浮点数7.0的实际值可能为6.9999（当然一般这种比较小的数储存是正确的，但在数较大的时候就会丢失部分精度）。

因此，对于一些算术运算（如两个很大的数相减），**浮点数损失的精度更多**。

## 基本数据类型

### int类型

如前所述，通常单个数据类型关键字表示的是有符号数据类型；设数据类型占$k$个字节，即占$n=8k$位，则该数据类型表示范围为$-2^{n-1}～2^{n-1}-1$

由上可得，int类型是有符号整型。

1. 32位机器上int占用$4 bytes$，$1 byte=8 bit$，范围为$-2^{31}～2^{31}-1$，即$-2147483648～2147483647$
2. 16位机器上int占用$2bytes$，$1 byte=8 bit$，范围为$-2^{15}～2^{15}-1$，即$-32768～32767$

声明时的用法：

1. 单变量声明：`int nums`;

2. 多变量声明：`int dogs,cows,goats`;

3. 多变量声明及初始化：`int dogs,cows=1,goats; //有效，通常见于考试出题`

4. 十进制赋值：不增加前缀。

   十进制显示：使用`%d`

5. 八进制赋值：增加0前缀。如`int a=010;printf("%d",a)`得`a=8`

   八进制显示：使用`%o`；如`int a=010;printf("%o",a)`得`a=10`

   显示八进制前缀：使用`%#o`；如`int a=010;printf("%#o",a)`得`a=010`

6. 十六进制赋值：增加0x前缀。如`int a=0x10;`，则`printf("%d",a)`得`a=16`

   十六进制显示：使用`%x`；如`int a=0x10;printf("%#x",a)`得`a=10`

   显示十六进制前缀：使用`%#x`；如`int a=0x10;printf("%#x",a)`得`a=0x10`

#### 其他整数类型

C语言提供3个附属关键字修饰基本整数类型：`short`、`long`和`unsigned`。

1. `short int`类型（或者简写为short，短整型）是有符号类型，可简记为16位int

   占用的存储空间为$2bytes$，常用于较小数值的场合以节省空间。

   表示范围为$-2^{15}$～$2^{15}-1$，即$-32768$～$32767$

   `unsigned short int`表示范围为$0$～$2^{16}-1$，即$0$～$65535$

2. `long int`类型（或简写为long，长整型）是有符号类型，可简记为32位int

   占用的存储空间为$4bytes$，适用于较大数值的场合。

   表示范围为$-2^{31}$～$2^{31}-1$，即$-2147483648$～$2147483647$

   `unsigned long int`表示范围为$0$～$2^{32}-1$，即$0$～$4294967295$

3. `long long int`类型（或long long，C99标准加入，双长型）是有符号类型，可简记为64位int

   占用的储存空间至少为$8bytes$，适用于更大数值的场合。

   表示范围为$-2^{63}$～$2^{63}-1$，即$-9223372036854775808$～$9223372036854775807$

   `unsigned long long int`表示范围为$0$～$2^{64}-1$，即$0$～$18446744073709551615$

基本上整数类型均可添加`unsigned`关键字，添加后用于非负值场合，若设数据类型占$k$个字节，$n=8k$，则该数据类型表示范围为$0$～$2^{n}-1$，这是因为用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。

1. 对于`short`可以使用`h`前缀，如

   `short int` 使用 `%hd`表示十进制，使用 `%ho`表示八进制，使用 `%hx`表示十六进制

2. 对于`long` 可以使用`l`前缀，如

   `long int`使用 `%ld`表示十进制，使用 `%lo`表示八进制，使用 `%lx`表示十六进制

3. 对于`long long` 可以使用`ll`前缀，如

   `long long int`使用 `%lld`表示十进制，使用 `%llo`表示八进制，使用 `%llx`表示十六进制

4. 存在`unsigned`前缀且需要用十进制表示时用`%u`替换`%d`，其他时候不变。

**程序实例**

```c
/* toobig.c-- 超出系统允许的最大值*/
#include　<stdio.h>
int main(int args,char *argv[]){
    int　i　=　2147483647;
    unsigned　int　j　=　4294967295;
    printf("%d　%d　%d\n",　i,　i+1,　i+2);
    printf("%u　%u　%u\n",　j,　j+1,　j+2);
    return　0;
}
```

输出结果：

```
2147483647	-2147483648	-2147483647
4294967295	0	1
```

即当数据溢出最大值时，系统并未通知用户，因此编程时必须注意这类问题。

### char类型

字符常量：用单引号括起来的单个字符被称为字符常量。如'A'

声明时的用法：

1. `char id;`
2. `char id='T';//不能改为T或者"T"，前者是变量，后者是字符串`
3. `char id='ABCDEFG';//这样赋值的结果是id的值为'G'` 

输出时的用法：

1. `%c`为`char`输出字符格式，`%d`为`char`输出整数格式。
2. `%s`为`char *`输出字符串格式。
2. `printf`中的转换说明决定数据的显示方式，而不是储存方式。

**易错点：字符类型的存储**

<u>第一，C语言将字符常量视为int类型而非char类型！</u>

例如对于`char grade='8';`拆解如下：

grade是char类型变量，允许数值范围1字节，即 0 ～ 0xFF

'8'是字符常量，相当于`int x='8';`允许的数值范围是4字节，即 0 ～ 0xFFFFFFFF

因此上述语句实际等价于`char grade=(char)'8';`或者`char grade=(0xFF & '8');`

另外需要注意0xFF & 在此用作保留位数，如保留最低8位，使用0xFF；保留8-16位，使用0xFF00；依次类推。

<u>第二，C语言允许用`signed`或`unsigned`修饰`char`</u>

该点在用`char`处理小整数时很有用；如果处理字符，则无需任何修饰符。

#### 非打印字符

使用ASCII码表示或使用特殊符号表示的字符。这些符号序列又称为转义序列。

| 转义序列 | 表示字符   | 含义                                           |
| -------- | ---------- | ---------------------------------------------- |
| \a       | 警报符号   | 使计算机产生一次蜂鸣警报                       |
| \b       | Backspace  | 移回一个空格                                   |
| \f       | 换页符     | 换到下一页                                     |
| \n       | 换行符     | 移到下一行                                     |
| \r       | 回车符     | 光标返回至当前行行首，用于套印                 |
| \t       | 水平制表符 | 移动到下一水平制表位，相当于Tab                |
| \v       | 垂直制表符 | 移动到下一垂直制表位                           |
| \\\      | 反斜线     | 插入一个反斜线字符                             |
| \\'      | 单引号     | 插入单引号                                     |
| \\"      | 双引号     | 插入双引号                                     |
| \?       | 问号       | 插入问号                                       |
| \0       | 空字符     | 插入一个空字符，它被定义为具有数值0            |
| \0oo     | 八进制值   | oo是有效的八进制数，每个o可表示0-7中的一个数   |
| \xhh     | 十六进制值 | hh是有效的十六进制数，每个h可表示0-f中的一个数 |

特别注意：

1. 不是所有转义字符在所有的显示设备上都起作用。例如换页符和垂直制表符号在电脑显示屏幕上会生成奇怪的符号而并不会造成光标的移动。仅在打印机上才会产生前面的效果。
2. 用其他进制表示一个字符，需要在编码值前面加一个反斜杠并用单引号括起来。
   1. 用八进制ASCII码表示字符，如`beep='\007'`，八进制表示时可以省略前面的0，`\07`、`\7`都可以。
   2. 用十六进制ASCII码表示字符，如`enter=\xa`

看下面转义字符例子：

```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    float salary;
    printf("\aEnter your desired monthly salary:");
    printf("$_______\b\b\b\b\b\b\b");
    scanf("%f",&salary);
    printf("\n\t$%.2f a month is $%.2f a year",salary,salary*12.0f);
    printf("\rGee!\n");
    return 0;
}
```

### Bool类型

C99标准新增`_Bool`类型用于表示布尔值，即逻辑值`true`和`false`。

实际上C语言用1表示`true`，用0表示`false`。故而`_Bool`类型实际上是一种整数类型，占用1位存储空间。

为了与C++兼容，可添加头文件`<stdbool.h>`，从而用`bool`声明变量。

### 可移植类型

C99标准新增`stdint.h`和`inttypes.h`，用于确保类型在各系统中功能相同。

| 16位平台                  | 32位平台              | 64位平台                |
| ------------------------- | --------------------- | ----------------------- |
| char    1个字节8位        | char    1个字节8位    | char    1个字节8位      |
| short  2个字节16位        | short  2个字节16位    | short  2个字节16位      |
| **int       2个字节16位** | int       4个字节32位 | int       4个字节32位   |
| long    4个字节32位       | long    4个字节32位   | **long    8个字节64位** |
| /                         | long long 8个字节64位 | long long 8个字节64位   |
| **指针    2个字节**       | 指针    4个字节       | **指针    8个字节**     |

#### 精确宽度整数类型

保证所表示的类型是固定的精确宽度。

例如：

1. 在使用32位int的系统中，`int32_t`作为int的别名
2. 在使用16位int，32位long的系统中，`int32_t`作为long的别名。

```c
//altnames.c 可移植整数类型
#include <stdio.h>
#include <stdbool.h> 
#include <inttypes.h> //支持可移植类型
 
int main()
{
	int32_t me32; //me32是一个32位有符号整型变量
	me32=45933945;
	printf("me32 = %d\n",me32);
	printf("me32 = %" PRId32 "\n",me32);
    /* 
     * 参数PRId32被inttypes.h中的"d"替换
     * C语言又会把多个连续的字符串合并为一个字符串
     * 因此最终等价于上一条语句
    */
	return 0;
}
```

#### 最小宽度整数类型

当系统不支持精确宽度整数类型时，一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。

例如：

`int_least8_t`被定义为可容纳8位有符号整数值的类型中宽度最小的类型的别名。

即使某系统最小整数类型是16位，未定义`int8_t`类型，仍可使用`int_least8_t`类型，系统自动将之实现为16位的整数类型。

#### 最快最小宽度类型

例如：

`int_fast8_t`被定义为系统中对8位有符号值而言运算最快的整数类型别名。

#### 最大整数类型

最大有符号整数类型`intmax_t`，32位机器上一般等价于`long long`，64位机器上一般等价于`long`或`long long`。

最大无符号整数类型`uintmax_t`，32位机器上一般等价于`unsigned long long`，64位机器上一般等价于`unsigned long`或`unsigned long long`。

### 浮点类型

1. float类型，至少能表示保留6位有效数字，取值范围至少是$1.175*10^{-38}$ ～ $3.402*10^{+38}$

   系统储存float类型浮点数通常占用4字节，共32位，1位(31)表示符号，8位(30-23)表示指数和符号，后23位(22-0)表示非指数部分（尾数或有效数）及符号。

   > 保留6位有效数字的理解见下面的程序

   ```c
   /* floaterror.c */
   #include<stdio.h>
   int main(int argc, char *argv[])
   {
       float a,b;
       b=2.0e20;
       printf("%f \n",b);
       b=b+1.0;
       printf("%f \n",b);
       a=b-2.0e20;
       printf("%f \n",a);
       return 0;
   }
   ```

   > 计算机缺少足够的小数位来完成正确的运算，该浮点数有21位有效数字，浮点数最多能表示6-7位有效数字，因此计算一定是错误的。

2. double类型，(标准要求至少能表示保留10位有效数字) 实际上至少能表示15-16位有效数字，取值范围至少是$1.7*10^{-308}$ ～ $1.7*10^{+308}$（待参考其他资料）

   系统储存double类型浮点数通常占用8字节，共64位，1位(63)表示符号，11位(62-52)表示指数和符号，后52位(51-0)表示非指数部分（尾数或有效数）及符号。

   long double类型能表示18-19位有效数字，浮点数占用12字节，共96位。

   > 将上述程序改为double，位数减为15，可以得到正确结果。

3. 浮点型常量的写法

   有符号数字(包括小数点)+e/E+有符号数字(指数)

   正号可以省略，可以省略小数点(2E5)或指数部分(19.28)，但不能同时省略两者；可以省略小数部分(3.E16)或整数部分(.45E-6)，但不能同时省略两者。

   **不能在浮点型常量中加空格**！

4. 十六进制表示法

   在十六进制数前加上十六进制前缀(0x或0X)，用p和P代替e和E(即用2的幂代替10的幂)。

   例如`0xa.1fp10=(10+1/16+15/256)*1024`

5. 浮点类型的比较

   **不可将浮点变量用“\==”或“!=”与任何数字比较!**

   无论是float还是double类型的变量，都有精度限制。应该设法转化成“> =”或“ <=”形式。 

   `if((x> =-epsilon)  &&  (x <=epsilon))`  其中epsilon是允许的误差（即精度）。

   ```c
   const double eps = 1e-8;//10^-8
   //为了方便使用，可以定义如下的宏
   #define Equ(a,b) (fabs(a-b)<eps)
   #define More(a,b) (a-b>eps)
   #define Less(a,b) (a-b<-eps)
   #define MoreEqu(a,b) (a-b>-eps)
   #define LessEqu(a,b) (a-b<eps)
   ```

6. 浮点数的运算

   通常浮点数被假定为double类型，如果运算结果类型是float，这样会减慢运行速度。

   在浮点数常量后面加上f或F后缀可以覆盖为float类型；；加上l或L后缀可以覆盖为long double类型。

7. 浮点数打印

   使用`%f`作为float和double的输出格式，`%lf`作为double的输出格式。

   使用`%e`作为指数记数法的浮点数。如果支持十六进制，可用`a`和`A`代替`e`和`E`。

   使用`%Lf`、`%Le`、`%La`作为long double的输出格式。
   
   
    ```c
    /* showf_pt.c 以多种方式显示浮点类型的值*/
    #include <stdio.h>
    int main(int argc, char *argv[])
    {
        float aboat=32000.0;
        double abet=2.14e9;
        long double dip=5.32e-5;
        printf("%f can be written %e or %a\n",aboat,aboat,aboat);
        printf("%f can be written %e or %a\n",abet,abet,abet);
        printf("%Lf can be written %Le or %La\n",dip,dip);
        return 0;
    }
    ```
   
8. 浮点数的上溢和下溢

   上溢时显示inf或infinity（无穷大）。

   ```c
   float toobig=3.4E38*100.0f;
   printf("%e\n",toobig);
   ```

   下溢时损失精度（尾数的末尾位被舍去）。

   ```c
   float toosmall=1.17549E-38;
   for(int i=0;i<5;i++){
       toosmall=toosmall/10.0f;
       printf("%e\n",toosmall);
   }
   ```

   还有一种特殊的浮点值为NaN(Not a number)。例如传入正余弦值，超出范围则返回结果为NaN。

### 复数和虚数类型

该部分略。

## 数据存储

### 数据类型大小

使用`sizeof()`函数计算数据类型的大小。

```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    printf("Type int has a size of %zd bytes.\n",sizeof(int));
    printf("Type char has a size of %zd bytes.\n",sizeof(char));
    printf("Type long has a size of %zd bytes.\n",sizeof(long));
    printf("Type long long has a size of %zd bytes.\n",sizeof(long long));
    printf("Type double has a size of %zd bytes.\n",sizeof(double));
    printf("Type long double has a size of %zd bytes.\n",sizeof(long double));
    return 0;
}
```

C99和C11提供了`%zd`转换说明匹配`sizeof()`的返回类型，缺省类型是`unsigned long`，因此也可以使用`lu`。

### 数据类型存储

浮点数和整数存储中存在本质不同。

即使两个32位存储单元存储的位数据完全相同，其中一个解释为float类型，另一个解释为long类型，它们表示的值也完全不同。

如float值为256.0时，long值为113246208。

### 刷新输出

何时刷新缓冲区？当缓冲区满、遇到换行字符、需要输入的时候。
