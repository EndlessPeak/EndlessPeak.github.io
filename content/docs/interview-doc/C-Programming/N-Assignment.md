---
title: 值和引用传递
authors:
  - EndlessPeak
toc: true
featuredImage: 
date: 2022-03-21
hidden: false
draft: false
weight: 5
---

### 值传递

#### 变量作值传递

函数参数通过值来传递，即传递给被调用函数的参数值**存放在临时变量中**，而不是原来的变量中。

```c
void swap1(int a,int b){
     int temp = a;
     a = b;
     b = temp;
}
int main(){
    swap1(a,b);//无法交换变量的值
}
```

该函数中的参数a和参数b都是临时变量，生存周期仅在该函数中，因此调用该函数无法完成变量交换。

#### 指针作值传递

若需让函数能够修改主调函数中的变量，调用者需要向被调用的函数提供待设置值的变量的地址（从技术角度看，地址就是指向变量的指针），而被调用函数则需将对应的参数声明为指针类型。

指针作值传递的原理：虽然指针的地址未发生变换，但是**指针所指向的内存单元存储的值发生了变化。**通过这样的方式达到修改变量的目的。

```c
void swap2(int *a,int *b){
    //通过指针访问变量的值，然后直接交换值
    int temp=*a;//取出地址a的值，并赋值给整型变量temp
    *a=*b;		//取出地址b的值，并将这个值赋给地址a指向的值
    *b=temp;	//将temp的值赋给地址b所指向的值
}
int main(){
    swap2(&a,&b);
}
```

注意，指针作值传递的过程中，**修改的对象必须是指针指向的内存单元而不是指针本身！**看下面的例子，它无法完成变量的值的交换。

```c
void swap3(int *a,int *b){
    //交换指针的值，从而达到交换指针所指向的变量的值
    int *temp=a;
    a=b;
    b=temp;
}
int main(){
    swap3(&a,&b);
}
```

看下面的例子，理解指针作值传递：

```c
#include <stdio.h>
//测试函数
int* test(int *a){
    printf("%d\n",&a);
    return a;
}
int main(){
    int a[2]={1,2};
    int *p=a;
    printf("%d\n",&p);
    p=test(a);
    printf("%d\n",&p);
    return 0;
}
```

程序将指针作实参传入函数，结合对实参的存储地址和形参的存储地址分析，可以发现地址不同，因此判断是函数内形参是临时变量，因此应视为指针作值传递。

### 引用传递

引用是变量的一个别名，调用这个别名和调用这个变量是完全一样的。

注意：

1. 引用是别名，并不是一种数据类型，内存并**不会给它单独分配内存**，而是直接调用它所引用的变量。
2. 特别地，C语言不接受引用，函数**形参**列表**不接受**引用传递；仅**实参**可以使用引用。

```c
void swap4(int &a,int &b){//该代码无法通过编译，形参不接受引用传递
    int temp=a;
    a=b;
    b=temp;
}
int main(){
	int a=10;
	int &d=a;//该代码无法通过编译，C语言不接受引用
    swap3(&a,&b);//仅实参可以使用引用
}
```

