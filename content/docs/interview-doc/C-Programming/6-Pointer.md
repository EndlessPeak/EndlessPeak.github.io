---
title: 指针
authors:
  - EndlessPeak
toc: true
featuredImage: 
date: 2022-03-21
hidden: false
draft: false
weight: 6
---

## 概念

计算机程序在存储数据时需要跟踪三种属性：

1. 信息存储在何处
2. 存储的值是多少
3. 存储的信息是什么类型

声明变量时：

1. 通过声明语句指明的符号名跟踪内存单元；
2. 程序为该变量分配内存来存储值；
3. 声明语句指出值的类型和符号名；

变量的**地址**称为该变量的**指针**，保存变量地址的变量称为指针变量；

通过变量A存储变量B的地址，并可以通过A访问B，则称A为指向B的**指针变量**，一般简称A为指向B的指针。

## 指针

### 声明

定义指针变量：`dataType * p;`

1. \*在与数据类型结合时，表示这是一个指向该数据类型的指针类型；

2. \*与变量名结合时，作为间接值/解除引用运算符，表示将通过该指针变量间接找到所指向的变量的值；或表示p是一个引用，通过解除引用该指针变量从而找到它指向变量的值；

综上，称`p`是`dataType*`类型，而`*p`是`dataType`类型。

连续定义时每个变量前都需要带\*，否则只有第一个变量会被解析为指针变量。

```c
int *a,*b,*c;
```

### 赋值与取值

由于指针保存变量的地址，因此用取地址运算符对变量取地址，而后将地址赋给指针。

```c
int *p=&a;
//这种声明即赋值的方法等效于下面两行：
int *p;
p=&a;
```

注意到`p`是`int*`类型，`a`是`int`类型，`&a`是`int*`类型。

对指针作解除引用运算，得到指针所指向的变量的值。

```c
int c=*p;
```

对指针变量A所指向的变量B的值的操作等效于直接对B进行操作。

```c
#include<stdio.h>
int main(){
    int a=10;
    int *p=&a;
    *p=20;
    printf("%d",a);
}
```

### 地址

指针变量保存的是地址，地址本质上是整数。

一般地，**指针变量占2个字节(16位)或4个字节(32位)或8个字节(64位)。**

```c
#include<stdio.h>
int main(){
	char a='A',*pa=&a，*paa = &a;
    int b=20,*pb=&b;
    double c=99.9,*pc=&c;
    printf("&a=%#xc, &b=%#x, &c=%#x\n", &a, &b, &c);
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    pa++; pb++; pc++;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    pa -= 2; pb -= 2; pc -= 2;
    printf("pa=%#X, pb=%#X, pc=%#X\n", pa, pb, pc);
    //比较运算
    if(pa == paa){
        printf("%d\n", *paa);
    }else{
        printf("%d\n", *pa);
    }
    return 0;
}
```

注意到pa、pb、pc 每次加 1，它们的地址分别增加 4、8、1，正好是 int、double、char 类型的长度；减 2 时，地址分别减少 8、16、2，正好是 int、double、char 类型长度的 2 倍。

结论：指针的值每次加1减1实际上是代表指向**下一个/上一个元素**。具体值的变化取决于指针的类型。

特别注意：

1. `(*p)++`代表指向的元素自增，去掉括号则代表指向下一个元素！因为单目运算符结合顺序是**右到左**。
2. 不能对指针变量进行乘、除、取余等运算。

## 数组

数组是一种数据格式，用来存储多个同类型的值。

1. 声明数组应指出：存储的元素的<u>数据类型</u>、<u>数组名</u>、数组元素<u>个数</u>。

2. 访问数组则应从0开始，一直到n-1结束。

   特别地，编译器不会检查下标是否有效。因此保证下标的有效性尤为重要。

数组名<u>可以认为</u>是一个指针，指向数组的第0个元素。**数组第 0 个元素的地址也称为数组的首地址。**

> 数组名的本意是表示整个数组，但在使用过程中经常会转换为指向数组第 0 个元素的指针，所以上面使用了“认为”一词，表示**数组名和数组首地址并不总是等价。**
>
> 下面的例子尝试说明数组名和数组首地址不等价的问题：

```c
#include <stdio.h>
int* test(int arr[]){
    return arr;
}
int main(){
    int arr[] = { 1, 2, 3, 4, 5 };
    int len1=sizeof(arr)/sizeof(int);
    int *p=test(arr);
    int len2=sizeof(test(arr))/sizeof(int);
    int len3=sizeof(p)/sizeof(int);
    printf("%d,%d,%d",len1,len2,len3);
}
```

注意：

1. `sizeof`是运算符，C标准规定不能用于函数，但是GNU C扩展了，使之对void类型返回1，<u>对函数类型返回函数指针的长度(8)</u>。（注意划线部分也可能输出1）

2. 上述程序中函数`test`的返回值类型不要写错了。

   如果写`int`，编译器报“从返回类型为`int`的函数返回`int * `，将指针转换为整型而不进行类型转换”，而后返回整型，执行时会抛出异常，非常“贴心”。

下面的例子尝试说明数组名可以认为是数组首地址的情况：

```c
#include <stdio.h>
int main(){
    int arr[] = { 1, 2, 3, 4, 5 };
    int len = sizeof(arr) / sizeof(int);  //求数组长度
    int i;
    for(i=0; i<len; i++){
        printf("%d  ", *(arr+i) );  //*(arr+i)等价于arr[i]
    }
    printf("\n");
    return 0;
}
```

## 函数指针

函数指针是指向函数的指针，保存函数的入口地址。

函数指针声明：

```c
int (*p)();
```

