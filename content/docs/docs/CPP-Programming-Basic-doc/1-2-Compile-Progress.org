#+TITLE: 程序编译
#+DATE: <2022-07-01 Fri>
#+AUTHOR: EndlessPeak
#+TOC: true
#+HIDDEN: false
#+DRAFT: false
#+WEIGHT: 2
#+Description: 本文总结了 C/C++ 程序从源文件进行编译的过程。

* 编译器
Linux 平台上使用的编译器是 GCC(GNU Compile Collection) 编译器。

GCC 的编译选项可以归纳为以下几类：
1. 总体选项
   #+begin_src text
     -c	对源文件进行编译或汇编
     -E	对源文件进行预处理
     -S	对源文件进行编译
     -o	输出目标文件
     -v	显示编译阶段命令
   #+end_src
2. 语言选项
   #+begin_src text
     -ansi	支持符合ANSI标准的C语言程序
   #+end_src
3. 警告选项
   #+begin_src text
     -W	屏蔽所有的警告信息
     -Wall	显示所有类型的警告信息
     -Werror	出现警告信息就停止编译（将警告视作错误）
   #+end_src
4. 调试选项
   #+begin_src text
     -g	产生调试信息
   #+end_src
5. 优化选项
   #+begin_src text
     -O0	不进行任何优化
     -O1	对目标文件的性能进行优化
     -O2	提高目标文件的运行性能
     -O3	支持函数集成优化
   #+end_src
6. 链接选项
   #+begin_src text
     -Wl,<option>	将该选项跳过并传递该选项给链接器
     -l<library>	链接指定的库文件
     -L <dir>	指定链接器的额外搜索路径	
     -static	指定使用静态链接
     -shared	生成共享文件（动态库）
   #+end_src
7. 目录选项
   #+begin_src text
     -I <dir>	指定头文件的搜索目录
     -L <dir>	指定链接器的额外搜索路径	
   #+end_src
8. 配置选项
   待补充。

* 预处理
处理宏定义和 =include= ，去除所有的注释。 *不会对语法错误进行检查。*

如果需要知道 ~#inlcude <...>~ 的搜素路径，可以在预处理时加上 ~-v~ 选项，显示搜索列表的详情。
特别地，如果仅执行 ~gcc -v~ ，则得到的是 gcc 的版本。
#+begin_src shell
  gcc -E a.c -o a.i
  gcc -E a.c -o a.i -v
#+end_src

* 编译
** 本地编译
狭义上编译指的是生成汇编代码，并在此阶段检查语法错误。 *不会对逻辑错误进行检查。*

#+begin_src shell
  gcc -S a.i -o a.s
#+end_src

广义上编译指一直到生成 *可重定位* 的目标代码。

考虑下面的两个源代码文件：

A.cpp：
#+begin_src cpp
  #include <iostream>
  extern int shared;
  extern void swap(int *a,int *b);
  int main()
  {
      int a = 100;
      swap(&a, &shared);
      cout<<a<<endl;
      cout<<b<<endl;
  }
#+end_src

B.cpp：
#+begin_src c++
  int shared = 1;

  void swap(int* a, int* b){
      int tmp = *a;
      ,*a =  *b;
      ,*b = tmp;
  }
#+end_src

编译上面两个程序的命令是：
#+begin_src shell
  g++ -c A.cpp -o A.o
  g++ -c B.cpp -o B.o
#+end_src

** 交叉编译
交叉编译是在一个平台上生成另一个平台上的可执行代码。用来编译这种程序的编译器叫交叉编译器。交叉编译器的名字一般都有前缀，如 =arm-none-eabi-gcc= 。

交叉编译的使用方法跟本地编译相似，但有一点特殊的是：必须用 ~-L~ 和 ~-I~ 参数指定编译器用 arm 系统的库和头文件，不能用本地(X86)的库。或者也可以在 =makefile= 中使用 ~-include~ 指定头文件位置。
* 汇编
生成可重定位的目标代码。

#+begin_src shell
  gcc -c a.s -o a.o
#+end_src

可重定位的目标代码不能直接执行，可使用~file~命令查看：
#+begin_src shell
  file a.o
  a.o: ELF 64-bit LSB relocatable
#+end_src

* 链接
将各个可重定位的目标代码与启动代码组合起来。

** 链接类型
链接分为静态链接和动态链接两种，默认为动态链接，不必指明链接方式，可以添加需要链接的库文件参数；静态链接则均需显式说明。

#+begin_src shell
gcc a.o -o a
#+end_src


** 动态链接
*** 概念
动态链接是运行时链接，把调用所需要的动态库的模块和在库中的*位置信息*链接进目标程序，程序运⾏的时候寻找相应的库文件，并从中执行相应的代码，因此需要被链接的动态库文件的支持 。

=gcc= 和 =g++= 都是默认使用动态链接的。因此不需要考虑额外的命令。

使用 =ldd= 来检查二进制程序依赖的动态库。

编译上面两个程序并运行：
#+begin_src shell
g++ A.o B.o -o a1
#+end_src

查看该程序依赖的动态链接库：
#+begin_src shell
ldd ./a1
#+end_src

*** 优点
1. 对同一个函数的调用只会在内存中产生一份拷贝，无论是多个相同的程序还是不同的程序；
   这是因为动态库使用相对地址，所有依赖的进程都可从同一入口进入；
2. 更新方便，只需要对库文件进行更新，而不需要更新依赖库文件的程序；
3. 动态库可以再包含其他的动态或静态库。

*** 缺点
链接推迟到了程序运行时，执行程序会有性能损失。

** 静态链接
*** 概念
静态链接是编译时链接，把源⽂件中⽤到的静态库（归档文件）直接放进⽬标程序，程序运⾏的时候不再需要其它的库⽂件。

使用 =-static= 参数显式指定使用静态链接的方式。

#+begin_src shell
g++ -static A.o B.o -o a2
#+end_src

由于是静态链接，所有依赖的库均已与该程序一起合并成了一个二进制文件，因此无法查看依赖的库。

*** 优点
直接执行程序而不需要链接，没有性能损失。

*** 缺点
1. 对同一个函数的调用会在内存中产生多份拷贝，即使是相同的程序的多个运行实例（即进程）也会如此；
   这是因为不同的进程有各自的地址空间，入口不同，程序不知道如何共享；
2. 库文件需要更新时，依赖它的所有程序都需要重新编译，否则只能使用原来的版本；
3. 静态库不能再 *包含其他静态库和动态库* 。
   因为静态库是编译好的归档文件，不能与其他库链接。除非重新用归档工具将多个静态库的源文件链接成一个新的静态库。

* 装载运行
运行生成的可执行文件。

#+begin_src shell
  ./a
#+end_src

可执行的目标代码可以直接执行，可使用 ~file~ 命令查看：
#+begin_src shell
  file a
  a: ELF 64-bit LSB executable
#+end_src

如需检查返回值，使用命令 ~echo $?~ ，它将显示上次程序执行完后的返回值。

* 简化步骤
** 预处理、编译、汇编
#+begin_src shell
gcc -c a.c -o a.o
#+end_src


** 快速生成
#+begin_src shell
gcc a.c -o a
#+end_src
