[{"authors":["Serene Feather Pavilion"],"categories":[],"content":"SDK SDK Content RK3588 平台上的SDK(Software Development Kit)软件开发套件主要分为两类：\n瑞芯微原厂提供的SDK 开发板销售商提供的SDK 目前，ATK-DLRK3588开发板提供的SDK属于后者，它集成了：\nLinux Kernel 5.10 U-Boot 2017.09 Rootfs RK Development tool Documentation ATK-DLRK3588 SDK 获取该SDK需要Linux环境，下以Ubuntu环境说明获取步骤，但实际上操作方法并不仅限于Ubuntu Linux。\n注意版本： 正点原子官方使用的是 Ubuntu 20.04，事实上我测试了Ubuntu 24.04也没有问题，只需要一些额外的操作。\n安装SDK依赖 配置Git 解包SDK的版本控制文件（repo） 同步repo SDK Dependency 需要安装如下依赖：\nsudo apt update sudo apt install git ssh make gcc libssl-dev liblz4-tool expect \\ expect-dev g++ patchelf chrpath gawk texinfo chrpath diffstat \\ binfmt-support qemu-user-static live-build bison flex fakeroot \\ cmake gcc-multilib g++-multilib unzip device-tree-compiler ncurses-dev \\ bzip2 expat gpgv2 cpp-aarch64-linux-gnu libgmp-dev \\ libmpc-dev bc python-is-python3 python2 说明如下：\nAPT \u0026amp; APT-GET 关于 apt 和 apt-get：\n原来使用 apt-get 来安装，但在 ubuntu 16.04 以后，更推荐使用 apt 直接安装； 下列情况必须需要使用 apt-get: 使用 dist-upgrade 智能处理依赖关系，完成升级； 使用 dselect-upgrade Python2 关于 python2：\n在 ubuntu 24.04 软件仓库中不再提供 python2 的安装 手动安装 python2 步骤如下： wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz tar -zxvf Python-2.7.9.tgz -C . ./configure --enable-optimizations # 配置编译环境，启用优化选项 sudo make altinstall # altinstall 不会创建名为 python 的符号链接 Git Configuration 使用 repo 之前需要用户配置自己的 git 信息:\ngit config --global user.name \u0026quot;your name\u0026quot; git config --global user.email \u0026quot;your email\u0026quot; git config --global --list # 检查一下配置 Checkout Source 先将压缩包复制到指定位置，然后解包并检出源码。\ncp atk-rk3588_linux_release_v1.0_20240601.tgz /path/to/location tar -zxvf atk-rk3588_linux_release_v1.0_20240601.tgz -C atk-rk3588_linux_sdk cd atk-rk3588_linux_sdk .repo/repo/repo sync -l -j 16 # 最终的 repo 实际上是 python 脚本，如果不能直接解释，也可以手动指定解释器： python .repo/repo/repo sync -l -j 16 SDK Develop SDK Compile Auto Compile 以下将SDK所在的目录称为$SDK_DIR，与SDK里脚本定义的变量保持一致。 第一次同步SDK后建议自动编译一次SDK，目的是：\n指定板级生成文件 alientek_rk3588_defconfig ，它将生成配置文件到$SDK_DIR/.config。 编译生成下列镜像文件（不支持单独编译生成）： misc.img 烧录到 misc 分区，可用于 bootloader 到 recovery 或其他分区 oem.img 给厂家使用 parameter.txt 分区表文件，RK开发工具据此创建分区 该文件可以直接从 $SDK_DIR/device/rockchip/.chips/rk3588/parameter.txt 拷贝 userdata.img 给最终用户使用 编译生成下列镜像文件（支持单独编译生成）： MiniLoaderAll.bin 最先运行的 Loader 代码 由 TPL 和 SPL 两部分组成 TPL 运行在 SRAM，主要用于初始化 DDR， SPL 运行在 DDR，主要负责加载、引导 uboot.img uboot.img FIT格式镜像，包括： trust 镜像 (ARM Trusted Firmware + OP-TEE OS) u-boot 镜像 u-boot 设备树二进制(DTB,Device Tree Blob,下同) boot.img FIT 格式镜像，包括： 内核镜像 内核设备树二进制 资源镜像 resource.img 包含设备树二进制、启动 logo 等资源 rootfs.img 正常启动模式下对应的根文件系统 rootfs recovery.img 将上述所有镜像合成为 update.img 编译前记得把提供的 dl.tgz 解压到 buildroot 中的 dl 文件夹中，因为 buildroot 依赖很多第三方软件，现场下载速度较慢，而且有少数软件网址已失效。\n步骤如下：\n./build.sh lunch ./build.sh all Sperate Compile 能够支持单独编译的有三部分:\nuboot 执行命令 ./build.sh uboot 生成 uboot.img kernel 编译内核 ./build.sh kernel 生成 boot.img 编译恢复分区 ./build.sh recovery 生成 recovery.img rootfs 官方支持的根文件系统包括 buildroot 和 debian 官方提供了 yocto 但不建议使用 可以自行制作基于linux发行版的根文件系统 最终可以执行./build.sh updateimg将所有的镜像打包成整体 update.img，但我认为这个功能并不适合开发。\nSDK Clean 在 SDK 根目录下执行如下命令可对整个 SDK 进行清理:\n./build.sh cleanall 也可执行如下命令对各模块进行清理:\n./build.sh clean:loader # 清理 U-Boot ./build.sh clean:kernel # 清理 Linux 内核 ./build.sh clean:recovery # 清理 recovery ./build.sh clean:rootfs # 清理 rootfs SDK Configuration 配置 SDK 分为四个部分：\n对 SDK 进行板级配置 对 Uboot 进行配置 对 Kernel 进行配置 对 Rootfs 进行配置 SDK Board Configuration 在 $SDK_DIR 根目录下执行 make menuconfig 即可配置 配置后保存位置在 $SDK_DIR/output/.config 处。 正点原子文档描述配置后执行 make saveddefconfig，将配置保存到当前目录下 个人感觉没用，因为 make menuconfig 读取的是 $SDK_DIR/output/.config 除非去替换 $CHIP_DIR/defconfig 文件 Kernel Configuration 内核配置需要注意：\n下列操作会重新生成 .config 文件 在上级目录 $SDK_DIR 中执行 ./build.sh kernel 在本级目录 $SDK_DIR/kernel 中执行 ./make.sh board=ATK_DLRK3588 如需配置内核后编译，有两种办法： 在 $SDK_DIR/kernel 目录中编译（我没试过） 用生成好的配置替换 $SDK_DIR/kernel/arch/arm64/configs/rockchip_linux_defconfig ，然后再编译 其他注意事项： 默认不开启 exfat 文件系统支持，需要打开 注意架构，配置时执行 make ARCH=arm64 menuconfig 否则生成的内核无法运行 External Device 有一些不包含在内核驱动中的设备需要驱动，为此需要提供对应的内核模块，如：\n$SDK_DIR/external/rkwifibt/drivers/rtl8733bu/8733bu.ko \u0026hellip; 问：如何知道我需要哪些内核模块？\n答：\n编译 buildroot 并挂载生成的镜像 rootfs.img ，从 /lib/modules 中将所有内核模块拷贝出来 当然也可以看明白 external 中是怎么编译这些模块的，然后手动编译它们并拷贝到指定位置 这些模块可以在配置内核时指明以模块形式加载，也可以手动放到系统中指定的路径 /lib/modules ，然后每次开机手动用 insmod 或脚本加载。 也可以写一个脚本查找 $SDK_DIR 中编译了哪些模块 #!/bin/bash # 检查是否提供了输入目录参数 if [ -z \u0026quot;$1\u0026quot; ]; then echo \u0026quot;Usage: $0 \u0026lt;input_directory\u0026gt;\u0026quot; exit 1 fi # 设置输入目录变量 input_directory=\u0026quot;$1\u0026quot; # 检查输入目录是否存在 if [ ! -d \u0026quot;$input_directory\u0026quot; ]; then echo \u0026quot;Error: Directory $input_directory does not exist.\u0026quot; exit 1 fi # 查找并打印所有以 .ko 结尾的文件 find \u0026quot;$input_directory\u0026quot; -type f -name \u0026quot;*.ko\u0026quot; -print 如果需要排除 kernel 目录中的模块，可以修改脚本为： #!/bin/bash # 检查是否提供了输入目录参数 if [ -z \u0026quot;$1\u0026quot; ]; then echo \u0026quot;Usage: $0 \u0026lt;input_directory\u0026gt; [exclude_directories]\u0026quot; echo \u0026quot;Example: $0 /path/to/dir '/path/to/exclude1 /path/to/exclude2'\u0026quot; exit 1 fi # 设置输入目录变量 input_directory=\u0026quot;$1\u0026quot; exclude_directories=() # 检查是否提供了排除目录参数 if [ ! -z \u0026quot;$2\u0026quot; ]; then IFS=' ' read -r -a exclude_directories \u0026lt;\u0026lt;\u0026lt; \u0026quot;$2\u0026quot; fi # 检查输入目录是否存在 if [ ! -d \u0026quot;$input_directory\u0026quot; ]; then echo \u0026quot;Error: Directory $input_directory does not exist.\u0026quot; exit 1 fi # 构建find命令 find_cmd=\u0026quot;find \\\u0026quot;$input_directory\\\u0026quot; -type d \\( \u0026quot; # 添加排除目录 for dir in \u0026quot;${exclude_directories[@]}\u0026quot;; do find_cmd+=\u0026quot; -path \\\u0026quot;$dir\\\u0026quot; -o\u0026quot; done # 移除最后的 -o 并完成命令 find_cmd=\u0026quot;${find_cmd% -o} \\) -prune -o -type f -name \\\u0026quot;*.ko\\\u0026quot; -print\u0026quot; # 运行find命令 eval $find_cmd ","permalink":"https://endlesspeak.github.io/docs/build/arm-linux-doc/1-rk3588-sdk/","tags":[],"title":"RK3588 SDK"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Kalman Filter Process Model 假设系统状态空间模型为：\n$$ \\begin{aligned} X(k) \u0026= AX(k-1) + BU(k-1) + W(k) \\\\ Z(k) \u0026= HX(k) + V(k) \\end{aligned} $$ 其中：\n$A$ 和 $B$ 分别表示系统状态参数矩阵和系统控制参数矩阵； $Z(k)$ 是在 $k$ 时刻的测量值; $H$ 是系统测量参数矩阵； $X(k)$ 表示系统在 $k$ 时刻的系统状态； $U(k)$ 是处于 $k$ 时刻对系统的控制量； $W(k)$ 和 $V(k)$ 是过程和测量噪声。 Process 卡尔曼滤波过程如下：\n进行先验估计估算（一步状态预测） $$ \\hat{X}(k|k-1) = A \\hat{X}(k-1|k-1) + B U(k-1) $$ 计算预测协方差矩阵 $$ P(k|k-1) = A P(k-1|k-1) A^T + Q $$ 计算卡尔曼增益 $$ K(k) =\\frac{P(k|k-1) H^T} {(H \\hat{P}(k|k-1) H^T + R)^{-1}} $$ 计算最优化估计值（更新状态估计） $$ \\hat{X}(k|k) = \\hat{X}(k|k-1) + K(k) (Z(k) - H \\hat{X}(k|k-1)) $$ 更新后验协方差矩阵 $$ P(k|k) = (I - K(k) H) P(k|k-1) $$ 其中 $Q$ 和 $R$ 是过程和测量噪声的协方差矩阵。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/1-kalman-filter/","tags":[],"title":"Kalman Filter"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Basic Thread C Thread Impl C中实现多线程编程需要使用如下的函数原型：\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 其中：\n*pthread_t thread 用于存储创建的线程标识符； *const pthread_attr_t attr 用于设置线程属性； void *(*start_routine)(void *) 是指向函数的指针，该函数将在线程创建后执行，其必须接受并返回一个 void * 类型的指针。 *void arg 是传递给 start_routine 函数的参数。 以下是C进行多线程编程的示例：\n#include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; // 线程函数必须符合 void * (*start_routine) (void *) 的签名 void* print_message_function(void* ptr) { char* message = (char*) ptr; printf(\u0026quot;%s \\n\u0026quot;, message); return NULL; } int main() { // 定义线程标识符 pthread_t thread1, thread2; const char* message1 = \u0026quot;Thread 1\u0026quot;; const char* message2 = \u0026quot;Thread 2\u0026quot;; // 创建线程 pthread_create(\u0026amp;thread1, NULL, print_message_function, (void*) message1); pthread_create(\u0026amp;thread2, NULL, print_message_function, (void*) message2); // 等待线程结束 pthread_join(thread1, NULL); pthread_join(thread2, NULL); return 0; } CPP Thread Impl 以下是C++进行多线程编程的示例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; void print_message_function(const std::string\u0026amp; message) { std::cout \u0026lt;\u0026lt; message \u0026lt;\u0026lt; std::endl; } int main() { std::string message1 = \u0026quot;Thread 1\u0026quot;; std::string message2 = \u0026quot;Thread 2\u0026quot;; // 创建线程 std::thread thread1(print_message_function, message1); std::thread thread2(print_message_function, message2); // 等待线程结束 thread1.join(); thread2.join(); return 0; } ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/3-interview-doc/1-thread/","tags":[],"title":"Thread"},{"authors":[],"categories":[],"content":"Question 题目链接: Merge Sorted Array\n给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2=，另有两个整数 =m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，=nums1= 的初始长度为 m + n=，其中前 =m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。=nums2= 的长度为 n 。\nCode 使用双指针，并且操作结果保存到 nums1 的后面。\nclass Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { int ptr1=m-1; int ptr2=n-1; int tail=m+n-1; while(ptr1\u0026gt;=0||ptr2\u0026gt;=0){ if (ptr1\u0026lt;0) { nums1[tail]=nums2[ptr2--]; } else if(ptr2\u0026lt;0){ nums1[tail]=nums1[ptr1--]; } else if(nums1[ptr1]\u0026gt;nums2[ptr2]){ nums1[tail]=nums1[ptr1--]; } else { //nums1[ptr1]\u0026lt;=nums2[ptr2] nums1[tail]=nums2[ptr2--]; } tail--; } } }; ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/algorithms-doc/1-merge-sorted-array/","tags":[],"title":"Merge Sorted Array"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Mem management All Mem statistic 统计本机所有内存使用量。\nfree -h Sort by all user 统计所有用户的内存使用量。\nps aux --sort=-%mem | head -n 10 | awk 'NR==1 {print $0; next} { $5=int($5/1024) \u0026quot;M\u0026quot;; $6=int($6/1024) \u0026quot;M\u0026quot;; $11=substr($11, 1, 100); print $0; }' 其中，~$11=substr($11, 1, 100);~ 是因为某些命令过长需要进行限制，如 pycharm 或 distrobox 等。\nSort by someone 统计指定用户的内存使用量。 方法一：首先提取表头，然后显示内容及排序。\nps aux --sort=-%mem | head -n 1 \u0026amp;\u0026amp; ps aux --sort=-%mem | grep '^chan' | head -n 10 | awk '{ $5=int($5/1024) \u0026quot;M\u0026quot;; $6=int($6/1024) \u0026quot;M\u0026quot;; print $0; }' 方法二：手动输出表头，然后显示内容及排序。\necho \u0026quot;USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\u0026quot; ps aux --sort=-%mem | grep '^chan' | head -n 10 | awk '{ $5=int($5/1024) \u0026quot;M\u0026quot;; $6=int($6/1024) \u0026quot;M\u0026quot;; print $0; }' Monitor 实时监控内存，可以将上述命令编为脚本，然后使用watch循环输出。\nwatch -n 1 ./top_10_mem.sh Swapfile 内存不够时可以通过添加 swapfile 或者开启 swap partion 解决。\n生成交换文件。\nfallocate -l 32G /swapfile dd if=/dev/zero of=/swapfile bs=1M count=32768 设置权限并格式化文件。\nchmod 600 /swapfile mkswap /swapfile 开启交换文件。\nswapon /swapfile swapon --show 关闭交换文件\nswapoff /swapfile 如果需要用大交换文件替换小交换文件，建议先开后关。\n","permalink":"https://endlesspeak.github.io/docs/build/terminalconfiguration/linux-technology-6-2-sysstat/","tags":[],"title":"System Management"},{"authors":[],"categories":[],"content":"SLAM Problems Matrix and Sophus 求导 $ \\frac{\\partial R_1R_2}{\\partial R_1} $ 简述李群和李代数的关系。 给定 \\((H,W)\\) 图像或者 matrix，问如何去访问每一个元素，是先访问行呢？还是先访问列？跟缓存还有关系~ Sensors Model 除了视觉传感，还用过其他传感器吗？比如 GPS，激光雷达 写出单目相机的投影模型，畸变模型。 你认为室内 SLAM 与自动驾驶 SLAM 有什么区别？ 如何标定 IMU 与相机之间的外参数？ 在给定一些有噪声的 GPS 信号的时候如何去精准的定位？ 如果把一张图像去畸变，写公式，流程。 Non liear Optimize 熟悉 Ceres 优化库吗？简单描述一下。 描述（扩展）卡尔曼滤波与粒子滤波，你自己在用卡尔曼滤波时遇到什么问题没有？ 说一下 Dog-Leg 算法 Loop Closure 什么是闭环检测？常用的方法有哪些？你用的哪种方法？有没有创新？ Mapping 地图点的构建方法有哪些？ 3D 地图点是怎么存储的？表达方式？ Visual Odometry 如果对于一个 3D 点，我们在连续帧之间形成了 2D 特征点之间的匹配，但是这个匹配中可能存在错误的匹配。请问你如何去构建 3D 点？ 说一下 3D 空间的位姿如何去表达? 什么是 Essential，Fundamental 矩阵？ 给两组已经匹配好的 3D 点，计算相对位姿变换。已知匹配的 ICP 问题，写代码。 ORB-SLAM 初始化的时候为什么要同时计算 H 矩阵和 F 矩阵？ 计算 H 矩阵和 F 矩阵的时候有什么技巧呢？实际上在问归一化的操作。 ORB-SLAM 中的特征是如何提取的？如何均匀化的？ 什么是 ORB 特征，ORB 特征的旋转不变性是如何做的，BRIEF 算子是怎么提取的。 Backend 有哪几种鲁棒核函数？ RANSAC 在选择最佳模型的时候用的 metric 是什么？ 除了 RANSAC 之外，还有什么鲁棒估计的方法？ 给你 m 相机 n 个点的 bundle adjustment 当我们在仿真的时候，在迭代的时候，相机的位姿会很快的接近真值。而地图点却不能很快的收敛这是为什么呢？ 解释一下 Gauss-Netwon 和 LM 算法。 LM 算法里面那个 $λ $ 是如何变化的呢？ Other Problems 什么是紧耦合、松耦合？优缺点。 RGB-D 的 SLAM 和 RGB 的 SLAM 有什么区别？ 谈谈自己熟悉的 SLAM 算法，Lidar/Visual slam，说优缺点。 读 Maplab，设计室内服务机器人地图更新的方法、流程。 安装 2D lidar 的平台匀速旋转的时候，去激光数据畸变，写代码 什么是边缘化？First Estimate Jacobian？一致性？可观性？ 说一下 VINS-Mono 的优缺点 你做的工作在本质上有什么不同，贡献，创新本质上在哪里？ 给定几个连续帧的带有位姿的帧，如何去测量车道线相对于世界坐标系的坐标。 给你 xx 误差的 GPS，给你 xx 误差的惯导你怎么得到一个 cm 级别的地图。 给一组点云，从中提取平面。 给一张图片，知道相机与地面之间的相对关系，计算出图的俯视图。 双线性差值如何去做，写公式。 机器人从超市门口出发，前往 3 公里外的小区送货。请你设计一个定位系统，包括传感器的配置、算法的流程，用伪代码写出来。 Algorithms and Datastructure C Plus Plus 多线程的实现方式 std::vector 描述一下，如何动态扩展，如何 shink 内存 Eigen 是行优先还是列优先 unorder 容器与 ordered 容器的区别 说一下 Mat 是如何析构的 说一下智能指针，shared_ptr 与 unique_ptr 说一下什么是虚函数 普通指针如何实现一块内存只能有一个指针指向这种功能 C++ RTTI 是什么东西？ C++是如何实现多态的？ vector 的 iterator 什么时候失效？ 写 CmakeLists.txt，写 gcc 指令 Data Structure \u0026amp; Algorithms 写一个四叉树的结构 不用递归遍历二叉树 重建二叉树 求最大连通域 一个图，给出两个一对的若干节点对，求两个节点之间的通路。 实现一个稀疏矩阵的数据结构，并实现稀疏矩阵的加法。 棋盘格，每个格子角点上有一个灯，按一下周围四个灯就会取反。开始的时候这个棋盘格上灯状态随机，问如何操作这些按钮可以使得整个棋盘全灭。 编一个二分查找 给你一个数组去排序，说排序算法 给你 2D 平面的两个线段，判断两个线段是否相交 写快速排序、写反转链表 给两个排序数组，升序的。一个大小为 n，一个大小为 m。从中找出第 k 小的数字。 Frame Structure ORB-SLAM 的共视图是什么结构？内部如何存储的？ Learning Resources Easy SLAM and Robotic Tutorial Deep Learning Interview Book(Include Slam) 未完待续 ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/slam-interview/","tags":[],"title":"SLAM Interview"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Git子模块是一个强大的工具，用于在Git仓库中跟踪和管理另一个Git仓库。当你想要在你的项目中包含并跟踪第三方库（比如库的特定版本）的时候会使用到。\nBasic Operation Add Submodule 当你第一次添加子模块时，你可以使用如下命令：\ngit submodule add \u0026lt;repository-url\u0026gt; \u0026lt;path-to-submodule\u0026gt; 这会在项目中添加一个新的子模块并克隆子模块仓库到指定的路径。\nInit Submodule 克隆一个包含子模块的项目时，子模块目录会存在，但会是空的。你需要运行两个命令来初始化并更新子模块：\ngit submodule init --recursive git submodule update --recursive 当然这两个命令可以合并为一个：\ngit submodule update --init --recursive 或者你可以在克隆时使用参数来自动初始化和更新子模块。\ngit clone \u0026lt;repository-url\u0026gt; --recursive git clone \u0026lt;repository-url\u0026gt; --recurse-submodules Update Submodule 要更新子模块到最新的提交，你需要进入到子模块的目录中，然后拉取所需的更改。这可以通过以下命令完成：\ncd \u0026lt;path-to-submodule\u0026gt; git fetch git checkout \u0026lt;desired-branch-or-tag\u0026gt; 之后，你需要在主仓库中提交这个更改，这样就会记录子模块的新提交。当你更新子模块后，确保运行测试以验证更新没有破坏任何东西。\n如果你的子模块指向一个特定的分支，你可以在子模块目录中运行git pull来获取最新的提交，然后在主项目中提交这个更改。\nCommit Submodule 子模块实际上是指向特定提交的引用。当你更新子模块后，你的主项目会检测到子模块的提交指针已经变化。你需要提交这个变化到你的主仓库，这样其他人在更新代码或者克隆仓库时就会得到子模块的正确版本。\ngit add \u0026lt;path-to-submodule\u0026gt; git commit -m \u0026quot;Update the submodule to the latest commit\u0026quot; git push Gitignore \u0026amp; Gitmodules 子模块的路径不应该被添加到 .gitignore 文件。\n当你添加一个子模块时，Git会在你的主仓库中创建两个重要的文件：\n.gitmodules 包含子模块的URL和配置信息。 \u0026lt;path-to-submodule\u0026gt; 一个特殊的文件，它实际上是一个Git链接，指向子模块的特定提交。 这些文件应该被提交到你的主仓库中，这样其他协作者或者环境就可以正确地初始化和更新子模块。\n如果你删除了一个子模块，确保从.gitmodules和你的主仓库配置中移除相关的条目，否则Git会在某些操作时继续尝试访问已删除的子模块。\nAdvance Operation 此处介绍如何在Git中更改子模块的URL或路径。子模块是Git项目中的独立仓库，可以在主项目中作为一个独立的组件进行管理。有时候，我们需要更改子模块的URL或路径，以适应项目的需求或进行项目结构优化。\n下面将介绍两种常见的更改子模块URL或路径的情况。\nUpdate Submodule\u0026rsquo;s URL 下面是更改子模块URL的步骤：\n进入主项目的根目录，找到包含子模块的目录 将子模块从 .gitmodules 文件中删除 将子模块从主项目中删除 删除子模块相关的配置文件，例如 .git/modules/\u0026lt;submodule-name\u0026gt; 目录 添加新的子模块到主项目中 命令如下：\ncd main-project git submodule deinit my-submodule git rm my-submodule rm -rf .git/modules/my-submodule git submodule add \u0026lt;new-url\u0026gt; my-submodule Update Submodule\u0026rsquo;s Path 下面是更改子模块路径步骤\n进入主项目的根目录，找到包含子模块的目录 将子模块移动到新的路径。 更新 .gitmodules 文件中子模块的路径。 命令如下：\ncd main-project git mv old-subdir/my-submodule new-subdir/my-submodule git config -f .gitmodules submodule.my-submodule.path new-subdir/my-submodule Repair Submodule Config Files Git子模块的信息存储在几个地方：\n.gitmodules 文件：存储了子模块的URL和期望的路径 .git/config 文件：存储了关于子模块的本地配置信息 .git/modules 目录：存储了每个子模块的Git数据 当子模块的配置文件没有被正确更新时，需要进行修复，步骤如下\n更新 .gitmodules 文件 确保子模块的配置是正确的 同步 .gitmodules 的更改 执行 git submodule sync 修复子模块的 git数据目录 删除旧模块路径 rm -rf .git/modules/old-subdir/my-submodule 取消初始化子模块 git submodule deinit -f -- sub-dir/my-submodule 重新初始化子模块 git submodule update --init -- sub-dir/my-submodule ","permalink":"https://endlesspeak.github.io/docs/docs/git-doc/git-submodule/","tags":[],"title":"Git submodule Manage"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Installation 参考 Visual Studio Code Installation\nDeb install 从官网下载 deb 包，使用命令安装\nsudo dpkg -i code_XXX_amd64.deb sudo apt install ./code_XXX_amd64.deb 使用 apt install 命令安装后会自动将该软件的 apt 存储库和签名密钥添加到系统包管理器中，其位于 /etc/apt/keyrings/packages.microsoft.gpg 。\n也可以从官网手动添加 apt 存储库和签名密钥，然后更新包缓存安装。\nRpm install 从官网下载 rpm 包，使用命令安装\nsudo dnf install code_XXX_amd64.rpm 也可以从官网手动添加，注意 dnf 和 yum 并不支持自动识别和添加存储库及密钥。\nPackage Manager 建议从软件包管理器提供的软件安装。\nOpen with Code Gnome Gnome 环境的文件管理器是 nautilus ，有两种方法配置：\nPython Extension For Nautilus 运行命令：\nwget -qO- https://raw.githubusercontent.com/harry-cpp/code-nautilus/master/install.sh | bash 或首先手动下载 Github:harry-cpp/code-nautilus 仓库，然后本地执行。\nFilemanager Actions 安装 filemanager-actions ，使用 fma-config-tool 进行配置。\n需要注意目前该包由于缺乏更新已被归档，替代产品见 Actions for nautilus 。\nKDE 在 ~/.local/share/kservices5/ServiceMenus/ 下添加 .desktop 文件并编辑。\n对于 edit code here ，内容为：\n[Desktop Action opencodeossfile] Exec=code %F Icon=vscode Name=Edit with Code - OSS [Desktop Entry] Actions=opencodeossfile MimeType=text/plain;application/octet-stream; ServiceTypes=KonqPopupMenu/Plugin Type=Service X-KDE-Priority=TopLevel 对于 open code here ，内容为：\n[Desktop Action opencodeossdir] Exec=code %F Icon=vscode Name=Open with Code - OSS [Desktop Entry] Actions=opencodeossdir MimeType=inode/directory; ServiceTypes=KonqPopupMenu/Plugin Type=Service X-KDE-Priority=TopLevel Configuration Trust 该功能位于 Security→Workspace→Trust\nEnable 选项控制是否开启信任功能 \u0026quot;security.workspace.trust.enabled\u0026quot;: false, Empty Window 选项控制是否默认信任空窗口 Untrusted Files 选项控制如何打开默认不信任的文件 Title 该功能位于 Window 部分\n标题栏组成：Title ，包含多个组件 标题栏显示样式：Title Bar Style ，包含 native 和 custom 两种 Font Zoom 此部分用于更改全局缩放大小。\nEditor Font 此部分更改字体大小仅对编辑区的字体生效，且需要字体本身支持以下属性。\nfont Ligatures 字体连字通常用于美化代码和提高可读性，如 Fira Code 和 Operator Mono，都支持连字特性。\n\u0026quot;editor.fontLigatures\u0026quot;: true, Font Variations（字体变化） 字体变化是指使用不同的字体变体来显示不同的字形或字符，需要可变字体。\n\u0026quot;editor.fontVariations\u0026quot;: \u0026quot;'wdth' 93, 'wght' 90, 'GRAD' 88\u0026quot;, Font Weight（字体粗细） 字体粗细是指字体的粗细程度，可以通过 normal 或 bold 等关键字或从 1-1000 的数字值控制。\n","permalink":"https://endlesspeak.github.io/docs/build/editorconfiguration/1-vscode-configuration/","tags":[],"title":"VSCode Configuration"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Self Configuration Import Configuration 以 sddm 为例，浅谈如何导入 nix 配置文件。\n如下所示，在基本设置中导入 sddm-theme.nix 。\n# Enable the X11 windowing system. services = { xserver = { enable = true; # Enable the Plasma 5 Desktop Environment. displayManager ={ sddm.enable = true; sddm.theme = \u0026quot;${import ./sddm-theme.nix { inherit pkgs;}}\u0026quot;; }; desktopManager.plasma5.enable = true; # Enable touchpad support (enabled default in most desktopManager). libinput.enable = true; }; }; 在 sddm-theme.nix 中写入\n# sddm-theme-nix { pkgs }: let image = pkgs.fetchurl { url = \u0026quot;https://z1.ax1x.com/2023/11/18/piNMTFs.jpg\u0026quot;; sha256 = \u0026quot;02pgyhmm42bdx31yn64vbmyx7cfnn89zswj40rwr32fdgz83bxy7\u0026quot;; }; in pkgs.stdenv.mkDerivation { name = \u0026quot;sddm-theme\u0026quot;; # src = pkgs.fetchFromGitHub { # owner = \u0026quot;MarianArlt\u0026quot;; # repo = \u0026quot;kde-plasma-chili\u0026quot;; # rev = \u0026quot;a371123959676f608f01421398f7400a2f01ae06\u0026quot;; # sha256 = \u0026quot;sha256-fWRf96CPRQ2FRkSDtD+N/baZv+HZPO48CfU5Subt854=\u0026quot;; # }; src = pkgs.fetchFromGitLab { domain = \u0026quot;framagit.org\u0026quot;; owner = \u0026quot;MarianArlt\u0026quot;; repo = \u0026quot;sddm-sugar-candy\u0026quot;; #url = \u0026quot;https://framagit.org/MarianArlt/sddm-sugar-candy.git\u0026quot;; rev = \u0026quot;2b72ef6c6f720fe0ffde5ea5c7c48152e02f6c4f\u0026quot;; sha256 = \u0026quot;1db4p2d0k5a6avr7dg9h1r7y9mx711ci5dgwmljqjb8pq5b0a22y\u0026quot;; }; installPhase = '' mkdir -p $out cp -R ./* $out/ cd $out/Backgrounds cp -r ${image} $out/Backgrounds/magenta.jpg cd $out sed -i 's/Background=\u0026quot;Backgrounds\\/Mountain.jpg\u0026quot;/Background=\u0026quot;Backgrounds\\/magenta.jpg\u0026quot;/g' theme.conf ''; # the following are commented } 特别地，使用 SDDM 主题需要额外加上两个软件包：\nenvironment.systemPackage = with pkgs;[ libsForQt5.qt5.qtquickcontrols2 libsForQt5.qt5.qtgraphicaleffects ]; OverAttrs Configuration 下面的两个例子提供了软件包 overrideAttrs 的方法。\nenvironment.systemPackage = with pkgs;[ # KDE Programs # latte-dock is out of date,let's override it. # Refer to https://nixos.org/manual/nixpkgs/stable/#chap-overrides (latte-dock.overrideAttrs{ version = \u0026quot;v0.10\u0026quot;; src = fetchFromGitLab { domain = \u0026quot;invent.kde.org\u0026quot;; owner = \u0026quot;plasma\u0026quot;; repo = \u0026quot;latte-dock\u0026quot;; rev = \u0026quot;a840ac6faa9acb1570f8fa016e7ac7f2e5686e90\u0026quot;; sha256 = \u0026quot;sha256-+9ksvGB6IRlJ1PXsrLA5PuHFCHs80tkKPAu2iknNEAQ=\u0026quot;; }; }) ]; 如果希望对打包的过程进行修改，可以用 old 参数指代原有的步骤，并在后面附上需要添加的内容。\nenvironment.systemPackages = with pkgs-unstable;[ # IDE (jetbrains.clion.overrideAttrs (old:{ postFixup = '' ${old.postFixup} # add ja-netfilter cd $out/clion/bin echo '-javaagent:/home/leesin/Downloads/jetbra/ja-netfilter.jar=jetbrains' \u0026gt;\u0026gt; clion64.vmoptions echo '--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED' \u0026gt;\u0026gt; clion64.vmoptions echo '--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED' \u0026gt;\u0026gt; clion64.vmoptions ''; })) ]; Concat List 连接列表有两种办法。\n使用语法糖 (with pkgs;[ git ])++ (with pkgs-unstable;[ eza ]) 使用库自带的函数 lib.concatLists [ (with pkgs;[ git ]) (with pkgs-unstable;[ eza ]) ]; Self Package 自行打的包记录如下：\n{ stdenv, fetchurl, dpkg, buildFHSUserEnv, pkgs, makeWrapper, writeText, ... }: let baidunetdisk = stdenv.mkDerivation rec { pname = \u0026quot;baidunetdisk\u0026quot;; version = \u0026quot;4.17.7\u0026quot;; src = fetchurl{ url = \u0026quot;http://wppkg.baidupcs.com/issue/netdisk/Linuxguanjia/${version}/baidunetdisk_${version}_amd64.deb\u0026quot;; sha256 = \u0026quot;sha256-UOwY8FYmoT9X7wNGMEFtSBaCvBAYU58zOX1ccbxlOz0=\u0026quot;; }; nativeBuildInputs = [ dpkg makeWrapper ]; unpackPhase = \u0026quot;dpkg-deb -x ${src} .\u0026quot;; # 菜单项 desktopFile = writeText \u0026quot;baidunetdisk.desktop\u0026quot; '' [Desktop Entry] Name=baidunetdisk Name[zh_CN]=百度网盘 Name[zh_TW]=百度网盘 Exec=baidunetdisk --no-sandbox %U Terminal=false Type=Application Icon=baidunetdisk StartupWMClass=baidunetdisk Comment=百度网盘 Comment[zh_CN]=百度网盘 Comment[zh_TW]=百度网盘 MimeType=x-scheme-handler/baiduyunguanjia; Categories=Network; ''; installPhase = '' mkdir -p $out/opt/${pname} mkdir -p $out/share mkdir -p $out/bin cp -r ./usr/share/* $out/share rm $out/share/applications/${pname}.desktop install -Dm644 ${desktopFile} $out/share/applications/${pname}.desktop cp -r ./opt/${pname}/* $out/opt/${pname} chmod 644 $out/opt/${pname}/*.so makeWrapper $out/opt/${pname}/${pname} $out/bin/${pname} --set LD_LIBRARY_PATH $out/opt/${pname} --run \u0026quot;echo $out\u0026quot; ''; }; in buildFHSUserEnv { name = \u0026quot;${baidunetdisk.pname}\u0026quot;; targetPkgs = pkgs: (with pkgs.xorg; [ libX11 libxcb libXcomposite libXcursor libXdamage libXext libXfixes libXi libXrandr libXrender libXScrnSaver libXtst ]) ++ (with pkgs; [ nss nspr atk alsa-lib cups at-spi2-atk dbus glib gdk-pixbuf gtk3-x11 pango cairo expat libdrm libxkbcommon libGL stdenv.cc.cc.lib mesa libudev0-shim ]) ++ (with pkgs; [ ]) ++ [baidunetdisk]; runScript = \u0026quot;/bin/${baidunetdisk.pname}\u0026quot;; } ","permalink":"https://endlesspeak.github.io/docs/build/nixos-configuration/1-nixos-configuration/","tags":[],"title":"Python Development on NixOS"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Migrating rsync -aAXvhP --exclude={\u0026quot;/dev/*\u0026quot;,\u0026quot;/proc/*\u0026quot;,\u0026quot;/sys/*\u0026quot;,\u0026quot;/tmp/*\u0026quot;,\u0026quot;/run/*\u0026quot;,\u0026quot;/mnt/*\u0026quot;,\u0026quot;/media/*\u0026quot;,\u0026quot;/lost+found\u0026quot;} / /mnt rsync是一个用于复制和同步文件的强大工具。在您提供的命令中，-aAXv选项组合的意义如下：\n-a（或\u0026ndash;archive）：这个选项是多个选项的组合，它包含了-rlptgoD（递归、链接、权限、时间、所有权（用户和组）、设备文件和特殊文件），基本上是用来创建源目录的精确副本的。\n-A（或\u0026ndash;acls）：保留ACLs（访问控制列表），这样可以保留文件的权限设置。\n-X（或\u0026ndash;xattrs）：保留扩展属性，这对于保留文件的特定于文件系统的设置很重要。\n-v（或\u0026ndash;verbose）：详细模式，rsync会打印出更多的信息来显示它在做什么。\n如果您添加 -h 和 -P 选项，它们各自代表：\n-h（或\u0026ndash;human-readable）：输出信息以更适合人类阅读的方式显示，例如，使用K、M来表示千字节、兆字节。\n-P：这个选项是\u0026ndash;partial \u0026ndash;progress的组合，它允许部分传输的文件在中断后再次传输时能够继续，而不是从头开始。同时，它还显示传输过程中的进度条。\n","permalink":"https://endlesspeak.github.io/docs/build/operating-system-tool/1-linux-migrating/","tags":[],"title":"Linux 迁移"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"GCC GCC 13 支持 p1689 特性，但是与 cmake 配合尚存在一定问题。\nClang Clang 16 支持 p1689 特性，且可以直接与 cmake 配合使用。\n注意：\n模块特性尚处于实验状态，需要开启对应的 cmake 版本的 API。 目前测试情况是需要将模块编译成库进行链接，但不必一定是共享库。 cmake_minimum_required(VERSION 3.27) project(learnCPP20) set(CMAKE_CXX_STANDARD 20) set(CMAKE_CXX_EXTENSIONS OFF) set(CMAKE_EXPERIMENTAL_CXX_MODULE_CMAKE_API \u0026quot;aa1f7df0-828a-4fcd-9afc-2dc80491aca7\u0026quot;) set(CMAKE_EXPERIMENTAL_CXX_MODULE_DYNDEP 1) add_library(employee_lib SHARED) target_sources(employee_lib PUBLIC FILE_SET cxx_modules TYPE CXX_MODULES FILES src/employee.cppm ) add_executable(learnCPP20 src/employee.cpp ) ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/2-advanced-doc/1-modules/","tags":[],"title":"Modules for CPP"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Rustup rustup 是管理 Rust 版本和相关工具的命令行工具。即使部分 Linux 发行版已经打包提供了 rust 软件包，我们仍然建议使用 rustup ，因为它可以自由地添加目标平台支持以及工具链列表。\nUnix 标准的安装 Rust 最新稳定版本的 rustup 的流程为：\ncurl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh 特别需要注意，Rust 代码在编译为目标文件后，需要调用链接器进行链接。\n建议安装 GCC (GNU 编译器套件)或 Clang(LLVM 编译器套件)等 C 编译器。一方面，一些常见的 Rust 包依赖于 C 代码；另一方面，Rust 尚无自己独有的稳定链接器。该部分在以后会下该纳西讨论。\nrustc 仅能将代码编译为目标文件，不能编译成目标机器指令。\n可以将其看作一个完整的编译前端和部分编译后端，目标文件需要经过链接器链接后生成可执行的文件(目标机器指令)。\nWindows 访问 https://www.rust-lang.org/zh-CN/tools/install 安装 Rust 提供基于 GNU 和 MSVC 构建的版本 MSVC 需要 C++ build tools，访问 https://visualstudio.microsoft.com/visual-cpp-build-tools/ GNU 需要 MinGW 程序包，安装后配置好环境变量即可。 Update \u0026amp; Uninstall 通过 rustup 安装 Rust 后，更新到最新版本很简单。在 shell 中运行以下更新命令： rustup update\n要卸载 Rust 和 rustup，在 shell 中运行以下卸载命令： rustup self uninstall\n特别地，这行卸载命令在 Windows 中会将已注册的环境变量全部删除。\nDoc Rustacean 可以通过 rustup doc 在本地打开文档并查看帮助。\n在互联网上查阅官方所有文档索引，见 https://www.rust-lang.org/zh-CN/learn\n对标准库使用有疑问也可访问：\n中文版 https://rustwiki.org/zh-CN/std/ 英文版 https://doc.rust-lang.org/std/index.html ","permalink":"https://endlesspeak.github.io/docs/docs/rust-programming-basic-doc/1-installation/","tags":[],"title":"Rust Installation"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"嵌入式系统组成 嵌入式系统由硬件和软件组成。\n硬件 硬件是嵌入式系统的运行基础，提供了嵌入式软件运行的物理平台、通信接口。\n硬件主要包括处理器、存储器、IO 设备和通信接口。\n处理器包括： 微控制器 MCU 微处理器 MPU 数字信号处理器 DSP 片上系统 存储器包括： 易失性存储器 非易失性存储器 片上 IO 外设包括： 数字键盘 MOS 管 LED LCD 传感器 开关与按键 摄像头 \u0026hellip; 嵌入式 IO 通信接口包括： UART SPI IIC USB CAN I2S Ethernet ZigBee \u0026hellip; 软件 软件是嵌入式系统的控制核心，软件用于控制系统运行、实现系统功能。\n软件包括：\n引导程序 设备驱动程序 嵌入式操作系统（可选） 应用软件 嵌入式系统特点 实时性高 可靠性高 生命周期长 快速开发 交叉编译 面向特定应用场景 可裁剪 \u0026hellip; 嵌入式开发过程 交叉编译 宿主机 是用于开发嵌入式系统的开发环境，使用它提供的嵌入式开发环境为开发提供过程支持。\n目标机 是所开发的嵌入式系统的运行环境，为嵌入式软件提供工作和运行条件。\n交叉编译 指的是由宿主机编译可执行文件，交由目标机执行的过程。\n连接方式 连接方式分为两种，一是通过物理线路连接，二是通过逻辑连接。\n物理线路连接包括串口(Serial Port)、以太网口(Ethernet)、在线调试器(SWD/JTAG)等； 逻辑连接即按照某种通信协议建立起来的通信连接，如 ZigBee，Bluetooth 等。 开发环境 常用的嵌入式系统的集成开发环境有：\nARM ADS KEIL MDK 使用的编译器是 armcc IAR EWARM STM32CubeIDE 使用的编译器是 arm-none-eabi-gcc 对于嵌入式程序的调试，通常可以使用：\n软件仿真器（软件模拟硬件） ROM 监控器（运行宿主机的调试代理与运行目标机的监控程序通信） 在线仿真器（替代目标机上的 CPU） 片上调试（内置于目标开发板中的 CPU 中的调试模块硬件实现） 目标文件 链接器 把所有目标文件和相关的库函数组合成可重定址的目标程序文件。 该文件由下列段组成：\ntxt 段 data 段 初始化的全局变量 bss 段 未初始化的全局变量 定址器 是根据预设的描述各段在存储器中地址信息的脚本文件，对可重定址的目标程序文件的每个段指定物理内存地址，并输出包含二进制内存映像的可执行文件。\n启动文件 由汇编编写，是系统上电复位后第一执行的程序。\nARM 处理器 ARM 含义 ARM 指代 Advanced RISC Machine Limited 公司或其公司的产品； ARM 指代 RISC MPU/MCU 的体系结构； 如同 x86 架构是一种 CISC 体系结构一样， ARM 架构是一种 RISC 体系结构。另外还有 MIPS 架构、 PowerPC 架构等等，它们也属于 RISC 体系结构。 体系结构主要包含 RISC 和 CISC 两种：\nRISC 是精简指令集，指令数量少，设计相对简单，能耗较低，更多的应用在各种移动终端； CISC 指的是复杂指令集，指令数量多、设计复杂、能耗高，例如 intel 的处理器使用这种指令集； ARM 处理器 ARM 处理器是英国 Acorn 有限公司设计的低功耗成本的第一款 RISC 微处理器，全称为 Advanced RISC Machine； ARM 处理器本身是 32 位设计，但也配备 16 位指令集，一般来讲比等价 32 位代码节省达 35%，却能保留 32 位系统的所有优势； ARM 经常混淆的名词是内核版本号和片上系统称号，内核版本号和 Soc 号都是由 ARM 公司确定的，而芯片的型号主要由生产的厂商确定，并且一个内核版本号可能会对应多个 Soc 号。 常见的内核的版本号与对应的片上系统版本号如下表所示：\n内核版本号 SoC 版本号 ARMv4 ARM7 ARMv4 ARM9 ARMv5 ARM9+xScale ARMv6 ARM11 ARMv7 Cortex-M/Cortex-A/Cortex-R 其中：\nSoC 版本号仅 ARM7 使用冯诺依曼结构，ARM9/10/11 均使用的是哈佛结构； 表中的 Cortex 系列释义如下： Cortex-M 即 M-Profile，针对微控制器单片机方面的场合，其中的 M 表示 micontroller，微处理器，此系列主要用于做单片机，主要代表有 STM32； Cortex-A 即 A-Profile，其中的 A 表示 appliacation，应用级处理器，面向尖端的基于虚拟内存的操作系统和用户应用，此系列主要用于平板电脑，手机等，具有低功耗的特点； Cortex-R 即 R-Profile，针对实时系统，其中的 R 表示 realtime，此系列主要用于航天等实时性要求较高的领域； ST 微控制器 ST/STM/STM32 含义 ST 指的是 ST 意法半导体公司 STM 指的是 ST Microcontroller，即 ST 微控制器 32 指的是 32 位 STM32 指的是基于 ARM 架构的 32 位微控制器 STM32F767IGT6 中： F 表示基础类型，L表示低功耗，H表示高性能，MP 使用 MPU 767 指的是芯片产品系列名称 I 指的是 176 引脚 G 指的是闪存 Flash 容量为 1MB T 指的是封装类型为 QFP 6 指的是温度范围为工业级，-40-85℃。 MPU/MMU MPU(Memory Protection Unit) 它是内存保护单元，用于保护内存； 它在大多数计算机的低功耗处理器中实现，更新计算机处理器的指令提取和数据访问等事务； 它用来防止进程访问受保护的内存，有助于防止错误出现。 MMU(Memory Management Unit) 它是内存管理单元，用于处理和管理内存； MMU 会在程序调用时陷入内核态并保存现场资源和进行额外处理； 运行诸如 Linux、WinCE 等多用户多进程操作系统，都需要 MMU，才能为每个用户进程分配独立的地址空间； 运行类似于 ucOS、ucLinux 的精简实时 RTOS 则不需要 MMU。 区别对比： MMU 具备而 MPU 不具备的特性包括：缓存控制，总线仲裁，bank 切换。这些特性是更复杂的计算机所需要的，以便信息处理流程更顺畅无误。 通过使用 MMU，你能优化你的计算机性能，因为它可以让微处理器不用关心上述特性，由独立的 MMU 单元来全权负责。 MPU/MCU MCU(Mirco Controller Unit)是微控制器； 典型的 MCU 通常使用片内 flash 存储器来存储和执行程序代码。以这种方式存储程序意味着 MCU 有非常快的启动时间，上电能够快速执行代码； 片内存储还有个优势是可以加密程序。使用片内存储方式唯一不足就是总存储空间受 MCU 本身所限； 目前市场上绝大多数 flash 型 MCU 最大空间为 2M 字节，从各种应用上看，这证明存储空间是一个限制因素。 MPU (Micro Processor Unit)是微处理器； MPU 没有存储空间的限制，MPU 使用外部存储器提供程序和数据空间；程序一般放在非易失性存储器如 NAND 或者串行 Flash 内；启动时，程序载入到外部 DRAM 中，然后开始执行； 上述内容表明 MPU 没有 MCU 启动运行来的快，但 MPU 可扩展的外部 DRAM 和 NVM 容量能达到数百 Mbytes，甚至达到 Gbytes； 供电方面，一般 MCU 仅仅需要单电压供电，而 MPU 需要几路不同的电压分别给 IO，内核，DDR 等供电，开发者往往需要在电路板上设计附加的电源转换芯片。 MPU 和 MCU 本质上是因为应用定位不同，为满足不同的应用场景而按不同方式优化出来的两类器件： MPU 注重通过较为强大的运算/处理能力，执行复杂多样的大型程序，通常需要外挂大容量的存储器。 而 MCU 通常运行较为单一的任务，执行对于硬件设备的管理/控制功能。通常不需要很强的运算/处理能力，因此也不需要有大容量的存储器来支撑运行大程序。通常以单片集成的方式在单个芯片内部集成小容量的存储器实现系统的“单片化”。 ","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/1-stm32-basic/","tags":[],"title":"STM32 Basic Knowledge"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Ubuntu Configuration Ubuntu Install 虚拟机平台不限，推荐使用：\nVMWare Virtualbox Qemu Ubuntu 版本需要选择 Ubuntu 20.04 安装。发行版代码应该为 focal 。 请使用 lsb_release -a 或 lsb_release -c 验证。\nAdditional Function 虚拟机工具之增强功能可以使得虚拟操作系统的屏幕自适应窗口大小。\n点击 Virualbox 菜单栏中的安装增强功能。 如果没有启动安装，可打开文件管理器，在挂载的逻辑设备中手动运行安装文件。 为使增强工具生效，需要重启操作系统，在 Virubalbox 中可以设置缩放模式。 Files Exchange 虚拟机交换文件可以实现与宿主机的文件交换。\n点击 Virualbox 工具栏中的设置 依次点击 常规，高级 ，将共享剪贴板和拖放均改为双向。 VirualBox Extension 在 VirualBox 官网下载 Extension Pack 在 VirualBox 中点击 管理，扩展，添加扩展包 Input Method 安装 fcitx5\nsudo apt install fcitx5 fcitx5-* im-config #配置输入法为fcitx5 特别地，尽管有多种方法配置环境变量，仍然建议将环境变量配置到 ~/.xprofile 中。\nexport GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx 如果输入法有问题，尝试执行 fcitx5-dignose 进行问题诊断。\nNew Template Ubuntu 操作系统右键菜单中没有新建文档的选项，需要到 ~/Templates 下新建各种文档用作新建的模板。 比如，至少新建一个 .txt 文件。\nROS Install Ubuntu Software Settings 配置 Ubuntu 的软件和更新，允许安装不经认证的软件。\n在 ubuntu 中搜索应用程序 软件和更新 ，打开软件和更新对话框 依次勾选： main universe restricted multiverse Ubuntu Mirror 按照 Ubuntu 镜像使用帮助 操作，编辑 /etc/apt/sources.list 文件。\n# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse Ubuntu Software Source 配置 Ubuntu 的软件源。主要介绍从官方源和国内镜像源两种方法。特别地，官方源由于需要访问 github 网站，需要科学上网工具。\nInstall From Offical 官方源的安装方法如下：\nSetup sources.list\n允许操作系统从 packages.ros.org 上接受 ROS 软件。\nsudo sh -c 'echo \u0026quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\u0026quot; \u0026gt; /etc/apt/sources.list.d/ros-latest.list' # 有关源的选择可以使用国内镜像源 Setup keys\n如果从官方源接受 ROS 软件，则需要执行下面的操作以安装密钥。\nsudo apt install curl # if you haven't already installed curl curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add - Install From China 国内源的安装方法如下：\nSetup sources.list\n下面是部分国内的镜像源：\nhttps://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ https://mirrors.ustc.edu.cn/ros/ubuntu/ 可参考对应的使用帮助：\nhttps://mirrors.tuna.tsinghua.edu.cn/help/ros https://mirrors.ustc.edu.cn/help/ros.html Ubuntu Install ROS 建议使用 apt 而不是 apt-get 进行安装。\n安装 ROS 本体\nsudo apt update sudo apt install ros-noetic-desktop-full # recommand 安装 ROS 相关的软件\nsudo apt install ros-noetic-ackermann-msgs sudo apt install ros-noetic-controller-manager sudo apt install ros-noetic-driver-base sudo apt install ros-noetic-effort-controllers sudo apt install ros-noetic-geographic-info sudo apt install ros-noetic-gazebo-ros-control sudo apt install ros-noetic-gmapping sudo apt install ros-noetic-joint-state-controller sudo apt install ros-noetic-navigation sudo apt install ros-noetic-rtabmap-ros sudo apt install ros-noetic-teb-local-planner sudo apt install ros-noetic-openslam-gmapping 安装其他插件\nsudo apt install tcl-dev tk-dev python3-tk 安装依赖 其中 build-essential 包括了 gcc , g++ , make , dpkg-dev 等工具。 由于 catkin_make 命令依赖 cmake ，因此 cmake 和 extra-cmake-modules 是必须的。\nsudo apt install git build-essential cmake extra-cmake-modules python3 python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool 下载 gazebo 模型 如果从 github 下载慢，可以尝试从 gitee 导入模型。\ngit clone https://github.com/osrf/gazebo_models.git ~/.gazebo/models sudo chmod 777 -R ~/.gazebo/models/* 如果有其他包需要安装，可以直接指定包名。\nsudo apt install ros-noetic-PACKAGE 如果需要搜索包，可以指定搜索关键词\napt search ros-noetic Environment 将 ros-noetic 和 gazebo 均加入 PATH 中，编辑 ~/.bashrc\nsource /opt/ros/noetic/setup.bash # change bash to zsh if you need source /usr/share/gazebo/setup.bash # check if it is setup.sh Dependencies sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 初始化 rosdep 以使用部分 ROS 工具。\nsudo apt install python3-rosdep sudo rosdep init rosdep update Test ROS Installation 可以设置终端的新建方式为新建标签，然后新建三个终端标签，依次输入下面的命令用以测试 ROS 是否顺利安装。\nroscore rosrun turtlesim turtlesim_node rosrun turtlasim turtle_teleop_key Compile 一切就绪后，~Ctrl+C~ 结束运行的测试程序，编译项目。\ncatkin_make ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/ros-doc/1-ros1-install/","tags":[],"title":"ROS1 Installation"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Tmux Brief Report Tmux 是一个终端复用器(terminal multiplexer)，属于常用的开发工具。\nSession 命令行的使用方式是：打开一个终端窗口(terminal window，以下简称\u0026quot;窗口\u0026quot;)，在里面输入命令 用户与计算机的这种临时的交互，称为一次\u0026quot;会话\u0026quot;(session) 会话的特点是，窗口与其中启动的进程是紧密关联的。 Tmux Tmux 将会话与窗口解除绑定，降低耦合\n允许在单个窗口中访问多个会话 允许新窗口接入已经存在的绘画 允许每个会话连接多个窗口，达到会话共享 允许在会话中拆分窗口 Basic Usage Enter \u0026amp; Exit tmux 即可进入 Tmux 窗口。 exit 或 Ctrl+d 退出 Tmux 窗口 Prefix Shortcuts Ctrl+b 是快捷键的前缀快捷键 ^b+? 显示帮助， q 退出帮助 Session New Session tmux new -s \u0026lt;session-name\u0026gt; 创建一个 Tmux 窗口，名称是 \u0026lt;session-name\u0026gt;\nDetach Session tmux detach 将当前会话与窗口分离 Ctrl+b d 同上 tmux ls 查看当前所有的 Tmux 会话，或者 tmux list-session Ctrl+b s 同上 Attach Session tmux attach -t 0 根据会话编号接入已存在的会话 tmux attach -t \u0026lt;session-name\u0026gt; 根据会话名称接入 Kill Session tmux kill-session -t 0 tmux kill-session -t \u0026lt;session-name\u0026gt; Switch Session tmux switch -t 0 tmux switch -t \u0026lt;session-name\u0026gt; Rename Session tmux rename-session -t 0 \u0026lt;new-name\u0026gt; tmux rename-session -t \u0026lt;old-name\u0026gt; \u0026lt;new-name\u0026gt; Ctrl+b $ 重命名当前会话 Windows 窗口指的是整个终端当前呈现给用户的内容，在一次会话中可复用多个窗口。\nc for create new window \u0026amp; for close current window l for switch to last window n for next window p for previous window w for show window menu list Pane 窗格指的是对窗口进行划分的形式，一个窗口可划分为多个窗格。\n% for horizontal split \u0026quot; for vertical split x for close current pane ; for switch to last pane o for move anti-clockwise C-o for swap pane anti-clockwise Double Tmux 当本地与远程同时使用 tmux 时，快捷键会被本地 tmux 捕获，解决办法：\n使用双前缀方法，让第一次快捷键被本地 tmux 捕获，第二次快捷键被远程 tmux 捕获。 更改本地或远程的 tmux 快捷键。 ","permalink":"https://endlesspeak.github.io/docs/build/terminalconfiguration/linux-technology-6-1-tmux/","tags":[],"title":"Reuse Terminal by Tmux"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"计算机系统层次结构 微程序级 本级的语言是微指令集，使用微指令编写微程序，由硬件执行。微命令→微指令→微程序 传统机器级 本级的语言是指令集，可以使用微程序翻译并运行程序。 操作系统级 管理软硬件资源，提供用户与系统交互的接口。 汇编语言级 本级的语言是汇编语言，完成汇编语言在不同平台的具体翻译与实现工作。 高级语言级 本级的语言是高级语言，使用编译或解释程序完成翻译工作。 高级编程语言 高级语言特性 指令更加抽象而不具体（封装） 程序可移植性得到提高（编译器跨平台，目标机对应的编译器的帮助下完成移植） 面向过程、面向对象、面向切面（编程思想） 语言理念与特点 计算机语言处理两个概念，数据和算法。\nC 结构化编程技术反应了过程性编程的思想，开发模块完成各个任务。便于编写和阅读，便于修改与维护，提高了可靠性，保证了质量。 自顶向下规划，结构化编程，模块化设计。 面向过程，强调算法。 C++ 面向对象编程试图让语言满足问题的要求，即设计与问题本质特性相对应的数据格式。 面向对象，强调数据，信息隐藏。 C/C++与其他高级语言相比的优点 高效性，程序运行速度快 粒度细，提供了相当程度的自定义性和控制，涉及指针、内存管理，需要承担更多的责任 软件过程 翻译程序与解释程序 翻译是将一种语言（源语言）翻译成等价的，用另一种语言（目标语言）编写的程序。若指代的是从高级语言向机器语言翻译，则称为编译。 解释是通过直接利用用户的输入执行源程序中的指定操作，特点是一边解释一边执行。\n编译型语言与解释型语言 编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。即一次编译，终身执行。\n解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。即每次运行，每次解释。\n主要区别 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。\n编译程序 运行速度快 ，解释程序跨平台性好， 错误诊断效果好 。\n应用举例 编译型语言：由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用前者； 解释型语言：网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言。 例如，C语言是编译型语言；Python 则是解释型语言。\n编译程序 编译阶段包括三部分：编译，汇编，链接\n编译的任务 是高级语言转换为汇编语言 其可细分为：编译预处理、词法分析、语法分析、语义分析、中间代码产生、机器无关与相关优化、目标代码产生等。 主要是进行词法分析和语法分析。 汇编的任务 是将汇编语言转换为机器语言 链接的任务 是将源文件中用到的*库函数*与汇编生成的*目标文件*合并，同时将多个目标文件链接生成可执行文件。 静态链接与动态链接 静态链接 链接器在链接时将库文件或目标文件的内容加入到可执行程序中的做法。 优点：\n代码装载速度快，运行略快； 静态依赖包含在发布的二进制程序中，不需要额外环境； 缺点： 生成的可执行文件体积较大，包含相同的公共代码，造成浪费。\n动态链接 动态链接将链接的过程推迟到了运行时再进行。 优点：\n生成的可执行文件小； 适合大规模软件开发，开发耦合度小； 链接库可以相互共享，链接库与可执行文件独立，提高可维护性和可扩展性； 缺点：\n需要依赖外部动态链接库； 速度较慢； 程序开发 定义程序的目标 类似软件过程中的 需求分析 ，明确程序目的，输入，算法，输出。\n设计程序 类似软件过程中的 概要设计 ，执行逻辑、数据处理、界面显示等\n编写代码 类似软件过程中的 详细设计 与编码，把设计的内容翻译成 C 语言。\n编译 该步是文件由代码变成程序最重要的一步。\n运行\n测试与调试 类似软件过程中的测试，测试可以理解为设计提供的输入并分析得到的输出；调试则是在分析测试过程中代码段的内在逻辑和数据的变化规律等。\n维护及修改 类似软件过程中的维护与再工程。\n术语提要 源代码文件 就是用户编写的代码文件；\n可执行文件 就是最终生成的程序；\n中间代码文件 即 C 源代码文件转换为最终可执行文件过程中生成的代码文件，或称为过程文件；\n目标代码文件 即编译器编译后得到的代码文件，注意：中间代码文件包括目标代码文件;，当然也包括其他的一些文件，即目标代码文件是中间代码的子集（大部分情况下是真子集）；\n库文件 是 C 语言提供的一些提前准备好的代码文件，库文件包含许多现成可用的代码。库文件包括静态链接库和动态链接库，静态链接库的文件会被包含在最终生成的可执行文件中；动态链接库文件则只会在执行时与可执行文件进行链接。\nC 编程的基本策略是把 源代码文件 转换为 可执行文件 。如前所述，典型的 C 通过编译、链接完成这个过程（汇编可以看作编译的一部分）。\n编译器 的作用是把 源代码 转换成 中间代码 。\nC 使用上述这种分而治之的办法以对程序实现模块化，例如可以独立编译单独的模块，稍后用链接器合并已编译的所有模块。通过这种方式的优点在于如果只更改某个模块，不必因此重新编译其他的模块。\n中间代码 或者说中间文件，具有很多种形式，最普遍的形式，即把源代码转换得到的机器语言代码，并把转换的结果放在目标代码文件中。此时中间代码指代 目标代码文件 。\n目标代码文件缺失 启动代码 。启动代码充当着程序和操作系统之间的接口。\n目标代码文件也许还缺失 库函数 ，几乎所有的 C 程序都需要使用 C 标准库中的函数，部分程序还需要非标准库中的库函数。库文件中包含许多函数的目标代码（当然也包括它们的源代码）。\n链接器 的作用是把中间代码和其他代码还有预编译的库代码合并成为可执行文件。\n","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/1-1-compilerlanguage/","tags":[],"title":"Compiler Language"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"名词释义 入侵检测技术的原理如何？\n包括基于数据源划分和基于检测技术的划分。数据源就是数据如何产生，可基于主机或基于网络；检测技术则分为基于误用和基于异常。基于误用可以理解为模式匹配，基于异常是只要不合法就判断为非法。入侵检测技术可简化成一种二分类问题。\n如何选择研究方法？\n由于使用基于异常的检测技术，也就是对正常或者不正常的访问进行划分，数据集中包含了最终的分类标签，因此采用的是监督学习。\n在生成方法和判别方法中，生成方法是统计得到联合概率，计算后得到条件概率；判别方法则直接学习条件概率，因此判别方法可以简化学习问题。\n毕业课题中，第一，所有的变量理论上都可以观测到值，不存在隐变量；第二，实际应用中部署的是训练好的模型，生成模型学习收敛速度快这点并不占优势，最后是由于判别方法直接学习条件概率或决策函数，准确率较高。\n什么是输入空间，什么是输出空间，什么是特征空间？\n输入X可能取值的集合是输入空间；\n输出Y可能取值的集合是输出空间；\n每个具体的输入是一个实例，由特征向量表示；\n所有特征向量存在的空间称为特征空间。\n特征空间与输入空间有时候不同，不同的情况是输入空间通过某种映射生成了特征空间。\n什么是损失函数，什么是经验风险，什么是期望风险，什么是结构风险？\n损失函数：针对单个具体样本，表示模型预测值与真实样本值之间的差距。常见的损失函数有0-1损失函数、平方损失函数、绝对损失函数、对数损失函数（对数似然损失函数）。 经验风险：对所有训练样本的损失函数的平均值，或模型对所有训练样本的预测能力。 期望风险：对所有样本的损失函数的平均值，或模型对未知样本和已知的训练样本的综合预测能力。 结构风险：是对经验风险和期望风险的折中，在经验风险函数后面加一个正则化项。 为什么使用决策树、支持向量机、前馈神经网络算法实现入侵检测？\n选择决策树是因为它原理简单，可解释性高，可视性好，一开始使用迭代二分法决策树作为原型，后面改用最大信息增益比率决策树进行实现，原因是需要对连续值进行划分；\n选择支持向量机则是因为它是传统机器学习算法中表现最优异的一种，推导严谨，分类比较精确，具体实现上使用序列最小优化算法进行实现，后面借鉴了一下最小二乘法的实现；\n选择前馈神经网络，它结构简单，实现快，可用它与传统机器学习算法进行对照。\n没有免费午餐定理\n任何一个预测函数，如果在某些样本上表现好，那么在另一些样本上就表现不好。\n如果不对数据在特征空间的先验分布有一定假设，那么表现好与表现不好的情况一样多。\n定理价值：\n必须假设：在特征空间上接近的样本属于同一类别的概率更高。 没有放之四海而皆准的最好算法，因为没有人知道特征空间先验分布的真正情况。 如何评价学习的效果？采用何种标准？\n样本共有4类，分别是：\nTP：实例是正例，且被判定为正例 FP：实例是反例，但被判定为正例，误报 TN：实例是反例，且被判定为反例 FN：实例是反例，但被判定为正例，漏报 正确率：$Accuracy=\\frac{TP+TN}{TP+TN+FP+FN}$\n精确率：$Precision=\\frac{TP}{TP+FP}$\n召回率：$Recall=\\frac{TP}{TP+FN}$\n两者通常相互“制约”：追求精确率高，则召回率就低；追求召回率高，则通常会影响精确率。\n数据处理 项目过程（项目是怎么实现的）\n项目主要分为数据处理、模型学习和模型预测三个步骤。具体过程见下：\n环境准备\nimport numpy as np import pandas as pd import matplotlib.pyplot as plt import math 你的数据集是怎样选取的，为什么要这样选择？\n我选择的数据集是CIC-IDS-2017，基于以下原因。（待完善）\n你对数据做了哪些预处理？有哪些改进的方法？\n主要包括：数据准备、删除缺失值、归一化和特征缩放。\n数据处理这块参考了一个使用CIC-IDS-2017数据集的入侵检测基线系统，它有一个删除低关联的特征的操作，但是基于异常的入侵检测本身需要更多维度的数据作为支撑，对于未知的入侵过程来说具体哪些特征属于低关联特征是不清楚的，因此这里没有选择删除低关联的特征。\n数据准备如何实现？\n解压缩数据：\n!unzip XXXX.zip -d ./data/ 项目使用pandas导入数据集，导入后格式为dataframe：\nwednesday=pd.read_csv('XXX.csv',low_memory = False) #low_memory参数可以省略 若使用numpy导入数据集，导入后格式是元组：\np = r'XXXX.csv' with open(p,encoding = 'utf-8') as f: data = np.loadtxt(f,str,delimiter = \u0026quot;,\u0026quot;) print(data[:5]) 注释：\nnumpy导入数据使用的方法是numpy.loadtxt()，默认是float格式，通过加入str参数可使其识别字符串类型数据，避免导入出错； with open() as f是读入文件方法，r代表以只读方式打开文件； [:5]代表的是从第1行一直到第5行。 对数据列名进行规范：\nwednesday = wednesday.rename(str.lstrip, axis='columns') 注释：\ndataframe.rename()方法用于更改数据的行列名。通过axis参数指定行列。 str.lstrip()方法用于去除字符串起始部分的选定字符，默认为空格。 查看标签情况：\ndf = wednesday print(df['Label'].unique()) 注释：\ndataframe.unique()方法以数组形式返回列的唯一值（去除重复值），用于获知有哪些标签。 dataframe.nunique()方法返回的是列的唯一值的个数。 获得数据列名：\n#法一，等价于法二 lables=[column for column in df] #法二 lables=[] for column in df: labels.append(column) lables.remove('Label') print(lables) print(len(lables)) 注释：\nc for b in a指的是对a中每一个迭代对象b，都进行c操作。此处将语句放在元组里等于对迭代对象使用list.append()方法。 list.remove()方法用于移除元组中的某个元素。 list.len(list)方法用于获得元组中的元素个数。 缺失值删除是如何实现的？\n将inf替换为NaN，然后删除缺失值\ndf=df.replace(np.inf,np.nan) df=df.dropna(axis=0) 注释：\ndataframe.replace()方法用于将数据中的某个元素统一替换为另一个元素； dataframe.dropna()方法用于将数据中的缺失值删除 axis=0或\u0026rsquo;index\u0026rsquo;表示删除包含缺失值的行；axis=1或\u0026rsquo;columns\u0026rsquo;表示删除包含缺失值的列 标签与特征分离\nX = df.loc[:,df.columns != \u0026quot;Label\u0026quot;] y = df.loc[:,df.columns == \u0026quot;Label\u0026quot;] 注释：\ndataframe.loc()方法用于切片，提供参数为行索引名称或条件 , 列索引名称，切片结果是闭区间； dataframe.iloc()方法亦用于切片，提供参数为行索引位置和列索引位置，切片结果是开区间。 归一化和特征缩放是如何实现的？\n对于标签数据，使用sklearn.LabelEncoder()来转化\nencoder = LabelEncoder() y = encoder.fit_transform(y) 注释：\nLabelEncoder 来转化 dummy variable（虚拟数据）非常简便，encoder 可以将数据集中的文本转化成0或1的数值，从而解决二分类问题。 fit_transform()方法对数据进行统一处理，包括将数据缩放(映射)到某个固定区间，归一化，正则化等标准化等。特别地，得到的类型为numpy。 对于非标签数据，使用sklearn.RobustScaler()来转化\nscaler=RobustScaler() X = scaler.fit_transform(X) 注释：\n归一化分为StandardScaler，MinMaxScaler，RobustScaler等；\n标准化缩放方法通过减去均值然后除以方差（或标准差）；\n最大最小值缩放方法将特征缩放到给定的最小值和最大值之间；\n鲁棒缩放方法使用中位数和四分位矩，不容易受到异常值影响。\n原理：\n四分位数，把所有数值从小到大分为四等份，处于三个分割点位置的数值是四分位数；\n第一四分位数和第三四分位数的差称为四分位距；\n计算方法为：\n$$ v_i^{'}=\\frac{v_i-median}{IQR} $$ 其中median是中位数，IQR是样本的四分位距。\n另外，dataframe.values()方法用于将pandas转为numpy类型\n训练集与验证集划分\n使用sklearn.train_test_split()方法。\nx_train, x_test, y_train, y_test = train_test_split(X, y, test_size=0.30, shuffle=True, random_state=123, stratify=y) 其他问题 Python的四大数据类型是哪些？\n元组、列表、字典、字符串\n项目具有哪些改进方向？\n决策树：CART树 支持向量机：最小二乘法、加权、稀疏核机 神经网络：循环神经网络 ","permalink":"https://endlesspeak.github.io/docs/docs/machinelearning-doc/traddional-machine-learning/1-summarize/","tags":[],"title":"机器学习综述"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"你本科阶段有哪些项目经历？\n做过三个项目，分别是一个使用Java Server Page的考务管理系统，一个使用MybatisPlus + Springboot的商城系统，还有一个是有关三种传统机器学习算法的实现，使用的是最大信息增益比率的决策树、序列最小最优化算法的支持向量机和前馈神经网络。\n下面是Java Web项目可能涉及的问题。\n综合问题 使用的是什么技术，采用的是什么架构？\n使用的技术：\n考务管理系统使用的是Java Server Page+Java Bean+Servlet； 商城项目使用的是Mybatis Plus + Spring Boot； 采用的架构：\n考务管理系统使用的是MVC模式； 商城项目使用的是Java三层架构； 什么是MVC模式？\nM for Model，代表业务模型 V for view，代表视图层 C for controller，代表控制器 考务管理项目中，JavaBean是业务模型M，JSP是视图层V，Servlet是控制器C； 什么是Java三层架构？\n业务层（逻辑层、service层）\n采用事务脚本模式。将一个业务中所有的操作封装成一个方法，同时保证方法中所有的数据库更新操作同时成功或同时失败。避免部分成功部分失败引起的数据混乱操作。\n表现层（MVC）\nM称为模型，也就是实体类，Bean。用于数据的封装和数据的传输。\nV为视图，也就是GUI组件，JSP，用于数据的展示。\nC为控制，也就是事件，Controller，用于流程的控制。\n持久层（DAO）\n采用DAO模式，建立实体类和数据库表映射Mapper。也就是哪个类对应哪个表，哪个属性对应哪个列。\nDAO位于业务逻辑和持久化数据之间实现对持久化数据的访问。就是将数据库操作都封装起来。\n商城项目主要分为哪些部分？对应Java三层架构的哪一层？\n主要有 JSP→Web/Controller→Service→ServiceImpl→Dao/Mapper→Bean\nBean是各个基础类，是业务模型，属于MVC层的Model层；\nDao封装对持久化数据的访问操作，如何处理数据并调用数据库；\nService提供相应的服务，分模块调用各个Dao；\nServiceImpl是它们的具体实现；\nController是MVC的Controller层，\n实现相应的功能，分模块请求多个服务，还包含请求服务时的预处理；\nJSP是MVC的View层，负责展示具体的页面；\n服务器中状态码分别代表什么？\n状态码1xx 等待继续\n100 等待继续提出请求 状态码2xx 处理过程\n200 服务器已成功处理的请求 状态码3xx 服务器位置改变\n301 永久移动 302 临时移动 307 临时重定向 状态码4xx 服务器已收到请求，但未做出期望的回应\n400 服务器不理解请求的语法 401 服务器请求身份验证 403 服务器拒绝请求 404 服务器找不到请求的网页 状态码5xx 服务器错误\n500 服务器遇到错误，无法完成请求\n可能是传递的参数内容不正确；\n501 服务器不具备完成请求的功能\n例如服务器无法识别请求方法；\n502 服务器网关错误，从上游服务器收到无效响应\n网关工作在网络层，网关错误指的是服务器正在充当另一台服务器的中继代理，但是从该服务器收到的是错误的响应。\n503 服务器不可用\ncookie、session、token分别是什么？\ncookie是存储在浏览器端的加密文本，保存了大量轨迹信息。它由服务器生成，发送给浏览器。\n下一次相同的请求时，浏览器将把cookie发送到服务端，服务器使用这些信息来识别用户，确认用户状态。cookie是有状态的；\nsession对象是存储在服务器端的，它存储特定用户会话所需的属性和配置信息（仅在会话期间有效）。\n当会话结束时，session对象被销毁。而下次产生该会话时，将会重新生成session对象；\ntoken是一小段通用的字符串。\ntoken令牌的值是存储在服务器中的数据库中，生成的token令牌也会保存在客户端的cookie中或其他地方。每次用户向服务器发送网络请求时都会附带token令牌，token是无状态的。\nXXX\nJava Servlet 理论问题 JSP 过滤器是什么？\n过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。\n过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：\n在客户端的请求访问后端资源之前，拦截这些请求。 在服务器的响应发送回客户端之前，处理这些响应。 JSP和Servlet的区别？\nServlet是位于Web服务器内部的服务器端的Java应用程序，与传统的从命令行启动的Java应用程序不同，Servlet由Web服务器进行加载，该Web服务器必须包含支持Servlet的Java虚拟机。\nServlet具有独立于平台和协议的特性，可以生成动态的Web页面。它担当客户请求（Web浏览器或其他HTTP客户程序）与服务器响应（HTTP服务器上的数据库或应用程序）的中间层。\nJSP全名为Java Server Pages，中文名叫java服务器页面，是一种动态页面技术，它的主要目的是将表示逻辑从Servlet中分离出来。其根本是一个简化的Servlet设计。\nJSP技术使用Java编程语言编写类XML的tags和scriptlets，来封装产生动态网页的处理逻辑。网页还能通过tags和scriptlets访问存在于服务端的资源的应用逻辑。\nJSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。\nServlet中提供了两种请求方法，doGet和doPost方法，它们的联系和区别为何？\n它们都是HTTP协议中的两种请求发送的方法，都是TCP连接。\nget把参数包含在URL中，post通过request body传递参数；\nget请求只能url编码，post支持多种编码方式；\nget请求有长度限制，post请求则无此限制；\nget仅接受ASCII字符，post请求无此限制；\nget产生一个TCP数据包，post产生两个TCP数据包；\nget在传输层逻辑上只传输一次，服务器返回200 ok；\npost逻辑上传输两次，先传header，服务器返回100 contiune，再传data，服务器返回200 ok；\n具体实现 项目介绍\n登录系统 考试信息一览表：展示所有考试的情况，对于考试，管理员可以安排监考（若未安排监考）或修改考试信息，普通老师也可以申请成为监考； 监考信息修改：与考试申请表相同，设置标志为修改； 监考安排与指派：列出所有老师的当前状态，以及是否安排为主监考或副监考； 监考信息一览表：展示所有老师的概要信息、监考次数、 当前状态等情况； 考试申请表：普通老师向管理员申请考试，并添加相应的内容并提交； 查看我的考试申请：普通老师查看自己申请的考试情况； 待审核考试表：向管理员展示所有申请的考试，等待管理员进行审核； 代码复用技术\n条件查询，参数是条件语句，返回对象数组； 因为结果可能存在一个或多个，返回数组使上层不关心具体的实现细节，使用ResultSet提供的方法()进行遍历，避免在函数编写和调用时的复杂性，上层也无需判断可能的操作数量； 其他的查询，例如查询所有考试、根据考试编号查询考试、根据考试状态查询考试等查询方法，可直接调用该条件查询，只需修改对应的条件语句参数即可； 前端接收数据格式\n前端Layui使用json字符串格式数据渲染表格，因此需要将object对象转化为json格式。使用的是fastjson包。\n定义转换函数：（待完善）\n传入参数为object，code，message，count等信息； 初始化jsonObject对象，并使用jsonObject.put()方法依次加入code，message，count信息到JSONObject中； 使用json.toJSONString(object)将object转换为JSONObject； 由于object可能有多个，将JSONObject装入JSONArray后再加入JSONObject； 最后将JSONObject转为JSON字符串格式； 登录系统\n请求 AccountServlet 进行登录并向其传参；\n使用 request.getParameter() 获得登录页面传来的参数；\n实例 AccountBean 类的对象并调用其 login 方法；\n在 AccountBean 类中创建dataBaseBean类对象，并运行sql语句，返回到ResultSet类的对象中。\nResultSet.beforeFirst()跳转到开头；\nResultSet.next()依次遍历\nResultSet.getString(XX).equals(YY)验证用户名与密码是否正确。\n正确的话获取AccountBean类的用户名，类型和职工号。\nrequest.getSession().setAttribute(XXX, YYY);登录成功将account对象写入session\n改进思路：使用string.concat()连接字符串，使用string.format()形成格式化字符串。\n主页面\nAccountBean account=session.getAttribute获得当前登录的用户名和用户类型；\n根据用户类型获得用户对应的导航栏界面；\n表格页面\n使用layui中的soulTable组件。\n数据接口为ExamQueryServlet，数据格式为json格式，包括code,msg,count,data等。\n监听行工具事件，layui提供了方法获得当前行的数据，将数据作为参数赋给跳转页面。\n监考申请\n添加班级时，可以选择的班级由嵌入的java代码连接dataBaseBean，获得返回的内容并加入到选项中。\n添加班级使用内容模板，使用layui提供的JavaScript代码，获得父节点对象，克隆目标，修改ID，添加属性，加入到原来的表单中，更新渲染。\nrequest.getRequestDispatcher(request.getHeader(\u0026quot;Referer\u0026quot;)).forward(request, response);其中Referer代表请求的来源，forward代表请求转发。\nwindow.location.href()重定向到页面。\n请求转发和重定向的区别\n请求转发是一个请求一次响应，而重定向是两次请求两次响应。 请求转发地址不变化，而重定向会显示后一个请求的地址。 请求转发是服务器的行为，是由容器控制的转向，整个过程处于同一个请求中，因此客户端浏览器不会显示转向后的地址； 重定向是客户端的行为，重新发送了请求，整个过程不在同一个请求中，因此客户端浏览器会显示跳转后的地址。 请求转发只能转发到本项目其它Servlet，而重定向不只能重定向到本项目的其它Servlet，还能定向到其它项目。 请求转发是服务端行为，只需给出转发的Servlet路径，而重定向需要给出requestURI，既包含项目名。 Spring Boot 理论问题 容器\n容器是一种为某种特定组件的运行提供必要支持的一个软件环境。\nSpring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。\nSpring的DI依赖注入\n依赖关系的管理交给spring的IOC容器维护，在当前类需要用到其他类的对象，由spring为我们提供，只需在配置文件中说明维护关系即可；\n这样做的目的是降低程序之间的耦合（依赖关系）。\n依赖注入的内容和方式\n依赖注入的内容包括：\n基本类型和string 其他bean类型（在配置文件中或者注解配置过的bean） 复杂集合类型 依赖注入的方式：\n使用构造函数 使用set注入完成复杂集合类型数据 注解方式 Spring的控制反转\n控制反转是一种设计思想，即你设计好的对象交给IOC容器控制，而不是传统的在你的对象内部直接控制。依赖注入是控制反转的一种典型实现方式。 由IoC容器控制了对象；控制外部资源获取。 控制权发生了反转，即从应用程序转移到了IOC容器。所有组件不再由应用程序自己创建和配置，而是由IoC容器负责。 Spring AOP 面向切面编程\nAOP把系统分解为不同的关注点，或者称之为切面（Aspect）； 模块化常用方法或常用步骤，对其进行动态代理； AOP对于解决参数固定的特定问题非常有效，但对经常需要变动的步骤则不容易实现； 什么是Map，为什么用Map\nMap是一个接口，它的每个元素包含一个key对象和一个value对象，key必须是唯一的且不能重复。\nMap的实现类包括HashMap、TreeMap、HashTable。\nTreeMap是有序的，HashMap和HashTable是无序的； Hashtable的方法是同步的（线程安全），HashMap的方法是异步的（非线程安全）； Hashtable不允许null值，HashMap允许null值（key和value都允许） Map的通用方法有：\n返回map集合大小 int size;\n判断map集合为空 boolean isEmpty();\n根据key值获取value Object get(Object key);\n添加元素\u0026lt;key value\u0026gt; Object put(Object key,Object value);\n获取元素的键和值的接口；\ninterface Entry\u0026lt;k,v\u0026gt;{\rk getKey();\rv getValue();\r}\r注解举例？\n@Override\n作为注释使用；代码规范，对父类方法的重写；编译器验证父类中是否有此方法；\n@ApiModel\n表示对model属性的说明或者数据操作更改，返回给swagger。\n@TableId\n用于主键的注解。\n@Mapper\nMybatis框架中定义的一个描述数据层接口的注解。\n@Autowired\n注入一个定义好的bean类。\n声明式事务\n事务管理是为了当出现异常情况时，用它保证数据的一致性。\n1. 使用`PlatformTransactionManager`来表示事务管理器，所有的事务都由它负责管理。\r2. 使用`TransactionStatus`表示事务；\r声明式事务是建立在AOP之上的。其本质是对方法前后进行拦截。\n1. 添加`@EnableTransactionManagement`注解就可以启用声明式事务；\r2. 添加`@Transactional`注解为方法提供事务支持；\rMyBatis的原理\n读取 MyBatis 配置文件 通过配置文件加载映射 生成Configuration对象 构造会话工厂 创建SqlSessionFactory对象 创建会话对象 根据工厂创建SqlSession对象 输入参数映射 执行SQL语句 输出结果映射 MyBatis使用的设计模式\n工厂模式使对象的创建过程延迟到子类进行，父类操作的是抽象产品，不关心子类的具体实例。\n工厂模式定义创建对象的接口，让子类自行决定实例化哪一个工厂类。\n数据库范式\n1NF 是指数据库表的每一列都是不可分割的基本数据项；\n2NF 是指实体的属性完全依赖于主关键字，而不能只依赖一部分属性；\n3NF 是指属性不依赖于其它非主属性；\n例如存在部门信息表，每个部门除了部门号还有部门名称等；员工信息表中列出部门编号后不能再列出部门名称等，防止信息冗余。\nBCNF 是指在3NF基础上，消除主属性对码/键的部分依赖、传递依赖，则称它符合BCNF；\n即每一个决定因素都包含码。\n数据源或连接池\n数据源的目的是提高程序性能，具体原理是： 事先实例化数据源，初始化部分连接资源 使用连接资源时可以从数据源获取 使用完毕后将连接资源归还给数据源 常见的数据源有哪些？ C3P0连接池 Druid连接池 我使用的是spring-boot-starter-jdbc连接池 SQL注入问题\n应用程序使用拼接SQL的技术而被黑客利用，攻击后台。\n使用mybatis编写sql语句时，#{ }和${ }两种方式 进行模糊查询。\n${ }表示拼接字符串，将接收到的参数内容不进行任何处理，会出现SQL注入问题。 #{ }会先对sql语句进行预处理，不会出现SQL注入问题。 具体实现 项目简介\n登录 商品信息管理 商品展示页面 前端 前台 商品管理页面 前端 后台 商品增删改查 后端 物流信息管理 物流管理页面 前端 后台 物流增删改查 后端 订单信息管理 订单管理页面 前端 后台 订单增删改查 后端 客户信息管理 客户管理页面 前端 后台 客户增删改查 后端 购物信息管理 购物管理页面 前端 前台 购物增删改查 后端 前端后端，前台后台的区别\n前端 后端 前台 后台 登录逻辑和安全框架 shiro\n数据层 Realm\nshiroRealm负责用户的认证和权限的处理\n管理层 ShiroSecurityManager\nSecurityManager权限管理类，组合了登录、登出、权限和session的处理 用户层 Subject\nShiroFilterFactoryBean用于生成shiroFilter，指示哪些页面被保护，一般是除了登录页面和首页以外的全部页面。\n登录过程中，令牌token作参数；\n登录过程\nController获得登录时传入的字符串 将字符串封装成自定义token类对象 根据token对象调用subject中的登录方法，放在try中，捕获各类匹配错误 subject登录方法调用service中的登录方法，进而映射到Mapper中的SQL语句进行匹配 无错误，根据SecurityUtils中的getSubject().getSession().getAttribute()实例化用户对象 分页查询的实现\n下拉菜单或数据表的行操作的实现\n页面跳转的实现\n加入购物车功能的实现\n生成订单的功能实现\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/projectdevelopment/","tags":[],"title":"项目经历"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"如果现在让我选择一个我心目中最好的Linux发行版，同时也是最简单的Linux发行版，作为长期甚至终身使用的Linux，我会选择的发行版是：Arch Linux！\n尽管入门可能会有难度，但它比任何其他的发行版都要好，它可以避免管理其他任何系统时所不得不忍受的痛苦。人们通常会想到入门难度，但最重要的其实是终身难度。同时，Arch Linux比其他发行版更有可能改变人们对Linux发行版的看法。——Luke Smith\n下面我结合我这段时间的学习，谈谈如何在Arch Linux上打造属于我自己的工作环境。\nInitialization 在刚安装完Arch Linux的电脑上依次运行下面的命令。\n注：如果是Manjaro发行版，由于开源驱动nouveau比较弱智，需要在启动选项中调参设置。\n具体的做法是在进入grub菜单后选择Manjaro按e进入启动参数设置，搜索第一个quiet并在后面加入nouveau.modeset=0之后按Ctrl+X启动；\n正常进入系统之后记得输入命令sudo vim /boot/grub/grub.cfg ，然后把上面的操作重复一遍。\n命令约定：无$标识符的命令代表以root身份执行；通常它们在终端中以#开头。\narchlinux login:root #以root方式登录 Password: dhcpcd #有线网络连接时，自动分配IP地址 pacman -S vim #安装编辑器之神VIM vim /etc/pacman.conf 查找Color并删去注释，然后在文件尾添加以下内容：\n[archlinuxcn] SigLevel = Never #或者Optional TrustedOnly Include = /etc/pacman.d/archlinuxcn vim /etc/pacman.d/archlinuxcn #使用Ctrl+Shift+C/V向文件中加入以下内容 ## 浙江大学 (浙江杭州) (ipv4, ipv6, http, https) ## Added: 2017-06-05[archlinuxcn] Server= https://mirrors.zju.edu.cn/archlinuxcn/$arch ## 中国科学技术大学 (ipv4, ipv6, http, https)[archlinuxcn] Server= https://mirrors.ustc.edu.cn/archlinuxcn/$arch ## 清华大学 (ipv4, ipv6, http, https)[archlinuxcn] Server= https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch ## xTom (Hong Kong) (ipv4, ipv6, http, https) ## Added: 2017-09-18 ## xTom Hong Kong Mirror[archlinuxcn] Server= https://mirror.xtom.com.hk/archlinuxcn/$arch ## Unique Studio (湖北武汉) (ipv4, http, https) ## Added: 2017-08-02[archlinuxcn] Server= https://mirrors.hustunique.com/archlinuxcn/$arch ## 上海科技大学 (上海) (ipv4, http, https) ## Added: 2016-04-07[archlinuxcn] Server= https://mirrors-wan.geekpie.org/archlinuxcn/$arch ## 中国科学院开源软件协会 (北京) (ipv4, http) ## Added: 2017-02-09[archlinuxcn] Server= http://mirrors.opencas.org/archlinuxcn/$arch ## 电子科技大学凝聚网络安全工作室 (ipv4, http) ## Added: 2016-05-28[archlinuxcn] Server= http://mirrors.cnssuestc.org/archlinuxcn/$arch ## 网易 (ipv4, http)[archlinuxcn] Server= http://mirrors.163.com/archlinux-cn/$arch ## 重庆大学 (ipv4, http)[archlinuxcn] Server= http://mirrors.cqu.edu.cn/archlinuxcn/$arch 然后再继续执行下面的命令：\npacman -S archlinuxcn-keyring #安装密钥 可能遇到Unable to lock database错误，执行下面的命令作为解决方案：\nrm /var/lib/pacman/db.lck pacman -Syyu #强制更新软件源列表并更新本机软件 注1：你可能会在以后的使用过程中遇到更新出错的情况。但是请注意，用户应当对自己的滚动升级的系统稳定性负责任。用户自己决定何时升级、修改配置。Arch与其他发行版的一个不同是，Arch是真正的“DIY”发行版。抱怨系统损坏是无意义的，毕竟上游的改动不是Arch开发者的责任。\n注2：如果是Manjaro发行版，初始执行更新软件源列表出错，运行下面命令：\npacman-mirrors -i -c China -m rank 或者sudo vim /etc/pacman.d/mirrorlist并向其中添加下列内容：\n## 中科大 Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch ## 清华大学 Server = https://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$arch ## 上海交通大学 Server = https://mirrors.sjtug.sjtu.edu.cn/manjaro/stable/$repo/$arch ## 浙江大学 Server = https://mirrors.zju.edu.cn/manjaro/stable/$repo/$arch 依次执行下面的命令：\npacman -S nvidia #安装NVIDIA驱动 注：关于驱动的内容，请详细地参考：Arch NVIDIA\npacman -S xorg xorg-sever #首先安装Xorg，如果使用NVIDIA闭源驱动还需要追加Xorg-xrandr pacman -S xf86-input-synaptics #笔记本的触摸板驱动 pacman -S ttf-dejavu wqy-microhei #安装中文字体包 #注，本条见后面的中文输入法 新增一个普通用户，养成良好的安全习惯，日常事务用普通用户进行：\nuseradd -m -g users -G wheel -s /bin/bash \u0026lt;username\u0026gt; #上述命令为添加用户，-m表示添加用户的登入目录（即家目录），用户名\u0026lt;username\u0026gt;,-G表示所属的附加群组wheel，-g指定用户所属的群组，值可以是组名，也可以是GID，用户组必须已经存在，默认值100，即users，-s指定用户登入后所使用的shell passwd \u0026lt;username\u0026gt; #设置该用户的密码 ln -s /usr/bin/vim /usr/bin/vi #把vim编辑器链接到vi上（当然习惯使用vi也可以不链接，或者链接nano都行） visudo #使用该命令为你的用户进行提权 使用visudo进入sudo file后，查找到# %wheel ALL=(ALL) ALL，去除前面的#号。完成这一切后，输入exit退出管理员用户，并以新添加的用户身份登录。\nDeepin ※安装DDE (Deepin Desktop Environment)桌面环境是最重要的一步，命令如下：\n$ sudo pacman -S deepin deepin-extra 注：DDE 桌面我个人理解是Gnome系的设计理念，KDE系的外观。(注：Gnome是为对抗KDE应运而生的桌面环境)；DDE 的显示管理器默认为 lightdm，如果你需要安装多个桌面环境，例如将KDE Plasma和DDE 同时安装，则用下面的命令查询正在起作用的显示管理器：\n$ sudo systemctl status sddm $ sudo systemctl status lightdm 如果登录管理器不能正常运作，使用下面的命令检查报错信息：\n$ sudo journalctl -u lightdm 可以选择自己喜欢的显示管理器启用，并弃用另一个显示管理器。简要命令如下：\n$ sudo systemctl enable lightdm $ sudo systemctl disable sddm 为Deepin切换Deepin风格的登录界面：\n$ sudo vim /etc/lightdm/lightdm.conf 将/greeter-session=example-gtk-gnome改为/greeter-session=lightdm-deepin-greeter并去掉前面的#号。\nKDE Plasma ※如果选用KDE Plasma，则安装KDE桌面环境是最重要的一步。如果觉得整体安装包过大，可以安装虚包：\n$ sudo pacman -S plasma kde-applications #完整包 $ sudo pacman -S plasma-meta kde-applications-meta #虚包 安装图形登录界面：\n$ sudo pacman -S sddm sddm-kcm $ sudo systemctl enable sddm #开启sddm服务，以自动登录到显示管理器 Basic Apps 安装日常使用的软件命令如下：\nNVIDIA 如果是使用NVIDIA闭源驱动，则使用下列命令编辑启动管理器的脚本：\n$ sudo vim /usr/share/sddm/scripts/Xsetup 加入下列内容：\nxrandr --setprovideroutputsource modesetting NVIDIA-0 xrandr --auto 输入下列命令获知本机的显卡型号及PCI地址：\n$ lspci -k | grep -A 2 -E \u0026quot;(VGA|3D)\u0026quot; $ sudo vim /etc/X11/xorg.conf 在该文件(没有会自动创建一个)中输入下列内容：\nSection \u0026quot;Module\u0026quot; Load \u0026quot;modesetting\u0026quot; EndSection Section \u0026quot;Device\u0026quot; Indentifier \u0026quot;nvidia\u0026quot; Driver \u0026quot;nvidia\u0026quot; BusID \u0026quot;1:0:0\u0026quot; #填入刚才获得的显卡PCI地址，注意每部分均为个位数 Option \u0026quot;AllowEmptyInitialConfiguration\u0026quot; EndSection 配置以上部分，重启之后Arch Linux应该就能顺利进入sddm登录管理器了。\n问题：配备intel集成显卡和NVIDIA独立显卡的机器登入图形界面时机器挂起/关机\n首先，需要注明的是，这是Linux对于NVIDIA显卡驱动支持不完善的问题引起的。但硬件驱动支持不完善是典型的上游错误(NVIDIA显卡没有发挥它的作用是NVIDIA团队的问题，而不是Arch开发者的责任)。\n如果不启动图形界面，只用tty，是没有问题的。\n解决方法：\n如果你将你的Display Manager加入了守护进程(即每次会自动登入Display Manager)，那么我目前能想到的方法是使用Live CD，将你的Arch Linux挂载在Live CD上，然后使用arch-chroot操作。\n如果你开机进入的是tty(即你每次都是手动启动图形界面)，那么就按照平时在终端中的操作来进行操作即可。\n操作如下：\n$ sudo pacman -S bumblebee # 安装bumblebee $ sudo nano /etc/modprobe.d/modprobe.conf #在文件中添加“options nvidia NVreg_Mobile=1”，然后保存退出，重启机器 安装图形网络管理工具： $ sudo pacman -S networkmanager #一般来说你应该已经安装过了，此处以防万一。 $ sudo pacman -S net-tools $ sudo systemctl enable NetworkManager #开启网络管理服务 $ sudo systemctl enable dhcpcd 安装声音相关的软件： $ sudo pacman -S alsa-utils pulseaudio pulseaudio-alsa 安装Yay： Yay是AUR的包管理器。(也可以使用yaourt，见下)\n$ git clone https://aur.archlinux.org/yay.git --depth=1 $ cd yay $ makepkg -si #编译安装 $ sudo pacman -Qs yay #安装完成后可以通过这条命令查看yay是否安装 注意1：\n在安装yay时要改为普通用户，否则Manjaro发行版在makepkg的时候可能报错。因为root在makepkg时可能会造成毁灭性灾难，因此是不被允许的。但如果先以root账户克隆文件，再以普通用户安装时，又会提示权限不够，还需要sudo chown，相当麻烦。\n注意2：\n在makepkg时出现==\u0026gt;错误： Cannot find the fakeroot binary. ==\u0026gt; 错误： Cannot find the strip binary required for object file stripping. 是因为缺少打包基本工具，即base-devel，需要先安装这个软件包组。\n注意3：\n其实，直接执行sudo pacman -S yay也能得到yay。构建是为了熟悉这种从源代码开始打包安装的过程。任何从AUR软件仓库上下载软件的用户都应该会这种构建过程，否则可能在安装软件中出现毁灭性灾难。\n配置中国镜像：\n$ yay --aururl \u0026quot;https://aur.tuna.tsinghua.edu.cn\u0026quot; --save 配置文件的位置位于~/.config/yay/config.json，也可通过下面的命令查看修改过的配置：\n$ yay -P -g 安装Yaourt Yaourt也是AUR的包管理器，但已经停止更新，故建议使用yay。\nsudo pacman -S yaourt #安装Yaourt #配置Yaourt #添加之前首先备份原文件（这是可选的） cp /etc/yaourtrc /etc/yaourtrc.backup #修改 /etc/yaourtrc配置文件 vim /etc/yaourtrc #去掉#AURURL 的注释,并修改 AURURL=“https://aur.tuna.tsinghua.edu.cn” 安装中文输入法： ※Fcitx 如果安装的是中州韵、谷歌拼音、sun拼音、cloud拼音等非搜狗输入法，具体命令如下：\n$ sudo pacman -S fcitx fcitx-im fcitx-configtool #输入法框架及管理器 $ sudo pacman -S fcitx-rime #中州韵输入法 $ sudo pacman -S fcitx-googlepinyin #谷歌拼音输入法 $ sudo pacman -S fcitx-cloudpinyin #cloud拼音输入法 注：可以用这些输入法组合搜狗输入法的词库，相比直接使用搜狗拼音输入法来说，稳定性更好。\n如果安装搜狗拼音输入法，则输入法框架选用的是fcitx-lilydjwg-git(这是fcitx-qt4的archlinuxcn源包名)；可以先查询一下：\n$ sudo pacman -S fcitx fcitx-im fcitx-configtool $ pacman -Ss fcitx-qt4 #该命令是查询软件包命令，会返回软件包名，以该名为准。 如果没有像前文一样正确配置archlinuxcn源，则上述查询命令不会有返回结果，需要用yay安装或者正确配置archlinuxcn源。\n$ sudo pacman -S fcitx-qt4 #该软件包以上个命令返回为准 $ sudo pacman -S fcitx-sogoupinyin #安装搜狗拼音输入法 注：据说Gnome(GTK)用户要安装fcitx-qt5，其可选依赖于fcitx-configtool；而KDE(QT)用户则需要安装软件包kcm-fcitx；该包中包含qt5；如果完全根据情境安装，非常复杂，我的建议是：小孩子才做选择，大人我全都要。遇到软件包冲突后再根据提示进行卸载操作。\n编辑相关文档：\n$ vim /home/\u0026lt;username\u0026gt;/.xprofile #激活fcitx和桌面环境语言设定 编辑内容如下：\nexport GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=\u0026quot;@im=fcitx\u0026quot; 注1：.xprofile文件生成后需要注销或重启级别的操作才能生效。未生成该文件或该文件未生效，则中文输入法不会出现汉字候选框。\n注2：如果提示搜狗拼音输入法出现问题，请按提示删除~/.config/sogouPY*两个文件夹后重启fcitx。\n中文字体包及emoji $ yay -S ttf-linux-libertine ttf-inconsolata ttf-joypixels ttf-twemoji-color noto-fonts-emoji ttf-liberation ttf-droid #Emoji安装 $ yay -S wqy-bitmapfont wqy-microhei wqy-microhei-lite wqy-zenhei adobe-source-han-mono-cn-fonts adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts #中文字体 IBUS IBUS输入法管理器是fcitx的替代品，自行查找安装方式。\n安装Git $ sudo pacman -S git #Manjaro Linux发行版已经安装了git 安装浏览器 浏览器的可选项比较多，下面列举几个以供参考。\nFireFox：火狐浏览器，支持多扩展。\nGoogle-Chrome：谷歌浏览器，它类似Linux中的Arch，具体优点不赘述。\nChromium：开源、支持多扩展的谷歌浏览器(工程版)。\nMidori：轻量、快速的浏览器。\n$ yay -S google-chrome #或者google-chrome-stable $ sudo pacman -S firefox $ sudo pacman -S chromium $ sudo pacman -S midori Advanced Apps 社交软件 安装QQ和TIM $ sudo pacman -S deepin.com.qq.im $ sudo pacman -S deepin.com.qq.office 安装微信 $ sudo pacman -S electronic-wechat # 基于Electron的微信，本质上是网页版的微信 $ sudo pacman -S wine-wechat # Wine集成的Windows平台的微信 # wine-wechat可能需要安装wine-mono字体，它建议使用pacman进行管理： # sudo pacman -S wine-mono 至于它们运行所遇到的问题，建议阅读下一篇博客。\n音乐播放器 $ yay -S netease-cloud-music 下载工具 Transmission\n$ sudo pacman -S transmission-qt # 基于Qt的图形化界面 $ sudo pacman -S transmission-gtk # 基于GTK的图形化界面 # 两种皆可 qBittorrent\n$ sudo pacman -S qbittorrent 视频播放工具 VLC\n$ sudo pacman -S vlc 磁盘无损分区工具 Gparted\n$ sudo pacman -S gparted 安装电池选项 TLP，提供优秀的 Linux 高级电源管理功能,不需要你了解所有的技术细节。默认配置已经对电池使用时间进行了优化，只要安装即可享受更长的使用时间。除此之外，TLP 也是高度可配置的，可以满足各种特定需求。\n参考官方文档，等待补充。\n$ sudo pacman -S tlp 安装蓝牙设备管理器 Blueman\n$ sudo pacman -S blueman 使用之前需要将bluetooth添加至守护进程：\n$ sudo systemctl enable bluetooth 文件系统NTFS挂载工具 NTFS-3G\n$ sudo pacman -S ntfs-3g 系统托盘工具 Trayer，注意，该工具只适合在未配系统托盘的窗口管理器（如dwm）中使用。\n$ sudo pacman -S trayer trayer有很多的选项。对于只使用窗口管理器的人来说，可以参考如下启动选项：\ntrayer --transparent true --expand false --align right --width 20 --SetDockType false --tint 0x88888888 \u0026amp; 电池状况监控工具 ACPI\n$ sudo pacman -S acpi 图形化的解压缩软件 Xarchiver\n$ sudo pacman -S xarchiver ","permalink":"https://endlesspeak.github.io/docs/build/operating-system-configuration/linux-technology-5-1-desktop-config/","tags":[],"title":"Arch Linux 桌面环境配置"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Parrot Sec OS是Linux发行版中十大渗透测试系统之一，为广大渗透测试工作者提供了大量已经集成好的测试工具。采用的是基于Gnome的Mate桌面，外观上非常炫酷，科技感十足。系统中编程环境完善，支持C++、Java、Python等多种语言编程，官方还提供了多种版本以适应不同电脑下载。\n本文拟以Parrot Sec OS为例，讲解如何在物理机上安装Linux发行版。\n选择Parrot Linux的主要原因是Windows 10+Linux双系统中Parrot Linux对NVIDIA显卡的“支持”比较好——在未安装对应显卡驱动前，可以选择不使用NVIDIA显卡，这样就不会出现无法进入Linux系统的情况。\n注：\n我曾经尝试安装Ubuntu 18.04 LTS，由于显卡支持的原因，在Logo加载界面始终无法进入系统。\n当然显卡支持的问题早有解决方案。如果存有这方面的顾虑，可以先了解有关自己电脑的详细配置，而后在社区中寻找解决方案。\n在开始讲Linux的安装之前，必须明确一个先决条件：你的计算机中已经安装有一个或多个Windows版本。这是因为如果你在没有任何操作系统的空物理机上安装Linux，以后再要安装Windows系统，那么Windows的引导程序就会将Linux的引导程序覆盖。引导覆盖会使得你无法再进入Linux系统，即使它事实上还是存在于你的计算机之中的。\n当然，这个问题可以修复；但如果确实这么做，解决方法很麻烦。\n安装前的准备 浅析引导 当一块硬盘接驳主机之后，它的首要任务是建立分区列表，分区列表有MBR和GPT两种，其中MBR分区模式只能分4个主分区，分区列表最大为2.1TB的硬盘，GPT分区列表则支持 9.4ZB硬盘（9.4ZB=1024EB=94亿TB） 。NTFS，FAT32，EXT4等属于文件系统，就像是给分好区的硬盘上打上格子，方便填充数据。至于打成什么样的格子由文件系统决定。\nMBR分区表(Master Boot Record):即硬盘的主引导记录分区列表，在主引导扇区，只支持容量在 2.1TB 以下的硬盘，超过2.1TB的硬盘只能管理2.1TB，最多只支持4个主分区或三个主分区和一个扩展分区，扩展分区下可以有多个逻辑分区。\nGPT分区表(GUID Partition Table):即全局唯一标识分区列表，是一个物理硬盘的分区结构。它用来替代BIOS中的主引导记录分区表（MBR）。Windows最大仅支持128个GPT分区，GPT可管理硬盘大小达到了18EB( 1EB=1024PB ,1PB=1024TB)。\n注：只有基于UEFI平台的主板才支持GPT分区引导启动。\nUEFI(Unified Extensible Firmware Interface):全称“统一的可扩展固件接口”， 是一种详细描述全新类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而使开机程序化繁为简，节省时间。\nESP分区(EFI system partition):该分区用于采用了EFI BIOS的电脑系统，用来启动操作系统。分区内存放引导管理程序、驱动程序、系统维护工具等。如果电脑采用了EFI系统，或当前磁盘用于在EFI平台上启动操作系统，则应建议ESP分区。\nMSR分区：即微软保留分区，是GPT磁盘上用于保留空间以备用的分区，例如在将磁盘转换为动态磁盘时需要使用这些分区空间。\n**归纳1：**传统BIOS不支持GPT分区列表，仅支持MBR格式。新型引导方式UEFI则取代传统BIOS，它加入了对新硬件的支持，其中就有2TB以上硬盘。它不支持MBR模式，仅支持GPT格式。\n近两年出现的UEFI主板，采用UEFI+BIOS共存模式，并且在BIOS中集成UEFI启动项。BIOS+MBR已经趋于淘汰，UEFI+GPT是大势所趋。\nGPT这种新型磁盘模式，与常用的MBR磁盘相比更稳定，自纠错能力更强。 WinXP系统无法识别GPT磁盘，对Win7、Win8来说GPT磁盘可以任意读写，但无法安装操作系统。GPT磁盘必须在使用支持FEI的主板后才可以安装Win7、Win8。\nGPT磁盘的保留分区（隐藏分区）又称为EFI保留分区（ESP），可以防止将该磁盘挂接到XP系统中被误认为是未格式化的磁盘而格式化，导致数据丢失。该保留分区在将硬盘初始化（或转化）为GPT模式时自动创建，大小随硬盘总容量而定。\n一般来说，GPT格式的磁盘至少有三个区，第一个是EFI系统保护区（默认隐藏不加载）第二个是MSR微软保留分区，第三个是系统数据分区。\n**归纳2：**如果你的电脑是Win10系统，那么一般是GPT分区，使用UEFI引导；如果是Win7、8的系统，那么也是GPT分区，而引导方式则有待商榷(不排除是MBR)；如果是WinXP或者Win98系统，那一定是MBR分区引导。(话说回来这年头真的还有人用Win98吗？)\n注：\n判断电脑的BIOS引导模式，在运行对话框中输入msinfo32，回车打开系统信息(或在控制面板/系统与安全/管理工具/系统信息)。寻找到BIOS模式项，观察是否是UEFI。\n硬盘空间 磁盘分区是Linux安装中重要的部分，也是最困难的部分，因为Linux的文件系统和Windows有别。\n首先要明确的是，你的电脑已安装有Windows系统。那么，你选择要安装Linux，你必须划分出一块空间用于Linux的安装。\n划分的方法：右击我的电脑，在弹出的菜单中选择管理，在弹出的对话框中选择存储，在存储栏下选择磁盘管理，以加载虚拟磁盘服务。\n选择一块空间充足(推荐40GB空闲空间以上)的分区，右键选择压缩卷，然后压缩出至少40960MB空间(最好是和已有的分区大小不同，原因见下)。\n需要记住该压缩卷的空间大小，且最好是和已有的分区大小不同，因为在Linux下各个分区的标识符和Windows下完全不同。所以届时可能需要通过空间大小来识别你分配的用于Linux安装的是哪一部分空间。\n压缩卷的意思是实际要从该卷中分多少空间出来作为新卷(即新分区)用。\n安装介质 第一，在所选择的发行版官网上下载ISO镜像文件。\nParrot Sec OS下载地址为：https://parrotlinux.org\n官网上的ISO镜像文件一般分为多种版本，目前Parrot Linux分为Security、Home/Workstation、Other Builds三种版本。个人用户一般选择Security或者Home均可。如果希望拥有完整的编程环境和渗透测试工具集的话，选择Security版本。\n在接下来的Installer ISO分类中选择Parrot Security(Mate)或者KDE Edition(KDE Plasma)均可。Mate桌面环境基于Gnome，而KDE Plasma顾名思义是Kit Desktop Environment。如果要安装在虚拟机上，可以选择Parrot Security也可以选择Virtual Appliance。\n第二，在下载完成ISO后，使用UItraISO(软碟通)工具制作U盘启动盘(即安装所需的启动媒体)。\n第三，重启电脑进入BIOS，进行Boot设置。\nBIOS的进入，不同的电脑按键不一样。一般来说，在开机的时候连按Del键(Del键位于小键盘上)进入BIOS。进入后设置启动顺序。\nHDD代表的是硬盘启动； USB代表从USB接口启动； FDD、CD/DVD、NetWork代表是软盘，光驱和网卡，一般不使用。 将从硬盘启动设置到从U盘启动，然后保存退出即可。\n由于U盘启动是临时安装时使用，也可以不进入BIOS设置启动顺序，而是在开机的时候连按ESC键，在弹出的设备启动界面中选择从U盘启动即可。\n注意：\n部分电脑可能设置有Security Boot，如果切换为U盘启动，会提示： Secure Boot Violation:Invalid signature detected,check secure boot policy in setup.\n这种情况需要进入BIOS设置界面，在Security选项卡下选择secure boot control选项，调整该选项的属性为disable，保存并退出。\n部分电脑可能在开机时按ESC键不会出现设备启动界面，这可能是由于电脑所使用的主板默认设置的并不是ESC键呼出设备启动界面；也可能是主板根本没有设备启动界面这一项设置。具体需要自行查阅自己电脑的主板信息。(尤其是淘换来的二手主板或寨板等等)\n安装中的操作 下面以Parrot Linux为例，说明如何安装Linux发行版。\n确认一切安装准备都就绪后，插入作为启动媒体的U盘，并重启电脑，选择从U盘启动，以进入Live环境。\n进入到如下图所示的安装界面，选择Install. 注意：从上图可以清楚的看到有一个模式是\u0026quot;Live Mode\u0026ldquo;启动模式，这个选项表示用户可以直接启动预载于启动媒体中的Linux系统，不需要经过安装步骤。该模式的作用是给用户预览一下此系统是怎么样的，是否符合用户预期。试用系统一般不会改变计算机中的内容。\n选择安装模式，选择Install with GTK GUI以提供图形用户界面的配置。\n语言选择中文(简体)，当然其他也无所谓。 选择区域为中国。 选择键盘映射为汉语，等待其加载组件完成。\n设置管理员用户名与密码，默认的管理员用户名是root，密码自行设置。\n设置普通用户的用户名和密码\n注意：普通用户的密码和管理员用户密码不要填写同一个密码！关于普通用户与管理员用户的关系以后会详细讨论。\n磁盘分区——这是最关键的一步，一定要慎之又慎。\n如果是安装仅Linux系统而无Windows系统，可以选择向导(使用整个磁盘)；如果是计算机先已安装有Windows，再安装Linux，则应当选择手动分区，然后单击继续按钮。\n对于Linux系统而言，必须有根分区(简称一切的根)\u0026ldquo;root\u0026quot;和交换分区\u0026ldquo;swap\u0026rdquo;。\n根分区被用来存放系统所必须的文件，它被挂载到根目录(/)下。\n交换分区则相当于Windows中的虚拟内存概念。该交换分区被当做低速RAM使用。Parrot Linux允许用户不显式地指派交换分区，如果你的系统不是很忙而内存又很充裕的话。\n手动分区界面中，用户可以自行建立分区方案。缺省的分区方案如下：\n将所有文件放在同一个分区中(推荐新手使用)； 将/home放在单独的分区 将/home、/var和/temp都分别放在单独的分区。 选定分区方案后继续，手动分区可能需要自行创建各个分区，故下面以建立根分区为例介绍建立各个分区的过程：\n选定之前划分的特定空间，创建一个新分区。\n由于创建的是根分区，分区容量默认为全部剩余空间。\n挂载点设置为\u0026rdquo;/\u0026ldquo;表示将该分区挂载至根目录下。\nswap分区不需要挂载点，其大小指派4G-8G均可。\n主分区和逻辑分区的文件系统一般都设置为EXT4日志文件系统，当然为了更好的扩展性，你也可以选择btrfs文件系统。EXT4和btrfs文件系统可以转换，因此不必过分纠结。如果某些分区有默认文件系统，就选择默认。\n文件系统似乎是内核中比较稳定的部分，人们一直使用的 ext2/3在近年来暴露出了一些扩展性问题，于是便催生了 ext4 。然而很多目前有关 ext4 的文章都不约而同地提到了 btrfs，并认为 ext4 将是一个过渡的文件系统。 ext4 的作者 Theodore Tso 也盛赞 btrfs 并认为 btrfs 将成为下一代 Linux 标准文件系统。\n分区完毕后在分区表中还可以单击各分区对其进行修改。\n一般来说，分区可设置为两个\u0026rdquo;/\u0026quot;(主分区),\u0026ldquo;swap\u0026rdquo;(逻辑分区)，也可以划分的更加详细一些。\n完成了磁盘分区的操作后，需要将GRUB安装至硬盘。\n不论电脑上是Windows+Linux，还是仅有Linux，都需要安装GRUB。GRUB用于引导Linux的启动。单击继续后在接下来的界面中选择将GRUB安装到手动输入设备/dev/sda上。然后耐心等待安装完成。\n出现如图所示的界面则证明安装成功。\n注：安装介质就是插入的U盘，在点击重启的时候，应当拔出。\n安装后的配置 GNU Grub Version 2.02 重启系统后最可能遇到问题是出现GNU Grub Version 2.02界面。\n注：\nGNU Grub Version 2.02界面是指电脑会卡在开机自检后的一个黑屏界面上，电脑要求输入命令。命令行会提示grub\u0026gt;\n命令行也有可能提示unknown file system，进而显示grub rescue\u0026gt;\n出现该界面表明Grub引导出现了问题，需要手动引导电脑进入操作系统。(不同的电脑可能出现的Grub的版本号不相同)\n出现该界面，请考虑本机是否有固态硬盘：\n如果有固态硬盘，且Linux安装在固态硬盘上，或者没有固态硬盘，则可以选择解决方案一； 如果有固态硬盘，但Linux没有安装在固态硬盘上，或者想迅速解决问题，请选择解决方案二。 解决方案一：\n通过设置参数手动从grub引导电脑进入操作系统\n先使用ls命令，找到你的Linux安装在哪个分区(grub\u0026gt;为电脑显示，后面是输入的命令)\ngrub\u0026gt;ls 该命令会会罗列所有的磁盘分区信息，比如显示：(hd0,1),(hd0,5),(hd0,3),(hd0,2)\n然后依次调用如下命令： X表示每个分区的标识符。\n如果之前安装Linux时/boot没有进行单独分区，则用以下命令：\ngrub\u0026gt;ls (hd0,X)/boot/grub 如果之前安装Linux时对/boot进行了单独分区，则用下列命令：\ngrub\u0026gt;ls (hd0,X)/grub 找到包含/boot的分区后，系统会列出很多文件，这表明Linux安装在该分区。\n假设找到（hd0,5）时，显示了文件，现在设法临时性将grub的两部分关联起来：\ngrub\u0026gt;set root=(hd0,5) grub\u0026gt;set prefix=(hd0,5)/boot/grub #若/boot没有进行单独分区，则执行这条命令 grub\u0026gt;set prefix=(hd0,5)/grub #若/boot进行了单独分区，则执行这条命令 调用如下命令，就可以加载出grub引导菜单。\ngrub\u0026gt;insmod normal #启动normal启动 grub\u0026gt;normal 见方案二第2步。\n注：\ngrub shell中的ls命令查看的并不是你电脑上的所有磁盘分区，如果你有固态硬盘，（一般固态硬盘位于磁盘读取顺序中的第一个）ls只会查看固态硬盘上的分区，很显然，如果你有固态且Linux没有安装在固态硬盘上，那么无论你ls哪个分区，都不会显示文件，只会提示文件系统未知，在这种情况下想将grub临时关联起来，只能是无稽之谈。\n解决方案二：\n重启，然后在开机的时候连按ESC键，在弹出的设备启动界面中选择Linux。\n成功进入Linux后，在终端执行($为命令行显示，表示目前是普通用户，后面是输入的命令)：\n$ sudo update-grub $ sudo grub-install /dev/sda #如果你的第一块硬盘是机械硬盘则执行该命令 $ sudo grub-install /dev/nvme0n1 #如果你的第一块硬盘是固态硬盘则执行该命令[见注2] $ reboot #重启 注1：\n$ 标识符是命令行中默认的提示，输入时不必加上。 sudo命令会提示输入管理员密码，输入密码时屏幕是没有显示的，此处要注意。 注2：\n对仅机械硬盘的电脑来说，sda是你的第一块硬盘的硬盘号，输入sdb,sdc等都不对；\n对有固态硬盘的电脑来说，建议进入Linux后先执行命令 sudo fdisk -l命令查看磁盘情况，然后将第一块显示的磁盘(它类似nvme0n1这种名称)作为你将要输入grub-install的位置。\n分区号码不要指定，对机械硬盘来说，输入sda1，sda5等都不对；对固态硬盘来说，输入nvme0n1p1,nvme0n1p2等等都不对。注意要在重启后检查是否已经恢复了grub的启动菜单。\n即使重启后能顺利地进入Linux系统，我也建议在终端执行上述三条命令，因为笔者自己电脑的Grub是在进入Windows后重启再进入Linux的时候失效的。所以更新Grub是必须的操作，除非你每次开机的时候都调出设备启动界面手动选择要启动的操作系统。\n注3：\n即使你已经按照上面的步骤正确地做过一遍，你仍有可能会在进入Windows后再关闭再启动，在进入Grub时出现GNU Grub Version 2.02的引导问题，并且有可能会反复出现。这种情况笔者在安装manjaro、deepin等发行版的时候发生过。\n目前还没有找到有效的自动化解决方案，所以只能默认把Windows 置EFI启动项首位，并在每次开机想要进入Linux时连按ESC进入启动管理手动选择Linux系统。\nWlan0 : No Wireless connection 在终端输入下面的命令，检查返回结果：\n$ iwconfig #一般(没有无线网卡的电脑)会出现下面的返回结果。 eth0:no wireless connection lo:no wireless connection #如果(有无线网卡的电脑)出现的结果同上，那么说明无线网络配置有问题，需要重新进行配置 类似eth0的名称表示的是以太网(有线网络)，lo表示的是本地环回，类似wlan0的名称表示的是以太网(无线网络)。必须出现类似wlan0的名称才表示有无线网络连接。如果没有显示类似wlan0的项，则可能说明驱动安装不正确。应当进行下列操作：\n检查电脑是否有无线网卡，且无线网卡是否插好(笔记本略过此步骤)\n输入下面两条命令中的任意一条。\n$ lspci | grep Network $ lspci | grep -i net 在返回的结果中寻找wireless Network Adapter的版本信息。例如，笔者自己的电脑无线网卡版本在终端中显示为 RTL8821CE。\n部分Linux发行版显示无线网卡版本的信息可能不全，可以用Windows协助查看，在Windows下查看网络驱动的版本信息方法是：进入控制面板/网络和Internet/网络和共享中心/更改适配器设置→进入网络连接，查看WLAN下的属性信息，如下图所示：\n在github网站上下载驱动。对于RTL8821CE，这里使用tomaspinho/rtl882ce。\n下载解压缩，在下载的文件夹中(/home/download)右键→在终端中打开，执行：\n$ sudo ./dkms-install.sh 如果Arch系提示有错误，则按照错误信息安装对应的依赖。一般可能要安装的依赖有：bc、dkms、linux-headers等等。\n命令执行完成后再次执行iwconfig命令，如果出现了wlan0，说明驱动安装成功。\n点击无线网图标，即可连接到无线网。\n更新源配置 查看当前的Parrot Security镜像源，执行：\n$ parrot-mirror-selector 修改Parrot Security更新源\n众所周知，Linux发行版一般为国外公司(使用Deepin OS/Red Flag等国产发行版的例外)，一般它们的更新源都部署在国外的服务器上，国内访问会很缓慢。故此，需要修改发行版的更新源为国内的镜像，以提高更新速度。当然，这并不是必须的。\n在终端执行以下命令：\n注，Parrot Linux有相当多配置文件的存放位置与其他Debian发行版位置不同！\n$ vim /etc/apt/sources.list.d/parrot.list 使用#注释掉之前的更新源，而后将下面的代码根据地理位置任选一二拷贝到文件尾。\n#中科大和USTCLUG deb http://mirrors.ustc.edu.cn/parrot parrot main contrib non-free #北京清华大学，TUNA协会 deb https://mirrors.tuna.tsinghua.edu.cn/parrot/ parrot main contrib non-free #上海大学 deb https://mirrors.shu.edu.cn/parrot/ parrot main contrib non-free #上海交通大学 NIX用户组 deb https://mirrors.sjtug.sjtu.edu.cn/parrot/ parrot main contrib non-free 按ESC键，输入“ :wq” 回车，以保存配置文件并退出。\n执行下面两条更新命令，第二和第三条命令任选一条执行即可。\n$ sudo apt-get update $ sudo apt-get upgrade $ sudo apt-get dist-upgrade 注：\nupdate是更新软件的列表信息,包括版本,依赖关系等\nupgrade在不改变现有软件设置的基础上更新软件\ndist-upgrade在会改变配置文件和改变旧的依赖关系基础上更新软件\n更新版本实际上就是更新软件包，由于Debian系列发行版都采用的是滚动升级，所以dist-upgrade仅用来升级软件，而dist-upgrade则用来更新版本。(版本升级会修改大量配置文件)\n安装中文输入法 安装Google拼音输入法，在终端输入命令：\n$ sudo apt-get install fcitx-googlepinyin $ reboot 安装IBUS拼音输入法，在终端输入命令：\n$ sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4 $ im-config -s ibus #启动iBus框架 $ sudo apt-get install ibus-pinyin $ sudo ibus-setup #打开iBus设置 $ reboot 安装搜狗拼音输入法，在终端依次输入下列命令：\n$ sudo apt --fix-broken install $ sudo apt-get update $ sudo apt-get dist-upgrade $ sudo apt-get install fcitx fcitx-frontend-gtk2 fcitx-module-dbus fcitx-bin fcitx-frontend-gtk3 fcitx-module-kimpanel fcitx-config-common fcitx-frontend-qt4 fcitx-module-lua fcitx-config-gtk fcitx-frontend-qt5 fcitx-modules fcitx-data fcitx-module-x11 fcitx-frontend-all fcitx-libs-dev fcitx-ui-classic $ reboot 如果安装任何软件的过程中提示依赖关系有错误 ，则在终端尝试输入命令解决：\n$ sudo apt-get install -f 安装搜狗拼音输入法也可以尝试在搜狗官网上下载deb安装包，然后在下载位置打开终端，执行下面的命令：（最后的字符串是安装包名，请自行替换）\n$ sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb $ reboot DIY桌面环境 Mate桌面下更换主题\n可以在系统自带的主题中选择选择喜欢的主题；可以访问下面的网址。\nParrot系统 访问：https://www.mate-look.org/ (需要VPN) Kali系统 访问：https://www.gnome-look.org/browse/cat/135/ord/latest/ (访问缓慢)\n注：一定要选择3.x版本的主题才适合，因目前的Mate桌面环境是基于Gnome 3的。\nMate桌面环境更换为KDE桌面环境\n$ sudo apt-get update $ sudo apt-get dist-upgrade $ sudo apt-get install parrot-kde 执行第三条命令后系统会提示选择默认会话窗口，需要从lightdm改为sddm。\n$ sudo apt autoremove parrot-mate* $ reboot 重启后，在登录系统时，在界面上的session中选择plasma，输入口令进入。\n安装Cairo-Dock\n依次执行下面的命令。\n$ sudo apt-get update $ sudo apt-get install cairo-dock cairo-dock-plug-ins 安装 screenfetch\n$ sudo apt-get update $ sudo apt-get install screenfetch ","permalink":"https://endlesspeak.github.io/docs/build/operating-system-installation/linux-technology-3-1-parrot-linux-installation/","tags":[],"title":"Parrot Linux 物理机的安装、引导与配置"},{"authors":["Serene Feather Pavilion"],"categories":["Linux Basic"],"content":"尽管很多人已经不习惯看长篇大论, 但我还是要说, 这是一篇值得你从头读到尾的长篇文章。\n2005年9月22日，清华在读博士生王垠在水木社区BLOG上发表了《清华梦的粉碎–写给清华大学的退学申请》明确要求退学,引起社会各界广泛争论。 他创作的长篇文章《完全用Linux工作》从不同角度居高临下的阐述了他眼中Linux完全优越于Windows的各种理由， 这篇文章并不简单的是一篇论述“Windows能做的事Linux都能做”这样的文章，而是通篇洋溢着一个彻底批判 Windows 平台基础的计算机哲学、计算机应用和计算机教育体系的人的万丈豪情。 尽管可能有些偏激，但是不乏详细的推理论述。\n我将该文分享如下，并将其作为我即将要撰写的Linux技术基础系列文章的序言，以此勉励自己时刻谨记自己学习Linux的初心，提醒自己要为非Win化的传承而努力。希望本文的研究与讨论，能为诸位读者提供更宽广的讨论空间。\n转变你的观念 Linux可以高效的工作 我已经半年没有使用 Windows 的方式工作了。Linux 高效的完成了我所有的工作。\nGNU/Linux 不是每个人都想用的。如果你只需要处理一般的事务，打游戏，那么你不需要了解下面这些了。\n我不是一个狂热的自由软件份子，虽然我很喜欢自由软件。这篇文章也不是用来推行自由软件运动的，虽然我觉得自由软件运动是非常好的。\n这篇文章也不是用来比较 Linux 和 Windows 内核效率，文件系统，网络服务的。我现在是作为一个用户而不是一个开发者来说话的，我们的讨论是基于操作，应用层面的。是为了告诉大学里还不了解，或者不理解 UNIX 的科学工作者和大学生，UNIX 比 Windows 更适合用于科学研究工作，请大家理解 UNIX 的工作方式，不要用 Windows 的标准来要求 Linux，而要用一个科学工作者的标准来要求自己，用UNIX 的思想来武装自己。\n我显然是反对在大学，特别是理工科专业推广 Windows 的。我也反对在对”娃娃”们的计算机启蒙教育中使用 Windows。因为 *Windows 不论从技术上，经济上，思想风格上都是与我们培养高科技人才的目标格格不入的。Windows 的流行属于历史遗留问题，爷爷一级的人当然已经不可救药，但是我们不应该让下一代继续走上歧途。\nUNIX 不是计算机专家的专利 当我建议一些非计算机专业的人用 Linux 的时候，很多人说：”UNIX 是计算机系的人用的，我们不能理解。” “UNIX 是男孩用的，我们女孩不用。”\n但是其实世界上的大多数科学家和工程师几乎用的都是 UNIX 作为他们的电脑工具。就因为它简单，可靠，稳定，强大，有趣。甚至很多时候 UNIX 就是唯一的选择。\n你说：”我们都会用 UNIX 的话，你们计算机专业的人还用来干什么？” 很容幸的告诉你，计算机专业的有一部分人就是专门为你们提供这样强大而方便的计算机工具的。如果他们制造的工具只有自己会用的话，那这个工具还有什么用？\n理解 GNU/Linux 不要用 Windows 的标准来要求 Linux。\n由于GNU/Linux这个词太长，下面如果没有特别指明，”Linux”就是指GNU/Linux”。\n在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得”Linux 只不过是跟 DOS 差不多的东西”，那请问问你旁边的 Linux 用户，Linux 到底是什么？\n那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和 UNIX，虽然他们也在用它，但是他们有时会问：”为什么 Linux 不能像 Windows 那样 ……？”，”怎么Redhat Linux不能 mount NTFS 分区！”，”Linux 下用什么整理硬盘？”，”什么时候OpenOffice才能完全兼容Word文件啊？”，”现在还有什么Windows能干的事情Linux干不了的？ “……\n他们有40G的硬盘，却只为 Linux 分配了2G空间，有时还抱怨”这个东西怎么占这么多硬盘！” 似乎 Windows 该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对Drag\u0026amp;Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像 Windows 程序的 Linux 程序，一定会很高兴的说：”哈哈！Linux 也能……了！”如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux 解决问题的时候，甚至用Wine来运行Windows程序。有时实在没办法，只好重启到Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare 虚拟一个 Linux 玩。\n你如果出现了上面的情况，说明你的思想受到了 Windows 的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的 UNIX 思想。你支持 Linux，你喜欢 Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：Linux 从来就不是一个玩具，它是天才UNIX的后代。UNIX 是自晶体管发明以来最伟大的发明，它从诞生那一天开始就比 Windows 的设计出色。\n你要体会什么叫做”设计”，一个糟糕的设计并不是到后来缝缝补补就可以变好的，而一个出色的设计，不但可以以不变应万变，而且可以影响到后来者。一个出色的设计配上一个出色的实现，那就是非常出色的发明。Linux 就是这样的一个出色的发明。\nUnix 是简单的，你不需要成为一个天才也能理解这种简单。\nLinux 并不需要追赶 Windows，也不需要打垮微软。它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。\nUNIX 的设计者 Dennis Ritchie 说：”Unix is simple. It just takes a genius to understand its simplicity.” 但是我不这么认为，因为我不是一个天才，但是我却勇敢的把 Windows 完全删除掉，遇到不明白的事情的时候努力用 UNIX 的方式去解决，而不是寻求 Windows 的帮助。现在我体会到了 UNIX 的思想和好处，我可以用比 Windows 高效几倍的效率工作。因为我相信这样的信念：”Windows 能办到的事 Linux 一定能办到，而且办的更好。”\n这小节开头的话应该改成：”Unix 是简单的，你不需要成为一个天才或是计算机专家。但是在这个冲斥着 Windows 错误观念的世界，你需要信念和勇气才能理解它的简单。” 我下面就告诉你一些我理解到的东西。首先，你要知道的是微软在国际科学领域是根本没有地位的。\n微软的实际地位 微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的 MIT，Stanford 的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个”小”并不是说它人少，钱少，而是说它先进技术少。\n我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC 作为平台。我在分析算法时还得到 Fortune 很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给 Fortune，他回信说：”对不起。我机器上没有 MFC。” 话说的很客气，但是我已经感觉到了他对 Windows的不屑。然后我把 MFC 静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。\n你能感觉到这位科学家对微软和 Windows 是什么态度了吧？不是反感，而是他心里根本没有 Windows 这个东西！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！\n好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office XP，学校的选课系统是非IE不能正确浏览，论文用 Word 编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连 863 项目都用 VC 写程序了。我很久以前就看到一份报纸说，”微软为什么不严厉打击盗版？” 这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，”以后我要你们加倍的来还我！” 确实如此，它的目的快实现了。\n计算机教育的现状 Windows 笼罩下的中国计算机教育 说句丢脸的话，比尔盖茨很久以前是我的偶像……\n在中国，比尔盖茨被很多人奉为神圣，”少年电脑天才”，甚至有的人提到他的名字就做出”抱拳对天”的姿势。很多人谈到微软的”新技术”，”高科技” 都是眉飞色舞。各种”VC编程圣经”，”深入了解 Visual C++”之类的书，在开头几页都会出现非常肉麻的字眼，”在那团团的混沌中，一个开天辟地的精灵，Windows 1.0，诞生了……”\n微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些 DOS 命令，打字，Windows 基本操作，Word 文档处理，PowerPoint，高级班可能有 Excel，Access…… 参加各种微软认证考试，MCSE，MSDE 的人络绎不绝。考试辅导班都贴出了”280元，考过为止”之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是”Microsoft Press”的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了 XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的 Windows XP 内部发行版。\n“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的 Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi 编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种”初级阶段”的时候就已经用 Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！\n我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过”中华学习机”。看到新入学的同学们各个谈论的都是 “Windows 95″，”VC”…… 我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：”你们天天谈论的瘟95是什么啊？”答： “win95就是一个操作系统，跟DOS是一类。””朵死是什么？” “你连DOS都不知道是什么？别在计算机系混了。” 学校上课当然不讲VC编程之类的东西，但是上 Pascal 的老师有一次就说：”嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC 了，我们还在讲 Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。” 于是，有些同学很多时候上课都捧着一本很重的”Windows 编程大全”之类的书，根本没有听课。吃饭时就念念有词的跟我说，”代码的优化是无止境的”，”匈牙利命名法真是伟大的发明” …… 这就是中国很多大学计算机系的情况。\n感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，X window的人一旦说 UNIX 好，X window 好的时候，都被一群人围着说教：”这个 Windows 也能做到”，”你对 Windows 有偏见”，”微软才是主流啊”，”你敢瞧不起 win2k？”，”.NET 就是世界潮流”，”微软的毕竟是新技术”，”有钱就是有技术”…… 甚至在一番论战比较后败下来还是要说：”Windows 性能差点，但是易用性强”，”Windows 是老百姓用的，要求别那么”，”微软那么有钱，以后想超过 UNIX 还不容易吗？”……\n发达国家的计算机教育 我前段时间在 USENET 发文问有关 Scheme 语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很”深奥”的有关程序语言语法，文法的书，他告诉我很多网站可以学习 LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 “Syntactic Closures”。他还打包给我寄过来一份 MIT 的 “How to Design Programs”。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行Scheme 程序。他对 Emacs 的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme 解释器。这对于我来说是望尘末及了。\n他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，他是丹麦一所普通高中的计算机老师。\n他说他在高中里讲授程序设计和算法，计算机语言文法。他说用 Scheme，他的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。\n天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！\n微软和它的朋友们的如意算盘 下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是 100多美元，每次升级又是几乎同样的价钱。Windows NT 还要贵几倍，而且有用户数目限制，5个用户的，10个用户的…… 以后如果要增加用户数目还要按比例付钱。\n花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上Windows 之后一般第一件事就是去下载一个 WinZip 吧，”只要 29 美元”。Windows会中病毒啊，马上花 70 美元买一个 Norton AntiVirus 吧。还有黑客呢？再买一个Norton Internet Security 好了，100 美元。系统需要优化，磁盘需要整理，买一个Norton System Works 是你最佳的解决方案，100美元。\n可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套 Office XP 吧，一起买便宜些，459.90美元。\n那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看”帮助”也学不会。买本书看看吧，我推荐”Special Edition Using Microsoft Office XP”，不贵，才28美元。又由于这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，17.85美元。\n你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为 Windows程序员。首先买一个 Visual Studio.NET 吧，要不然怎么编译程序。494.95美元。\n为了紧跟微软动向，世界潮流，不能不注册个 MSDN 什么的吧？这个贵一点，不过物有所值啊，2,799美元。\n嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样”自由”的，”安全”的生活了。\n反对使用Windows的原因 很多人都说不应该完全否定 Window，Windows 也有它的长处。不应该骂微软。\n对。 Windows 容易操作，适合普通用户。如果微软把它自己定位在 P\u0026amp;G，Philips 那样的地位，能够给我们的百姓提供周到的，完善的，价廉物美的服务。那我肯定是很喜欢它的。但是从上面的种种情况说明，微软是一个野心极大的国际垄断组织！它的产品没有一个是不出问题的：Windows 不稳定，容易中病毒，而微软不为大家免费提供杀毒软件。我就是要让你们花钱买我的朋友 Symantec 的杀毒软件，谁叫你们已经上了我的贼船？这叫什么售后服务啊！\n你买来微软的程序，安装的时候一般都有一个协议，说：” 由于微软的程序造成你的数据损坏或丢失，微软概不负责。” 我想很多人肯定觉得这个不合理，不想按那个 “I accept”。但是你的软件买都买来了，钱都花了，现在一按 “I decline”，安装程序马上就会退出。你只好被迫点击了 “I accept”！这不是不平等条约吗？\n我已经目睹了好几个朋友的文档被 Microsoft Word 损坏，有的是编辑了十多天的30多页的论文，有的是费了很大工夫做出来的个人简历，那个朋友为此失去了到自己向往的P\u0026amp;G 工作的机会。就在他要投简历的前一个晚上，就在那一瞬间…… 不知道他痛哭的时候有没有想起要投诉微软，可是谁叫我们用的都是盗版呢，况且你还点击了 “I accept”。\n微软仗势已经占有大部分PC市场，制定不符合国际标准的”微软的标准”，以不合理的方式压制其它公司的软件，这个问题已经在美国司法部闹了很久了。他甚至在 Windows系列操作系统中放置能够通过网络泄漏用户信息的代码，以至于 Windows 刚进入澳大利亚时被澳大利亚政府禁止使用。\n有些人说：”微软毕竟开创了一个历史，造就了今天的 IT 行业。”\n但是，如果没有微软，我们今天早就用上非常稳定，非常可靠，非常方便，非常”傻瓜”的软件了！微软是阻挡信息技术发展的罪魁祸首。\n微软的程序的工作方式(注意，我只是说操作方式，病毒的事情另外算)确实适合于一般家庭，上上网，发发邮件，打打游戏都不错。可是微软却要把自己包装成什么 “高科技”企业，要在世界各地设置”研究院”，在大学计算机系赠送不适合用于科研的 Windows产品，甚至出钱请图灵奖得主来中国畅谈”二十一世纪的计算”，还在大会上宣传自己的 .NET 技术。非要把别人认为自己是科学的，自己是领导世界高科技的。但是呢？它什么高科技也没有。欧洲，美国，哪一个关键部门在用微软的东西？NASA? DOE? CERN?你仔细想一想，微软的程序对人类到底有什么重大作用？\nWindows与Linux的比较 “Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”\n有个朋友看我半年没有用 Windows，有时就会问我：”你只用 Linux，有没有发现有些Windows 能处理的事情 Linux 干不了？” 我回答说：”Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”\nWindows 能做的有益的事情 Linux 都能做 Windows 下的某些功能确实是我们需要的，那么 Linux 的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比 Windows 的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX, 所以几乎所有商业的科学工程程序，比如Matlab, Mathematica, AutoCAD, Candence的，Synopsys的，Avant! 的……全都是先有UNIX 的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给Windows，因为 Windows 的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有 PSpice, UNIX 的 HSpice 要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。\n但是 Windows 下有些东西在 Linux 下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows 的那个程序都要差很多，那么原因有两种可能性：\n有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于 Gtk, Qt 的诞生，Linux 下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。当然也有一流的程序用 Gtk 和 Qt，比如 GVIM 就可以用 Gtk 作为图形界面，我还知道 Synopsys 一些程序用了 Qt。\n我曾经也犯过这样的错误，从外表区分一切。结果优秀的 FVWM, lftp, Mutt, wget 都被我忽略过。当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友 我第一次看到 FVWM 觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM 都说：”哇！真漂亮。”\n有另一种完全不同的方式可以达到相同的目的，甚至更好。\n很多人很关心 Open Office, Star Office, AbiWord, … 他们多么盼望有一天某一个Linux 程序能够完全兼容的打开一个复杂的 doc 文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式。它一定会不断变化 doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc 文档时总是有某种问题，从而你必须购买 Microsoft Office 和 Windows。\n你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是 Linux 或者其它类型的 UNIX，他们没有 Word 可用，怎么处理文档呢？这么多年没有一个像Open Office 的程序出现，难道大家没有办法写文档吗？\n显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的幻灯片，它们是什么做的？原来 UNIX 用户早就有非常方便的 troff, LaTeX, SGML等东西可以处理文档，而且它们比起 Word 都要高明的多。Word 显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word 的程序，除非某些公司想抢微软的饭碗。\n很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和 PowerPoint。我见过一个教授，他的 Windows 笔记本电脑上除了 PowerPoint 什么都没有。有一天演示的时候，他指着堆乱字符说：”对不起，这是一个公式……怎么每次都是这样……” 其实有比PowerPoint 好几百倍的东西可以制造幻灯片，你可以用最简单的方法制造世界一流效果的论文和幻灯片。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开 Windows。\nWindows 能做的那些没用的事情 Linux 永远做不好 电脑游戏 有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux 下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike, 没有 Star Craft, ……\n并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。\n你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony Hawk’s Pro Skaters 里滑板…… 但是 It’s not real！你虽然有很高的”反恐技巧”，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制 Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在 THPS 里作出一个 “360 kickflip to hangten grind to fakie”，但是你踩在自己的滑板上的时候还不会 ollie！\n说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows + PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo 的 N64，Namco的街机……每一个都比 Windows 游戏精彩，每一个都有如此高的3D性能，以至于Pentium4, Itanium + GForce4 都无法与它们比美！\nLinux 的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么 Linux 几乎没有游戏了吧？\n“整理硬盘，优化系统“ 这是一个非常有意思的话题，仅次于有关”病毒”的话题。相信很多 Windows 用户都有整理硬盘的经历。在很多 Windows 用户眼里，”硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。\n我也曾经津津有味的看着 Norton Defrag 一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告100% 没有碎片。你的硬盘现在已经达到最佳状态。” 我现在才发觉我那时是多么的幼稚。\nLinux 和 UNIX 用户似乎从来没有”整理硬盘”这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX 的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！\nLinux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux 用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS 高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以”越用越整齐”，”越用碎片越少”！你应该把文件大部分放在 Linux 的分区，而不是 Windows 分区，因为它比 Windows分区可靠得多。\n还有更滑稽的事情就是有很多”Norton System Doctor”，”Windows优化大师”，”超级兔仔注册表魔法” 之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来”优化”它，而且为了得到优化，你需要付钱！这些问题 Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。\nIDE 有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux 现在已经有一些IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望 Linux 某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用 IDE？你说：”IDE 开发迅速，调试方便，适合大型程序……” 那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。\n高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。\n你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，X window 程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE 弄的，我还知道Candence, Synopsys，Mentor 的高性能的图形界面 EDA 程序也都不是 IDE 写的。你信不信，微软的人在写 Windows 本身的时候也根本不用 IDE。微软内部程序员最喜欢的编辑器其实是 VIM，用 VIM 的微软程序员上次向乌干达的可怜儿童捐助了1000多美元，这是值得称赞的。\n有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus 在内，没有一个人用IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说”GNU Emacs is evil”，但是其实他用的是一种跟 Emacs 有同样键绑定功能的 MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make 这样的自动工具调用 gcc 编译器完成编译工作的。甚至高级的 Windows 程序员也不用 IDE，他们可以从命令行调用 cl，nmake 来编译自己的程序。虽然这样的 Windows 程序员很少，但是他们却是最了解 Windows，最高明的Windows 程序员。\n为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX 的设计思想了。首先，一个 IDE 集成了编辑器，编译器，汇编器，调试器，跟踪器…… 这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上 as，调试器比不上 gdb，ddd, 跟踪器比不上 strace, ltrace, truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套 IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮…… 跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。\n而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM 里可以调用GNU make，make 可以调用 gcc, ld, … make 的出错信息可以被 VIM 捕获，VIM 能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是 gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd 来显示各种数据结构之间的关系。你还可以在 Emacs 里调用 gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs 还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件…… 你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin 都可以在内部使用 VIM，这样就更方便了。实际上 make 在其它方面还能帮你很多忙，我的每一个比较大型的 LaTeX文档都是用 make 维护的。\n释放内存 我在 Windows 下做过的一件最傻的事情莫过于“释放内存”了。有一天我看到一个 Windows 程序说：“这个程序可以帮你把大量内存释放出来给一个很大的程序用。”我试了一下，居然一下把我的 64M 内存释放出来 48M！我高兴极了。现在想一想，那是多么傻的事情，那么多的内存留着干什么？不用白不用啊！一个操作系统，居然还需要别人写的程序来释放内存，那是什么样的操作系统？\n在 Linux 下用 free 命令，你会发现你的内存几乎每时每刻都快要被用完。那是因为 Linux 把大部分内存用来作为磁盘缓冲了。Linux 有比 Windows 先进的磁盘缓冲技术。你有没有发现你往硬盘写数据的时候，很快就完成了？那是因为 Linux 在内存里有很多磁盘缓冲区，你要写到硬盘上的数据先被写到了这些内存里，然后Linux 就告诉你“拷贝完成”，当你马上又想删除刚才写入的某些数据时，Linux 只是把数据从内存里移除，然后报告“删除完成”。在一定的间隔时间后，Linux才把数据写回硬盘，这样不但高效，避免了多次硬盘操作，而且减少了文件的不连续，也就是减少了“碎片”。Windows 当然也有磁盘缓冲，但是由于它内存管理的低效率，它不敢把大量内存都用来作为磁盘缓冲，因为它没有能力在用的时候随时把内存收回来。\nLinux 能干的高精尖的事情 Windows 都干不了 当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC 机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC 机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows 的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows 机器是以”死机”著称的，我们怎么能放心？\n所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows 的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过 Windows 版本的 Mathematica 和 Linux 的有什么区别吗？\n下面举几个其他的例子：\nIBM 制造的最大的并行计算机有 8000 多个处理器，Windows 不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。 《泰坦尼克号》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是 Linux 机器做的。 民航总局用来训练地情人员的虚拟现实训练设备，Windows 当然无能为力。那都是商业的 IRIX 机器。 UNIX 是最早支持 TCP/IP 网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997年，微软的比尔盖茨还在扬言：”Internet 是没有前途的。” 微软的这个”远见卓识”大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。\n其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。\nLinux 干不了的有用的事情 Windows 照样干不了 当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是 Linux干不了的事情，Windows 肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux 必定是你的好伙伴。\n不要把Linux和X window掩盖起来！不要把我们的用户当成傻瓜。\n什么？你早就知道 Windows 是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。\n怯除Windows流毒 拒绝用Windows的方式思考问题 “好了，现在我已经知道windows是垃圾了，那么我应该用什么？”\n“Linux + X window”\n“那我问你，X window 是什么样的？”\n“不就是跟 Windows 差不多吗？只不过 ‘Start’ 按钮比较方，而且上面不是一个Windows 标志，而是一个脚丫子。点击一下居然还有很漂亮的中文菜单。我喜欢！”\n“你知道什么是’根窗口’吗？”\n“不知道。从来没听说过呢？”\n“根窗口就是遮盖整个屏幕的那个最大的窗口。”\n“哪儿有什么窗口啊！我没有看到呢？”\n你发现了问题吗？这些 Linux 用户说是在用 Linux 和 X window，但是他们对 Linux和 X window 几乎完全不了解。很多人用了那么久 X window 都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和其它程序有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口? quot;class name”，”resource name”是什么东西。他们也不知道.Xdefaults 是用来干什么的。特别是他们很多人都不知道 X window 的字体是如何命名的，什么是 fontset，有了一个新的字体也不知道怎么安装。\n他们被遮在 Linux 之上的一层一层的包装迷惑了，他们等待有图形界面的工具来帮助完成一切事情，他们认为 Linux 跟 Windows 一样，只是麻烦一点。他们知道 Linux内核很好，但是他们感觉不到 Linux 和 X window 在操作层面的天生的先进性，随后不久就把 Linux 完全删除掉了。你发现没有，要用户理解 UNIX 和 X window 的操作层面的先进性，才是留住用户的最好办法。如果用户体会不到操作时的方便和高效，内核再好他们也不会理会。\n但是用摹仿 Windows 的作法来吸引用户，永远会失败的。因为 Linux 如果摹仿Windows那一套低效率的方式，那么 Linux 的这套”低效率方式”永远比不上Windows 的那一套”低效率方式”。那么用户就会说：”这个 Linux，没有一样比的上 Windows。”\nLinux 天生就是继承了 UNIX 的高效的工作方式，为什么我们要把它掩盖起来？我们为什么只告诉用户 KDE 的菜单怎么用？我们为什么不能像早期的 X window 书籍那样第一节就告诉用户什么是 X server, 什么是 X client，什么是 Window Manager, 什么是根窗口。第二章就告诉用户窗口有哪些属性，什么是 classname, resource name, hint，怎样使用 .Xdefaults, xrdb ……\n在这里我又不得不说一下那些 Linux 的发行公司和写书的人，他们把 Linux 和X window 包装起来，却没有从基本上告诉用户 X window 的工作原理。很多书籍讲授的层次就是在Gnome, KDE 的菜单操作的层次，靠大量抓图来占篇幅，”繁荣”Linux 书籍市场。\n现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这”图形化”，”可视化” 的年代，你如果还在用 troff, LaTeX 写文档，你还在用VIM 自己编辑 HTML，用 Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用Xlib 写程序, 你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩 Clossal Cave 这样的字符模式冒险游戏，那你就是老古董。\n其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是 Windows的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你还是没能摆脱微软给你的潜移默化的东西。如果你离不开 Windows 那样的环境，你迟早会删掉自己的 Linux。\nGUI vs. CLI 做一个坚定不移的”两面派”！\n大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了：\nGUI派用户：”哇！我一看你这小子就是 CLI 的。要不然自己写什么 Makefile？用什么Mutt？”\nCLI派用户：”切～ 你还用 X！高手都不用 X。你是 GUI 那边的。”\n可怜的我：”555～～ 你们都不要我～～ GUI 和 CLI 就那么水火不容吗？”\n计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command LIne)的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个 SecureCRT 登录到Sun 机器，然后用一个 vanilla vi 编辑程序，我建议他启动一个 GVIM 过来显示在Exceed 上可以有语法加亮。但是他坚决反对，说：”高手不用X。你想想，要是我在一个很慢的网络连接怎么用 X？而且好多服务器没有装 X 程序。”\n但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun 机器有全套X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用 Windows，他后来打开了好几个 SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择”SSH2″，然后点击”Connnect”。他还不断的夸SecureCRT 是”网络管理员投票选出的最受欢迎的登录方式”。老天，SecureCRT 本身就是个 GUI 啊，他其实没有明白X window 的好处。\n你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM 很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用 Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用 VIM 编辑 LaTeX。我自己写Makefile 来维护 LaTeX 文档。我有时用 mpg321 来放 mp3。我上BBS用的我自己写的expect 脚本。 好了，CLI 派的朋友可以收我做盟友了\n你说我是 CLI 的老古董？我的 FVWM 被我配置为可以”手写操作”，我只要画一个”r”就可以启动 rxvt，我只要画一个 “U” 就可以启动 GVIM，…… 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla 浏览网页，…… GUI 派的现在好像认我做朋友了\n好了。CLI 派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行:\nModule FvwmConsole -terminal rxvt -geometry 45×5-0+0 \\ -bg gold -fg midnightblue \\ -fn “-adobe-courier-medium-r-*-*-14-*-*-*-*-*-*-*” 你是不是现在又想把我逐出师门？\nGUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入：\nAll (rxvt) MoveToDesk 把我所有的 rxvt 移动到我现在工作的桌面。”这家伙，怎么这么快就叛变了！”\n其实何必分什么 GUI 和 CLI，UNIX 和 X window 都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI 还是命令行的都可以互相协作。UNIX 和X window是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI的模糊界线吗？我就是坚定不移的”两面派”。\nUNIX的真谛何在 UNIX 是简单的 “我相信简单就是最好，如果太复杂，我是不能理解的。” -Seymour Cray\n很多第一次用 Linux 的人会惊奇的发现，Linux 的程序居然不”安装”就可以运行，程序拷贝到随便那个目录都可以用，而不是一定要占用你第一个分区的空间。程序的设置只是一些简简单单的文本文件。你根本不需要什么”注册表修改器” 就可以改变系统的设置。这就叫做简单，但是简单就是美。虽然这只是 UNIX 简单性的一个肤浅的认识，你已经体会到了某些东西。\n但是简单并不意味着功能弱，并不意味着落后。相反，简单意味着强大，意味着生命力。\n我不会再继续阐述我理解到的”UNIX 的简单”，因为这个需要自己去体会。\nUNIX 是永恒的 有人说：”Plan9 会取代 UNIX，Mach 会取代 Linux 内核。”\n但是你如果是一个深入体会了 UNIX 的人，你就会知道：UNIX 的思想是永恒的，不管时过境迁，Plan9 是否代替 UNIX，UNIX 的灵魂都会在 Plan9 身上现形！\n我为同一个设备写过 Linux 内核和 Windows VxD 驱动程序。写 Linux 驱动程序时，我对 UNIX 设计的完美的一致性，远见性所折服。UNIX 用同样界面的 read(), write()系统调用就可以对不同的对象：普通文件，设备文件，管道，管道文件，socket，……进行统一的读写操作。我跟本不需要写一个测试用的应用程序就可以对我的设备驱动进行测试，因为 cat, cp, dd, 它们也使用了同样的 read(), write()，设备和普通文件在应用程序眼里没有区别。在那个还没有 Smalltalk, 没有 C++ 的年代，UNIX 的设计者已经使用了所谓的 “面向对象方法”。对，C 语言也可以实现面向对象。\nUNIX的系统调用几十年都没有很大变化，这非但不是顽固，不进步的象征，反而是UNIX 的远见卓识的体现！这就跟 TeX程序几十年都不变的情况差不多。这些才是真正的永恒的 master piece!你应该改变所有软件都必须从 0.1, 1.0, 1.1, 1.2, 2.0, …, 3.0, 3.1,95, 98, 2000, XP, … 不断升级的想法。\nWindows 就不同了，它在最开头只是一个 DOS之上的图形包装而已。后来为了兼容以前的糟糕设计，不得不加上很多累赘。我写VxD 驱动程序的时候就深有体会，Windows 95 程序对设备的操作只有用DeviceIoControl，我不得不写了两个应用程序来对设备驱动进行测试。Windows内核的不一致性和隐密性使我非常恼火。不过 Windows WDM驱动程序现在也有了 ReadFile, WriteFile，…… 那说明什么？那说明Windows 在向 UNIX 学习，或者有可能是某个 UNIX设计人员在微软打了几天临工，顺手加了几个UNIX的东西进去。这样做是没有用的，Windows从一开始就是非常糟糕的设计，它的历史的包袱太沉重了，缝缝补补有什么用？它只能永远的被UNIX 甩在身后！\nUNIX 是强大的 让聪明人干任何他们想干的事情。\nUNIX 的一个特点就是非常高的灵活性，X window也具有这种灵活性。这种灵活性体现在哪里呢？\nUNIX 的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个.inputrc 文件，就可以把它变成 vi的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误……\nUNIX程序设计的思想是提供给用户“机制”，而不限制用户制定“政策”。这是一个重要的尊重用户的作法。\n我们再来看看 X window。X window是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的X程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件…… 比如有时我的 XFree86 上会出现四个不同机器上的XTerm，两个不同机器上的 GVIM，…… 它们统一受本机上的 FVWM指挥。\nX window 程序都具有很多很多命令行参数和 resource参数。你可以随意的在命令行或者 .Xdefaults文件设置所有的颜色，字体，尺寸…… 而且如果你用 xrdb 把 .Xdefaults导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。\nX window 的窗口具有 Property,也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property的存在，使得 X window 具有无比强大的生命力。X的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了ICCCM(客户程序间通信规范)，这个规范就是通过 property定义的。现在又有人定义了一套“扩展的窗口协议(EWM Hints)”，使得X window 可以具有某些 Windows 的特征，比如一个工具条程序可以告 诉窗口管理器：“这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。”\n一个强大的窗口管理程序比如FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！\n你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 “Yes orNo”？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？\n还有就是很多 Windows程序把人当成傻瓜，而它是“智能程序”。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。\n如果连“一句话开头一个字母要大写”这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。\n只有符号才能完全操纵计算机 我们来说说很多初学 Linux 的用户。虽然他们在用 Linux，但是他们打心眼儿里是觉得 Windows 的工作方式好，他们希望 Linux 有一天能”像Windows那样”。你说：”我鼠标一点，我菜单一拉，…… 就可以完成我的操作。” 但是我要告诉你：”Linux 从来没有摹仿 Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows 的先进。Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。”\n看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget,tin, … 没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置?难道它们的设计者就那么低能，连个图形配置界面也写不出来?\n当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配 置文件的效果，你需要成百上千的菜单，checkbox, radio button, … 到时候你根本没办法找到你需要修改的地方了!而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，…… 一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed, Perl，你会觉得那才是真正的自动化啊。\n鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。\n各个小程序的完美配合 这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。X window也继承了这种好传统。\n这恐怕就是Windows和其它操作系统望尘莫及的地方了。UNIX 程序设计之统一，配合之完美，真使我难以置信!shell, grep, find, awk, sed, make, Perl,Emacs, vi, tin, Mutt, … 它们是那么的具有一致性!你一旦学会了 sed 的正则表达式，其它程序基本上都能用了。你一旦学会了 vi 和 VIM, 你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了 VIM 在今天的完美而统一的操作方式!而且vi的操作还体现在 Mutt, tin 等很多程序中。你甚至可以把 bash 设置为 vi 的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里”嵌入”另外一个程序。\n在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在Windows 下使用 Perl来进行一些自动工作。但是 Windows 的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual Studio 窗口里面嵌入UltraEdit 编辑器，你别想用一个 expect 脚本来控制 telnet 到水木清华BBS，这就是为什么 helloooo 诞生在 Linux 而不是 Windows。我曾经试图从Windows + Exceed + SecureCRT ssh 登录到 Sun 机器，然后通过 ssh 的隧道(X11 tunnel)把 X 程序传到 Exceed 上运行，但是搞了两天都没有成功!而在Linux 下这个事情根本就是不用怎么配置的，OpenSSH 和 XFree86 本来就是完美结合，只要打开 ssh 的 “forward X11″ 选项就什么都搞定了。\nWindows 的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的 Virtual Terminal, 自己的通讯代码。每一个 IDE 都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织…… 不能 DIY!\n你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的乒乓球拍，木板，胶皮，海绵，胶水都是可以自己选择…… 而用Windows 程序，你得到的是大杂烩，就像你去买”品牌机”，只有那么几种配置，而且附带很多你不需要的软件和服务;就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地! Windows 程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必须重新买全套配件!\n而 UNIX 和 X window 就是高档的”组装货”。比如我用 Mutt 的时候，我可以用VIM 也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv 来显示附件里的图片，我可以用 lynx 把 HTML 附件转成文本嵌入窗口中，我也可以把HTML 附件交给 Mozilla 图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它 PGP 程序。\n我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail 帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理…… 这一切我都可以办到!我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。\n学UNIX绝对不是浪费时间 有人告诉我：\u0026ldquo;你看我用 Windows 什么都不用学。而用 Linux，光是安装就花了我一个星期！\u0026rdquo;\n首先，我要告诉你的是，你装 Linux 花了一个星期，不是因为 Linux 不好装，而是因为你已经习惯了 Windows，对 Linux 最初难以理解而已。你想一想你最初安装Windows的时候呢？你花了多少时间搞明白什么是硬盘分区？什么是盘符？什么是目录？你认为Windows 就是那么容易可以学会的吗？虽然你觉得没花时间学，但是你以前在用别人的机器的时候已经耳濡目染，自然就了解了。而且由于你想要 Linux 和 Windows 并存于硬盘上，又增加了安装难度。而且你肯定没有得到有经验的 Linux 用户的帮助，否则他们会在20分种之内帮你搞定。一个星期也太夸张了.\n如果一开始用的就是Linux就没有这个问题。你想想如果你没有用过 windows，你肯定会很习惯 /etc, /usr, /usr/local ,\u0026hellip; 而不是 C:, D:, E:, \u0026hellip; 是不是？如果你只用过Linux，你第一次用 windows 时恐怕也会问：\u0026quot;/bin 目录哪里去了啊？\u0026quot;\n最重要的是，你用惯了的UNIX工具，它们可以伴随你一生，而不会那么容易变化或消失。你可以永远不用再换另外的工具了。除非那个工具比你这个好的太多，而且可以完全模拟你现在的工具。\n我们实验室一个60多岁的老师，用vi, cc, make, \u0026hellip;都几十年了，他以前的经验绝对没有白费，而且教会了我们一批又一批的学生。vi 伴随着 UNIX 的最初发行而诞生，直到今天还是世界上头两号编辑器之一！有些人的 FVWM 配置文件已经用了 10 多年，现在完全不经修改还可以用。\n看看 Windows 的工具，你从 Borland C++ 换到 VC, 就必须适应新的环境：菜单不同了，颜色不同了，按钮不同了，帮助信息不同了，热键不同了，编译器参数，调试器功能也不同了，…… 那个时候恐怕花要花你很多时间去适应。当你刚刚适应了 VC, 你又要换成VJ, PowerBuilder, C++Builder, \u0026hellip;\n很多windows程序员都是这样，开头在dos下用Turbo C, 然后是 Borland C, VC, C++ Builder,VS，VSC \u0026hellip;\u0026hellip;不断追赶微软的潮流。而且微软的SDK, MFC, .NET …… 什么都在不断变化，不断出问题，又不断的在修改…… Windows 程序员不得不买又厚又重的 Microsoft Press 的书籍，看了才一个月，又过时了。今天你才学会了写 VxD，明天你就必须用WDM 了。你不得不注册 MSDN 才能赶上 Microsoft 的步伐。很多人说：\u0026ldquo;计算机是贵族的专业。\u0026rdquo; 这就是微软一手造成的。\n这些东西才是没完没了的浪费大家的时间和金钱的。这是在浪费生命！我们为什么不使用从诞生就那么一致和完美的 UNIX？你需要理解先进工具的设计理念。UNIX 的工具就像我们用的汽车，它的离合器，油门，刹车，方向盘，后视镜，永远都在同样的位置。用惯了的话，你对你的汽车的每一个部件都会了如指掌，甚至你自己都可以修车了。这难道不好吗？\n有人说：\u0026ldquo;你说我们需要了解 UNIX，难道你要开车还必须了解汽车的结构吗？\u0026rdquo; 你去问问开车的司机，哪一个不了解汽车的结构的，那他的驾照就是混来的。你难道想要傻瓜型的\u0026quot;微软牌汽车\u0026quot;吗？我们来看看：\n你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱。车上的防撞气囊不时会冒出来，说是为了你的安全。每开100英里要大修一次，每过一年要换一次引擎。附带的，你还必须换用由微软汽车公司指定的石油公司提供的新型号的机油。你的车出了问题，但是法律规定，你不准私自拆开你的汽车来修理，你必须到微软汽车公司指定的维修点去，需要付相当多的钱才能修好一个小毛病。\n最可气的是，你每换一个型号的微软牌汽车，它的刹车和离合器都在不同的位置，你需要重新去考驾驶执照。如果这辆汽车在途中刹车失灵，你受了重伤，你也不能状告微软汽车公司，因为你买来汽车之后必须签一个合同，说\u0026quot;由于微软牌汽车对你和家人造成的一切死伤，微软概不负责。\u0026quot;\n怎样完全用 GNU/Linux 工作 说了这么多 Windows 的不好。我还没有告诉你我怎么用 Linux 处理有些必要的事情。半年以前我由于中文老是配置不好，一直是双系统，不时需要重启到 Win2k 来处理汉字。后来我找到了 miniChinput, XSIM 和 SCIM 输入法。这下可以处理汉字了。而且 VIM 和Emacs 对汉字支持越来越好。我的大部分文本是用 VIM 编辑的，包括程序，信件，网页，LaTeX 论文，MetaPost 绘图语言。\n我不用 Word 这样的程序写论文，而是用 LaTeX，因为这是世界上效果最好，最方便的论文工具，是大多数学术杂志要求的格式。幻灯都是用 ConTeXt 做的，用起来很简单，而且效果非常漂亮。你可以看看我的TeX介绍。\n至于绘图，你可以用很多可视化的工具，比如 xfig，dia。但是对于我来说，任何可视化的工具都不能完成某些任务，我需要一种可以精确描述图形的语言。我找到了MetaPost。它简单又好用，而且效果是世界一流的。我的插图，如果不是图像，都是MetaPost 画出来的。\n我曾经抱怨 mozilla-mail经常突然消失，损坏我好几封快要完成的信件。后来我发现mozilla 的邮件处理程序确实是不稳定的，功能又弱，有经验的 UNIX 用户都不用这样的程序。Mutt 是一个非常稳定可靠的 UNIX 邮件处理程序，而且功能非常强大。我曾经为 Gnome 和 KDE 的不稳定而烦恼。现在我找到了非常强大的 FVWM。KDE，Gnome也能和 FVWM 一起工作。虽然 Gnome 和 KDE 总体不稳定，但是某些部件程序还不错，很多 gtk, Qt 的程序也很不错，它们很多都是可以独立于这些桌面环境运行的。\nLinux 有很多强大方便的工作方式是 Windows 没有的，或者有类似的东西，但是很差劲或者用起来不方便。比如 ssh 服务，rsync，cvs，expect ……\n结论 我写这么多的目的是什么?\n我希望喜欢 Linux 的朋友，完全清除微软和Windows 灌输在你脑子里的谬论，别再相信它们所谓的”新技术”，别再追赶Windows，因为追赶 Windows =倒退。\n马克思有一个思想很重要，”新生事物并不一定是在最近出现的。” UNIX，X window, TeX 虽然都比 Windows 先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。\n消除学计算机很难的幻觉，勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt ……这样强大的程序，勇敢的面对符号。不要再埋怨\u0026quot;Linux 为什么不能像 Windows 那样\u0026quot;，不要再浪费时间试用这样那样的程序，不要再忙着升级。\n我希望小学，中学的计算机老师能够提高自己的素质，在孩子们的启蒙教育中充分利用Linux的特点，引起孩子们对数学，对符号的好奇心。诱导他们用计算机来解决世界上的有趣问题，而不要把教学的范围局限于计算机的操作和它自身的问题。\n你需要理解 UNIX 的工作方式，因为那是大多数科学家的工作方式。是你需要改变而不是 Linux 和 UNIX。Linux 现在就可以成为你的好朋友。你需要认识它，了解它，信任它，才能完全的靠它来高效的工作，省出时间来处理世界上更加值得处理的事情。\n当然，在游戏机，手机，掌上电脑里，或者在用电脑来娱乐的时候，用一些\u0026quot;傻瓜软件\u0026quot;还是不错的。\n附录1：Linux程序推荐 附录内容：王垠用来处理日常事务的Linux程序，需要注意的是，王垠本人写作本文的时间是2005年，目前2020年已经来临，Linux上早就已经出现了一些对图形化用户非常友好的软件，同样非常强大（即作者所认为的傻瓜软件），读者可以作过渡性的尝试。具体的推荐以后的文章会谈到。\n好了好了。我知道你现在可能已经发现自己应该转向 Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。\n如果你只想做一个普通用户，主要目的是用 Linux 来完成自己的任务，那就可以不用系统管理员或者网络管理员的标准来要求自己，因为当一个系统和网络管理员确实很辛苦。这里我对实验室的网管同学鞠一躬，谢谢你的指点和帮助。不用把你的机器当成网络服务器，不用开放没有必要的服务，设置好 ssh, ftp 已经足够了。这样会省去了解很多没必要了解的东西的时间。不用过度考虑\u0026quot;安全\u0026quot;，因为 Linux 缺省已经很安全了。不过你有兴趣了解更多那也无妨。\n这里给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如 Matlab, Mathematica, Maple, HSpice, Design Compiler, …… 还有其它物理上的，化学上的，生物上的 …… 都必然有 Linux 和 UNIX 的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，它们是经过很多人辛勤劳动的产物，是可靠的程序，他们物有所值。\n下面列出我常用的一些 Linux 程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的。我不喜欢试用程序。\nShell: Bash shell，我使用 bash 的 vi 命令行方式。\n开发系列\n文本编辑器：VIM，Emacs 自动管理工具：make 我可以用make来自动编译程序，自动编译文档，自动更新插图…… 全自动，而且不会重复劳动。 编译器：GCC，G++ 调试器：gdb，ddd 汇编器：as 跟踪器：strace, ltrace, truss 其他：ld, Scheme48, j2sdk, Perl, Tcl/Tk \u0026hellip; 办公系列\n论文文稿：LaTeX 演示文稿：ConText 绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可以用 dia 来画一些流程图之类的图片。 图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert 程序可以转换图像格式，display 可以显示图片和简单编辑(缩放，换质量，转格式，简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可以用 Gimp, 它几乎和 Photoshop 差不多。 Email 处理：Mutt + Postfix + fetchmail PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv, djvu工具包和 netscape 插件。 看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。 文件处理\n加密程序：GnuPG。我的 PGP 密钥就是它搞出来的，我用了 2048 位加密。 打包与压缩程序：tar, gzip, bzip2, zip, rar, \u0026hellip; 虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 即可。 服务器\nftp 服务器：proftpd, vsftpd WWW 服务器：apache。(我一般没有开) ftp 客户程序：lftp 登录其它 UNIX, Linux 机器：openSSH, telnet。 openSSH 还可以把其它机器的 X 程序通过 ssh 加密的隧道传到我机器上显示。 下载工具：wget\nLinux操作方面\n虚拟终端：rxvt, xterm, gnome-terminal, mlterm, \u0026hellip; X server: XFree86 窗口管理器：FVWM。编译加入了 libstroke。 中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用 SCIM。 交流与沟通\n看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比 IE 好很多。 英汉字典：IBM智能词典，星际译王。 编辑网页：我用 VIM 直接写 HTML。你如果想要图形方式的可以用其它的比如 screem, BlueFish。 登录BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo 机器人的程序) QQ, ICQ: 我没有 QQ 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和很多其它的即时通信方式。ICQ 用户也可以用 Licq。 休闲\n视频播放器：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD, DVD, divx, wma, wmv \u0026hellip; 用 Windows 的同学都很羡慕我，说 Windows 要放这个需要大堆插件。rm 最好还是用 realplayer 放，它也是免费的。 音乐播放器： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg)。 mpg321 不如xmms管理音乐文件那么方便，但是有时我还是用 mpg321 放 mp3 作为背景音乐，因为懒得开一个xmms窗口:-) Word 文档：请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没有特殊的格式就用文本文件，要不我就不看。（笔者注：现在Linux可以使用WPS Linux版，是比较方便的）\n其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor Scheme, Scheme48, Scsh, \u0026hellip;\n这些程序只有 Doctor Scheme 有Windows版本。还有很多幕后工作但是你一般不察觉的：xinetd, telnetd, sshd, crond, atd, lpd, \u0026hellip; 他们都比 Windows 的对应者强的多。\n附录2：Linux基础学习参考书籍 附录内容：该附录为笔者自己个人使用到的Linux系统基础学习的书籍。其中最值得推荐的已标注为※。\nLinux从入门到精通（中国水利水电出版社） Linux从入门到精通（Linux典藏大系）（清华大学出版社） ※ 鸟哥的Linux私房菜（第四版）（人民邮电出版社） ","permalink":"https://endlesspeak.github.io/docs/build/operating-system-sum/linux-technology-1-fully-use-linux/","tags":["Linux","Windows"],"title":"完全使用Linux工作"},{"authors":[],"categories":[],"content":"","permalink":"https://endlesspeak.github.io/homepage/","tags":[],"title":"Serene Feather Pavilion"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Ubuntu-base 准备 ubuntu-base 镜像，我选择的是24.04镜像。\n注意各镜像站存储 ubuntu-base 的路径可能不一样：\n官方 https://cdimage.ubuntu.com/ubuntu-base/releases/24.04/release 清华大学 https://mirrors.tuna.tsinghua.edu.cn/ubuntu-cdimage/ubuntu-base/releases/24.04/release Build Rootfs 构建 ubuntu 根文件系统步骤如下：\n创建文件夹，并将下载的根文件系统解压到文件夹中 安装跨架构运行器，以在非 ARM64 架构的主机上设置一个 ARM64 架构的 chroot 环境。 apt isntall qemu-user-static 并拷贝到 cp /usr/bin/qemu-aarch64-static ./ubuntu-rootfs/usr/bin 设置 DNS cp -L /etc/resolv.conf ./ubuntu-rootfs/etc/resolv.conf -L 追踪被拷贝目标的真实位置，防止拷贝软链接过去 -b 若拷贝到的目标位置已有文件，则备份后拷贝 设置软件源 DEB822 格式 挂载根文件系统，需要写mount-rootfs.sh，并赋予可执行权限 #!/bin/bash # Ensure the path ends with a slash normalize_path() { if [[ \u0026quot;$1\u0026quot; != */ ]]; then echo \u0026quot;${1}/\u0026quot; else echo \u0026quot;$1\u0026quot; fi } mnt() { MOUNT_PATH=$(normalize_path \u0026quot;$2\u0026quot;) echo \u0026quot;MOUNTING at $MOUNT_PATH\u0026quot; sudo mount -t proc /proc \u0026quot;${MOUNT_PATH}proc\u0026quot; sudo mount -t sysfs /sys \u0026quot;${MOUNT_PATH}sys\u0026quot; sudo mount -o bind /dev \u0026quot;${MOUNT_PATH}dev\u0026quot; sudo mount -o bind /dev/pts \u0026quot;${MOUNT_PATH}dev/pts\u0026quot; # sudo chroot \u0026quot;${MOUNT_PATH}\u0026quot; } umnt() { MOUNT_PATH=$(normalize_path \u0026quot;$2\u0026quot;) echo \u0026quot;UNMOUNTING from $MOUNT_PATH\u0026quot; sudo umount \u0026quot;${MOUNT_PATH}proc\u0026quot; sudo umount \u0026quot;${MOUNT_PATH}sys\u0026quot; sudo umount \u0026quot;${MOUNT_PATH}dev/pts\u0026quot; sudo umount \u0026quot;${MOUNT_PATH}dev\u0026quot; } if [ \u0026quot;$1\u0026quot; == \u0026quot;-m\u0026quot; ] \u0026amp;\u0026amp; [ -n \u0026quot;$2\u0026quot; ] ; then mnt $1 $2 elif [ \u0026quot;$1\u0026quot; == \u0026quot;-u\u0026quot; ] \u0026amp;\u0026amp; [ -n \u0026quot;$2\u0026quot; ]; then umnt $1 $2 else echo \u0026quot;\u0026quot; echo \u0026quot;Either 1'st, 2'nd or both parameters were missing\u0026quot; echo \u0026quot;\u0026quot; echo \u0026quot;1'st parameter can be one of these: -m(mount) OR -u(umount)\u0026quot; echo \u0026quot;2'nd parameter is the full path of rootfs directory(with trailing '/')\u0026quot; echo \u0026quot;\u0026quot; echo \u0026quot;For example: ch-mount -m /media/sdcard/\u0026quot; echo \u0026quot;\u0026quot; echo 1st parameter : ${1} echo 2nd parameter : ${2} fi chroot ubuntu-rootfs 进入根文件系统 安装一些常见的软件 apt install dialog apt-utils language-pack-en-base apt install sudo vim udev net-tools ethtool udhcpc netplan.io iputils-ping locale-gen en_US.UTF-8 dpkg-reconfigure locales dpkg-reconfigure tzdata apt install ifupdown language-pack-zh-han* openssh-server systemctl set-default graphical.target 首先是一些可能抱怨的问题 debconf 会抱怨没有 dialog-like 程序 apt 会建议加上 apt-utils perl 会抱怨 locale 设置不正确 其次是需要优先安装网络工具 net-tools 提供 ifconfig netstat route arp 等实用工具 ethtool 是配置以太网的 udhcpc 是轻量 dhcp 客户端 netplan.io 用于配置网络 iputils-ping 提供 ping 命令以测试 运行一些修复命令 安装其他的软件，安装前检查 snap install core 可以安装桌面环境 ubuntu-desktop-minial lubuntu-desktop lxqt 是否是更佳的选择？ xubuntu-desktop 可以在安装桌面环境后裁剪软件，如卸载 libreoffice* lubuntu-update-notifier 等 如果不需要 ssh 连接，或者只需要 sftp，可改安装 openssh-sftp-server 等 language-pack-zh-han* 包括了 hans 和 hant 设置启动图形界面 设置管理员密码和普通用户密码 制作根文件系统镜像 mk-ubuntu-image.sh #!/bin/bash # stage 1 # 读取输入参数，包括根文件系统目录和目标镜像文件 rootfs_dir=$1 rootfs_file=$2 # 定义临时挂载目录 rootfs_mnt=\u0026quot;mnt\u0026quot; # stage 2 # 检查输入参数时候存在 if [ ! $rootfs_dir ] || [ ! $rootfs_file ]; then echo \u0026quot;Folder or target is empty.\u0026quot; exit 0 fi # stage 3 # 删除已存在的目标镜像文件 if [ -f \u0026quot;$rootfs_file\u0026quot; ]; then echo \u0026quot;-- Delete exist $rootfs_file ...\u0026quot; rm -f \u0026quot;$rootfs_file\u0026quot; fi # stage 4 # 创建新的目标镜像文件 echo \u0026quot;-- Create $rootfs_file ...\u0026quot; dd if=/dev/zero of=\u0026quot;$rootfs_file\u0026quot; bs=1M count=5120 sudo mkfs.ext4 -F -L linuxroot \u0026quot;$rootfs_file\u0026quot; # stage 5 # 创建挂载点目录 if [ ! -d \u0026quot;$rootfs_mnt\u0026quot; ]; then mkdir $rootfs_mnt fi # stage 6 # 将源根文件系统的数据复制到目标镜像文件中 # 方法是： # 1. 将目标镜像文件挂载到挂载点 # 2. 复制文件到挂载点 # 3. 同步文件系统缓存 # 4. 卸载镜像，删除挂载点 echo \u0026quot;-- Copy data to $rootfs_file ...\u0026quot; sudo mount $rootfs_file $rootfs_mnt sudo cp -rfp $rootfs_dir/* $rootfs_mnt sudo sync sudo umount $rootfs_mnt rm -r $rootfs_mnt # stage 7 # 检查与调整目标镜像大小 echo \u0026quot;-- Resize $rootfs_file ...\u0026quot; e2fsck -p -f \u0026quot;$rootfs_file\u0026quot; resize2fs -M \u0026quot;$rootfs_file\u0026quot; echo \u0026quot;-- Done.\u0026quot; Rootfs Post Hooks Size 查看制作的根文件系统大小：\nsudo du -sh ubuntu-rootfs --exclude=ubuntu-rootfs/{proc,sys,dev} Dbus 关于可能遇到的 dbus 错误 /run/dbus/system_bus_socket:\nservice dbus start service cron start User \u0026amp; Group 新建用户和组：\nadduser leesin usermod -aG sudo leesin Sleep 禁用睡眠、休眠等：\nsystemctl mask sleep.target systemctl mask suspend.target systemctl mask hibernate.target systemctl mask hybrid-sleep.target Display Manager 检查显示管理器\ncat /etc/X11/default-display-manager Flash Firmware Device 设备连接到系统后在 /dev/ttyACM0 位置。\nUser \u0026amp; Group PC 添加用户到 dialout 组，或者 uucp 组\nusermod -aG dialout leesin Parameter 分区表需要重新设置，原来的分区表是：\nCMDLINE: mtdparts=:0x00002000@0x00004000(uboot),0x00002000@0x00006000(misc),0x00020000@0x00008000(boot),0x00040000@0x00028000(recovery),0x00010000@0x00068000(backup),0x01c00000@0x00078000(rootfs),0x00040000@0x01c78000(oem),-@0x01cb8000(userdata:grow) 现在需要将分区表改为：\nCMDLINE: mtdparts=:0x00002000@0x00004000(uboot),0x00002000@0x00006000(misc),0x00020000@0x00008000(boot),0x00040000@0x00028000(recovery),-@0x00068000(rootfs:grow) 特别地，后面写的uuid千万不要修改。\nFlash 首先进入 Loader 模式或者 Maskrom 模式；然后执行设备检查\nsudo ./upgrade_tool LD 识别出设备后执行烧写\nsudo ./upgrade_tool UL MiniLoaderAll.bin -noreset sudo ./upgrade_tool DI -p parameter.txt sudo ./upgrade_tool DI -uboot uboot.img sudo ./upgrade_tool DI -misc misc.img sudo ./upgrade_tool DI -boot boot.img sudo ./upgrade_tool DI -recovery recovery.img 下面的命令仅在烧录 buildroot 系统时会用到\nsudo ./upgrade_tool DI -oem oem.img sudo ./upgrade_tool DI -rootfs rootfs.img sudo ./upgrade_tool DI -userdata userdata.img Resize 烧录之后需要进行磁盘扩容。\n由于分区有 uboot,misc,boot,recovery,rootfs 五个，所以扩容需要用 sudo resize2fs /dev/mmcblk0p5，否则mmcblk0p5分区只有5GiB。\nEthernet Network 修改 /usr/lib/NetworkManager/conf.d/10-globally-managed-devices.conf\n内容为\nunmanaged-devices=*,except:type:ethernet,except:type:wifi,except:type:gsm,except:type:cdma 即加入 except:type:ethernet 以允许网口连接有线网络。\nIssues Graphical Target 如果 sddm 进入之后是空，修改 /etc/sddm.conf 脚本\n[X11] SessionCommand=/etc/sddm/Xsession ping 在测试网络时报错如下：\nping: socktype: SOCK_RAW ping: socket: Operation not permitted ping: =\u0026gt; missing cap_net_raw+p capability or setuid? 意思是缺少 cap_net_raw 权能，或未设置 setuid 位：\ncap_net_raw 是一种 Linux 能力，允许程序创建原始套接字，而不需要拥有 root 权限。 setuid 位是文件权限位，允许程序以文件所有者的权限运行。 解决办法：\nsudo setcap cap_net_raw+p $(which ping) sudo ping www.bing.com 逆天 sudo set chmod u+s $(which ping) 逆天无极限 ","permalink":"https://endlesspeak.github.io/docs/build/arm-linux-doc/2-rk3588-ubuntu-migrate/","tags":[],"title":"RK3588 移植 Ubuntu 24.04"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Discourse NixOS 该部分文章尚未完成。 Impure Python Poetry devShell\n(pkgs.poetry.override { python = pkgs.python39; }) poetry run python -c \u0026quot;import matplotlib\u0026quot; Traceback (most recent call last): File \u0026quot;\u0026lt;string\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; ModuleNotFoundError: No module named 'matplotlib' python -m site sys.path = [ '/home/asymmetric/code/foo', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python310.zip', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python3.10', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python3.10/lib-dynload', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python3.10/site-packages', '/nix/store/qyy1khnfvvv6m57gkh8qijj45v3h78jy-python3-3.10.11-env/lib/python3.10/site-packages', ] USER_BASE: '/home/asymmetric/.local' (exists) USER_SITE: '/home/asymmetric/.local/lib/python3.10/site-packages' (doesn't exist) ENABLE_USER_SITE: False poetry run python -m site sys.path = [ '/home/asymmetric/code/foo', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python310.zip', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python3.10', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python3.10/lib-dynload', '/home/asymmetric/code/foo/.venv/lib/python3.10/site-packages', '/nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/lib/python3.10/site-packages', ] USER_BASE: '/home/asymmetric/.local' (exists) USER_SITE: '/home/asymmetric/.local/lib/python3.10/site-packages' (doesn't exist) ENABLE_USER_SITE: False [asymmetric@tachikoma:~/code/foo]$ poetry run python Python 3.10.11 (main, Apr 4 2023, 22:10:32) [GCC 12.3.0] on linux Type \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information. \u0026gt;\u0026gt;\u0026gt; import site \u0026gt;\u0026gt;\u0026gt; site.addsitedir(\u0026quot;/nix/store/qyy1khnfvvv6m57gkh8qijj45v3h78jy-python3-3.10.11-env/lib/python3.10/site-packages\u0026quot;) \u0026gt;\u0026gt;\u0026gt; import matplotlib \u0026gt;\u0026gt;\u0026gt; exit() [asymmetric@tachikoma:~/code/foo]$ poetry env info Virtualenv Python: 3.10.11 Implementation: CPython Path: /home/asymmetric/.cache/pypoetry/virtualenvs/foo-jKhUbUE3-py3.10 Executable: /home/asymmetric/.cache/pypoetry/virtualenvs/foo-jKhUbUE3-py3.10/bin/python Valid: True System Platform: linux OS: posix Python: 3.10.11 Path: /nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11 Executable: /nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/bin/python3.10 [asymmetric@tachikoma:~/code/foo]$ poetry env use -vv /nix/store/qyy1khnfvvv6m57gkh8qijj45v3h78jy-python3-3.10.11-env/bin/python Trying to detect current active python executable as specified in the config. Found: /nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/bin/python Using virtualenv: /home/asymmetric/.cache/pypoetry/virtualenvs/foo-jKhUbUE3-py3.10 [asymmetric@tachikoma:~/code/foo]$ poetry env info Virtualenv Python: 3.10.11 Implementation: CPython Path: /home/asymmetric/.cache/pypoetry/virtualenvs/foo-jKhUbUE3-py3.10 Executable: /home/asymmetric/.cache/pypoetry/virtualenvs/foo-jKhUbUE3-py3.10/bin/python Valid: True System Platform: linux OS: posix Python: 3.10.11 Path: /nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11 Executable: /nix/store/6qk2ybm2yx2dxmx9h4dikr1shjhhbpfr-python3-3.10.11/bin/python3.10 packages = with pkgs;[ python311Packages.tkinter (poetry.overrideAttrs (oldAttrs:{ # 禁用 --unset PYTHONPATH # 因为我有外部包(tkinter)需要使用 makeWrapperArgs = [ ]; })) ]; ","permalink":"https://endlesspeak.github.io/docs/build/nixos-configuration/2-python-poetry-devshell/","tags":[],"title":"Python Development on NixOS"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Rotation Matrix 2 Dimensional 从二维角度推导旋转矩阵更加明确。\n假设二维坐标系 $xOy$ 的第一象限中有点 $P(x,y)$，其与原点 $O$ 的连线 $OP$ 与 $x$ 轴正向夹角为 $\\alpha$，则：\n$$ \\left \\{ \\begin{aligned} x\u0026=|OP|\\cos \\alpha \\\\ y\u0026=|OP|\\sin \\alpha \\end{aligned} \\right . $$ 当坐标系向逆时针方向旋转 $\\beta$ 角时，原 $P$ 点的坐标变为： $$ \\left \\{ \\begin{aligned} x'\u0026=|OP|\\cos (\\alpha-\\beta)=|OP|(\\cos\\alpha\\cos\\beta+\\sin\\alpha\\sin\\beta)=x\\cos\\beta+y\\sin\\beta \\\\ y'\u0026=|OP|\\sin (\\alpha-\\beta)=|OP|(-\\cos\\alpha\\sin\\beta+\\sin\\alpha\\cos\\beta)=-x\\sin\\beta+y\\cos\\beta \\end{aligned} \\right . $$ 写成矩阵形式即： $$ \\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = \\begin{bmatrix} \\cos\\beta \u0026 \\sin\\beta \\\\ -\\sin\\beta \u0026 \\cos\\beta \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} $$ 当坐标系向顺时针方向旋转 $\\beta$ 角时，原 $P$ 点的坐标变为： $$ \\left \\{ \\begin{aligned} x'\u0026=|OP|\\cos (\\alpha+\\beta)=|OP|(\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta)=x\\cos\\beta-y\\sin\\beta \\\\ y'\u0026=|OP|\\sin (\\alpha+\\beta)=|OP|(\\sin\\alpha\\cos\\beta+\\cos\\alpha\\sin\\beta)=-x\\sin\\beta+y\\cos\\beta \\end{aligned} \\right . $$ 写成矩阵形式即： $$ \\begin{bmatrix} x' \\\\ y' \\end{bmatrix} = \\begin{bmatrix} \\cos\\beta \u0026 -\\sin\\beta \\\\ \\sin\\beta \u0026 \\cos\\beta \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} $$ Coordinate System 常见的坐标系包括地理坐标系（地球固连坐标系/导航坐标系）和载体坐标系（机体坐标系）。\n地理坐标系：用于研究飞行器相对地面的运动状态，相当于世界坐标系。 载体坐标系：以运动载体自身结构构成坐标系。 姿态是载体坐标系与地理坐标系的变换关系。\n3 Dimensional 当扩展到三维旋转时，可以使用齐次坐标的方式将旋转矩阵增广到三维矩阵，令未变化的坐标轴相对应的保持不变。\n由于线性变换不满足乘法交换律，因此为了得到确定的姿态，需要规定确定的旋转次序。假设旋转次序按照以下方式：\n绕物体的 $Z$ 轴旋转 $\\alpha$，得到偏航角 $yaw$ 绕旋转之后的 $Y$ 轴旋转 $\\beta$，得到俯仰角 $pitch$ 绕旋转之后的 $X$ 轴旋转 $\\gamma$，得到滚转角 $roll$ 旋转矩阵均是正交矩阵： $$ \\begin{aligned} R_z(\\alpha) \u0026= \\begin{bmatrix} \\cos \\alpha \u0026 -\\sin \\alpha \u0026 0 \\\\ \\sin \\alpha \u0026 \\cos \\alpha \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\\\ R_y(\\beta) \u0026= \\begin{bmatrix} \\cos \\beta \u0026 0 \u0026 \\sin \\beta \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\sin \\beta \u0026 0 \u0026 \\cos \\beta \\end{bmatrix} \\\\ R_x(\\gamma) \u0026= \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos \\gamma \u0026 -\\sin \\gamma \\\\ 0 \u0026 \\sin \\gamma \u0026 \\cos \\gamma \\end{bmatrix} \\end{aligned} $$ 这里需要注意，为什么 $Y$ 轴的旋转矩阵负号和其他两维不一样，因为对于 $Y$ 轴旋转时，其旋转矩阵维度顺序是 $$ \\begin{bmatrix} z' \\\\ x' \\end{bmatrix}= \\begin{bmatrix} \\cos\\beta \u0026 -\\sin\\beta \\\\ \\sin\\beta \u0026 \\cos\\beta \\end{bmatrix} \\begin{bmatrix} z \\\\ x \\end{bmatrix} $$ 当对向量进行反序时 $$ \\begin{bmatrix} x \\\\ z \\end{bmatrix}= \\begin{bmatrix} \\cos\\beta \u0026 \\sin\\beta \\\\ -\\sin\\beta \u0026 \\cos\\beta \\end{bmatrix} \\begin{bmatrix} x \\\\ z \\end{bmatrix} $$ 可以看到，其负号形式自然就发生变化了。\n地理坐标系依次经过欧拉角 $yaw$,$pitch$,$roll$ 角度旋转 $\\alpha,\\beta,\\gamma$ 角度得到载体坐标系，则由地理坐标系到载体坐标系变换的姿态变换矩阵为： $$ \\begin{aligned} R_n^b(\\alpha, \\beta, \\gamma) \u0026= R_z(\\alpha)R_y(\\beta)R_x(\\gamma) \\\\ \u0026= \\begin{bmatrix} \\cos\\alpha \u0026 -\\sin\\alpha \u0026 0 \\\\ \\sin\\alpha \u0026 \\cos\\alpha \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\cos\\beta \u0026 0 \u0026 \\sin\\beta \\\\ 0 \u0026 1 \u0026 0 \\\\ -\\sin\\beta \u0026 0 \u0026 \\cos\\beta \\end{bmatrix} \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos\\gamma \u0026 -\\sin\\gamma \\\\ 0 \u0026 \\sin\\gamma \u0026 \\cos\\gamma \\end{bmatrix} \\\\ \u0026= \\begin{bmatrix} \\cos\\alpha\\cos\\beta \u0026 -\\sin\\alpha\\cos\\gamma+\\cos\\alpha\\sin\\beta\\sin\\gamma \u0026 \\sin\\alpha\\sin\\gamma+\\cos\\alpha\\sin\\beta\\cos\\gamma \\\\ \\sin\\alpha\\cos\\beta \u0026 \\cos\\alpha\\cos\\gamma+\\sin\\alpha\\sin\\beta\\sin\\gamma \u0026 -\\cos\\alpha\\sin\\gamma+\\sin\\alpha\\sin\\beta\\cos\\gamma \\\\ -\\sin\\beta \u0026 \\cos\\beta\\sin\\gamma \u0026 \\cos\\beta\\cos\\gamma \\end{bmatrix} \\end{aligned} $$ 反过来，由载体坐标系向地理坐标系变换的姿态变换矩阵为： $$ \\begin{aligned} R_b^n(\\alpha, \\beta, \\gamma)\u0026= R_x(-\\gamma)R_y(-\\beta)R_z(-\\alpha) \\\\ \u0026= \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos\\gamma \u0026 \\sin\\gamma \\\\ 0 \u0026 -\\sin\\gamma \u0026 \\cos\\gamma \\end{bmatrix} \\begin{bmatrix} \\cos\\beta \u0026 0 \u0026 -\\sin\\beta \\\\ 0 \u0026 1 \u0026 0 \\\\ \\sin\\beta \u0026 0 \u0026 \\cos\\beta \\end{bmatrix} \\begin{bmatrix} \\cos\\alpha \u0026 \\sin\\alpha \u0026 0 \\\\ -\\sin\\alpha \u0026 \\cos\\alpha \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} \\\\ \u0026= \\begin{bmatrix} \\cos\\alpha\\cos\\beta \u0026 \\sin\\alpha\\cos\\beta \u0026 -\\sin\\beta \\\\ -\\sin\\alpha\\cos\\gamma+\\cos\\alpha\\sin\\beta\\sin\\gamma \u0026 \\cos\\alpha\\cos\\gamma+\\sin\\alpha\\sin\\beta\\sin\\gamma \u0026 \\cos\\beta\\sin\\gamma \\\\ \\sin\\alpha\\sin\\gamma+\\cos\\alpha\\sin\\beta\\cos\\gamma \u0026 -\\cos\\alpha\\sin\\gamma+\\sin\\alpha\\sin\\beta\\cos\\gamma \u0026 \\cos\\beta\\cos\\gamma\\\\ \\end{bmatrix} \\end{aligned} $$ Inertial Measurement Unit 由于惯性运动单元测量得到的姿态角通常是基于载体坐标系的，而不是地理坐标系的，因此其姿态变换矩阵与前述姿态变换矩阵对应关系正好相反。\n假设载体坐标系测量得到的欧拉角为 $yaw$,$pitch$,$roll$，则存在下列对应关系：\n由载体坐标系到地理坐标系的姿态变换矩阵 $C_n^b=R_b^n$ 由地理坐标系到载体坐标系的姿态变换矩阵 $C_b^n=R_n^b$ Gyromscope 惯性测量单元所在的载体坐标系和地理坐标系重合时，加速度计的测量值为 $A_n=\\begin{bmatrix} 0 \u0026amp; 0 \u0026amp; g \\end{bmatrix}^T$\n若载体处于任意一个位置时，加速度计的测量值为 $A_n=\\begin{bmatrix} a_x \u0026amp; a_y \u0026amp; a_z \\end{bmatrix}^T$。\n根据 $$ \\begin{bmatrix} a_x \\\\ a_y \\\\ a_z \\end{bmatrix}= \\begin{bmatrix} \\cos\\alpha\\cos\\beta \u0026 \\sin\\alpha\\cos\\beta \u0026 -\\sin\\beta \\\\ -\\sin\\alpha\\cos\\gamma+\\cos\\alpha\\sin\\beta\\sin\\gamma \u0026 \\cos\\alpha\\cos\\gamma+\\sin\\alpha\\sin\\beta\\sin\\gamma \u0026 \\cos\\beta\\sin\\gamma \\\\ \\sin\\alpha\\sin\\gamma+\\cos\\alpha\\sin\\beta\\cos\\gamma \u0026 -\\cos\\alpha\\sin\\gamma+\\sin\\alpha\\sin\\beta\\cos\\gamma \u0026 \\cos\\beta\\cos\\gamma\\\\ \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ g \\end{bmatrix} $$ 化简得 $$ \\begin{bmatrix} a_x \\\\ a_y \\\\ a_z \\end{bmatrix}= \\begin{bmatrix} -\\sin\\beta \\\\ \\cos\\beta\\sin\\gamma \\\\ \\cos\\beta\\cos\\gamma \\end{bmatrix} g $$ 解算得到 $$ \\left \\{ \\begin{aligned} \u0026\\beta = \\arcsin \\frac{a_y}{a_z} \\\\ \u0026\\gamma = -\\arcsin \\frac{a_x}{\\sqrt{a_y^2+a_z^2}} \\end{aligned} \\right . $$ Magnetometer 惯性测量单元所在的载体坐标系和地理坐标系重合时，磁力计的测量值为 $M_n=\\begin{bmatrix} M_N \u0026amp; 0 \u0026amp; M_D \\end{bmatrix}^T$。\n这里磁力计的测量值只包含了 $x,z$ 两轴，若记 $x,y,z$ 三轴分别对应地理坐标系上的南、东、天，则可以发现：\n东方向始终在地球上绘制同心圆，天和南方向组成的向量指向了地球的南极； 测量值中，$M_N$ 代表了北（南）方向的磁场强度分量，$M_D$ 代表地心（天）方向的磁场强度分量。 若载体处于任意一个位置时，磁力计的测量值为 $M_b=\\begin{bmatrix} M_x \u0026amp; M_y \u0026amp; M_z \\end{bmatrix}^T$。\n根据载体坐标系和地理坐标系的关系： $$ M_b=C_n^bM_n $$ 推导可得： $$ \\begin{bmatrix} M_x \\\\ M_y \\\\ M_z \\end{bmatrix}= \\begin{bmatrix} M_N\\cos\\alpha_m\\cos\\beta - M_D\\sin\\beta \\\\ M_N(\\cos\\alpha_m\\sin\\beta\\cos\\gamma-\\sin\\alpha_m\\cos\\gamma)+M_D\\cos\\beta\\sin\\gamma \\\\ M_N(\\cos\\alpha_m\\sin\\beta\\cos\\gamma+\\sin\\alpha_m\\sin\\gamma)+M_D\\cos\\beta\\cos\\gamma \\end{bmatrix} $$ 即有： $$ \\left \\{ \\begin{aligned} \u0026M_x\\cos\\beta+M_y\\sin\\beta\\sin\\gamma+M_z\\sin\\beta\\cos\\gamma=M_N\\cos\\alpha_m \\\\ \u0026M_x\\sin\\gamma-M_y\\cos\\gamma=M_N\\sin\\alpha_m \\end{aligned} \\right . $$ 从而可以计算出载体相对地磁北极的航向角： $$ \\alpha_m = \\arctan \\frac{M_x\\sin\\gamma-M_y\\cos\\beta}{M_x\\cos\\beta+M_y\\sin\\beta\\sin\\gamma+M_z\\sin\\beta\\cos\\gamma} $$ 最终航向角 $\\alpha = \\alpha_m + \\Delta \\alpha$，其中 $\\Delta \\alpha$ 是地磁北极与地理北极的夹角。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/2-pose-caculating/","tags":[],"title":"Pose Caculating"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Vector Brief std::vector 是 C++ 标准模板库(STL)中的一个动态数组类。它能够自动管理内存，在需要时自动扩展或收缩。std::vector 具有以下特点：\n动态大小：可以根据需要增加或减少元素的数量。 连续内存：元素在内存中是连续存储的，支持高效的随机访问。 自动扩展：在添加新元素时，std::vector 会自动扩展容量。 Extend 当向 std::vector 添加新元素时，如果当前容量不足以容纳新元素，std::vector 会自动扩展其容量。扩展的过程如下：\n检测容量：检查当前容量是否足够容纳新元素。 分配新内存：如果容量不足，std::vector 会分配一块更大的内存空间，通常是当前容量的两倍（具体倍数由实现决定）。 复制元素：将现有元素从旧内存块复制到新内存块。 释放旧内存：释放旧的内存块。 下面是一个例子演示在向 ~std::vector~ 中添加元素以触发动态扩展。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec; // vec.reserve(5); // 预留初始容量（可选） std::cout \u0026lt;\u0026lt; \u0026quot;Initial Capacity: \u0026quot; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026quot;, Address: \u0026quot; \u0026lt;\u0026lt; \u0026amp;vec[0] \u0026lt;\u0026lt; std::endl; // 添加元素并观察扩容 for (int i = 0; i \u0026lt; 10; ++i) { vec.push_back(i); std::cout \u0026lt;\u0026lt; \u0026quot;Size: \u0026quot; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026quot;, Capacity: \u0026quot; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; std::endl; } // 查看地址 std::cout \u0026lt;\u0026lt; \u0026quot;After push - Capacity: \u0026quot; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026quot;, Address: \u0026quot; \u0026lt;\u0026lt; \u0026amp;vec[0] \u0026lt;\u0026lt; std::endl; return 0; } 在这个示例中，vec 的容量会且仅会在需要时自动扩展，输出会显示每次扩展后的大小和容量。 结论：扩容会从 1 开始，每次扩容为之前的 2 倍，如 1，2，4，8，16 等。\nShrink std::vector 在删除元素后不会自动减少其容量。为了减少内存占用，可以使用shrink_to_fit 方法，该方法会尝试减少 std::vector 的容量以适应其大小。\n以下是一个示例，演示如何缩小 ~std::vector~ 的容量：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; vec; // 初始情况 std::cout \u0026lt;\u0026lt; \u0026quot;Initail Capacity: \u0026quot; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026quot;, Address: \u0026quot; \u0026lt;\u0026lt; \u0026amp;vec[0] \u0026lt;\u0026lt; std::endl; // 添加元素 for (int i = 0; i \u0026lt; 10; ++i) { vec.push_back(i); std::cout \u0026lt;\u0026lt; \u0026quot;Size: \u0026quot; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026quot;, Capacity: \u0026quot; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026quot;,Address:\u0026quot; \u0026lt;\u0026lt; \u0026amp;vec[0] \u0026lt;\u0026lt; std::endl; } // 删除元素 vec.erase(vec.begin() + 5, vec.end()); std::cout \u0026lt;\u0026lt; \u0026quot;After erase - Size: \u0026quot; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026quot;, Capacity: \u0026quot; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026quot;, Address: \u0026quot; \u0026lt;\u0026lt; \u0026amp;vec[0] \u0026lt;\u0026lt; std::endl; // 缩小内存 vec.shrink_to_fit(); std::cout \u0026lt;\u0026lt; \u0026quot;After shrink_to_fit - Size: \u0026quot; \u0026lt;\u0026lt; vec.size() \u0026lt;\u0026lt; \u0026quot;, Capacity: \u0026quot; \u0026lt;\u0026lt; vec.capacity() \u0026lt;\u0026lt; \u0026quot;, Address: \u0026quot; \u0026lt;\u0026lt; \u0026amp;vec[0] \u0026lt;\u0026lt; std::endl; return 0; } 结论：std::vector 每次扩容或缩容都会重新申请内存地址。\nOrdered \u0026amp; Unordered 在 C++ 的标准模板库（STL）中，unordered 容器和 ordered 容器有显著的区别。\nUnordered Container unordered 容器基于哈希表实现，包含以下几种主要类型：\nstd::unordered_set std::unordered_map std::unordered_multiset std::unordered_multimap Features unordered 容器特点如下：\n无序性：元素没有特定的顺序。插入顺序不影响元素的存储顺序。 哈希表实现：使用哈希函数对元素进行组织和查找。 平均常数时间复杂度：对于插入、删除和查找操作，通常可以在平均常数时间内完成。这使得它们非常适合需要快速查找的场景。 迭代器：由于无序性，迭代器遍历元素的顺序不确定。 Scene 需要快速查找、插入和删除操作的场景。 不关心元素顺序的情况。 Ordered Container ordered 容器基于树（通常是红黑树）实现，包含以下几种主要类型：\nstd::set std::map std::multiset std::multimap Features ordered 容器特点如下：\n有序性：元素按特定顺序存储（通常是按升序排列）。插入顺序可能会影响元素的存储顺序。 二叉树实现：使用平衡二叉树（例如红黑树）对元素进行组织和查找。 对数时间复杂度：对于插入、删除和查找操作，通常可以在对数时间内完成。这使得它们适合需要有序访问的场景。 迭代器：迭代器遍历元素时，按照存储顺序进行（例如升序） Scene 需要元素按顺序存储和访问的场景。 需要有序的范围查询操作的情况（例如查找某个范围内的元素）。 Example 下面是一个简单的示例，展示如何使用 unordered_map 和 map:\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;map\u0026gt; int main() { // unordered_map 示例 std::unordered_map\u0026lt;int, std::string\u0026gt; umap; umap[1] = \u0026quot;one\u0026quot;; umap[3] = \u0026quot;three\u0026quot;; umap[2] = \u0026quot;two\u0026quot;; std::cout \u0026lt;\u0026lt; \u0026quot;Unordered map elements:\u0026quot; \u0026lt;\u0026lt; std::endl; for (const auto\u0026amp; pair : umap) { std::cout \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; pair.second \u0026lt;\u0026lt; std::endl; } // map 示例 std::map\u0026lt;int, std::string\u0026gt; omap; omap[1] = \u0026quot;one\u0026quot;; omap[3] = \u0026quot;three\u0026quot;; omap[2] = \u0026quot;two\u0026quot;; std::cout \u0026lt;\u0026lt; \u0026quot;Ordered map elements:\u0026quot; \u0026lt;\u0026lt; std::endl; for (const auto\u0026amp; pair : omap) { std::cout \u0026lt;\u0026lt; pair.first \u0026lt;\u0026lt; \u0026quot;: \u0026quot; \u0026lt;\u0026lt; pair.second \u0026lt;\u0026lt; std::endl; } return 0; } ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/3-interview-doc/2-stl/","tags":[],"title":"STL"},{"authors":[],"categories":[],"content":"Remove Element 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\n假设 nums 中不等于 val 的元素数量为 k，要通过此题，需要执行以下操作：\n更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。=nums= 的其余元素和 nums 的大小并不重要 返回 k Code 双指针法，一个指向被赋值的元素，一个指向查找的元素。 我写的方法是头指针与尾指针调换(仅给头指针赋值)。\nclass Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int length = nums.size(); int head = 0; int tail = length - 1; for (head=0; head\u0026lt;=tail; head++) { // 考虑相等时该元素可能需要被排除 if(nums[head]==val) { nums[head]=nums[tail--]; } else { head++; } } return tail+1; // 考虑所有都不符合要求，使用head+1会导致多增加一个 } }; 官方题解是双指针都从头出发。\n其实这类题目隐含的是数组最右侧都是不需要关心的，此时双指针即可从头开始触发。\nclass Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int left = 0; // 头指针 int length = nums.size();// 长度 for(int right=0;right\u0026lt;length;right++){ if(nums[right]!=val){ nums[left]=nums[right]; left++; } } return left; } }; ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/algorithms-doc/2-remove-elements/","tags":[],"title":"Remove Element"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Three-way Comparison 三向比较运算符是C++20引入的特性，可用于确定两个值的大小顺序。它返回一个类枚举(enumeration-like)类型，其定义在 \u0026lt;compare\u0026gt; 和 std 名称空间中。\n相比原始类型，使用三向比较运算符不会带来太多收益；但是对于比较昂贵的对象来说则很有用。\nStrong Ordering 如果操作数是整数类型，则结果是强排序。\nstrong_ordering::less strong_ordering::greater strong_ordering::equal 下面给出了一个操作整数类型的例子。\nint i {11}; if (std::strong_ordering result { i\u0026lt;=\u0026gt;0 }; result == std::strong_ordering::less) { std::cout\u0026lt;\u0026lt;\u0026quot;less\u0026quot;\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;; } else if(result == std::strong_ordering::greater){ std::cout\u0026lt;\u0026lt;\u0026quot;greater\u0026quot;\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;; } else { std::cout\u0026lt;\u0026lt;\u0026quot;equal\u0026quot;\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;; } Partial Ordering 如果操作数是浮点类型，则结果是一个偏序。\npartial_ordering::less partial_ordering::greater partial_ordering::equivalent partial_ordering::unordered 下面给出了一个操作浮点数类型的例子。\n#include \u0026lt;cmath\u0026gt; float a = std::nan(\u0026quot;\u0026quot;); float b = std::numeric_limits\u0026lt;float\u0026gt;::infinity(); float c = 3.14; if( std::partial_ordering result { a\u0026lt;=\u0026gt;b }; result == std::partial_ordering::unordered) std::cout \u0026lt;\u0026lt; \u0026quot;Error,some number is illegal.\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; Weak Ordering 如果需要针对自己的类型实现三向比较，则选择弱排序。\nweak_ordering::less weak_ordering::greater weak_ordering::equivalent 下面给出了一个操作类的对象类型的例子。\nmodule; #include \u0026lt;string\u0026gt; export module employee; export class Employee{ public: std::string name; char first_initial; char last_initial; int employee_number; int salary; auto operator\u0026lt;=\u0026gt;(const Employee\u0026amp; other) const -\u0026gt; std::weak_ordering; }; auto Employee::operator\u0026lt;=\u0026gt;(const Employee\u0026amp; other) const -\u0026gt; std::weak_ordering{ // 按照薪水进行比较 if (salary \u0026lt; other.salary) { return std::weak_ordering::less; } else if (salary \u0026gt; other.salary) { return std::weak_ordering::greater; } else { return std::weak_ordering::equivalent; } } 其中：\n一般地，三向比较运算符可以写 auto operator\u0026lt;=\u0026gt;(const Person\u0026amp; other) const = default; 这个默认成员函数 通过使用 = default ，编译器将使用默认的比较行为来生成该函数的实现。默认比较的逻辑是按照类成员顺序逐个比较，并返回适当的 std::weak_ordering 值。 在该函数定义中，=const= 关键字表示该成员函数是一个常量成员函数，不修改对象状态。const 关键字必须放在函数参数列表后面，以确保函数签名的一致性。 值得说明的是，如果不指定返回类型，下面的代码将会返回对应数据类型所属的类枚举类型 std::strong_ordering\nauto operator\u0026lt;=\u0026gt;(const Employee\u0026amp; other) const { return salary \u0026lt;=\u0026gt; other.salary; } ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/2-advanced-doc/n-compare/","tags":[],"title":"Compare"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Install ROS2 by one command fishros 可用 fishros 提供的实用程序一行代码在 ubuntu 上安装 ROS2。\nwget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros\rglobal view 总体来看，它的安装流程包含如下命令:\nmkdir -p /tmp/fishinstall/tools\rwget http://fishros.com/install/install1s/install.py -O /tmp/fishinstall/install.py 2\u0026gt;\u0026gt;/dev/null\rsource /etc/profile\rsudo apt install python3-distro python3-yaml -y\rif [ $UID -eq 0 ];then\rapt-get install sudo\rfi\rsudo python3 /tmp/fishinstall/install.py\rsudo rm -rf /tmp/fishinstall/\rsudo rm fishros\r. ~/.bashrc\rinstall steps 安装步骤是下载 install.py 文件，执行它的过程中会自动下载两个以上的python文件：\nbase.py 在该文件中定义了下载的各项命令，它会执行 wget / curl / apt 等命令 用户请求的功能文件，当用户请求下载ROS2，则它会下载 tool_install_ros.py 文件 Install ROS2 Manually add software source dpkg --print-architecture 会显示当前操作系统的架构 lsb-release -cs 会显示当前操作系统(Linux发行版)的代码名称 /usr/share/keyrings 保存的是密钥环文件，软件在安装之前都需要密钥环签名才能验证软件是可信的，否则可能拒绝软件的安装。 使用下面的命令获取密钥环文件：\nsudo apt install curl gnupg2\rsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\r使用下面的命令添加软件源：\necho \u0026quot;deb [arch=$(dpkg --print-architecture)] signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/ros2/ubuntu $(lsb_release -cs) main\u0026quot; | sudo tee /etc/apt/sources.list.d/ros2.list \u0026gt; /dev/null\rsudo apt update\rinstall ROS2 安装针对ROS的开发工具，这一步是可选的\nsudo apt install ros-dev-tools\r安装 ROS2的桌面版软件包组\nsudo apt update\rsudo apt upgrade\r# iron now is the latest distribution\r# galactic is also available\rsudo apt install ros-humble-desktop-full\rsetup environment 每次执行诸如 ros2 等相关命令时，需要提前将其可执行目录导入到环境中。\n手动执行下面的命令 将命令添加到 bashrc 或 zshrc 中 source /opt/ros/humble/setup.bash\rsource /opt/ros/humble/setup.zsh\r也可以将它的快捷执行命令添加到 shell 的配置文件中。\nalias sros2='source /opt/ros/humble/setup.zsh'\rTry ROS2 以下内容中的操作命令均需要在不同的终端页(tab)中执行，或者使用终端复用工具。\ndemo nodes test 打开两个进程，一个用于接受信息，一个用于发送信息。\nros2 run demo_nodes_py listener\rros2 run demo_nodes_py speaker\r可以将 demo_nodes_py 改为 demo_nodes_cpp\nturtlesim 首先运行小海龟的节点，然后运行键盘控制程序。\nros2 run turtlesim turtlesim_node\rros2 run turtlesim turtle_teleop_key\rrqt 打开 rqt ，选择 introspection -\u0026gt; Node Graph 插件。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/ros-doc/1-ros2-install/","tags":[],"title":"ROS2 Installation"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"RDP(Remote Desktop Protocol)是一种远程桌面协议，由微软开发用于远程连接和控制计算机。允许用户通过网络从本地计算机的远程桌面客户端连接到远程计算机。\nServer 在需要被远程控制的计算机上安装 xrdp 程序。\nxRDP 是一个开源的 RDP 服务器程序，可以在 Linux 上提供 RDP 服务。\n它允许 Windows 系统上的远程桌面客户端通过 RDP 连接到 Linux 机器，并在远程桌面上进行图形界面操作。\nxRDP 可以与不同的桌面环境（如 GNOME、Xfce、MATE 等）配合使用。\n配置 xrdp 步骤如下所述：\n安装 xrdp 软件： ~sudo apt install xrdp~ 启动 xrdp 服务： ~sudo systemctl enable xrdp~ 设置防火墙规则 在 ubuntu 发行版上，使用 ufw 配置防火墙规则。 sudo ufw status sudo ufw enable sudo ufw allow 3389/tcp sudo ufw status Client Windows 默认安装有 msctc ，可以直接用于远程桌面控制。\nFreerdp Linux 可以考虑安装 freerdp ，它提供了一个 xfreerdp 命令用于连接远程计算机。\nxfreerdp 的基本使用方式如下：\nxfreerdp /u:\u0026lt;username\u0026gt; /p:\u0026lt;password\u0026gt; /v:\u0026lt;remote\u0026gt; 用户名和密码参数： /u:用户名：指定要用于连接的用户名。 /p:密码：指定与用户名对应的密码。 远程计算机地址参数：/v: 远程计算机地址：指定要连接的远程计算机的地址。 它可以是 IP 地址、域名或计算机名称。 远程桌面分辨率参数：/size: 宽度 x 高度：指定远程桌面的分辨率。 例如，/size:1024x768 将设置远程桌面的分辨率为 1024x768 像素。 远程音频参数：/audio-mode:模式：指定远程音频的传输方式。 可以选择的模式包括 none（禁用音频）、local（在本地播放音频）和 remote（在远程计算机上播放音频）。 远程文件共享参数：/drive:本地路径，远程路径：通过此参数可以共享本地计算机的硬盘驱动器。 指定本地路径和远程路径后，远程计算机就可以访问本地路径所对应的文件和文件夹。 远程连接体验参数： /wallpaper:模式：控制是否在远程桌面上显示壁纸。可以选择的模式包括 yes（显示壁纸）和 no（不显示壁纸）。 /fonts:模式：控制是否在远程桌面上使用远程计算机的字体。可以选择的模式包括 yes（使用远程计算机的字体）和 no（不使用远程计算机的字体） KRDC KRDC 是一个用于 Linux 操作系统的远程桌面客户端程序，它基于开源的 RDP 协议实现，可以与远程桌面服务器进行连接，并在本地计算机上显示和操作远程桌面。\n连接到远程计算机：通过 KRDC，你可以连接到远程计算机，可以是运行 Windows 的计算机或者其他支持 RDP 协议的远程桌面服务器。你需要提供远程计算机的 IP 地址、域名或主机名来建立连接。 建立连接配置：KRDC 允许你设置各种连接选项，如用户名、密码、域、远程计算机的分辨率等。你可以根据需要进行配置，以实现最佳的远程桌面体验。 窗口管理和显示：KRDC 提供了多种窗口管理选项。你可以选择连接到远程桌面时显示远程桌面的全屏窗口，或者选择显示在一个窗口中。你还可以根据需要调整远程桌面的分辨率和窗口大小。 文件传输和剪贴板共享：KRDC 允许你在本地计算机和远程计算机之间进行文件传输，并且支持剪贴板共享，方便在本地和远程桌面之间复制和粘贴文本或文件。 远程会话管理：你可以在 KRDC 中管理和切换多个远程会话。这意味着你可以同时连接到多个远程计算机，轻松切换并对其进行操作。 连接历史记录：KRDC 会自动保存你的连接历史记录，使你可以轻松选择最近连接过的远程计算机。 KRDC 在底层上依赖 freerdp ，但是也许不必先安装 freerdp ，因为包管理器可能能处理该依赖。\n","permalink":"https://endlesspeak.github.io/docs/build/operating-system-tool/2-linux-rdp-connection/","tags":[],"title":"RDP 远程桌面连接"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Hello Rust Editor 主流编辑器均支持 Rust 语言。此处仅讨论 Emacs 中如何获得 Rust 支持。\n首先，可以通过 melpa 安装 rust-mode ，基本配置如下：\n(use-package rust-mode :ensure t :mode (\u0026quot;\\\\.rs\\\\'\u0026quot; . rust-mode) :hook (rust-mode . (lambda () (setq tab-width 4))) ) 其次，Rust 代码风格不支持 tab ，而是将缩进映射为 4 个空格，可以默认禁用 tab ，例如作如下配置：\n(setq-default tab-width 4 indent-tabs-mode nil) Hello World Rust 命名风格：\nRust 文件通常以 .rs 结尾。 如果文件名中使用了多个单词，应 使用下划线隔开 。 左括号与函数声明建议在同一行，且带有一个空格。 fn main() { println!(\u0026quot;Hello, world!\u0026quot;); } Hello Cargo What\u0026rsquo;s cargo Cargo 是 Rust 的构建系统和包管理器。\n官方建议 Rustacean 使用 Cargo 来管理他们的 Rust 项目，用于:\n创建项目 构建代码 下载依赖库 编译依赖库 运行测试 代码检查 创建项目的命令如下：\ncargo new hello_cargo cd hello_cargo 一般地， cargo 会初始化 git 仓库，并带有 .gitignore 文件。 特别地，在 Git 仓库中运行 cargo 命令不会生成子仓库，除非使用 cargo new --vcs=git 无视此限制。 Cargo config Cargo 配置的项目一般包含一个 cargo.toml 文件，用于描述 cargo 的配置。它是 TOML (Tom\u0026rsquo;s Obvious, Minimal Language) 格式。\n[package] name = \u0026quot;hello_cargo\u0026quot; version = \u0026quot;0.1.0\u0026quot; edition = \u0026quot;2021\u0026quot; [dependencies] 注释：\n[package] ，是一个表块（section）标题，表明下面的语句用来配置一个包（package）。 edition ，指的是 Rust 语言的版本。每 6 周 Rust 发布一个小更新，每 2-3 年 Rust 生成一个新的版本。 [dependencies] ，指明项目所依赖的任何包，它们被称为 crate 。 Cargo dependency 包与 Crate 的概念\ncrate 是 Rust 代码编译单元，它可以是库或者二进制 包对应一个项目/代码仓库，它可以包含一个或多个 crate 有关更详细的内容，见 Package And Crate 小节 新增外部依赖的方式：\n[dependencies] rand = \u0026quot;0.8.5\u0026quot; Cargo 理解语义化版本（Semantic Versioning，有时也称为 SemVer）\n语义化是一种定义版本号的标准 小版本与大版本 0.X 是大版本 0.X.Y 是小版本 小版本具有兼容的公有 API 0.8.5 实际上是 ^0.8.5 的简写，它表示任何至少包含 0.8.5 但低于 0.9.0 的版本 0.9.0 或更高版本则不再确保 API 相同 Cargo command cargo build 命令会在 target/debug/hello_cargo 下创建一个可执行文件。 cargo run 命令会一次性完成编译并执行过程。 cargo check 命令用于快速检查代码，它 不 产生可执行文件。 cargo fix 命令用于修复代码常见问题 语言本身版本升级带来的 API 变化 依赖版本过时时自动更新 自动应用一些 lint 规则建议，如代码风格与错误处理 特别注意，对于依赖包的 API 变化，本命令 无法修改 cargo doc --open 命令构建本地依赖提供的文档 ","permalink":"https://endlesspeak.github.io/docs/docs/rust-programming-basic-doc/2-hello-cargo/","tags":[],"title":"Hello Cargo"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Cube 此处文章尚在施工。\n","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/2-stm32-cube/","tags":[],"title":"STM32 Cube"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"参考配置 以下记录在 Emacs 中所遇到的常见问题与解决方案。 如果不希望从零开始，这里有一些常见的配置推荐（持续更新）：\nMatthewZMD\u0026rsquo;s emacs Centaur\u0026rsquo;s emacs Redguard\u0026rsquo;s emacs Evanmeek\u0026rsquo;s emacs SpringHan\u0026rsquo;s emacs Cabins\u0026rsquo; emacs 7ym0n\u0026rsquo;s emacs 中文输入 fcitx5 是新一代输入法框架，具有默认的拼音输入引擎，当然也有 fcitx5-rime 。\nLocale 调整 locale:\nLANG=zh_CN.UTF-8 LC_CTYPE=\u0026quot;zh_CN.UTF-8\u0026quot; LC_NUMERIC=\u0026quot;zh_CN.UTF-8\u0026quot; LC_TIME=\u0026quot;zh_CN.UTF-8\u0026quot; LC_COLLATE=\u0026quot;zh_CN.UTF-8\u0026quot; LC_MONETARY=\u0026quot;zh_CN.UTF-8\u0026quot; LC_MESSAGES=\u0026quot;zh_CN.UTF-8\u0026quot; LC_PAPER=\u0026quot;zh_CN.UTF-8\u0026quot; LC_NAME=\u0026quot;zh_CN.UTF-8\u0026quot; LC_ADDRESS=\u0026quot;zh_CN.UTF-8\u0026quot; LC_TELEPHONE=\u0026quot;zh_CN.UTF-8\u0026quot; LC_MEASUREMENT=\u0026quot;zh_CN.UTF-8\u0026quot; LC_IDENTIFICATION=\u0026quot;zh_CN.UTF-8\u0026quot; LC_ALL= Install 安装软件包：\nsudo pacman -S xorg-fonts-misc 字体 Doom emacs 中设置字体 设置中文字体，并为其添加 hook 。原因是 doom eamcs 大量采用了懒加载技术。\n;;设置中文字体 (defun leesin/set-fonts() (set-fontset-font \u0026quot;fontset-default\u0026quot; 'unicode (font-spec :family \u0026quot;等距更纱黑体 Slab Sc\u0026quot; :size 20) nil 'prepend)) (add-hook! 'after-setting-font-hook :append 'leesin/set-fonts) 设置英文字体,注释中详细说明了如何查看本机字体。简单来说，可以使用 M-x menu-set-font 。\n(setq doom-font (font-spec :family \u0026quot;SauceCodePro Nerd Font\u0026quot; :size 20 ) doom-variable-pitch-font (font-spec :family \u0026quot;SauceCodePro Nerd Font\u0026quot; :size 20) doom-unicode-font (font-spec :family \u0026quot;SauceCodePro Nerd Font\u0026quot; :size 18) doom-big-font (font-spec :family \u0026quot;SauceCodePro Nerd Font\u0026quot; :size 22)) Vanilla Emacs 中设置字体 待更新\n终端渲染 (when (display-graphic-p) (set-frame-width (selected-frame) 150) (set-frame-height (selected-frame) 60)) 代理 (defun leesin/toggle-proxy () (interactive) (if (null url-proxy-services) (progn (setq url-proxy-services '((\u0026quot;http\u0026quot; . \u0026quot;127.0.0.1:8889\u0026quot;) (\u0026quot;https\u0026quot; . \u0026quot;127.0.0.1:8889\u0026quot;))) (message \u0026quot;代理已开启.\u0026quot;)) (setq url-proxy-services nil) (message \u0026quot;代理已关闭.\u0026quot;))) Org 中文行内格式 ;; 设置org-mode中文格式，包括行内格式，折行问题 ;; 由于Emacs懒加载的特性，下面的代码需要加入hook才能运行 ;; 注意必须是 `add-hook' 而不能是 `add-hook!' (add-hook 'org-mode-hook (lambda () (setcar (nthcdr 0 org-emphasis-regexp-components) \u0026quot;-[:multibyte:][:space:]('\\\u0026quot;{\u0026quot;) (setcar (nthcdr 1 org-emphasis-regexp-components) \u0026quot;-[:multibyte:][:space:].,:!?;'\\\u0026quot;)}\\\\[\u0026quot;) (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components) (org-element-update-syntax) ;; 规定上下标必须加 {}，否则中文使用下划线时它会以为是两个连着的下标 (setq org-use-sub-superscripts \u0026quot;{}\u0026quot;) ;; 设置自动换行 (setq truncate-lines nil) ;; 针对中文折行的问题进行设置 (toggle-word-wrap nil) )) 背景透明 ;;;###autoload (defun leesin/toggle-transparency() (interactive) (let ((alpha (frame-parameter nil 'alpha))) (set-frame-parameter nil 'alpha (if (eql (cond ((numberp alpha) alpha) ((numberp (cdr alpha)) (cdr alpha)) ((numberp (cadr alpha)) (cadr alpha))) 100 ) '(90 . 90) '(100 . 100) )))) ","permalink":"https://endlesspeak.github.io/docs/build/editorconfiguration/2-vanilla-emacs-configuration/","tags":[],"title":"Vanilla Emacs"},{"authors":[],"categories":[],"content":"GNU Compile Collection Linux 平台上使用的编译器是 GCC(GNU Compile Collection) 编译器。\n当提到 GCC 时，通常指的是 GNU 编译器套件，它支持多种高级语言（实验性的），提供较好支持的语言包括：\nC/C++ Fortran Ada Objective-C/C++ D Rust GCC 为这些语言提供了良好的链接支持，同时提供了相对应的编译工具，它们都属于 GCC 的一部分。\n当提到 gcc 时，专指的是 gcc 编译器，它的编译选项可以归纳为以下几类：\n总体选项\n-c\t对源文件进行编译或汇编 -E\t对源文件进行预处理 -S\t对源文件进行编译 -o\t输出目标文件 -v\t显示编译阶段命令 语言选项\n-ansi\t支持符合ANSI标准的C语言程序 -x\t用户可以输出希望gcc处理的语言 对 GCC 的 -x 功能说明：\n可以用该功能调用 GCC 针对不同语言的编译前端处理不同的代码，支持 c/c++/assembly 等三种语言 -x c++ 可以处理 C++代码，但是有以下内容需要注意： gcc 默认不会链接 C++的标准库，需要 -lstdc++ 才能正常编译 gcc 不会自动定义 __cplusplus 宏，需要手动添加 -D__cplusplus 参数 警告选项\n-W\t屏蔽所有的警告信息 -Wall\t显示所有类型的警告信息 -Werror\t出现警告信息就停止编译（将警告视作错误） 调试选项\n-g\t产生调试信息 优化选项\n-O0\t不进行任何优化 -O1\t对目标文件的性能进行优化 -O2\t提高目标文件的运行性能 -O3\t支持函数集成优化 链接选项\n-Wl,\u0026lt;option\u0026gt;\t将该选项跳过并传递该选项给链接器 -l\u0026lt;library\u0026gt;\t链接指定的库文件 -L \u0026lt;dir\u0026gt;\t指定链接器的额外搜索路径 -static\t指定使用静态链接 -shared\t生成共享文件（动态库） -fuse-ld 指定使用哪个链接器 目录选项\n-I \u0026lt;dir\u0026gt;\t指定头文件的搜索目录 -L \u0026lt;dir\u0026gt;\t指定链接器的额外搜索路径 配置选项 待补充。\nPreprocessing 处理宏定义和 include ，去除所有的注释。 不会对语法错误进行检查。\n如果需要知道 #inlcude \u0026lt;...\u0026gt; 的搜素路径，可以在预处理时加上 -v 选项，显示搜索列表的详情。\n特别地，如果仅执行 gcc -v ，则得到的是 gcc 的版本。\ngcc -E a.c -o a.i gcc -E a.c -o a.i -v Compilation Native Compilation 狭义上编译指的是生成汇编代码，并在此阶段检查语法错误。 不会对逻辑错误进行检查。\ngcc -S a.i -o a.s 广义上编译指一直到生成 可重定位 的目标代码。\nCross Compilation 交叉编译是在一个平台上生成另一个平台上的可执行代码。用来编译这种程序的编译器叫交叉编译器。交叉编译器的名字一般都有前缀，如 arm-none-eabi-gcc 。\n交叉编译的使用方法跟本地编译相似，但有一点特殊的是：必须用 -L 和 -I 参数指定编译器用 arm 系统的库和头文件，不能用本地(X86)的库。或者也可以在 makefile 中使用 -include 指定头文件位置。\nAssembly 使用 -C 参数生成可重定位的目标代码。\ngcc -c a.s -o a.o 可重定位的目标代码不能直接执行，可使用 file 命令查看：\nfile a.o a.o: ELF 64-bit LSB relocatable 考虑下面的两个 C++ 源代码文件： A.cpp：\n#include \u0026lt;iostream\u0026gt; #include \u0026quot;B.h\u0026quot; int main(){ int a = 100; swap(\u0026amp;a, \u0026amp;shared); std::cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;std::endl; std::cout\u0026lt;\u0026lt;shared\u0026lt;\u0026lt;std::endl; } B.h:\nextern int shared; void swap(int * a, int * b); B.cpp：\n#include \u0026quot;B.h\u0026quot; int shared = 1; void swap(int* a, int* b){ int tmp = *a; *a = *b; *b = tmp; } 编译上面两个程序的命令是：\ng++ -c B.cpp -o B.o g++ -c A.cpp -o A.o Linking 将各个可重定位的目标代码与启动代码组合起来。\ngcc a.o -o a 例如，将上面两个程序的目标代码组合并运行：\ng++ A.o B.o -o a1 链接分为静态链接和动态链接两种，默认为动态链接，不必指明链接方式，可以添加需要链接的库文件参数；静态链接则均需显式说明。\n需要注意的是，无论是静态链接还是动态链接，链接的目标都是 库文件 而不是 目标文件 。\nDynamic Linking Concept 动态链接是运行时链接，把调用所需要的动态库(或称为共享库)的模块和在库中的*位置信息*链接进目标程序，程序运⾏的时候寻找相应的库文件，并从中执行相应的代码，因此需要被链接的动态库文件的支持 。\ngcc 和 g++ 都是默认使用动态链接的。因此不需要考虑额外的命令。\nGenerate 生成动态库的方法如下：\n准备好源文件和其对应的头文件，源文件可以有多个，头文件数量可以和源文件数量不同，也可以和编译出的库文件数量不同；\n使用下面的命令编译动态库：\ng++ B.cpp -shared -fPIC -o libB.so 需要注意：\n-shared 表明编译的是共享库 -fPIC 表明指定生成位置无关代码 特别地，此处绝对不能使用 -c 选项，否则编译结果将为可重定向的目标文件，而非共享库 使用下面的命令链接：\ng++ A.cpp -L . -lB -o A 由于默认动态库的链接路径为 /usr/lib ，因此从当前路径链接需要修改生成的二进制文件，可以修改 LD_LIBRARY_PATH 或者使用 patchelf\npatchelf --add-rpath . A 使用 ldd 来检查二进制程序依赖的动态库。\nldd ./a1 Advantage 对同一个函数的调用只会在内存中产生一份拷贝，无论是多个相同的程序还是不同的程序； 这是因为动态库使用相对地址，所有依赖的进程都可从同一入口进入； 更新方便，只需要对库文件进行更新，而不需要更新依赖库文件的程序； 动态库可以再包含其他的动态或静态库。 Disadvantage 链接推迟到了程序运行时，执行程序会有性能损失。\nStatic Linking Concept 静态链接是编译时链接，把源文件中用到的静态库（归档文件）直接放进目标程序，程序运行的时候不再需要其它的库文件。\nGenerate 生成静态库的方法如下：\n编译代码为目标文件\ng++ -c B.cpp -o B.o 将目标文件生成静态库(归档文件)\nr 将文件插入到静态库中，如果文件已经存在于库中，则替换原有的文件 c 创建一个静态库，如果库文件不存在，则创建一个新的库文件 s 为静态库中的成员文件创建符号表，这对于链接时解析符号非常重要 ar rcs libB.a B.o 使用 -static 参数显式指定使用静态链接的方式。\ng++ -static A.o -L . -lB -o a2 静态链接下，所有依赖的库均已与该程序一起合并成了一个二进制文件，因此无法查看依赖的库。\nAdvantage 直接执行程序而不需要链接，没有性能损失。\nDisadvantage 对同一个函数的调用会在内存中产生多份拷贝，即使是相同的程序的多个运行实例（即进程）也会如此； 这是因为不同的进程有各自的地址空间，入口不同，程序不知道如何共享； 库文件需要更新时，依赖它的所有程序都需要重新编译，否则只能使用原来的版本； 静态库不能再 包含其他静态库和动态库 。 因为静态库是编译好的归档文件，不能与其他库链接。除非重新用归档工具将多个静态库的源文件链接成一个新的静态库。 Loading 运行生成的可执行文件。\n./a 可执行的目标代码可以直接执行，可使用 file 命令查看：\nfile a a: ELF 64-bit LSB executable 如需检查返回值，使用命令 echo $? ，它将显示上次程序执行完后的返回值。\nOptimization 编译的过程并非每一步命令都是必须的，可以跳过一些步骤，编译器会自动处理。\nPre/Compile/Assembly 从源文件快速生成目标文件的命令：\ngcc -c a.c -o a.o Rapid Generation 从源文件快速生成可执行文件的命令：\ngcc a.c -o a ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/1-2-program-compilation-by-gcc/","tags":[],"title":"Program Compilation by GCC"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"基本概念 软件概念 软件：软件=程序+数据+文档\n程序:按事先设计的功能和性能需求执行的指令序列； 数据:是程序能正常操纵信息的数据结构； 文档:与程序开发、维护和使用有关的图文材料； 软件的特征：\n软件不是制造的，而是设计开发或工程化的； 软件的开发时间和工作量难以估计； 软件会多次修改，测试困难； 软件可能随着运行的时间增加而效率变低或问题变多； 软件生产是简单的拷贝； 软件开发环境对产品影响巨大； 软件功能划分：\n系统软件:服务于其他程序的程序。(操作系统、编译器) 应用软件:解决特定需要的独立应用程序。(管理系统、浏览器) 支撑软件:支持需求分析、设计、实现、测试和支持管理的软件。(如中间件、数据库) 工程/科学软件:带数值计算的特征。 嵌入式软件。 产品线软件:为不同用户使用提供特定功能。 web 应用软件。 人工智能软件:利用非数值计算解决复杂问题。 软件危机 软件危机：在计算机软件的开发、运行和维护过程中所遇到的一系列严重问题。 (效率和质量问题)\n软件危机的原因：\n客观上，即软件本身特点：逻辑部件、规模庞大。 主观上，即不正确的开发方法：忽视需求分析，忽视设计，忽视合作，忽视软件维护。 消除软件危机的途径：\n正确的认识 软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。 推广使用在实践中总结出来的开发软件的成功技术。 软件工程 软件工程的定义：\n将系统的、规范的、可度量的方法应用于软件开发、运行和维护过程，即将工程应用到软件。 对上述中各种方法的研究。 软件工程的目标：\n在给定的时间和预算内，按照用户的需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件。\n软件工程三要素：方法、工具、过程\n方法：软件工程方法是构建软件工程的解决方法，软件工程方法分两类：结构化方法和面向对象方法。 工具：为软件工程的过程和方法提供自动化或半自动化的工具支持。 过程：过程贯穿软件开发的各个环节,在各环节之间建立里程碑； 软件工程的发展过程：\n传统软件工程→对象工程→过程工程→构件工程\n过程模型 软件生命周期 定义：一个软件产品或软件系统从定义、开发、投入使用到被淘汰的全过程；\n三阶段：定义、开发、维护；\n八步骤：问题的定义、可行性研究、需求分析、概要设计、详细设计、编码实现、测试、维护；\n软件过程 定义：软件生产过程中的一系列活动、动作、任务的集合，这些活动贯穿于软件开发的整个过程。\n软件过程也称为软件生存周期过程，是指软件生存周期中的一系列相关过程。为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。\n能力成熟度模型 成熟度模型标准(CMM)如下：\n初始级:工作无序,缺乏健全的管理制度。 可重复级:管理制度化,建立了基本的管理制度和规程,初步实现标准化。 已定义级:过程标准化,工作和管理工作,均已实现标准化、文档化。 量化管理级:产品和过程已建立了定量的质量目标。开发活动中的生产率和质量是可量度的。 优化级:持续的过程改进,拥有防止出现缺陷、识别薄弱环节以及加以改进的手段。 需求分析 系统设计 质量保证 回归测试 回归测试的概念\n在软件测试的各个阶段，在修正发现的软件缺陷或增加新功能时，变化的部分必须进行再测试。此外,对软件进行修改还可能会导致引入新的软件缺陷以及其他问题。为解决这些问题，需要进行回归测试。 回归测试是指有选择地重新测试系统或其组件，以验证对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求。 回归测试可以在所有的测试级别执行，并应用于功能和非功能测试中。 回归测试应该尽量采用自动化测试。 回归测试的范围\n缺陷再测试：重新运行所有发现故障的测试，而新的软件版本已经修正了这些故障。 功能改变的测试：测试所有修改或修正过的程序部分。 新功能测试：测试所有新集成的程序。 完全回归测试：测试整个系统。 软件维护 项目管理 ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/softwareengineering/","tags":[],"title":"软件工程"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"原理 简要描述一下决策树的原理\n决策树解决二分类问题时，每一次决策都选择一种最佳属性进行划分，最终得到结果。 为了得到最佳划分，就需要在每次划分中获得更多的信息，引入信息熵（信息的混乱程度）来刻画划分过程中获得的信息量大小； 信息熵根据信息整体的随机变量进行定义，度量的是整体信息的混乱程度，因此当需要对某种属性进行划分时就需要条件熵； 根据在数据集整体上分类的不确定性（经验熵）减去在数据集上根据属性A分类的不确定性（条件熵）称为信息增益。信息增益越大，分类能力就越强。 使用信息增益，分类器会倾向于选择每个类别更少的样本的分类方式（比如说样本编号、网络端口），为了消除这种影响，将信息增益除以原来的熵，使划分结果更加科学。每步中都计算每个特征的信息增益比，选取信息增益比最大的特征作为最佳划分特征。 连续值离散化：连续型属性的值从小到大进行排序，计算各区间的中位点，组成候选划分点，依次计算以这些划分点划分的信息增益，当信息增益最大时选择此划分点作为该属性的最佳划分点 决策树数据处理\ndataSet=np.concatenate((x_train, y_train), axis=1) dataSet=dataSet.tolist() testSet=np.concatenate((x_test, y_test), axis=1) testSet=testSet.tolist() 实现思路 计算信息熵\n输入：数据集dataSet，特征值索引labelIndex\n输出：对应的信息熵shannonEnt；\n划分数据集\n输入：数据集dataSet，列索引axis （按哪个特征划分） ，划分特征的值value，属性离散/连续\n输出：\n若为离散属性，则返回属性值相等的样本去掉该列属性之后合并成的数据集 若为连续属性，则分别返回小于和大于该属性值的样本去掉该列属性之后合并成的数据集 计算信息增益\n输入：数据集dataSet，特征值索引labelIndex，特征值类型labelPropertyi（离散/连续）\n算法：\n计算根节点的信息熵（作为原信息熵）\n获得特征值列表（使用set函数去除重复值，注意去除后数据类型为元组）\n对离散的特征：\n对每个特征值，都尝试划分数据集，计算其信息熵\n对连续的特征：\n用list函数将元组转为列表；\n用sort函数对特征值排序；\n特别地，如果只有一个值，就视作是只有左子集而无右子集，对其进行划分并计算信息熵；\n对每两个相邻的值计算平均值，以此作为划分点计算划分后的数据集的信息熵，按样本个数加权相加，取其中距离零点的信息熵（因为信息熵算的是负数因此这里取最小的）；\n输出：信息增益gain\n计算信息增益比率\n输入：数据集dataSet，特征值索引labelIndex，特征值类型labelPropertyi（离散/连续）\n算法：\n类似计算信息增益；\n信息增益除以经验熵得到信息增益比率；\n记录最佳划分点；\n输出：信息增益比率gainRatio，最佳划分点bestPartVaulei\n选择最佳划分方式\n输入：数据集，特征值类型离散/连续\n算法：\n对每个特征循环：\n调用计算信息增益比率函数求解出信息增益比率；同时信息增益比率函数调用信息增益函数求解各信息增益；\n求出平均信息增益，取信息增益大于平均增益及信息增益比率最大的划分点\n输出：最佳划分属性的索引和划分值\n返回出现次数最多的类别（多数表决）\n使用字典存储各个类别，统计它们出现的次数:\nclassCount = {} for i in range(len(classList)): if classList[i] not in classCount.keys(): classCount[classList[i]] = 0 classCount[classList[i]] += 1 按值对字典排序。\nsortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1), reverse=True) 返回最多的类别和数量\nreturn(sortedClassCount[0][0], sortedClassCount[0][1]) 递归创建决策树\n输入：数据集dataSet，特征labels，特征属性离散/连续\n算法：\n首先得到所有的类别向量（特征向量）；\n如果只有一个类别，返回类别和数量； 如果所有的特征都被遍历完了（每次划分的特征会被移除到数据集外），则返回最多的类别和数量； 如果无法通过划分选出最优的特征，返回出现次数最多的类别； 使用字典构建决策树：\n根节点为最佳划分点，划分点内容判断的是值是否小于特征； 左子树为对小于最佳划分点创建决策树； 右子树为对大于最佳划分点创建决策树； 最后返回根节点；\n输出：决策树\n决策树节点测试\n输入：决策树某节点，标签classList，特征labels，特征属性labelProperties，测试样本testVec\n算法：\n获得当前节点和其子树，每个结点都是一个条件判断语句，小于号左边是划分特征，小于号右边是值；\n使用dict.keys()方法得到当前节点的划分，类型为dict，使用list()[0]将该划分转为字符串； 使用str().find('\u0026lt;')方法找到小于号所在的位置，作为索引lessIndex； 使用str()[:lessIndex]得到根据哪个特征划分； 使用list.index()方法找到该特征划分的索引值； 通过取字典的该特征键值对，获得子树； 进入子树：\n使用dict.keys()得到子树的键，Y或者N； 条件值为str()[lessIndex+1:]； 判断下一级子树类型是不是字典： 是字典则分支不是叶子结点，将Y或者N的子树作为节点，递归； 不是字典则分支是叶子节点，返回标签； 输出：标签\n注释：程序中是返回标签字典，取字典中非0值的键作为标签；\n决策树测试\n输入：决策树根节点，标签classList，测试集dataTest，特征labels，特征属性labelProperties离散/连续\n算法：遍历测试集，对每个测试集样本调用决策树节点测试，返回标签（见8的注释）与测试集的标签比对，不符合则错误个数增加；\n输出：错误个数；\n求分类正确率\n输入：错误个数，总样本个数\n输出：正确率\n","permalink":"https://endlesspeak.github.io/docs/docs/machinelearning-doc/traddional-machine-learning/2-decisiontree/","tags":[],"title":"决策树问题"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"基本情况 自我介绍 Tell me a few things about yourself.\nDear professors, it\u0026rsquo;s a great honor for me to have the opportunity to present myself. My name is Li Qing han,22 years old, come from Hu Bei province. I received my bachelor\u0026rsquo;s degree in software engineering from Chang\u0026rsquo;an University in last June.\nIn the past 4 years,I focused on my study. I passed CET-4 and CET-6 in my sophomore and junior years respectively and got good grades in some software engineering subjects. In the need of my major,I participated in the course design and internship based on group cooperation as much as possible and served as the deputy leader in three of them. These development activities are most belongs to Java Web,such as Java Server Page, Java Bean,Mybatis and Spring. The technologies we use are constantly developing while our technical level is progressively improving. In addition, the experience of participating in these cooperation enhanced my ability of overall division of labor and interpersonal communication.\nIn my mind,I think my English comprehensive ability meet the postgraduate\u0026rsquo;s requirement. For example, I installed Arch Linux on my computer hard drive independently followed by the instruction manuals written in English. In the process of my graduation project,I tried to read the English paper such as least square version support vector machine,for which I read to broaden my view.\nMy graduation project is the concrete realization of three traditional machine learning algorithms, including decision tree, support vector machine and feed forward neural network. The more I learn,the more I find postgraduate is necessary. I dreamed one day I can have the chance to make a little contribution in academic research.\nThat’s all my self introduction,thank you.\n针对提问 Please introduce your internship or course design.\nThe content of the internship I participated in is to build an online furniture mall. Unlike Taobao, jd.com and other online shopping malls, my practice project simplifies the role,which means the seller and the system administrator is the same role and own the whole system. Buyers can register, log in, browse goods, add goods to the shopping cart, settle and generate orders; The system administrator can manage orders, deliver goods for orders, and manage the user information of each buyer.\nYou mentioned Java Web, please tell me Java Server Page, Mybatis and Springboot concepts and what are they used for.\nSure. JSP stands for Java Server Page, it is a dynamic web page technology standard developed by Sun Company. JSP can deal with problems together with other Java programs on the server. It use JDBC (java database connectivity) to access the database.\nMybatis is a persistence layer framework that supports customized SQL and advanced mapping.It makes create,read,update and delete more easier.\nThe Spring framework is an open source container framework that integrates various types of tools and frameworks and provides comprehensive functionality, services, and management.\nWhat is the installation process for Arch Linux?\nThe installation process of Arch Linux boils down to two steps: preparation and installation.\nPreparation includes prepare the installation media, check the Live environment, check the boot mode and network connection, select mirror service, and mount disks. Installation includes downloading the basic system packages, change root, and configure the system. What\u0026rsquo;s your understanding about machine learning? Machine learning is a multidisciplinary discipline, involving probability theory, statistics, approximation theory, convex analysis, algorithm and complexity theory,linear algebra and other disciplines.\nMachine learning using experience to improve performance.\nIt specializes in the study of how computers simulate or realize human learning behavior to acquire new knowledge or skills and reorganize the existing knowledge structure to continuously improve its own performance.\nCould you describe the machine learning algorithms used in your graduation project briefly?\nSure. My graduation project is to solve the classification problem, using decision tree, support vector machine and feed forward neural network.\nDecision tree select optimal attribute by information gain ratio to divide in every decision and obtain the final result.\nSupport Vector Machine partition a classified hyperplane in high dimensional space. It can also be considered to be developed from the idea of structural risk minimization, in which its loss function is the hinge loss function.\nThe least square support vector machine takes all samples as support vectors and transforms inequality constraints into equality constraints to simplify calculation of Lagrange multipliers.\nIts weighted version addresses the issue of sensitivity to outliers and reduces the error.\nThe feed forward neural network corrects the weight of each layer by calculating the error between the output value and the actual value.\n报考相关 动机与选择 Why do you want to go to graduate school instead of finding a job?\nLife is precious, it is necessary to catch any opportunity for self-development, especially in the competitive modern society. I think further my education will be a good choice for self-development.\nThe knowledge of science and technology are no limit. Therefore, my thirst for knowledge should never cease but grow as I dig deeper into this field.\nComputer science and technology is a broad and profound science, in which I hope to improve my cognitive ability, self-learning ability, independent thinking ability and critical thinking ability, broaden my vision and scope, and learn more knowledge.\nSo I think it\u0026rsquo;s necessary for me to further my study instead of going to work after graduation.\nWhy do you choose computer science and technology instead of software engineering as your major?\nI thought software engineering as a program development paradigm,while computer science and technology is a broad and profound science.\nSince I have learned how to learn a skill, now is the time for me to learn how to learn a science. I wish I could achieve systematic knowledge acquisition in this way.\nWhy do you choose to study at our school / institute?\nIt has always been my dream to further my education at your renowned university.\nI was initially attracted by your university\u0026rsquo;s high reputation. I have a classmate who have studied at your university,after consulting with him,I was even more impressed by the university\u0026rsquo;s strong academic atmosphere and the professors\u0026rsquo; sense of responsibility. All of which strengthened my determination to try my best to start my studies at here.\nWhat\u0026rsquo;s your impression of UESTC?\nFormerly known as Chengdu Institute of Telecommunications Engineering formed in 1956,University of Electronic Science and Technology of China is one of the key university. It is the forefront of modern socialist universities both at home and abroad in the coordinated development of science and technology.\nWith electronic information science and technology as the core and engineering as the major, the university is a multi-disciplinary and research-oriented national key university.\n计划与打算 Do you have any plans to study abroad?\nI\u0026rsquo;ve read about it before. Studying abroad has certain requirements on academic performance and professional quality. If there is a chance, I will have a try.\nHow do you feel about choosing a mentor?Which kind of professors do you like best?\nI have known about various research teams in advance, and I am very interested in these unknown fields. However, I don\u0026rsquo;t have any special ideas in choosing a tutor. Each professors has his or her own unique academic methods and characteristics. What I should do is to improve myself as much as possible and try to get the right tutor to choose me,adjust my own situation to adapt to him.\nMaybe those who are knowledgeable and own the sense of responsibility and have strong scientific research and innovation ability would be my favorite.\nAre you considering reading a PhD?\nI would be very grateful if I can meet my ability and have the opportunity to study for a PhD. I hope that through three years of study and accumulation as a postgraduate, I can master various abilities required by academic research, study in the field I am interested in, and go further and longer on the academic road.\nHow do the people around you think of computer science and technology/software engineering?\nThey usually can\u0026rsquo;t distinguish the difference between computer science and technology and software engineering, but they all think that computer major has a good combination in many positions in today\u0026rsquo;s society, and people engaged in computer work are usually regarded as high-quality compound talents.\n个人问题 What\u0026rsquo;s your greatest advantage and what\u0026rsquo;s the worst weakness?\nMy strongest asset I think is my ability to focused on things until they all get done,never give up easily. When I meet a hard nut to crack, a great sense of responsibility pushed me to forge ahead; while the job is over,an incomparable sense of accomplishment combined with fulfillment fountained in my heart.\nThe strive for high quality sometimes leads to an defective ends in efficiency. In addition,being focused on work inevitably leads to certain social drawbacks and less time to deal with life matters, that might be my greatest weakness I think.\nOf course sometimes I will suspend some difficult problems for advancing the overall development of the software. Write them down and discuss them with others will be a good choice.\nTaking unnecessary pains to study these problems that may be beyond my personal competence may won\u0026rsquo;t have the desired results.\nHave you attended any training institutions or similar programs before?\nI once consulted the postgraduate entrance examination training agency for knowing some information about the postgraduate entrance examination there, and compare it with the information I collected by myself.\nI think it is not cost-effective and unreasonable to spend money on postgraduate training. The purpose of the postgraduate examination is to cultivate our ability of self-learning,information inquiring,interpersonal communication, and most importantly,believing in ourselves.\nIf you failed this time what will you do in the near future?\nFailure doesn\u0026rsquo;t matter. I would conclude the weakness I had during the period and summary what I have learned. Maybe I will apply for other college or choose to find a job. Whatever I choose, I will never stop striving to do my best.\nXXX\n未来规划 What do you expect to achieve during your study if you are enrolled into this institute?\nOR: What is your plan in the postgraduate study?\nIf I have the honor to get the chance to learn at here,I will concentrate on the study and research in the selected field. First,I will work hard to learn the theoretical knowledge, constructing a solid foundation for my further study. Second,I would like to strengthen my language ability, for example,learn C \u0026amp; C plus plus and python in the hard way,especially the STL. Third, I plan to do some practical work with the help of my supervisor. Through this,I can get skills which cannot be acquired from the textbooks or corporation. I hope that in the next three years, I can improve my capacity of self-learning and independent thinking, and have valuable academic outputs.\nWhat are your future goals? Will you continue studying or find a job?\nLearning is to master a certain ability that they can contribute to the state, society, family and live a more comfortable life, if I can find a suitable job when I graduate and meet the requirements, I will choose to make contribution in practical application. Else,continuing to study will be better for me.\nXXX\n本科学习 Please introduce your university.\nI studied in Chang \u0026lsquo;an University as an undergraduate, which is located in Xi \u0026lsquo;an, the ancient capital of the six dynasties.\nThe campus is rectangular, which means \u0026ldquo;grew up in Chang \u0026lsquo;an University\u0026rdquo;.\nThe library, called Shaw Building, is the tallest building on campus and is located in the rectangular center.\nThe northeast of the library is the dormitory, while the northwest is the car test ground, the southwest is the teaching building, and to the southeast is the laboratory.\nThe school extends along weishui, and the teaching building is built according to the lake. I appreciate the scenery of the campus very much. Learning in such an environment make me feel relaxed and happy.\nTell me something about your graduation thesis. (See Self Introduction Related Questions)\nSure. My graduation project is to solve the classification problem, using decision tree, support vector machine and feed forward neural network.\nDecision tree select optimal attribute to divide in every decision and obtain the final result.\nSupport Vector Machine partition a classified hyperplane in high dimensional space.\nThe least square support vector machine follows structural risk minimization and can simplify calculation.\nIts weighted version addresses the issue of sensitivity to outliers and reduces the error.\nThe feed forward neural network corrects the weight of each layer by calculating the error between the output value and the actual value.\nWhich course do you like best?\nMy favorite course is data structure,because the teacher\u0026rsquo;s class was very interesting, which stimulated my interest in programming,and helped me learn a lot of practical vocational skills. In addition,the data structure is important in future professional development. Therefore, I studied really hard in this course.\nWhat impressed you most during your college years?\nIt was one day when I was still working on my undergraduate graduation project,I was a new bud of Python at that time. The prototype had already been realized , but when it comes to the specific data set, the compiler always reported errors. In order to solve the problem,I worked on it from 8 a.m. to 6 p.m. without eating or drinking. I was very hungry and it was raining hard outside, but the anger and dissatisfaction in the deep side of my heart push me forge ahead. Until I solved lots of basic mistakes, and watched it from reading data step by step to finally getting the final results, an incomparable satisfaction and accomplishment fountained in my heart. I guess that moment impressed me most.\nTell me something about your major.\nMy undergraduate major is software engineering. I think my major provides a flexible but standardized software development paradigm. Through the combination of scientific demand analysis, outline design and detailed design, the needs of customers and the realization of software can be more standard and scientific, and the scalability and maintainability of software will also be improved.\nPlease tell me about your study details in your college.\nWhat qualifications have you obtained? 证书\nWhat have you learned from your internship experience? 实习\nWhat have you learned from your research experience/competition experience?\nSorry but I did not participate in any scientific research or competition activities during my undergraduate study actually. I tried ACM team selection when I was a freshman, but I didn\u0026rsquo;t pay enough attention to it and didn\u0026rsquo;t prepare enough at that time, so I failed. I hope I can obtain more abundant scientific research experience in the postgraduate stage.\nWhat do you think have been the most important change in your study field over the past 5 years?\n其他问题 Tell me something about your family.\nThere are three members in my family,my parents and me. Generally speaking,My family is warm and harmonious.\nMy father is a intermediate engineer in the elevator industry. He\u0026rsquo;s been helping me with my study for as long as I can remember. He usually told me attitude decides achievement. Every sunny weekend he will go fishing. According to him, fishing can not only train patience but make people feel ease and comfortable.\nMy mother is a factory product inspector. No matter in work or life, she is always meticulous. Caution is the only way to avoid making mistakes. Under her influence, I always double-check my important work.\nTell me something about your hometown.\nMy hometown is Suizhou, located in the north of Hubei Province. The world-famous chime bells were unearthed here. It is also the birthplace of Yan Emperor Shen Nong, the ancestor of The Chinese empire. What\u0026rsquo;s more, Suizhou is rich in producing special propose vehicles. It is called special propose vehicles\u0026rsquo; mother land.\n专业问题 What\u0026rsquo;s the difference of C and Java?\nC is procedural oriented, while Java is object oriented. C is a compiled language, and Java is a kind of hybrid language of compilation and interpretation. In addition, the application of C and Java are different.\nPlease state your understanding of Object-oriented programming.\nObject-oriented programming is mainly composed of four concepts: abstraction, inheritance, encapsulation and polymorphism.\nModels are meant to characterize things in the real world. Abstract is a way to describe the specific characteristics of things and the law of change.\nInheritance make it possible to share methods and member variables between parent and child classes.\nEncapsulate the function to reuse code and perform specific functions.\nPolymorphism refers to the fact that methods of the same name in a parent class can have different implementations.\nPlease talk about TCP/IP.\nTCP/IP is a protocol cluster that can transfer information between different networks. It contains FTP、SMTP、TCP、UDP、IP and other protocols. It is divided into application layer, transmission layer, Internet layer and network interface layer. The main protocols of the application layer are HTTP,FTP,DNS. Transmission layer have UDP and TCP protocols. Internet layer use IP,ICMP,IGMP protocols,network interface layer applys ARP protocol for communication.\nWhat\u0026rsquo;s the difference between TCP and UDP, and what\u0026rsquo;s the full name of UDP?\nTCP is a connection-oriented protocol while UDP is a connectionless protocol. A TCP connection can be established only after packet exchanges for three times and disconnect before four additional packet exchanges. UDP transmits information without establish conncetion. TCP is reliable but UDP does not guarantee reliable delivery. TCP uses stream mode and UDP uses datagram mode. TCP guarantees data order, UDP does not.\nThe full name of TCP/UDP is Transmission Control Protocol/User data Protocol.\nWith the deepening understanding of machine learning, I have developed a strong interest in this field. They will gradually play an increasingly important role with the development of science and technology, I hope one day I have the chance to make a contribution in it.\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/englishinterview/","tags":[],"title":"英语面试"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"​ 襄州，地处平原中部，夏季凉爽宜人，冬季略有寒意，山峦稀少略有起伏，河流宽阔少见湍急，温润时不显潮湿，干爽时不见燥闷，非常适合居住。闻名江湖的真武道宗便坐落于襄州岘山，其建筑蜿蜒连绵山脉十余里，气派无比，恢弘非常。\n真武是道家正统玄门，其开派祖师张梦白出自书香门第，心怀大志，欲以胸中笔墨报效国家。然而他参加乡试却屡试不中，蹉跎数载光阴，万念皆空。无巧不巧，归途偶遇道人扶摇子，拜之为师，受其教导，改弦更张，以文入武。扶摇子离别襄州四处云游，张梦白闭关参道家真谛，卒有所得，觅得襄州极北岘山，开宗立派。后更岘山名为真武山。真武山地势极高，更兼苍松峻岭，层峦叠嶂，云雾缭绕。弟子们在此观景悟道，以云海为引，凭内功运转，吸灵气精华，悟天地奥秘，印证武学，成就斐然，闻名于江湖之中。\n如今值六月下旬，对地处长江中下游的襄州来说，正是梅雨时节，淫雨霏霏。淅淅沥沥的小雨连绵已有十数天，偏偏今日却是朗日晴空，万里无云，极目远眺，天空湛蓝纯净，悠远通透，令人心旷神怡。“久在樊笼里，复得返自然”，真武弟子们觅得如此好天气，从殿中鱼贯而出，来到太极道场之中，沐浴阳光，吐纳清气。\n熙攘的人群中有一人与常人相异，只见他：昂藏七尺，衣带紧束，道袍整洁，一尘不染，头饰规整，双目有神，可谓“湛湛涵渌，清澜澄浚”，精神气蕴均沉稳而内敛，直如真武武训：重剑无锋；其乃真武派中潇湘子座下弟子，又被称为第三代弟子，唤作张慎峰。\n纵观太极道场，便会发现分布在太极道场上的其他真武弟子与张慎峰的不同之处：举凡真武弟子，身后均背负着一副巨大的剑匣，里面收着一长一短两柄阴阳子母双剑，遇敌时左手取短剑，右手取长剑，阴虚阳实，滴水不漏。而张慎峰的打扮则是左手持拂尘，乍看过去，竟有几番仙风道骨意味，然而若是一阵大风吹过，灰袍在下部飘起，拂尘遮满前胸，长头发散在项后，便会上中下同时迎风飘舞，令人忍俊不禁。\n“师尊。”张慎峰轻功掠步，走到无人的僻静之处，朝身前一名负手睥睨峰下云海的六旬老者躬身行礼。\n老者背对着他，望着涯外无垠的云海，感叹道：“梅雨时节竟有如此晴朗的天气，真是难得。”顿了一顿，回过头来，清癯的脸上露出了微笑，道：“慎峰，你可知道我今日为何唤你前来？”\n“弟子不知。”张慎峰恭谨地说道，站立有如木桩一般，纹丝不动，眼中满是尊敬和虔诚。\n张慎峰的这位师尊，道号潇湘子，是真武祖师爷张梦白当年的故交，随张梦白一起悟道，论及武行修为，他确实逊色张梦白一筹；然而他潇洒写意，随性洒脱的为人处事之道则远胜张梦白。既入真武，俗名已忘，烦恼落尽，尘事远离，潇湘子专心以武证道，武学进境一日千里。十年前，八荒论剑切磋，潇湘子使一手阴阳双剑，阴虚阳实，以柔克刚，连败神威、五毒、太白、丐帮四个江湖大派掌门，从此，潇湘子之名闻于四海，留下了一段传奇佳话。\n不过，真正令张慎峰对师尊恭谨有加的并不是其武功修为如何高深莫测，而是另有缘由。\n两年前，张慎峰拜入真武门墙，本以为能从此开始修习武道，谁料想被安排在杂役院中作扫院道士，安排每日打扫林间山道，房屋殿堂，与练武可以说是毫无交集。张慎峰甚至一度以为，此生已于练武无缘，后适逢潇湘子出游归来，轻功回山。及至隐仙道，轻功去势已尽，恰好落在张慎峰面前，而后便一眼相中了他，收其为记名弟子，传授武学，教授修为，此恩深重，几同再造，在这位“伯乐”师尊面前，张慎峰怎能不心虔志诚，恭默守静？\n老者转身，望向涯边无垠的云海，悠悠道：“莫语常言道知足，万事至终总是空。理想现实一线隔，心无旁骛脚踏实。谁无暴风劲雨时，守得云开见月明。花开复见却飘零，残憾莫使今生留。此际梅雨之间的晴朗，正是‘守得云开见月明’。”\n“沙落蚌中，蚌沉于海底低吟悲号，经年累月才磨合出温润莹泽的珍珠；云覆月辉，待到风轻云淡之时，皎皎皓月才有一番“别时圆”的意味；指抚琴弦，血痕斑斑，天长日久方可奏出动人乐韵。这其中的道理，你懂得么？”\n张慎峰连忙答道：“弟子知道，唯有坚持不懈，持之以恒，方能证得真武法身，寻得天道。”\n“天道？”老者闻言放声大笑，张慎峰更加恭敬，沉心静意不敢插言，待老者笑声渐弱，才低声问道：“师尊，弟子之言是否有不妥之处？”\n“然也。”潇湘子点头，而后右手掐指，肃然说道，“我辈修行中人，皆认为该属逆天而行，其实天道乃天地运行的奥秘，岂人力所能及？静心思虑，也不过是所得寥寥，何敢妄言逆天而行？又何敢放言寻求天道！只有时时刻刻将天地放在心中，时刻敬畏天地，谨记道法自然，才可能可以有所进益；你之所言，正如初生牛犊，血气方刚，争强好胜，此乃大忌，以后切不可重蹈覆辙。”\n张慎峰冷汗涔涔，一揖及地，肃然答道：“弟子领师尊教诲。”\n“嗯。”老者清癯的脸上露出些许笑意，点头道，“今日唤你前来，其一，是要让你明白，百折不挠、坚韧不拔，宝剑锋从磨砺出，梅花香自苦寒来，修行即是修心，修心途中，必须时刻谨守道心，保持灵台清净。心持清净大道生，此乃上善。至于其二，则是为师近日拟出了你日后的修行方向，希望你自今日起能够按照我之所言进行参悟。”\n“修行方向？”张慎峰疑惑道。\n“不错，自你从杂役道士入武道院，为师一直不让你习练太极三清剑，而是以拂尘代之，这其中其实大有道理。你可能不知，拂尘乃道场法器，演练风格独特，技法鲜明、软硬兼施，开合紧凑；舞动起来如天马行空，洒脱飘逸，闪展腾挪，灵活多变。以拂尘练武，才能最好的感受形与意合，意与气合，气与神合的融合之精妙，而切实领悟融合的精妙，方能为日后修行《八荒诀》打下坚实的基础。”\n“《八荒诀》？”\n“正是《八荒诀》。《八荒诀》乃当世独一无二的奇门心法，融合当今武林之精髓，集道家五门、佛门三宗、持兵八荒以及江湖百家的武功精要于一部心法口诀之中，更兼有江湖中绝世神功浩然正气、仙授长生剑、真武七截经等的影子。”\n“《八荒诀》繁多颠复，参差错落，根牙磐杂，故非心智坚韧者不能领悟，修炼此诀，多种元气在体内可能会相互冲突，故非体质坚韧者不能坚持。为师当年行走江湖，机缘巧合得此《八荒诀》，然为师那时已顿悟干戈止武之道，亟待证得法身，故并未习练此诀，而此后十年，为师广觅门徒，也未曾找到适合习练此诀的弟子。”潇湘子悠悠说道。\n“师尊的意思，难道我就是适合习练八荒诀的弟子？”张慎峰疑惑道，眉宇间却并无半分惊讶，动作神色更是一如往常，内心毫无半点波澜。\n潇湘子将他的动作一一看在眼里，对其卒然临之而不惊的反应暗暗点头，说道：“不错，当年我返回真武山时，轻功落在隐仙道上，发现你在那里扫除落叶，剪除杂草。观视之下，我发现你体内经脉之中竟有暗金流转。若是一般的武功练家子，大抵以为此乃你经年作杂役粗活而练出的类似少林之中的金钟罩之类的外门功夫，而以我看来，却远非如此。”\n“经脉之中苍劲暗流，而脸上却有淡淡紫意，分明是紫霞功筑基之兆，然而此功在江湖之中早已失传，即使是当年紫霞功仍有记载之时，也是特供华山派掌门修行之用，而你当时不过是入门一年有余的杂役道士，绝不可能接触此等上乘功法，从这一点上来说，你其实可谓是骨骼清奇，天赋异禀了。”\n“多谢师尊夸奖，但弟子还是不明白，难道有那个所谓的紫霞功作为内功心法，就能修炼《八荒诀》？”\n“旁人或许不行，但你却一定可以。”潇湘子斩钉截铁地说，“紫霞功当年乃华山派镇山之宝，是华山派修炼的快速功法，为长生不老之仙术，亦为道家技击之无上玄功，功成时“罡气”贯注全身，穿经过穴，周天行走，可闭穴，移穴。全身可做到不畏刀枪；一切尖锐之物击打，皆如触败絮，隔物传功，反震可抛敌十数丈，炸碎脏腑，并可开碎裂石，打散服气。关键在于，紫霞功极难练成，即使天赋出众，功法小成也需十年光景，而你呢，如今不过十七八岁，便已以紫霞功筑基，此等进境，非天才不可谓也！”\n“师尊，传言是否有误？毕竟，您刚才说功成时能不畏刀枪，可前几天晚上我还不小心被烛剪划破了口子，也许……师尊您是看错了。”张慎峰出言道。\n其实，潇湘子之言几乎无错，而张慎峰此番出言也是事出有因。\n自张慎峰来到真武山，行事一直十分谨慎。刚刚入门两个月有余时，他在打扫山道时，不慎跌落山崖，然而却因祸得福，不仅未受外伤，反而在隐仙道的山崖下发现了隐藏在残砖碎瓦下的隐秘洞穴。洞穴不深，废弃已久，居中一个蒲团儿，上面放着一本泛黄的破旧书籍。及至他回到杂役院后，拿起书细细观视，发现竟是一部强身健体的内功功法。虽然功法并不出众，但在没有武学可习练的情况下，张慎峰视其为至宝。自此，张慎峰便每日打扫完之后按照功法加以修行，直至今日，算起来已有一年又四个月。\n以张慎峰看来，那本功法若是放在江湖中，也不过就是一本普通之极的内功功法，绝无可能是什么华山至宝《紫霞功》。故而他出言相询，以免是潇湘子看错，误把生铁作碧玉。独自一人，多年涤荡，他之心性早已坚韧无比，并不为外物所累。所谓奇珍异宝，人杰地灵，在他看来，皆是浮云；得之他幸，不得他命；不以物喜，亦不以己悲。\n“被烛剪划破口子？”潇湘子闻言大笑，旋即以手作剑，挥出一道凌厉地剑气，直冲张慎峰而来，此招乍放看似平和无波，实则浑厚如山似岳，乃真武一派成名绝学之一：和光同尘。“挫其锐，解其纷，和其光，同其尘，是谓玄同。”\n两人之间本来就只有一丈之遥，张慎峰见师尊猛然成招，立刻拳掌相出，随劲风而动，摆出太极之中的单鞭之势。\n此招名为观水，又名上善，“上善若水，水善利万物而不争，此太极雏形也。”剑气击打在张慎峰的观水之势上，一阵氤氲波动，未能建功。\n潇湘子左手掐诀，口中念念，旋即身后一道与他自身完全一样的影子逐渐凝实，而后闪烁到张慎峰身上，横劈竖砍十八般招式尽出，正是和光同尘的驱影逐形追打技，驱使黑影对目标发动多段打击，且打击一次比一次沉重。\n张慎峰眉心发胀，精神力倾泻而出，以太极守势卸去打击力道，只见黑影在张慎峰左右上下四处打击，却只有一圈又一圈的波纹震荡，而张慎峰本人毫发无伤。影子的九次击打终于去势已尽，消散在空中，而张慎峰运观水之势也恰至尽头，收招而立。\n潇湘子看着站立如初的张慎峰，满意地说：“你看我这剑气比之你那烛剪又如何？可能伤你半分？”见张慎峰凝思不答，笑道：“你名字之中这个慎字起的好，只是，太慎了。哈哈哈……”\n说罢，潇湘子拔身而起，顷刻便消失不见，惟一本极厚的陈旧古籍从潇湘子原先站立之处飘然而落。\n“师尊？”张慎峰见潇湘子飞身离去，本能地喊了一句；而后急忙站定，朝着潇湘子离去的方向连拜三拜，这才珍而重之地将落到地上的古籍收好，转身离去。\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch1/","tags":[],"title":"第一章 紫霞"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"数据结构基本概念 基本概念 数据是信息的载体，表现为能被计算机识别和处理的符号集合。 数据元素是数据的基本单位，用来描述个体。 数据项是构成数据元素的不可分割的最小单位。数据项可理解成个体的各项属性。 数据对象是相同性质数据元素的集合，即个体的集合。数据对象是数据的一个子集。 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 例如，要开发班级教务系统，则一个班级中的每个学生信息（个体）都是一个数据元素，每个学生信息包括学生的姓名、年龄等各种属性，这些属性是数据项。表示该班级的所有学生信息的集合即为数据对象。把这些数据对象组织起来并表示它们之间的关系，再加上相关的操作，即为数据结构。可以用一张表组织起来，或者用图表示，或者用树表示，等等。\n综上所述，还能得到以下几点：\n相同的数据元素，通过描述数据元素间不同的关系，可以组成不同的数据结构； 不同的数据元素，通过描述数据元素间相同的关系，可以组成相同的数据结构。 数据结构三要素 数据的逻辑结构\n逻辑结构表示数据间的逻辑关系。包括：\n集合 同属一个集合 线性结构 一对一 树形结构 一对多 图状结构 多对多 数据的物理结构（存储结构）\n是数据结构在计算机中的表示。既要存储数据元素，又要存储它们之间的关系。\n物理结构会影响存储空间分配的方便程度以及数据运算的速度。\n物理结构包括：\n顺序存储\n连续存储，逻辑上相邻，物理上也相邻。\n非顺序存储\n链式存储 索引存储，建立索引表 散列存储，又称哈希存储 数据的运算\n运算的定义是针对逻辑结构的 运算的实现是针对物理结构的 数据类型 数据类型是高级编程语言概念，是一个值的集合和定义在此集合上的一组操作的总称，如整型变量，实型变量，数组，结构体等。每个数据都属于某种数据类型。\n抽象是抽取出实际问题的本质，抽象数据类型是由用户定义，表示具体的应用问题的模型，以及相应的操作的总称。\n原子类型\n如年龄，值不可再分；\n结构类型\n如设置学生结构体，分为姓名、年龄等等；\n抽象数据类型\n三元组（数据对象、数据关系、基本操作集）\n特别地，抽象数据类型构成了一个完整的数据结构。\n算法及评价 基本概念 算法是对特定问题求解步骤的一种描述，是指令的有限序列。\n算法的重要特性（必要条件）：\n有穷性 确定性 可行性 输入 0个以上 输出 1个以上 ”好“的算法的目标：\n正确性 可读性 健壮性 高效率与低存储量需求 算法度量 时间复杂度 加法公式： $$\rT(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(x),g(x)))\r$$ 乘法公式： $$\rT(n)=T_1(n)\\times T_2(n)=O(f(n))\\times O(g(n))=O(f(x)\\times g(x))\r$$ 渐进时间复杂度：\n从左至右依次为常数阶、对数阶、线性阶、线性对数阶、K次方阶、指数阶。 $$\rO(1)","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/datastructure-summary/","tags":[],"title":"数据结构基本概念"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"操作系统概念 操作系统 操作系统是：\n计算机系统资源的管理者，组织、调度、分配软硬件资源； 作为用户与计算机硬件之间的接口，向上层（用户）提供服务； 最接近硬件的软件，即计算机系统中最基本的系统软件。 扩展：系统软件和应用软件\n系统软件：OS、数据库管理系统、语言处理程序、服务性程序、标准库程序；\n应用软件：用户编写的程序、驱动程序、辅助设计软件、实时控制软件\n操作系统特征 操作系统基本特征包括并发、共享、虚拟、异步。最基本特征是并发和共享，两者互为存在条件。\n并发\n并发是同一时间间隔发生。如单核CPU。\n并行是同一时刻发生。如多核CPU。\n操作系统的并发性通过分时得以实现，需要中断的支持。\n共享\n互斥共享方式，如打印机，磁带。该共享方式称为互斥式共享，其所需的资源在一段时间内只允许一个进程访问，称之为临界资源或独占资源。 同时访问方式，如磁盘设备，通常是宏观上的同时访问，微观上分时访问，称分时共享。 虚拟\n一个物理上的实体变为若干逻辑上的对应物。虚拟通过并发性实现。 时分复用技术：将一个物理上的CPU虚拟为多个逻辑上的CPU，称虚拟处理器； 空分复用技术：从逻辑上扩充存储器的容量，称之为虚拟存储器。 异步\n多个并发执行的程序以不可预知的速度向前推进，称之为进程的异步性。 需要保证运行环境相同时产生的结果也相同。 操作系统的目的与功能 计算机角度来说，操作系统是计算机系统资源的管理者\n处理器管理、存储管理、文件管理、设备管理\n用户角度来说，操作系统是用户与计算机硬件系统之间的接口\n命令接口，直接给用户使用的接口，包括\n联机命令接口，或交互式命令接口，用于分时或实时系统。\n例如终端。\n脱机命令接口，或批处理命令接口，用于批处理系统。\n类似可执行脚本。\n程序接口，由一组系统调用（广义指令）组成。用户通过系统调用来请求系统的服务。\n注：也可将接口分为直接给用户使用的接口与通过程序间接调用的接口，直接给用户使用的包括命令接口和GUI图形接口，通过程序间接调用的是程序接口；与此同时GUI图形接口也会调用程序接口。\n操作系统用作扩充机器\n仅包括硬件的计算机称逻辑，经过操作系统扩充后方可使用。覆盖了软件的机器称之为扩充机器或虚拟机。\n操作系统的发展与分类 手工操作阶段 用户独占全机，资源利用率低； 人机速度矛盾，CPU等待手工操作，CPU利用不充分。 批处理阶段 在此阶段操作系统开始出现。 为解决下列矛盾而产生： 人机速度矛盾 CPU、IO设备速度不匹配的矛盾 主要缺点：缺乏交互性。 单道批处理系统 优点：解决了人机速度矛盾；\n缺点：未解决CPU与IO设备之间的矛盾。\n特点：自动性、顺序性、单道性。\n多道批处理系统 优点：解决了人机速度矛盾、CPU与IO设备之间的矛盾；资源利用率高。\n缺点：用户响应的时间长，不能提供人机交互功能。\n特点：多道、宏观上并行、微观上串行。\n分时操作系统 分时是将处理机的时间分成很短的时间片，轮流上处理机运行。\n优点：解决了人机交互的问题（用户的请求可以被及时响应）。\n缺点：不能处理紧急任务（未区分各任 务之间的优先级）。\n实时操作系统 优点：在严格时限内作出处理，利于完成紧急任务。\n特点：及时性和可靠性。\n注意：对于实时操作系统，资源利用率不是需要重点考虑的因素。\n分类：\n硬实时操作系统\n飞行控制系统、导弹发射系统\n软实时操作系统\n股票交易系统、铁路订票/铁路信号系统、银行管理系统、门禁系统\n非实时操作系统\n干扰项：计算机辅助设计（CAD）系统、办公自动化系统等\n其他操作系统 网络操作系统\n实现网络中资源共享和计算机间的通信。\n分布时计算机系统\n特点：分布性、并行性。与网络操作系统的本质不同是：分布式操作系统中的若干计算机相互协同完成同一任务。（所有计算机地位相当）\n个人计算机操作系统\n操作系统的运行环境 运行机制 CPU执行两种程序，一种是操作系统内核程序，另一种是（系统外层的）应用程序。\n特权指令=广义指令；\n管态=内核态，运行内核程序；\n目态=用户态，运行应用程序；\n内核态→用户态：执行特权指令修改PSW（程序状态字寄存器）；\n用户态→内核态：由中断（外中断）引发，或由异常（内中断）引发，硬件自动变态；\n时钟管理\n置时钟指令是特权指令，读时钟指令是非特权指令。\n中断机制\n中断是操作系统必须提供的功能；并发、多道需要中断的支持。\n原语\n运行具有原子性，不可中断。\n中断与异常 定义 广义来说，操作系统内核夺回CPU使用权的唯一途径是中断。\n狭义来说，中断分为外中断和内中断，其中外中断称作中断，内中断称作异常。\n中断具体是内还是外，取决于中断信号的来源，来自CPU内部称内中断，来自CPU外部称外中断。\n中断与异常是从用户态到内核态的途径。\n通常异常会引起中断，但中断不一定是由异常引起的。\n分类 内中断/异常\n异常不能被屏蔽，一旦出现必须立即处理。\n自愿中断、陷入、陷阱——指令中断（如访管指令，它不是特权指令）\n强迫中断\n硬件故障\n由错误条件引起，可能被内核程序修复，修复后内核会将CPU使用权还给应用程序。例如缺页故障。\n软件终止\n致命错误引起，不可被修复。应用程序执行结束。如整数除以0，非法使用特权指令等。\n外中断/中断\n时钟中断 IO中断请求 中断实现原理 硬件完成部分（中断隐指令）\n关中断\n保存断点\n主要是将断点：程序计数器PC 保存\n引出中断服务程序\n操作系统完成部分（内核态，进入中断服务程序）\n保存现场和屏蔽字\n保存程序状态字寄存器PSW和通用寄存器的内容。\n特别地，子程序调用不需要保存。\n开中断\n执行中断服务程序\nCPU根据中断类型查询中断向量表，根据类型使用中断处理程序处理中断。\n关中断\n恢复现场和屏蔽字\n开中断\n中断返回\n系统调用 系统调用是操作系统向上层（编程语言或用户）提供的一系列操作的接口。\n请求系统调用（用户态）→执行系统调用（内核态）→返回（用户态）。\n这样做的目的是：用户不能直接执行对系统影响非常大的操作，保证了系统的稳定性和安全性。\n表：各种指令的区别。\n指令名称 指令类别 定义角度 详细释义 特权指令 特权指令 指令系统 用于管理硬件和系统安全的指令。仅能在管态（核心态）执行，目态下执行该种指令，CPU会自动中断并切换至管态。 访管指令或陷入指令或Trap指令 非特权指令 指令系统 应用程序自愿进管的指令，目的是请求系统的服务。执行后进入管态，同时也意味着程序放弃CPU的控制权。访管指令后可以接系统调用。一般是需要执行特权指令时使用。 广义指令或系统调用 不定 操作系统 应用程序通过系统调用来请求获得操作系统内核的服务，系统调用是一段代码。特别地，特权指令是系统调用的真子集，执行系统调用并不一定非得执行特权指令，亦有可能有非特权指令。但执行系统调用必须在内核态下。 表：系统调用与库函数的区别\n名称 详细释义 库函数 库函数可以理解为是编程语言向上层对某些请求服务的一种封装，使编程更加方便快捷。库函数中有可能包含零个（如取绝对值），一个或多个系统调用（如创建文件）。它运行在用户态，需要时可以请求系统调用从而转到内核态，结束后返回用户态。 系统调用 操作系统向上层（编程语言或用户）提供的一系列操作的接口，应用程序通过系统调用来请求获得操作系统内核的服务。执行系统调用必须在内核态下。 操作系统的体系结构 大/单/宏内核 优点：高性能 缺点：庞大，结构混乱，难以维护 典例：Linux，Unix 微内核 优点：可靠，清晰 缺点：性能低下（因需要频繁切换用户态和内核态） 典例：Windows NT ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/operating-system/operating-system-summary/","tags":[],"title":"绪论"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"创建项目 用create-next-app快速创建项目。create-next-app是Next.js的脚手架工具，用于直接建立项目目录和基本结构。首次使用create-next-app,需要进行全局安装，安装命令如下。\n$ npm install -g create-next-app 注1：Arch Linux滚动发行版中使用npm更新自身会与官方软件源更新npm产生冲突，因此避免使用npm更新自身，或者更新命令改为：\n$ pamac update 上述方法也不能避免产生的文件冲突，pamac会自动将冲突文件备份为bak。\n注2：npm全局安装的组件位置为/usr/lib/node_modules/，为当前用户安装的目录为./node_modules\n接下来创建一个项目总目录，博客项目分为三个大模块，所以需要一个顶层目录。 创建完成后，再进入目录。 安装完成后，进入你要建立项目的位置，使用npx来进行安装。\n$ npx create-next-app blog npx可以调用项目内安装的模块而不需要切入到项目的node_modules目录下；同时也可以在避免全局安装模块的情况下运行它。当然本例中仍然全局安装了create-next-app。\n输入后按回车，就会自动给我们进行安装项目需要的依赖，Next相关的命令也会添加好。完成后可以使用yarn dev来测试一下。在浏览器中输入http://localhost:3000/，网页顺利渲染说明项目创建成功。\n博客首页 首页初始化 用create-next-app建立好后，主页是默认的，删除默认的文件并把首页index.js改成下面的代码。\nimport React from 'react' import Head from 'next/head' const Home = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Home\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;div/\u0026gt; ) export default Home Next.js现已支持CSS文件，不需要额外增加@zeit/next-css包。\n按需加载 Ant Design 接下来用yarn来安装antd，输入：\n$ yarn add antd 然后再安装一下babel-plugin-import，命令如下：\n$ yarn add babel-plugin-import 安装完成后，在项目根目录建立.babelrc文件，然后写入如下配置文件。\n{ \u0026quot;presets\u0026quot;:[\u0026quot;next/babel\u0026quot;], //Next.js的总配置文件，相当于继承了它本身的所有配置 \u0026quot;plugins\u0026quot;:[ //增加新的插件，这个插件就是让antd可以按需引入，包括CSS [ \u0026quot;import\u0026quot;, { \u0026quot;libraryName\u0026quot;:\u0026quot;antd\u0026quot; } ] ] } 在pages目录下，重写_app.js文件，然后全局引入CSS 。\nimport App from 'next/app' import 'antd/dist/antd.css' export default App 这样Ant Design就可以按需引入了。现在index.js加入一个按钮，看看是否可以正常使用,代码如下。 如果能正常使用，我们的基本环境就已经建立完成了。\nimport React from 'react' import Head from 'next/head' import {Button} from 'antd' const Home = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Head\u0026gt; \u0026lt;title\u0026gt;Home\u0026lt;/title\u0026gt; \u0026lt;/Head\u0026gt; \u0026lt;div\u0026gt;\u0026lt;Button\u0026gt;我是按钮\u0026lt;/Button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div/\u0026gt; ) export default Home 组件1:博客头部 Ant Design的24格栅格化系统\n编写公用的头部遇到的第一个问题是如何让界面适配各种屏幕，直接使用Ant Design的轮子来制作。\nAnt Design做好了栅格化系统，可以适配多种屏幕，简单理解成把页面的分成均等的24列，然后进行布局。\n需要对适配几个属性熟悉一下：\nxs: \u0026lt;576px响应式栅格。 sm：≥576px响应式栅格. md: ≥768px响应式栅格. lg: ≥992px响应式栅格. xl: ≥1200px响应式栅格. xxl: ≥1600px响应式栅格. ","permalink":"https://endlesspeak.github.io/docs/docs/develop-doc/blog-react-springboot/react-develop-1/","tags":[],"title":"Hello React"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"通过输入man man进入man命令的帮助手册。\nUnix的联机帮助分为很多章节，如表所示：\n章节 内容 1 可执行程序或 shell 命令 2 系统调用(内核提供的函数) 3 库调用(程序库中的函数) 4 特殊文件(通常位于 /dev) 5 文件格式和规范(如配置文件) 6 游戏 7 杂项(包括宏包和规范，如 man(7)，groff(7)) 8 系统管理命令(通常只针对 root 用户) 9 内核例程 联机帮助的规范如表所示：\n文本形式 意义 加粗文本 按原样显示。 倾斜文本 用相应的参数进行替换。 [-abc] “[ ]” 内的任意/全部参数都是可选的。 -a|-b 以“|”分隔的选项可以一起使用。 参数 \u0026hellip; 参数 可以重复。 [ 表达式 ] \u0026hellip; “[ ]”内的整个 表达式 可以重复。 联机帮助的部分参数如表所示：\n参数 意义 -d 打印调试信息 -f 等同于whatis，显示来自手册页的简短说明 -w 显示手册页的具体位置 -k 搜索关键词对应的手册页概述并显示所有的匹配结果 -a 强制显示名字匹配搜索条件的所有手册页 -H[浏览器] 生成HTML页面并在浏览器中输出结果 下面是关于帮助的命令示例：\nman ls\n显示 项目 (程序) ls 对应的手册页。\nman man.7\n显示章节 7 中宏包 man 对应的手册页。（这是“man 7 man”的另一种拼写方法。）\nman \u0026lsquo;man(7)\u0026rsquo;\n显示章节 7 中宏包 man 对应的手册页。（这是“man 7 man”的另一种拼写方法。该方法在复制和粘贴手册页的交叉引用时可能更方便。请注意，括号在通常情况下必须被引号括起以避免 shell 转义。）\nman -a intro 正确执行时显示手册中包含的所有可用的 intro 手册页。可以在连续显示过程中退出或跳过任一页。\nman -k printf\n将关键词 printf 作为正则表达式来搜索对应的手册页概述和手册页名称，并打印所有匹配结果。等效于 apropos printf.\nman -f smail\n查找 smail 引用的手册页并输出找到的所有概述。等效于 whatis smail.\n","permalink":"https://endlesspeak.github.io/docs/docs/develop-doc/linux-utils-program/1-man/","tags":[],"title":"使用Man命令"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"如果是经常从事文本工作(如软件工作者进行代码编辑、学生进行笔记整理、文字工作者的撰写、校对等工作)的用户建议选用窗口管理器作为日常工作环境。\n独立的窗口管理器可以和KDE、Gnome等桌面环境搭配使用，一来可以起到工作环境转换的适应作用；二来集成化的桌面环境可以应对各种不时之需。所以我将之放在本篇介绍；当然，熟练地使用窗口管理器，原则上可以不借助其他任何桌面环境就能完成所需的各种工作。\nShell 查看系统当前使用的shell。\n$ echo $SHELL /bin/bash 查看系统是否安装了zsh (有些发行版可能自带zsh，而fish一般不会自带)\n$ cat /etc/shells #列出当前可用的终端 /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin /bin/tcsh /bin/csh /bin/zsh 安装功能强大、智能友好的终端命令解析器Fish Shell和Z Shell的具体内容见下。\nFish Shell 安装Fish Shell $ sudo pacman -S fish $ which fish #查看fish Shell的安装位置 $ chsh -l #列出当前可用的终端(另一种命令方式) $ chsh -s /usr/bin/fish #为当前用户切换终端 安装Oh-my-fish $ git clone https://github.com/oh-my-fish/oh-my-fish $ cd oh-my-fish $ bin/install --offline $ fish_config #Colors:Dracula Prompt:Terlar 完成后点选set theme和set prompt #最后回车得到fish和oh-my-fish 配置Oh-my-fish $ omf install wttr #安装fish shell下的天气显示插件 $ alias c clear #定义快捷命令 $ funcsave c #记录快捷命令到配置文件 $ alias l \u0026quot;ls -la\u0026quot; $ funcsave l **注意！**如果不小心定义了错误的快捷命令，可能会导致严重的后果。最典型的例子就是定义循环的命令，例如输入alias A B 和alias B A(A和B分别代表一条命令)，然后再输入A或者B，那么计算机可能会输出大量function错误，也可能直接崩溃宕机关闭。\n如果已经定义了错误的命令，如alias fuck ls,有以下两种修复办法：\n在~/.config/fish/functions中查找之前定义的别名的文件，本例中文件名为fuck.fish，删除之即可。 再定义一次命令，将fuck转义回原来的语义。输入alias fuck fuck即可。 Z Shell 安装Z shell $ sudo pacman -S zsh 安装Oh-my-zsh #方法一，通过curl下载安装 $ sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; #方法二，通过wget下载安装 $ sh -c \u0026quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 由于诸位都懂的原因， 使用curl和wget从github上下载的安装方式通常可能报错port 443拒绝访问。这个时候就需要使用 工具云托管平台 码云托管平台了。\n在码云极速下载这个镜像账号中找到oh-my-zsh的仓库，链接如下：https://gitee.com/mirrors/oh-my-zsh\n方法一：更改脚本中的克隆位置，运行脚本：\n在tools文件夹中复制install.sh的全部内容到Linux下的任一编辑器。GVIM、NeoVim和Emacs等终端下编辑器需要使用Ctrl+Shift+C/V或\u0026quot;+p粘贴。其他如Kate，Gedit，VScode等则不用改变键位。\n修改该文件的Default settings部分：\n- # Default settings - ZSH=${ZSH:-~/.oh-my-zsh} - REPO=${REPO:-mirrors/oh-my-zsh} - REMOTE=${REMOTE:-https://gitee.com/${REPO}.git} - BRANCH=${BRANCH:-master} + # Default settings + ZSH=${ZSH:-~/.oh-my-zsh} + REPO=${REPO:-mirrors/oh-my-zsh} + REMOTE=${REMOTE:-https://gitee.com/${REPO}.git} + BRANCH=${BRANCH:-master} 然后在终端中运行命令：\n$ cd /path/to/install.sh #注意先切换到文件存放位置 $ ./install.sh #再运行安装脚本，即可从码云镜像站下载oh-my-zsh的源代码。 方法二：先克隆整个项目到~/.config/oh-my-zsh。克隆命令如下：\ngit clone -c core.eol=lf -c core.autocrlf=false \\ -c fsck.zeroPaddedFilemode=ignore \\ -c fetch.fsck.zeroPaddedFilemode=ignore \\ -c receive.fsck.zeroPaddedFilemode=ignore \\ --depth=1 --branch \u0026quot;master\u0026quot; https://gitee.com/mirrors/oh-my-zsh ~/.oh-my-zsh 然后对仓库中的install.sh脚本进行修改：删去main函数中调用setup_ohmyzsh函数的行。\n$ cd /path/to/install.sh #注意先切换到文件存放位置 $ ./install.sh #再运行安装脚本，即可从码云镜像站下载oh-my-zsh的源代码。 配置Oh-my-zsh 修改Oh-my-zsh的主题 $ vim ~/.zshrc ZSH_THEME=\u0026quot;robbyrussel\u0026quot; 自动提示与命令补全 $ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins 打开 ~/.zshrc 文件，找到插件设置命令，修改为\n- plugins=(git) + plugins=(zsh-autosuggestions git) 语法高亮 $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins - plugins=( [plugins...]) + plugins=( [plugins...] zsh-syntax-highlighting) 如果语法高亮不生效，则考虑zsh-syntax-highlighting放置在插件列表的最后以解决问题。以下是官方文档说明：\nWhy must zsh-syntax-highlighting.zsh be sourced at the end of the .zshrc file?\nzsh-syntax-highlighting.zsh wraps ZLE widgets. It must be sourced after all custom widgets have been created (i.e., after all zle -Ncalls and after running compinit). Widgets created later will work, but will not update the syntax highlighting.\n使配置生效 $ source ~/.zshrc Terminal Applications 关于它们各自的配置以后会提到，这些工具都是完全自定义化的，首先应该参考它们的官方文档。\n文件管理器Ranger\n系统硬件查看器neofetch或screenfetch\n系统资源查看工具htop\n使用图形渲染的终端模拟器alacritty\n展示目录下的文件工具tree\n展示本地或远程的包的结构工具pactree\n解压缩软件zip\n将终端输出的内容重定向到剪切板工具xsel\n终端下的Todo List工具task\n终端命令代理privoxy或proxychains\n来自Suckless社区中X下的极简终端模拟器st\n$ sudo pacman -S ranger neofetch htop alacritty tree pactree zip task privoxy $ git clone https://git.suckless.org/st # 克隆源代码的仓库 $ cd st/ $ sudo make clean install # 编译安装 I3 Window Manager 安装i3wm： $ sudo pacman -S i3 #默认回车即可。由于i3-gaps和i3-wm冲突，因此最后实际安装的是i3-gaps，而这正是我所需要的。 $ sudo pacman -S alacritty $ sudo pacman -S lxappearance $ sudo pacman -S feh #安装设置壁纸的软件 lxappearance #打开外观配置 feh --bg-fill /this/path/to/your/picture 配置i3wm： 输入命令:xmodmap -pke \u0026gt; ~/.Xmodmap\n注：该命令是将键盘布局生成可阅读的文本文件并保存到家目录下。\n输入命令:vim ~/.config/i3/config，在配置文件中添加下面的内容。\nexec --no-startup-id xrandr -s 1920x1080 #可选项，修改屏幕分辨率 exec xmodmap ~/.Xmodmap #载入当前键盘布局配置文件 bindsym $mod+d exec rofi -show run bindsym $mod+d exec rofi -show window #该条与上条任选其一 new window 1pixel #窗口仅有1像素单位的边框 gaps inner 15 #窗口边框距离屏幕边缘距离15个单位 注1：\nbindsym表示使用快捷键执行；$mod表示i3下的Super键；\nexec表示执行程序；-show run指定为运行程序，-show window指定为显示打开的窗口。故有些情形下两个参数可以混用。\n注2：\n更多其他配置敬请自行探索。我本人的Dotfiles已上传到代码托管平台。\n安装窗口渲染器 我安装的是自行编译的compton,为顺利安装compton,先安装系统可能缺少的依赖，命令如下：\n$ sudo pacman -S libconfig asciidoc make #安装相关的依赖 不过现在已经出现了picom，Xcompmgr，而compton已经不再维护，有需要的完全可以通过官方库安装它们。\n$ git clone https://github.com/tryone144/compton.git $ cd /path/to/compton #切换到克隆的compton库文件夹中 $ make #可能会有一些警告，忽略 $ make docs #这是可选的，制作帮助文档，使用man compton获取。 $ make clean install #clean是可选参数，可以不加 在克隆的compton库中有一份配置文件模版，将之拷贝到用户个人的配置文件夹里，并在编译成功之后即可配置该文件：\n$ cp compton.sample.conf ~/.config/compton.conf $ vim ~/.config/compton.conf 安装自定义计算机状态栏 我使用的是polybar，如果你喜欢i3status，可以不安装polybar。\n$ sudo pacman -S cmake git python python2 pkg-config wireless_tools #安装polybar构建所需的依赖 $ yay -S polybar 下面是最重要也是最困难的部分：安装字体。\n$ yay -S tty-unifont siji-git 此处的困难是对于网络而不是技术层面上来说的，由于软件包取自AUR，速度极慢，极易失败。\n新安装的polybar需要拷贝一份配置文件，然后自行修改polybar的配置文件进行配置。\n$ cd ~/.config $ mkdir polybar $ cp /usr/share/doc/polybar/config ~/.config/polybar/ #将配置文件拷贝到用户当前目录下 默认polybar的名称为example，载入polybar的命令为：\n$ polybar example 默认在i3wm中设置自动启动的办法：\n$ exec_always polybar example \u0026amp; ","permalink":"https://endlesspeak.github.io/docs/build/operating-system-configuration/linux-technology-5-2-textmode-config/","tags":[],"title":"Arch Linux 文本环境配置"},{"authors":["Serene Feather Pavilion"],"categories":["Linux Basic"],"content":"Arch Linux 是通用 x86-64 GNU/Linux 发行版，初始安装仅提供命令行环境：用户不需要删除大量不需要的软件包，而是可以从官方软件仓库成千上万的高质量软件包中进行选择，搭建自己的系统。支持x86-64架构。Arch采用滚动升级模式，尽全力提供最新的稳定版软件。\n本文拟以Arch Wiki与Installation guide为原本，附带一些自己的理解，尝试说明在物理机上安装Arch Linux。\nArch 之道，或者叫Arch哲学，一言以蔽之，Keep It Simple, Stupid.(保持简单，一目了然)\n简洁：Arch Linux 将简洁定义为：避免任何不必要的添加、修改和复杂增加。它提供的软件都来自原始开发者(上游)，仅进行和发行版(下游)相关的最小修改。\n现代：Arch尽全力保持软件处于最新的稳定版本，只要不出现系统软件包破损，都尽量用最新版本。\n实用：Arch 注重实用性，避免意识形态之争。\n以用户为中心：许多 Linux 发行版都试图变得更“用户友好”，Arch Linux 则一直是，且永远会是“以用户为中心”。Arch是为了满足贡献者的需求，而不是为了吸引尽可能多的用户。\n一般来说，安装Arch最好的也是最完备的教程就是官方的Installation guide与Arch Wiki，虽然部分内容有中文版，但是中文的翻译有些时候会落后于英文版，所以不推荐完全依赖于中文Wiki。另外， 官方Wiki的写作方式更偏向于文档，没有我们所习惯的按步骤编排的安装过程，给不熟悉这种写作方式的人们造成了阅读与使用上的困难。\n安装前准备 命令约定：无$标识符的命令代表以root身份执行；通常它们在终端中以#开头。\n准备硬盘空间 检查硬盘，需要有一块空闲的磁盘空间来进行安装，大小在30GiB以上。\n准备安装介质 安装之前需要准备安装介质，这里推荐U盘作为安装介质。对于Arch Linux来说，不能使用UltraISO (软碟通)制作U盘启动盘。因为软碟通制作启动盘使用的是ISO镜像，而Arch Linux制作启动盘需要DD镜像。\n安装镜像的官方下载地址可参阅下载页\nWindows系统下制作安装介质，推荐使用usbwrite，参阅下载页。\nLinux系统下制作安装介质，要使用dd命令制作，可参阅教程\n启动Live环境 选择U盘启动的顺序(参阅上一篇博客)，在出现Arch Linux启动界面后选择Boot Arch Linux。\n然后将会以 root 身份登录进入虚拟控制台，默认的shell是zsh。\n检查引导方式 目前的引导方式主要分为EFI引导+GPT分区表与BIOS(LEGACY)引导+MBR分区表两种。具体可参见上一篇博客中关于引导的内容。\n在终端中输入(注：命令前的**#表示目前是root用户身份，命令后的#**表示命令注释)：\nls /sys/firmware/efi/efivars 注：Arch Linux Live环境默认集成了类似bash- completion的软件包，在输入命令的时候Tab键可以对命令进行自动补全。\n方法：键入命令或文件名的前几个字符，然后按Tab键，它会自动补全命令或显示匹配你键入字符的所有命令，此时为终端提供你所需命令的更多信息并按Tab键可使得终端识别你所需要的命令。\n其他提示：\n方向键↑(或Ctrl+p) 显示上一条命令\n方向键↓(或Ctrl+n) 显示下一条命令\nCtrl+C: 终止当前正在执行的命令\n输入命令并回车执行后，如果提示：\nls: cannot access '/sys/firmware/efi/efivars': No such file or directory 表明你是以BIOS方式引导，否则为以EFI方式引导。\n当然，这种方法不能100%确认是BIOS还是EFI方式引导的，更加保险的方法是执行fdisk -l查看分区表，如果你的硬盘(将以 rom，loop 或者 airoot 结束的结果忽略掉)的Disklabel type属性为gpt并且有一个Type为EFI System的分区（一般为256M左右），那么你应该是EFI引导的。\n改变显示字体 所有的字体都安装在/usr/share/kbd/consolefonts/下，在输入到此处时按Tab查看所有可选字体，然后选择你喜欢的字体。此处选择的是LatGrkCyr-12x22.psfu.gz。\nsetfont /usr/share/kbd/consolefonts/LatGrkCyr-12x22.psfu.gz 改变键盘布局 如果键盘布局不是普通的布局，例如是colemak布局等，输入以下命令：\nloadkeys colemak 当然，一般使用的键盘都是通用105键(国际)，不必更改。\n连接网络环境 Arch Linux并不能离线安装，它需要联网来下载需要的组件，所以此时需要连接网络。\nip link #查看网络设备 对笔记本电脑来说网络设备一般有三种，名称分别应该类似于lo,wlan0,eth0。查看网络连接可以参阅Network configuration (简体中文)\nlo是本地环回； wlan0是无线网络，参阅Wireless network configuration(简体中文) eth0是有线网络，参阅Ethernet Arch Linux在网络工具上已经弃用了net-tools转而使用iproute2。其详细命令变化如下：\n已弃用命令 替换命令 arp ip neighbor ifconfig ip address,ip link netstat ss route ip route 更多更完整的总结，请参阅这篇文章。\n使用下面的命令连接有线网络并测试：\nip link dhcpcd #动态分配IP地址 ping www.baidu.com 注：Arch Linux在启动后，守护进程dhcpcd已被默认启用以探测有线设备，会自动连接有线网络，一般不需要配置。同时，由于Arch在硬件集成上对有线网卡的适配性更好，因此，如果是在物理机上安装的话，更推荐使用有线网络。\n依次使用下列命令连接无线网络并测试：\nip link ip link wlan0 up iwlist wlan0 scan | grep ESSID 注：连接wifi可以用WiFimenu，但是WiFimenu一般不支持企业网络和校园网络协议。\nwpa_passphrase 网络 密码 \u0026gt; 文件名(如internet.conf) wpa_supplicant -c internet.conf -i wlan0 \u0026amp; #注：\u0026quot;\u0026amp;\u0026quot;表示后台运行 dhcpcd #动态分配IP地址 ping www.baidu.com 出现类似64 bytes from...的内容说明成功连接网络，此时使用使用ctrl+c结束Ping命令。\n更新系统时间 使用下面的命令查看系统时间是否正常。\ntimedatectl status 使用 timedatectl命令更新系统时间以确保系统时间是准确的：\ntimedatectl set-ntp true 正常情况下这样的命令并没有输出，所谓没有消息就是最好的消息。\n建立硬盘分区 系统识别磁盘后会将其分配为一个块设备，为固态硬盘分配的ID类似于/dev/nvme0n1,为机械硬盘分配的ID类似于/dev/sda。输入：\nfdisk -l 需要忽略的内容：形如以 rom，loop 或者 airoot 结束的内容。\n需要记录的内容：形如/dev/sda，/dev/nvme0n1等等之类的分区内容，最好拍照一张留以备用。\n如果你是BIOS/MBR方式引导，跳过创建引导分区的步骤。 如果你是EFI/GPT方式引导，并且同时安装了其他系统，那么你应该可以在分区列表中发现一个较小的并且类型为EFI的分区，这是你的引导分区，请记下它的路径（/dev/sdxY)备用，跳过创建引导分区的步骤。 如果你是EFI/GPT方式引导，但是没有这个较小的并且类型为EFI的引导分区（这种情况一般只会出现在新电脑+新硬盘时），那么需要先创建一个引导分区。 分区示例：\nBIOS with MBR 挂载点 分区 分区类型 建议大小 /mnt /dev/sdX1 Linux filesystem 30GiB以上 [SWAP] /dev/sdX2 Linux swap 大于512MiB，建议4GiB UEFI with GPT 挂载点 分区 分区类型 建议大小 /mnt/boot OR /mnt/efi /dev/sdX1 EFI system partition 260MiB-512MiB /mnt /dev/sdX2 Linux x86-64 根目录 (/) 30GiB以上 [SWAP] /dev/sdX3 Linux swap 大于512MiB，建议4GiB 如果文件系统支持，此处也可以不设交换空间，而是用交换文件代替。\n能够创建分区的命令很多，如fdisk，parted，cfdisk，此处展开讲fdisk命令和带GUI的cfdisk命令。\n注：在物理机上分区时，要认真检查硬盘是否选择正确，如果有多个硬盘，可能用来安装Linux的硬盘并不是如下所写的/dev/sda，而是/dev/sdb，因此必须反复核对需要操作的硬盘的ID号。\n创建引导分区 执行命令：\nfdisk /dev/sda #如果是机械硬盘，将sda替换成之前输出的磁盘ID如sda,sdb,sdc等 fdisk /dev/nvme0n1 #如果有固态硬盘且引导在固态上，将nvme0n1替换成之前输出的固态硬盘ID 下面进入了fdisk的操作环境， 输入m并回车可以查看各命令的作用。\n如果你是一块全新的硬盘：输入g来创建一个全新的gpt分区表，否则直接进行第2步。 输入n创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，这里我们输入+512M来创建一个512M的引导分区。 这时我们可以输入p来查看新创建的分区。 输入t并选择新创建的分区序号来更改分区的类型，输入L可以查看所有支持的类型，输入1更改分区的类型为EFI。 输入w来将之前所有的操作写入磁盘生效，在这之前可以输入p来确认自己的分区表没有错误。 输入以下命令来格式化刚刚创建的引导分区： mkfs.fat -F32 /dev/sda1 #机械硬盘执行该命令并将sda替换为输出的磁盘ID如sda1等对应的分区 mkfs.fat -F32 /dev/nvme0n1p1 #固态硬盘执行该命令并将nvme0n1p1替换为刚创建的分区 格式化完成，引导分区就创建好了。\n创建根分区及交换分区 输入下面的命令：\nfdisk /dev/sdx #如果要将Linux安装在机械硬盘中则将sdx替换成你要操作的磁盘如sdb sdc等 fdisk /dev/nvme0n1 #如果要将Linux安装在固态硬盘中则将其替换为之前输出的固态硬盘ID 如果是一块全新的硬盘，则依次考虑下面的步骤（否则直接进行第2步）：\n如果在之前新建了分区表并创建了引导分区：直接进行第2步。 如果是BIOS/MBR引导方式：输入o来创建一个全新的MBR分区表。 如果在另一块硬盘中已经有引导分区(譬如在机械硬盘中安装Arch Linux，而引导分区在固态硬盘中)： 输入g来创建一个全新的gpt分区表。 输入n创建一个新的分区作为交换分区。\n要求输入分区编号，一般按默认(直接回车)，也可以指定。 要求选择起始扇区，按之前记录的磁盘数据选择计划的磁盘块起始扇区，也可以直接回车使用默认数值； 要求输入结束扇区或是分区大小，按之前记录的磁盘数据选择所计划的磁盘块大小或结束扇区；交换分区设512MiB-4GiB均可(输入格式写+4G即可)。 循上面的过程创建一个新分区作为根分区，如果我们想要使创建的分区完全占满空闲的空间，可以在要求输入结束扇区或分区大小时直接回车使用默认结束扇区。\n(可选)循上面的过程再创建Home分区及其他分区，用来挂载/home和其他挂载点。\n输入p来查看新创建的分区，如果不正确则输入d将之前的分区删除并重新操作。\n输入t分别更改交换分区和根分区的类型为Linux swap和Linux filesystem，它们对应的编号分别是19和20，依次更改它们的类型。\n检查完成后，通过输入w来将之前所有的操作写入磁盘生效。\n在终端输入以下命令来格式化并开启刚刚创建的交换分区：\nmkswap /dev/sdxY #将sdxY替换为刚创建的分区 swapon /dev/sdxY #开启交换空间 在终端输入以下命令来格式化刚刚创建的根分区： mkfs.ext4 /dev/sdxZ #将sdxZ替换为刚创建的分区 如果刚才有创建Home等分区，则还需要输入类似于格式化根分区的命令来格式化这些分区。 如果无法根据上面的步骤完成分区，也可以使用GUI界面的cfdisk命令。\n使用cfdisk后选择分区表类型，选择对应自己电脑磁盘的类型(EFI引导选GPT选项，MBR引导选DOS选项) 分区内容大体如上所述，分区大小可以用界面底端的Resize命令，分区类型用界面底端的Type命令。 分区设置完毕后，用底端的Write命令写入磁盘，然后退出cfdisk，最后使用上面提到的mkfs命令格式化分区。 选择镜像服务 该步需要进行编辑配置文件的操作，所以需要掌握命令行下非常著名的数款编辑器的基本操作。此处以Vim为例，当然也可以用nano等其他编辑器。具体学习过程参阅VIM教程，此处尽可能详细地论述整个操作过程：\n执行以下命令，用Vim编辑/etc/pacman.conf，该文件记录了Arch Linux的软件包pacman的所有配置，包括记录所有镜像源的配置文件的存储地址。 vim /etc/pacman.conf 输入/Color并回车以找到写有color的那一行，光标选中它前面的#并按Del键删除以使其从注释变为可用，而后输入:wq回车保存并退出。\n执行以下命令，用Vim编辑/etc/pacman.d/mirrorlist，该文件记录了Arch Linux在全球范围内部署的所有服务器。 vim /etc/pacman.d/mirrorlist 该引用块的内容不再可用\n按照下面的操作配置以使中国镜像源服务器地址在更新中优先使用。\n初始时保持光标在页面最顶层，是普通模式；\n输入qa回车以开启一个寄存器a，它表示你之后的操作都会记录到录制的宏中；\n输入/^\\n回车以寻找文件的第一个空行，光标从这里开始；\n输入/China回车以从光标起始点往下寻找中国镜像源，按V进入(行)可视模式，再按↓键选中这两行，按d键剪切选中的内容，输入:1回车使光标返回到最顶端，；\n输入/^\\n回车以寻找文件的第一个空行，按P将剪切的内容以向前插入的方式粘贴到此。\n输入q停止录制，现在你手动制作了一个自动寻找中国镜像源地址的宏，它存在vim的寄存器a中。\n输入7@a 即可将刚才录制的这个宏循环执行7次，将7个中国镜像源服务器地址转移到文件首。\n输入:wq保存退出该文件。\n更正：目前只会记录一部分服务器，且不会显式按地区分类，因此需要手动添加服务器。\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.cernet.edu.cn/archlinux/$repo/os/$arch 挂载磁盘分区 执行下面的命令，将根分区挂载到/mnt下：\nmount /dev/sdxY /mnt #将sdxY替换为之前创建的根分区 如果是EFI/GPT引导方式，还需执行以下命令创建/boot文件夹并将引导分区挂载到/mnt/boot下。**BIOS/MBR引导方式则无需进行这步。**如果对家目录进行了分区，还需要挂载家目录。\nmkdir /mnt/boot mount /dev/sdxY /mnt/boot #将sdxY替换为之前创建或是已经存在的引导分区 mkdir /mnt/home mount /dev/sdxZ /mnt/home 安装中的操作 安装基本包组 下面的命令将安装基本的Arch Linux包组到磁盘上。这是一个联网下载并安装的过程。\n通过pacstrap这个脚本来安装基本包组，执行以下命令：\npacstrap /mnt base base-devel linux linux-firmware linux-headers #见下面的注释 注：19年10月底Arch Linux替换了base包组，如果说原来的base包组是完善的建筑，那么现在的base包只能算是一个脚手架，所以官方文档上只安装base软件包，linux内核与linux-frmware常规硬件的固件就显得有些太过简略了一些，下面的包组请考虑按需追加：\nbase-devel(包含源码安装的支持软件)对大多数人来说都是需要追加安装的，除非明确地知道自己的需求； visudo，调整sudo权限依赖于vi或vim，所以你需要加入这两个软件包之一； nano默认也不再提供了，所以需要的话请追加这个包； 动态分配IP的dhcpcd同样需要追加。 配置挂载文件 安装完成后，需要生成自动挂载分区的fstab文件，执行以下命令：\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab 注：-U表示通过UUID记录，不加参数会通过label记录\n由于这步比较重要，所以需要输出生成的文件来检查是否正确，执行以下命令：\ncat /mnt/etc/fstab 从输出结果中应该可以看到之前格式化的磁盘分区被挂载到了根分区/下；如果是EFI/GPT引导的还应该有引导分区被挂载到/boot目录。\n如果输出的结果不正确，说明前面的操作出现了致命错误，很可能是分区错误或是挂载错误。应当立即解除挂载，然后返回前面分区步骤重新分区格式化。 解除挂载需要执行下面的命令：\n#注：仅在配置挂载文件出错时执行下面的命令并返回前面的步骤重新格式化！ umount /mnt/boot #如果是EFI/GPT引导先执行本命令 umount /mnt 更改操作位置 Chroot意为Change root，相当于把操纵权交给新安装（或已经存在）的Linux系统，执行了这步以后的操作都相当于在磁盘上新装的系统中进行。\n执行如下命令：\narch-chroot /mnt 注：如果以后系统出现了问题，只要插入U盘启动盘并启动， 将系统根分区挂载到了/mnt下（如果有efi分区则efi要挂载到/mnt/boot下），再通过这条命令就可以进入系统进行修复操作。\n设置系统时区 依次执行如下命令设置时区为亚洲上海并生成相关配置文件：\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systohc 作本地化修改 执行下面的命令以安装一些必须的软件包。Arch Linux拥有非常强大的包管理工具pacman，大部分情况下，一行命令就可以搞定包与依赖的问题。 安装包的命令格式为pacman -S 包名，pacman会自动检查这个包所需要的其他包（即为依赖）并一起安装。\npacman -S vim dialog wpa_supplicant ntfs-3g networkmanager 执行下面的命令以编辑语言配置文件：\nvim /etc/locale.gen 在文件中通过输入**/+查找关键字+回车**找到zh_CN.UTF-8 UTF-8 zh_HK.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 en_US.UTF-8 UTF-8这四行，光标选中后按Del键去掉行首的#号，输入:wq保存并退出。\n然后执行：\nlocale-gen vim /etc/locale.conf 按i键进入插入模式，输入 LANG=en_US.UTF-8，按ESC键返回普通模式，保存退出。\n更改键盘布局 如果使用的键盘不是通用105键，在arch-chroot之后需要重新配置键盘布局，先输入exit命令从已经安装的Arch环境回退到Live环境，然后执行vim /mnt/etc/vconsole.conf，输入下面的内容并保存，然后再arch-chroot进入Arch环境。\nKEYMAP=colemak #使键盘布局为colemak布局 keycode 1=Caps_Lock #可选，使大写锁定键和ESC键互换。 keycode 58=Escape 设置主机名称 打开(不存在会自动创建）/etc/hostname文件：\nvim /etc/hostname 在文件的第一行输入设定的myhostname，保存并退出。\n再编辑/etc/hosts文件：\nvim /etc/hosts 在文件末添加如下内容(将myhostname替换成设定的主机名)，保存退出\n#缩进不必对齐 127.0.0.1\tlocalhost ::1\tlocalhost 127.0.1.1\tmyhostname.localdomain\tmyhostname 设置Root密码 Root是Linux中具有最高权限帐户，很多操作必须通过Root用户进行，比如使用pacman，我们之前进行所有的操作也都是以Root用户进行的，也正是因为Root的权限过高，如果使用不当会造成安全问题，所以我们之后会新建一个普通用户来进行日常的操作。在这里我们需要为Root帐户设置一个密码：\npasswd Linux下命令均以#或$开头，这两个符号对应着命令行中的命令提示符，#代表以Root用户执行命令，$代表以普通用户执行命令。\n安装微码引导 Intel CPU使用pacman命令安装：\npacman -S intel-ucode AMD CPU使用pacman命令安装：\npacman -S amd-ucode 安装启动引导 安装最流行的Grub2。（如果曾经装过Linux，要删掉原来的Grub，否则不可能成功启动）\n首先安装os-prober和ntfs-3g这两个包，它可以配合Grub检测已经存在的系统，并自动设置启动选项。\npacman -S os-prober ntfs-3g 如果为BIOS/MBR引导方式： 安装grub包： pacman -S grub 部署grub： grub-install --target=i386-pc /dev/sdx #将sdx换成你安装的硬盘 注意这里的sdx应该为硬盘（例如/dev/sda），而不是形如/dev/sda1这样的分区。\n生成配置文件： grub-mkconfig -o /boot/grub/grub.cfg 如果你没有看到提示信息或提示出错，请仔细检查是否正确完成上面的过程。常见问题如下：\n如果报warning failed to connect to lvmetad，falling back to device scanning.错误。参照Arch wiki中搜索关键词use_lvmetad所在位置，简单的方法是编辑/etc/lvm/lvm.conf这个文件，找到use_lvmetad = 1将1修改为0，保存，重新配置grub。 如果报Warning: this GPT partition label contains no BIOS Boot Part；Warning: Embedding is not possible. GRUB can noly be install.Error: will not proceed with blocklists错误， 是因为实际是UEFI引导的系统没有正确挂载boot分区。首先检查是不是按照BIOS方式安装的系统，二是检查是否正确挂载/mnt/boot。正确配置好boot分区之后从“挂载分区”这步开始重做。 如果为EFI/GPT引导方式： 安装grub与efibootmgr两个包： pacman -S grub efibootmgr 部署grub： grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub 生成配置文件： grub-mkconfig -o /boot/grub/grub.cfg 提示信息中如果你发现错误，请仔细检查是否正确完成上面的过程，常见问题如下：\n如果报warning failed to connect to lvmetad，falling back to device scanning.错误。可参阅这篇文章，简单的方法是编辑/etc/lvm/lvm.conf这个文件，找到use_lvmetad = 1将1修改为0，保存，重新配置grub。\n如果报grub-probe: error: cannot find a GRUB drive for /dev/sdb1, check your device.map类似错误，并且sdb1这个地方是你的u盘，这是u盘uefi分区造成的错误，对我们的正常安装没有影响，可以不用理会这条错误。\n检查启动引导 建议使用如下命令检查是否成功生成各系统的入口，如果没有正常生成会出现开机没有系统入口的情况：\nvim /boot/grub/grub.cfg 检查接近末尾的menuentry部分是否有windows或其他系统名入口，检查是否符合安装的预期。\n如果没有看到Arch Linux系统入口或者该文件不存在，请先检查/boot目录是否正确部署linux内核：\ncd /bootls 查看是否有initramfs-linux-fallback.img initramfs-linux.img intel-ucode.img vmlinuz-linux这几个文件，如果都没有，说明linux内核没有被正确部署，很有可能是/boot目录没有被正确挂载导致的，确认/boot目录无误后，可以重新部署linux内核：\npacman -S linux 再重新生成配置文件，就可以找到系统入口。\n如果你已经安装os-prober包并生成配置文件后还是没有生成其他系统的入口，则可能是由于目前处于U盘安装环境下，而无法检测到其他系统的入口，可在下一步中重启登陆之后重新运行下面的命令：\ngrub-mkconfig -o /boot/grub/grub.cfg 如果还没有生成其他系统的入口，请参照Arch wiki GRUB来编辑和配置该文件并手动添加引导的分区入口。\n进入新的系统 接下来，你需要进行重启来进入已经安装好的新系统，执行如下命令：\nexit 如果挂载了/mnt/boot，先umount /mnt/boot，否则直接umount /mnt：\numount /mnt/boot umount /mntreboot 注意这个时候可能会卡在有两行提示的地方无法正常关机，长按电源键强制关机即可，没有影响。注意在重启后拔掉U盘启动盘。\n开机如果提示Arch Linux 版本号-Arch (tty1)，并且在输入root及设置的密码后出现命令提示符，则说明Arch Linux已成功安装。\n安装中的问题 安装分区警告 问题描述：分区时出现警告：逻辑分区和物理分区不对齐\n可能原因：SSD或者是HDD上原来装过Windows，则硬盘最开始的32M空间（图形界面下使用Gparted可以看到）是默认空白的。这样就会导致分区的不对齐。但其实对于SSD来说只是影响到速度，使用还是比较正常的\n解决方法：(未试验)使用shred命令彻底清洗磁盘，但耗时一般较长。\nshred -v /dev/sda 混合引导方式 事实上，Arch Linux支持三种启动方式，但启动方式分区和grub的安装略有不同。\nUEFI + GPT\n这是我采用的方式。具体对于grub的操作见上文。较新的主板推荐采用这种方式。\nBIOS + MBR\n这是较老的主板支持的分区方式，但在某些新的主板上已经不支持了。值得注意的是这种分区方式支持的硬盘是小于2T的。\nBIOS + GPT\n个人感觉这种分区方法的好处是方便后续在这块硬盘上安装别的Linux发行版并提高设备的兼容性。因为最好保证一块硬盘的分区表前后都是一致的，否则会出现兼容性的问题(这是我的猜想，有错误还请指正)。\n下面是关于第三种方法的安装和说明：\n在格式化分区时创建的分区表是GPT分区表而不能是DOS分区表。 制作文件系统时会弹出磁盘性能的警告，不需要在意。 安装系统引导步安装的包为grub和os-prober，然后依次执行： #先寻找本机已安装的操作系统 os-prober mkdir /boot/grub grub-install --force --target=i386-pc /dev/sda #生成grub配置文件 grub-mkconfig \u0026gt; /boot/grub/grub.cfg #敲入这条命令即可，使用BIOS的在grub-install时--target参数统一是i386-pc #这里也需要使用--force参数强制安装grub，因为无参数情况下的两个警告会使得grub安装失败 #这里grub安装的位置选择的直接是硬盘/dev/sdx，而不是任何一个分区,这已经强调多次了。 ","permalink":"https://endlesspeak.github.io/docs/build/operating-system-installation/linux-technology-3-2-arch-linux-installation/","tags":["Linux"],"title":"Arch Linux 物理机的安装与引导"},{"authors":["Serene Feather Pavilion"],"categories":["Linux Basic"],"content":"GNU/Linux，无论你是否相信，它已经成为目前增长最迅速的系统。无论是企业还是个人用户，Linux都是一个足够可靠的选择。我希望本系列文章能够使更多的人完全理解Linux，并热切地尝试去使用甚至探索它。\n建立Linux的概念 简而言之，Linux是一个操作系统，可以安装在包括服务器、个人电脑、PAD、手机、打印机等各类电子设备中。\n计算机系统是由硬件和系统软件所组成的，它们共同工作来运行程序。\n从物理结构上来说，计算机是由一个硬件组所组成的。\n从逻辑结构上来说，操作系统就是为了：\n​\t①更加有效的控制硬件资源，为它们进行分配和回收\n​\t②提供计算机运行所需要的功能\n​\t③提供一组系统调用接口作为程序开发使用。\nLinux是一种操作系统，它可以理解为一个软件组。软件可以分为操作系统级和应用软件级，从这个角度来说，Linux这个软件组中的所有软件均处于操作系统级。\n如果将整个计算机解剖成为硬件、内核、系统调用和应用程序四层，那么操作系统的层次如图所示：\n详细阐述Linux的起源与发展，以及与其密切相关的开放源代码许可证协议GPL，甚至追溯它的老大哥UNIX的起源与发展，我认为对于Linux操作系统的学习其实没有太大的帮助，而且这方面的内容网络上俯拾皆是，没有必要重复造轮子，除非你是历史系的学生需要选择这一板块作为毕业论文，或者你是法律系的学生需要将开源协议所涉及的问题用作案例分析。 在现阶段只需要知道：\nUNIX是一种稳定，成熟的操作系统。 GNU是GNU‘s Not Unix，由自由软件基金会发起，本意是一个名为GNU的，同UNIX兼容的操作系统， 开发这个系统的目的就是为了让所有计算机用户都可以自由地获得这个系统。任何人都可以免费 地获得这个系统的源代码，并且可以相互自由拷贝。 GNU有自己独特的公共许可证，即版权声明：GPL，其目的就是要让GNU永远是免费和公开的。 Linux由UNIX发展而来，与UNIX兼容。 Linux如今使用GPL，所以它是免费和公开的。 有关Linux、UNIX、GNU和GPL的详细内容，请自行百度。\nLinux的优缺点 Linux的特色 自由而开放的使用及学习环境\n由于Linux是基于GPL的授权之下，因此它是自由软件，也就是任何人都可以自由地使用戒者是修改其中的原始代码的意思。 这种开放性架构对科学界来说是相当重要的。因为很多的工程师由于特殊的需求，常常需要修改系统的原始代码， 使该系统可以符合自己的需求！而这个开放性的架构将可以满足不同需求的工程师，因此当然就有可能越来越流行。\n配备需求低廉\nLinux可以支持个人计算机的x86架构，系统资源不必像早先的Unix系统那般，仅适合于单一公司所出产的设备！ 单就这一点来看，就可以造成很大的流行。不过，如果你想要在Linux下执行X Window系统， 那么硬件的等级不能太低。\n核心功能强大而稳定\n由于Linux功能并不会输给一些大型的Unix工作站，因此，近年来越来越多的公司或者是团体、 个人投入这一个操作系统的开发与整合工作！例如IBM与升阳公司都有推出x86的Linux服务器。\n独立作业\n由于很多的软件套件逐渐被这套操作系统拿来使用，而很多套件软件也都在 Linux这个操作系统上面进行发展与测试，因此，Linux近来已经可以独立完成几乎所有的工作站或服务器的朋务了，例如 Web, Mail, Proxy, FTP…..\n目前Linux已经是相当成熟的一套操作系统，可以说这给微软造成了相当大的压力。此外，由于它的系统硬件要求很低，Linux在被淘汰的硬件中也可以执行的相当的顺畅、稳定，因此这也造成相当多“垃圾佬”的关注。\nLinux的优点 总体说来，Linux有以下优点：\n稳定的系统\nLinux是基于UNIX的概念而开发出的操作系统，它具有与UNIX系统相似的程序接口和操作方式，当然它也继承了UNIX稳定且有效率的特点。\n免费或少许费用\n任何人都可以免费取得Linux。早些年如果申请Ubuntu(Linux的发行版的一种)，甚至可以免费邮寄安装光盘到家中。与之相反，UNIX和微软可能需要负担庞大的版权费用，而且微软会有频繁的更新。\n安全性、漏洞的快速修补\n如果你对网络相当了解的话，你应该知道“没有绝对安全的主机”。但是Linux的社区开发模式可以随时获得最新的安全信息，相对来说更加安全。\n多任务、多用户\nLinux主机允许多人上线工作，资源的分配也比较公平，比Windows的单人多任务系统更加稳定。正是因此，Linux比Windows更加适合作为服务器使用。耗费资源更少，更为稳定，虚拟化技术、分布式计算和互联网应用等的支持性更佳。\n相对耗费资源小\n目前市面上任何一款能作为个人计算机使用的机器均可顺畅安装Linux，且耗费资源比Windows少，且少得多(前提是你正确安装了Linux及相关问题的解决方案)。\n适合需要小内核程序的嵌入式系统\nLinux的内核只有数百KB，所以它可以作为家电、小电子用品的操作系统，即嵌入式系统。顺便一提，目前手机中的Android系统正是基于Linux的开源操作系统。\n整合度高且多样的图形用户界面\n用户和用户组使得系统保密性更高\nLinux的缺点 需要命令行来管理\nLinux需要使用命令行的终端机模式进行系统的管理，Linux玩家必须接受使用命令管理计算机\n无特定的支持厂商\n自由软件使用自由开发，系统的问题只能在网上找答案或自己调试解决。\n游戏支持只有轻量\nLinux上最好不做无意义的事情，所以这里不讨论游戏。\n专业软件支持不足\n可能存在一些绘图、建模、金融方面的软件不支持Linux操作系统，(这里不得不提一句国内软件厂商鲜有支持Linux操作系统的) 但必须指出，这是商业方面的问题而不是操作系统的问题。\nLinux的发行版本 问：“如何选择适合我自己的发行版？”\n答：“你随意选择就可以了。”\n随着Linux各种支持的完善、稳定性和易用性的提升，现在各个发行版之间的差异性已经愈发的不明显了，可以随意选择。但不可否认的是，各发行版之间的差异确实依旧存在，每个发行版的用户数量、用户质量都不尽相同。\n发行版的综合介绍 概括地讲，Linux的发行版本可以大体分为两类\n商业公司维护的发行版本 社区组织维护的发行版本 前者以著名的Redhat Enterprise Linux（RHEL）为代表，后者则以Debian为代表。\n以下详细阐述各发行版的类别：\n主流分支\nDebian\nDebian分为三个版本分支 stable, testing 和 unstable。其中，Unstable为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。Testing的版本都经过Unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而Stable一般只用于服务器，上面的软件包大部分都比较过时，但是稳定和安全性都非常的高。\nDebian最具特色的是apt-get / dpkg包管理方式。Debian的资料也很丰富，有很多支持的社区，有问题求教可以在上面提问。\nDebian系的发行版包括以下几种：\nDebian\nDebian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。\nUbuntu\nUbuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。\nDeepin OS(由Knoppix发展而来)\nDeepin基于Qt/C++（用于前端）和Go（用于后端），拥有全新而独特的深度桌面环境（DDE）它旨在创造一个全新的简单、易用、美观的 Linux 发行版。\nGoogle Chrome OS\nLinux Mint\nRedHat\nRedhat应该说是在国内使用人群最多的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。\nRedhat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的于进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用，但是Fedora Core的稳定性较差，最好只用于桌面应用。\nRedHat系的发行版包括以下几种：\nCent OS(Community Enterprise Operating System)\nCentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级发行版，即RHEL的社区克隆版本。它旨在建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境。\nFedora Core\n由原来的Red hat Desktop发展而来。\nRHEL(Redhat Enterprise Linux)\n即所谓的Redhat Advance Server。注：该发行版是收费版本。\nOracle Linux\nMandriva\n是目前全球最优秀的Linux发行版之一，稳居于linux排行榜第一梯队。它是目前最易用的linux发行版，也是众多国际级linux发行版中唯一一个默认即支持中文环境的linux。\nRed Flag\n红旗Linux是中国较大、较成熟的Linux发行版之一。\nSlackware Linux\n它坚持KISS（Keep It Simple Stupid）的原则，就是说：\n没有任何配置系统的图形界面工具。一开始，配置系统会有一些困难，但是更有经验的用户会喜欢这种方式的透明性和灵活性。\nSlackware没有如RPM之类的成熟的软件包管理器。\nSlackware的软件包都是通常的tgz(tar/gzip)格式文件再加上安装脚本。Tgz对于有经验的用户来说，比RPM更为强大，并避免了RPM之类管理器的依赖性问题。\nSlackware Linux系的发行版包括：\nSUSE Linux\nSUSE”，德文”Software- und System-Entwicklung”，其英文为”Software and system development” 。广义上SUSE Linux是一系列Linux发行版。最典型的即为OpenSUSE。\nVector Linux\nVector Linux 是一份小巧快捷的、基于Intel处理器的PC机Linux操作系统。Vector Linux的创建者们有一则简单的信条：简单、小巧，并让最终用户决定他们的操作系统成为什么样子。\n新兴分支\nArch Linux\n系统主要由自由和开源软件组成，支持社区参与。系统设计以KISS原则（保持简单和愚蠢）为总体指导原则，注重代码正确、优雅和极简主义，期待用户能够愿意去理解系统的操作。\nArch Linux 系统安装、删除和更新软件的软件包管理器叫做 pacman。\n相比其他发行版，Arch Linux 属于轻量级选手，其简单的设计让它容易被轻松扩展和配置成为任何想要的系统类型。\nGentoo\nGentoo是Linux世界最年轻的发行版本，正因为年轻，所以能吸取在它之前的所有发行版本的优点，这也是Gentoo 被称为伟大、完美的Linux发行版本的原因之一。\n笔者个人对选择Linux发行版的理解 既然，本质上来说，Linux出名的就那么几种：Debian系、RedHat系、Arch Linux系、Open SUSE系。其他的发行版基本都是从这几个Linux衍生出来的(当然，也有一些可以说是独自建立的发行版比如英特尔的Clear Linux这种)，它们的唯一区别就在于包管理器的不同，那么，Llinux发行版的优先级建立只有两个因素：基于什么类别的发行版、使用体验怎么样。\n我个人针对Linux初学者的推荐如下：\nDeepin OS 优点：\n它是一个国内推出的发行版，所以相对于多数发行版来说，其本地化体验会有相当的提升。 其软件商店包含了很多国内常用的软件如QQ、微信、百度云。 其社区的中文用户量也算是比较庞大的，如果在使用中遇到问题，可以很方便的寻求答案。 缺点：\n软件版本更新比较中庸。 系统整体谈不上稳定。 社区的中文用户平均质量不高。 Ubuntu\n优点：\n可以把Ubuntu理解成Linux中的Windows：技术成熟、社区庞大，开箱即用。即使有一些软件在自带的软件商店找不到，同样可以去官方网站搜索。如果这个软件支持Linux，那么它一定会提供deb格式的安装包。\n但这个deb很大可能只能装在Ubuntu上而不能装在Ubuntu的父亲Debian上。因为Ubuntu虽然基于Debian，但它拥有自己的软件仓库，相对于Debian同样软件的版本要新。\nUbuntu拥有自己的显卡驱动方案，在英伟达和英特尔核显双显卡的笔记本上技术是比较成熟的。\n缺点：\n相当一部分Deepin上移植的国内的软件Ubuntu还没有，即使有，其安装过程也比较麻烦。 Ubuntu经常会出现恼人的“发送错误报告”窗口。 因为Ubuntu不是滚动更新，所以如果不是用长期支持版本的话，每半年就会有新的版本推送。这个更新是较为危险的，很可能会更新失败而无法使用。 Manjaro\nManjaro是基于Arch Linux的发行版，最大的特点就在于完全图形化和自动化了Arch Linux的安装过程，并且拥有一系列图形化的驱动和内核配置软件，这使得用户既可以享受到Arch Linux分支的各种优势，又可以一键设置驱动，亦能根据不同的使用条件而部署不同类型的内核，还不必花费大量时间阅读Arch Wiki来安装系统及从全文本界面逐步配置起图形界面。\n注：新兴分支Arch Linux的优势：\nArch Linux发行版的软件相比其他分支的发行版总是最新的，这得益于Arch近乎简陋的包管理工具，没有版本范围限制的Arch系总是可以毫无顾忌的把软件包更新到最新。\n但Arch Linux更新到最新同样可能出现一些意料之外的bug，所以Manjaro调慢了更新速度，一般是在Arch Linux更新的两个礼拜后Manjaro才会跟进这个版本的更新，如果这过程中出现了问题，Manjaro还会暂停版本的跟进。所以，可以说Manjaro消除了Arch Linux用户“滚挂”的顾虑。\nArch Linux特有的AUR软件仓库，使得几乎所有你能想到的软件都可以通过一条命令完成安装，而这条命令Manjaro还给图形化了。所以这相对于Ubuntu还需要去网上下载来讲简单了太多。\nPop！OS\n如果有较多的游戏需求，pop！OS这个基于Ubuntu的发行版可能个不错的选择。相对于前边三个发行版，Pop! OS开箱即配置好了游戏环境——我指的是Windows游戏。要知道，自己在Linux下配置一个完善的Windows游戏环境是很困难的。此时这个系统的优势便体现了出来：通过内置软件一键装好显卡驱动后便可直接运行。\n当然，读者最好还是按照之前已经提到的态度，那就是不用Linux做无意义的事情。\n还有一些关于渗透测试的Linux发行版需要说明：\nKali Linux\nKali 是一个基于 Debian Testing 的 Linux 发行版。该系统里包含了很多高级渗透测试和审计工具。大多数做安全测试的开源工具都被囊括在内。 这是黑客（或者自称黑客）的必备工具之一。它带有一套安全和计算机取证工具。其特色在于及时的安全更新，对ARM架构的支持，有四种流行的桌面环境供选择，以及能平滑升级到新版本。\nKali Linux 在渗透测试和白帽子方面是业界领先的。该发行版附带的大量入侵和渗透的工具和软件在全世界都得到了广泛认可，即使在那些甚至可能不知道 Linux 是什么的 Windows 用户中也是如此。\n注：\nKali Linux不适合初学者， 每一个工具必须小心使用。 Kali 的内核和软件都与Debian有异，即使它是基于Debian的。 Kali Linux不适合安装在物理机，因为容易被攻击。 Parrot Linux\nParrot Security OS 是基于 Debian Testing 的面向安全的操作系统，它被设计为用于渗透测试、计算机取证、反向工程、攻击、云计算渗透测试、隐私/匿名、密码等场合。 其特色在于MATE桌面环境。\nParrot 采用 Kali 的软件库来更新大部分工具，不过也有提供其自己的定制软件的软件库。它不只是一个简单的 Kali 修改版，而是一个建立在 Kali 工具库之上的新系统，因此，它引入了许多新功能和不同的开发选择。\n相对客观的选择Linux发行版 你可能会发现我并没有推荐RedHat系的发行版以及openSUSE。这主要是因为我很少接触这两个分支。如果想要较为客观的选择发行版，可以尝试这两种方法。\n参阅distrowatch.com\n注：该网站可能受到墙限制而无法打开。\n该网站聚合了几乎所有的类Unix发行版，并且根据点击量有一个排名列在这里。自然排名越高就说明热度越高，进而也能有一定的参考价值。但可以肯定的是，这里边肯定会有刷榜的情况出现，而且它也仅仅是展现了distrowatch用户的一个倾向，所以对你来说可能仅仅是一个参考作用。\n参阅Distro Chooser\n这是一个在线调查网站。它拥有中文页面，只需要根据自己的情况回答好16个问题，便可以给出一些适合你的Linux发行版。相对来说可以得到一个比较客观的结果，可以供你参考一下。如果你不喜欢听别人的主观意见，自己又不好决定，那么可以来这个网站来试一试。\n总体来讲，关于如何选择发行版这个问题可能仅仅对刚刚接触的人有参考价值。真正试用过一段时间Linux就应该能明白，在发行版上面纠结其实并没有什么太大的用处。得益于Linux的高度自定义性，你可以把任何一个发行版改造成你想要的样子，提前选择仅仅是为了省去改造的这个过程而已。但如果是初次接触，那么选择一个适合自己的发行版来使用，也许能体会到“一见钟情”的感觉吧。\n注：以下是2020.2.18日的更新内容。\n相信很多Linux初学者在接触Linux伊始都会和我一样折腾很多Linux的发行版，Linux的发行版千差万别。我对于任何刚接触Linux的人对Linux发行版的意见是：任何发行版都没有关系。因为它们是社会结构，一旦你获得了一定的Linux技能，理解人们在谈论发行版的任何问题都会变得非常容易。这是我对Linux发行版的一贯立场。\n但现在我不再会这样认为了。如果现在让我选择一个我心目中最好的Linux发行版，同时也是最简单的Linux发行版，作为长期甚至终身使用的Linux——答案可能会让你吃惊，我会选择的发行版是：Arch Linux！\n尽管入门可能会有难度，但它比任何其他的发行版都要好，它可以避免管理其他任何系统时所不得不忍受的痛苦。人们通常会想到入门难度，但最重要的其实是终身难度。同时，Arch Linux比其他发行版更有可能改变人们对Linux发行版的看法。\nUNIX/Linux经典哲学摘录 UNIX哲学 Everything (including hardware) is a file. 所有的事物（甚至硬件本身）都是一个的文件。\nConfiguration data stored in text. 以文本形式储存配置数据。\nSmall, single-purpose program. 程序尽量朝向小而单一的目标设计。\nAvoid captive user interfaces. 避免过于复杂花哨的界面。\nAbility to chain program together to perform complex tasks. 将几个程序连结起来，处理大而复杂的工作。\n下面三句是UNIX程序设计的准则。\nWrite programs that do one thing and do it well. 写“一次只做一件事，并能把这件事做好”的程序。\nWrite programs to work together. 写“互相协作（调用）”的程序。\nWrite programs to handle text streams, because that is a universal interface. 写“处理文件流”的程序。因为这（处理文件流）是一个通用接口。\nThe Art Of Unix Programing 哲学 Rule of Modularity: Write simple parts connected by clean interfaces. 模块化原则：写简单的，能够用清晰的接口连接的代码。\nRule of Clarity: Clarity is better than cleverness. 清晰化原则：清晰的代码要好过“聪明”的代码。\nRule of Composition: Design programs to be connected to other programs. 组件化原则：设计可以互相关联（拆分）的程序。\nRule of Separation: Separate policy from mechanism; separate interfaces from engines. 隔离原则：策略和机制分离，接口和引擎分离。\nRule of Simplicity: Design for simplicity; add complexity only where you must. 简洁原则：设计力求简洁，直到无法更简洁。\nRule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do. 小巧原则：不要写大的程序（模块、方法）。除非很明显的，没有别的办法可以完成。\nRule of Transparency: Design for visibility to make inspection and debugging easier. 透明原则：为可见性设计，使检查和调试更容易。\nRule of Robustness: Robustness is the child of transparency and simplicity. 健壮性原则：健壮性是透明和简单的孩子。\nRule of Representation: Fold knowledge into data so program logic can be stupid and robust. 陈述性原则：将认知转化为数据。所以，程序的逻辑可以是愚蠢（简单易懂）的，健壮的。\nRule of Least Surprise: In interface design, always do the least surprising thing. 最少的惊讶原则：在界面设计中，少做令人惊讶的设计。（不要标新立异）\nRule of Silence: When a program has nothing surprising to say, it should say nothing. 沉默原则：如果一个程序没有什么特别的东西要说（输出），那就什么都别说。\nRule of Repair: When you must fail, fail noisily and as soon as possible. 修复原则：如果必须失败，那就尽早。\nRule of Economy: Programmer time is expensive; conserve it in preference to machine time. 节约原则：程序员的时间是非常宝贵的。程序员的时间（编程时间）优于机器时间。\nRule of Generation: Avoid hand-hacking; write programs to write programs when you can. 生产原则：避免手工编程。如果可以的话，编写可以编写程序的代码。\nRule of Optimization: Prototype before polishing. Get it working before you optimize it. 优化原则：建立原型后再去修正。当它能正常工作后，再去优化它。\nRule of Diversity: Distrust all claims for “one true way”. 多样性原则：怀疑所有所谓的“不二法门”。\nRule of Extensibility: Design for the future, because it will be here sooner than you think. 扩展原则：为未来设计，因为未来来的比你想象的要早。\nX Window哲学 Small is beautiful. 小即是美。\nMake each program do one thing well. 让每个程序（方法）只做一件事情，并把它做好。\nBuild a prototype as soon as possible. 尽早建立原型。\nChoose portability over efficiency. 注重可移植性，而非效率。\nStore data in flat text files. 将数据存储在存文本文件中。\nUse software leverage to your advantage. 利用软件来发挥你的优势。\nUse shell scripts to increase leverage and portability. 使用Shell脚本提高编程的手段和程序的可移植性。\nAvoid captive user interfaces. 避免过于复杂花哨的界面。\nMake every program a filter. 使每个程序（方法）称为一个过滤器（筛选器）。\n","permalink":"https://endlesspeak.github.io/docs/build/operating-system-sum/linux-technology-2-linux-comprehensive-overview/","tags":["Linux"],"title":"Linux综合概述"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"要使用 KRDC（KDE Remote Desktop Client）连接到 RK3588 嵌入式开发板，可以按以下步骤操作：\nXRDP Install 在 RK3588 嵌入式开发板上设置远程桌面服务\n首先，安装 xrdp（远程桌面协议服务）：\nsudo apt update sudo apt install xrdp 然后，启动 xrdp 服务：\nsudo systemctl enable xrdp sudo systemctl start xrdp 检查 xrdp 服务状态：\nsudo systemctl status xrdp 确认服务正在运行。\n配置防火墙（如有必要）： 确保防火墙允许 3389 端口上的流量，这是 xrdp 的默认端口。\nsudo ufw allow 3389 KRDC Connect 安装 KRDC： 如果还没有安装 KRDC，可以使用以下命令进行安装：\nsudo apt update sudo apt install krdc 启动 KRDC： 在终端中运行 krdc 或者从应用程序菜单中找到并启动 KRDC。\n连接到开发板：\n在 KRDC 界面中，输入开发板的 IP 地址，并选择 RDP 作为协议。例如，输入 rdp://192.168.x.x（替换为开发板的实际 IP 地址）。\n点击连接，输入开发板的用户名和密码进行验证。\n注意事项\nIP 地址： 确保你的 PC 和开发板在同一个网络中，并且可以相互通信。可以通过命令 ifconfig 或 ip addr 检查开发板的 IP 地址。 用户权限： 确保远程连接的用户有足够的权限，并且防火墙设置正确以允许远程连接。 通过这些步骤，你应该能够使用 KRDC 从你的 PC 连接到 RK3588 嵌入式开发板的远程桌面。 ","permalink":"https://endlesspeak.github.io/docs/build/arm-linux-doc/3-rk3588-connect/","tags":[],"title":"RK3588 远程连接"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Direct Method Gauss LU Decomposition QR Decomposition Cholesky Decomposition 迭代解法 迭代解法通常用于处理大型稀疏矩阵，或当矩阵 A 具有特定结构时。\nJacobi Method 雅可比迭代法\nGauss-Seidel Method 高斯-赛德尔迭代法是雅可比迭代法的改进，每次迭代使用最新的值来更新解\nConjugate Gradient Method 共轭梯度法特别适用于求解大型对称正定矩阵的线性方程组。它通过在共轭方向上最小化二次型函数来逼近解。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/3-matrix-basic/","tags":[],"title":"Matrix Base"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Basic Sophus 是Strasdat 维护的 Sophus 库，地址。\n此处介绍 Sophus 的基础使用方法。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;Eigen/Core\u0026gt; #include \u0026lt;Eigen/Geometry\u0026gt; #include \u0026quot;sophus/se3.hpp\u0026quot; using namespace std; using namespace Eigen; /// 本程序演示sophus的基本用法 int main(int argc, char **argv) { // 沿Z轴转90度的旋转矩阵 Matrix3d R = AngleAxisd(M_PI / 2, Vector3d(0, 0, 1)).toRotationMatrix(); // 或者四元数 Quaterniond q(R); Sophus::SO3d SO3_R(R); // Sophus::SO3d可以直接从旋转矩阵构造 Sophus::SO3d SO3_q(q); // 也可以通过四元数构造 // 二者是等价的 cout \u0026lt;\u0026lt; \u0026quot;SO(3) from matrix:\\n\u0026quot; \u0026lt;\u0026lt; SO3_R.matrix() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;SO(3) from quaternion:\\n\u0026quot; \u0026lt;\u0026lt; SO3_q.matrix() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;they are equal\u0026quot; \u0026lt;\u0026lt; endl; // 使用对数映射获得它的李代数 Vector3d so3 = SO3_R.log(); cout \u0026lt;\u0026lt; \u0026quot;so3 = \u0026quot; \u0026lt;\u0026lt; so3.transpose() \u0026lt;\u0026lt; endl; // hat 为向量到反对称矩阵 cout \u0026lt;\u0026lt; \u0026quot;so3 hat=\\n\u0026quot; \u0026lt;\u0026lt; Sophus::SO3d::hat(so3) \u0026lt;\u0026lt; endl; // 相对的，vee为反对称到向量 cout \u0026lt;\u0026lt; \u0026quot;so3 hat vee= \u0026quot; \u0026lt;\u0026lt; Sophus::SO3d::vee(Sophus::SO3d::hat(so3)).transpose() \u0026lt;\u0026lt; endl; // 增量扰动模型的更新 Vector3d update_so3(1e-4, 0, 0); //假设更新量为这么多 Sophus::SO3d SO3_updated = Sophus::SO3d::exp(update_so3) * SO3_R; cout \u0026lt;\u0026lt; \u0026quot;SO3 updated = \\n\u0026quot; \u0026lt;\u0026lt; SO3_updated.matrix() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;*******************************\u0026quot; \u0026lt;\u0026lt; endl; // 对SE(3)操作大同小异 Vector3d t(1, 0, 0); // 沿X轴平移1 Sophus::SE3d SE3_Rt(R, t); // 从R,t构造SE(3) Sophus::SE3d SE3_qt(q, t); // 从q,t构造SE(3) cout \u0026lt;\u0026lt; \u0026quot;SE3 from R,t= \\n\u0026quot; \u0026lt;\u0026lt; SE3_Rt.matrix() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;SE3 from q,t= \\n\u0026quot; \u0026lt;\u0026lt; SE3_qt.matrix() \u0026lt;\u0026lt; endl; // 李代数se(3) 是一个六维向量，方便起见先typedef一下 typedef Eigen::Matrix\u0026lt;double, 6, 1\u0026gt; Vector6d; Vector6d se3 = SE3_Rt.log(); cout \u0026lt;\u0026lt; \u0026quot;se3 = \u0026quot; \u0026lt;\u0026lt; se3.transpose() \u0026lt;\u0026lt; endl; // 观察输出，会发现在Sophus中，se(3)的平移在前，旋转在后. // 同样的，有hat和vee两个算符 cout \u0026lt;\u0026lt; \u0026quot;se3 hat = \\n\u0026quot; \u0026lt;\u0026lt; Sophus::SE3d::hat(se3) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;se3 hat vee = \u0026quot; \u0026lt;\u0026lt; Sophus::SE3d::vee(Sophus::SE3d::hat(se3)).transpose() \u0026lt;\u0026lt; endl; // 最后，演示一下更新 Vector6d update_se3; //更新量 update_se3.setZero(); update_se3(0, 0) = 1e-4; Sophus::SE3d SE3_updated = Sophus::SE3d::exp(update_se3) * SE3_Rt; cout \u0026lt;\u0026lt; \u0026quot;SE3 updated = \u0026quot; \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; SE3_updated.matrix() \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/5-sophus/","tags":[],"title":"Sophus"},{"authors":[],"categories":[],"content":"平衡矩阵 小美拿到了一个 $n∗n$ 的矩阵，其中每个元素是 0 或者 1。小美认为一个矩形区域是完美的，当且仅当该区域内 0 的数量恰好等于 1 的数量。\n现在，小美希望你回答有多少个 $i∗i$ 的完美矩形区域。\n你需要回答 $1\\leq i \\leq n$ 的所有答案。\n输入描述：\n第一行输入一个正整数n，代表矩阵大小。 接下来的n行，每行输入一个长度为n的 01 串，用来表示矩阵。 $1\\leq n \\leq 200$\n输出描述：\n输出n行，第i行输出i*i的完美矩形区域的数量。\n解题思想：\n前缀和数组计算：\nprefix_zeros 数组的每个元素 prefix_zeros[i][j] 表示从矩阵左上角 (0, 0) 到 (i, j) 范围内 0 的数量。 利用动态规划的方法逐步累加每个位置的0数量，并减去重复计算的部分 快速计算子矩阵中的0数量：\n利用 prefix_zeros 数组，快速计算任意子矩阵中0的数量。计算公式基于二维前缀和的性质。\nbool perfect_matrix(int count_zero, int size) { int total_elements = size * size; return count_zero * 2 == total_elements; } std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; compute_prefix_zeros(const std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; a, int n) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; prefix_zeros(n, std::vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { prefix_zeros[i][j] = (a[i][j] == 0 ? 1 : 0); if (i \u0026gt; 0) prefix_zeros[i][j] += prefix_zeros[i-1][j]; if (j \u0026gt; 0) prefix_zeros[i][j] += prefix_zeros[i][j-1]; if (i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 0) prefix_zeros[i][j] -= prefix_zeros[i-1][j-1]; } } return prefix_zeros; } int count_zeros_in_submatrix(const std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prefix_zeros, int x1, int y1, int size) { int x2 = x1 + size - 1; int y2 = y1 + size - 1; int total = prefix_zeros[x2][y2]; if (x1 \u0026gt; 0) total -= prefix_zeros[x1-1][y2]; if (y1 \u0026gt; 0) total -= prefix_zeros[x2][y1-1]; if (x1 \u0026gt; 0 \u0026amp;\u0026amp; y1 \u0026gt; 0) total += prefix_zeros[x1-1][y1-1]; return total; } int main() { int n; std::cin \u0026gt;\u0026gt; n; std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; a(n, std::vector\u0026lt;int\u0026gt;(n)); for (int i = 0; i \u0026lt; n; i++) { std::string row; std::cin \u0026gt;\u0026gt; row; for (int j = 0; j \u0026lt; n; j++) { a[i][j] = row[j] - '0'; } } // 计算前缀和数组 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; prefix_zeros = compute_prefix_zeros(a, n); for (int size = 1; size \u0026lt;= n; size++) { int count = 0; // 遍历所有可能的子矩阵起点 for (int i = 0; i \u0026lt;= n - size; i++) { for (int j = 0; j \u0026lt;= n - size; j++) { int count_zero = count_zeros_in_submatrix(prefix_zeros, i, j, size); if (perfect_matrix(count_zero, size)) count++; } } std::cout \u0026lt;\u0026lt; count \u0026lt;\u0026lt; std::endl; } return 0; } 数组询问 小美拿到了一个由正整数组成的数组，但其中有一些元素是未知的（用0来表示）。\n现在小美想知道，如果那些未知的元素在区间 $[l,r]$ 范围内随机取值的话，数组所有元素之和的最小值和最大值分别是多少？\n共有q次询问。\n输入描述：\n第一行输入两个正整数n,q，代表数组大小和询问次数。 第二行输入n个整数a_i，其中如果输入的a_i为 0，那么说明a_i是未知的。 接下来的q行，每行输入两个正整数 l,r，代表一次询问。\n$$ \\begin{aligned} 1\\leq n,q \\leq 10^5 0 \\leq a_i \\leq 10^9 1\\leq l \\leq r \\leq 10^9 \\end{aligned} $$ 输出描述：\n输出 $q$ 行，每行输出两个正整数，代表所有元素之和的最小值和最大值。\n示例：\n输入例子：\n3 2 1 0 3 1 2 4 4 输出例子：\n5 6 8 8 例子说明：\n只有第二个元素是未知的。 第一次询问，数组最小的和是 1+1+3=5，最大的和是 1+2+3=6。 第二次询问，显然数组的元素和必然为 8。 解题思想：\n前缀和数组：预处理已知元素的前缀和，使得每次查询能够快速计算已知元素的和。 统计未知元素：在处理每个查询时，统计数组中未知元素（即值为0的元素）的数量，并根据查询的范围 $[l, r]$ 计算最小值和最大值。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; using namespace std; int main() { int n, q; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; a(n); vector\u0026lt;long long\u0026gt; prefix_sum(n + 1, 0); vector\u0026lt;int\u0026gt; unknown_count(n + 1, 0); for (int i = 0; i \u0026lt; n; ++i) { cin \u0026gt;\u0026gt; a[i]; // 计算前缀和，对已知元素进行累加 prefix_sum[i + 1] = prefix_sum[i] + (a[i] != 0 ? a[i] : 0); // 统计未知元素的数量 unknown_count[i + 1] = unknown_count[i] + (a[i] == 0 ? 1 : 0); } for (int i = 0; i \u0026lt; q; ++i) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; long long known_sum = prefix_sum[n]; int zero_count = unknown_count[n]; long long min_value = known_sum + zero_count * l; long long max_value = known_sum + zero_count * r; cout \u0026lt;\u0026lt; min_value \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; max_value \u0026lt;\u0026lt; endl; } return 0; } ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/algorithms-doc/3-meituan-interview/","tags":[],"title":"MeiTuan Interview 1"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"CV::Mat 在 OpenCV 中，cv::Mat 是用于表示图像或矩阵的主要数据结构。它封装了一个 n 维数组，可以存储不同类型的数值（如图像的像素值）。\ncv::Mat 的构造和析构过程涉及内存管理和引用计数机制，确保高效和安全地处理图像数据。\nConstructor cv::Mat 有多种构造方式，以下是几种常见的构造方法：\n默认构造函数\n创建一个空的 cv::Mat 对象:cv::Mat mat;\n指定大小和类型的构造函数\n创建一个指定大小和类型的矩阵:cv::Mat mat(rows, cols, type); 例如创建一个 3x3 的单通道 8 位无符号整数矩阵：cv::Mat mat(3, 3, CV_8UC1);\n通过数据指针和步长构造\n使用已有数据指针创建 cv::Mat: cv::Mat mat(rows, cols, type, data, step);\n通过文件读取构造\n读取图像文件并创建 cv::Mat 对象。如cv::Mat mat = cv::imread(\u0026quot;image.jpg\u0026quot;, cv::IMREAD_COLOR);\nDestructor cv::Mat 的析构函数会自动处理内存管理，确保内存安全释放。OpenCV 使用引用计数机制来管理 cv::Mat 对象的内存，当没有对象引用时，内存才会被释放。\n以下是析构的过程：\n引用计数递减：\ncv::Mat 内部维护了一个指向数据的指针和一个引用计数。当 cv::Mat 对象被销毁时，引用计数递减。\n内存释放：\n如果引用计数变为零，说明没有对象再引用这块内存，才会释放数据内存。\n以下是一个简化的示例，展示 cv::Mat 的引用计数和内存管理：\n#include \u0026lt;opencv2/opencv.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; void display_ref_count(const cv::Mat\u0026amp; mat) { // Mat::u 是指向 Mat::U 结构体的指针 std::cout \u0026lt;\u0026lt; \u0026quot;Reference count: \u0026quot; \u0026lt;\u0026lt; mat.u-\u0026gt;refcount \u0026lt;\u0026lt; std::endl; } int main() { cv::Mat mat1 = cv::imread(\u0026quot;image.jpg\u0026quot;, cv::IMREAD_COLOR); display_ref_count(mat1); // 初始引用计数 { cv::Mat mat2 = mat1; // mat2 共享 mat1 的数据 display_ref_count(mat1); // 引用计数增加 display_ref_count(mat2); } // mat2 作用域结束，引用计数减少 display_ref_count(mat1); // mat2 销毁后，引用计数减少 return 0; } 结论：\n构造：cv::Mat 提供多种构造函数，可以创建空矩阵、指定大小和类型的矩阵，或通过已有数据指针创建矩阵。 析构：cv::Mat 使用引用计数机制管理内存，当引用计数为零时释放内存，确保内存安全。 通过这种机制，OpenCV 确保 cv::Mat 对象的内存管理高效且安全，避免内存泄漏和重复释放的问题。\nMat::U Mat::u 是一个指向 Mat::U 结构体的指针，包含了引用计数和指向实际数据的指针。\n当多个 cv::Mat 对象共享同一块内存时，引用计数会跟踪这块内存的引用次数，以便在不再需要时正确释放内存。\n引用计数: cv::Mat 对象采用引用计数机制来管理内存:\n当一个 cv::Mat 对象被复制时，新对象将共享原始对象的数据，而不会立即复制数据 只有当某个对象需要独占数据或修改数据时，才会进行实际的数据复制。这种机制称为“写时复制”（Copy-on-Write, COW） struct Mat::U { int refcount; // 引用计数器 uchar* data; // 指向实际图像数据的指针 // 其他成员变量 }; 以下是一个简单的示例代码，展示了 Mat 对象的引用计数机制：\n#include \u0026lt;opencv2/opencv.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { // 创建一个 3x3 的单通道图像，所有像素初始化为 0 cv::Mat mat1 = cv::Mat::zeros(3, 3, CV_8UC1); // 打印 mat1 的引用计数；理论值是1 std::cout \u0026lt;\u0026lt; \u0026quot;mat1 refcount: \u0026quot; \u0026lt;\u0026lt; mat1.u-\u0026gt;refcount \u0026lt;\u0026lt; std::endl; // 创建 mat2，指向 mat1 的数据；理论值是2 cv::Mat mat2 = mat1; // 打印 mat1 和 mat2 的引用计数；理论值是2 std::cout \u0026lt;\u0026lt; \u0026quot;mat1 refcount after assignment: \u0026quot; \u0026lt;\u0026lt; mat1.u-\u0026gt;refcount \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026quot;mat2 refcount: \u0026quot; \u0026lt;\u0026lt; mat2.u-\u0026gt;refcount \u0026lt;\u0026lt; std::endl; // 修改 mat2，会导致数据复制； 此时 mat2 指向了新分配的数据内存 mat2.at\u0026lt;uchar\u0026gt;(0, 0) = 255; // 打印 mat1 和 mat2 的引用计数 // 理论值是1 std::cout \u0026lt;\u0026lt; \u0026quot;mat1 refcount after modification: \u0026quot; \u0026lt;\u0026lt; mat1.u-\u0026gt;refcount \u0026lt;\u0026lt; std::endl; // 理论值是1 std::cout \u0026lt;\u0026lt; \u0026quot;mat2 refcount after modification: \u0026quot; \u0026lt;\u0026lt; mat2.u-\u0026gt;refcount \u0026lt;\u0026lt; std::endl; return 0; } ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/6-opencv/","tags":[],"title":"OpenCV"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"ToolChain Embedded Toolchain 需要配置嵌入式编译工具链，它应该包括：\narm-none-eabi-gcc arm-none-eabi-g++ arm-none-eabi-ar arm-none-eabi-ld (bfd 链接方式) arm-none-eabi-gdb arm-none-eabi-nm arm-none-eabi-objcopy arm-none-eabi-objdump 在 NixOS 上配置工具链需要如下软件包：\npackages = with pkgs; [ gcc-arm-embedded ]; 在 Arch Linux 上需要安装如下软件包：\npacman -S arm-none-eabi-bintils arm-none-eabi-gcc arm-none-eabi-gdb arm-none-eabi-newlib 其中， arm-none-eabi-newlib 是用于编译程序的库文件，脱离库文件无法正确生成可执行的文件。\nOpenOCD 需要安装烧录和在线调试工具 OpenOCD(Open On-Chip Debugger) 以及连接工具 ST-Link(也可以是其他工具)\nOpenOCD 的烧录需要配置相关的参数，以 cfg 格式记录在文件中。\nsource [find interface/stlink.cfg] transport select hla_swd source [find target/stm32f7x.cfg] reset_config none adapter speed 10000 # 配置速率是必须的，否则无法正常完成下载 CLion Transfer 对之前以 stm32cubeide 或 stm32cubemx 开发的项目，可以方便地转化为 Clion 项目，转化的必要条件是:\n项目包含 .cproject 等必要的项目描述文件 项目包含 STM32F767IGTX_FLASH.ld 等内存描述文件 转化的过程是：\n直接用 clion 打开 stm32cubeide 项目 配置相关的 CMakeLists.txt 文件，主要是相关的编译工具链 方法一：将工具链目录加入 PATH 方法二：为工具链编写绝对路径 重启 Clion，依次选择 Tools → CMake → Reset Cache and Reload Project CMakeLists 下面提供一份可用的 CMakeLists.txt 文件\nset(CMAKE_SYSTEM_NAME Generic) set(CMAKE_SYSTEM_VERSION 1) cmake_minimum_required(VERSION 3.24) # specify cross-compilers and tools set(CMAKE_C_COMPILER arm-none-eabi-gcc) set(CMAKE_CXX_COMPILER arm-none-eabi-g++) set(CMAKE_ASM_COMPILER arm-none-eabi-gcc) set(CMAKE_AR arm-none-eabi-ar) set(CMAKE_OBJCOPY arm-none-eabi-objcopy) set(CMAKE_OBJDUMP arm-none-eabi-objdump) set(SIZE arm-none-eabi-size) set(CMAKE_TRY_COMPILE_TARGET_TYPE STATIC_LIBRARY) # project settings project(\u0026lt;PROJECT_NAME\u0026gt; C CXX ASM) # Write your project name here set(CMAKE_CXX_STANDARD 17) set(CMAKE_C_STANDARD 11) #Uncomment for hardware floating point #add_compile_definitions(ARM_MATH_CM4;ARM_MATH_MATRIX_CHECK;ARM_MATH_ROUNDING) add_compile_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16) add_link_options(-mfloat-abi=hard -mfpu=fpv4-sp-d16) # set FPU(Floating Point Unit) type to VFPv4 # with support for single-precision and double-precision floating-point operations # along with 16 VFP registers. # you can set -mfpu=fpu-dp instead,I have not tried yet. #Uncomment for software floating point #add_compile_options(-mfloat-abi=soft) add_compile_options(-mcpu=cortex-m7 -mthumb -mthumb-interwork) add_compile_options(-ffunction-sections -fdata-sections -fno-common -fmessage-length=0) # uncomment to mitigate c++17 absolute addresses warnings #set(CMAKE_CXX_FLAGS \u0026quot;${CMAKE_CXX_FLAGS} -Wno-register\u0026quot;) # Enable assembler files preprocessing add_compile_options($\u0026lt;$\u0026lt;COMPILE_LANGUAGE:ASM\u0026gt;:-x$\u0026lt;SEMICOLON\u0026gt;assembler-with-cpp\u0026gt;) # if the current compiled language is assembly,add compile options -x assembler-with-cpp if (\u0026quot;${CMAKE_BUILD_TYPE}\u0026quot; STREQUAL \u0026quot;Release\u0026quot;) message(STATUS \u0026quot;Maximum optimization for speed\u0026quot;) add_compile_options(-Ofast) elseif (\u0026quot;${CMAKE_BUILD_TYPE}\u0026quot; STREQUAL \u0026quot;RelWithDebInfo\u0026quot;) message(STATUS \u0026quot;Maximum optimization for speed, debug info included\u0026quot;) add_compile_options(-Ofast -g) elseif (\u0026quot;${CMAKE_BUILD_TYPE}\u0026quot; STREQUAL \u0026quot;MinSizeRel\u0026quot;) message(STATUS \u0026quot;Maximum optimization for size\u0026quot;) add_compile_options(-Os) else () message(STATUS \u0026quot;Minimal optimization, debug info included\u0026quot;) add_compile_options(-Og -g) endif () include_directories( Core/Inc Drivers/STM32F7xx_HAL_Driver/Inc Drivers/STM32F7xx_HAL_Driver/Inc/Legacy Drivers/CMSIS/Include Drivers/CMSIS/Device/ST/STM32F7xx/Include Drivers/CMSIS/DSP/Include BSP/Inc ) add_definitions(-DARM_MATH_CM7 -DDEBUG -DUSE_HAL_DRIVER -DSTM32F767xx) link_directories(Drivers/CMSIS/Lib/GCC) # the following link libraries depend on you # link_libraries(arm_cortexM7lfdp_math) file(GLOB_RECURSE SOURCES \u0026quot;Core/*.*\u0026quot; \u0026quot;Drivers/*.*\u0026quot; \u0026quot;BSP/*.*\u0026quot;) # file(GLOB ...) is a command to add all source files in project # set link memory map set(LINKER_SCRIPT ${CMAKE_SOURCE_DIR}/STM32F767IGTX_FLASH.ld) add_link_options(-Wl,-gc-sections,--print-memory-usage,-Map=${PROJECT_BINARY_DIR}/${PROJECT_NAME}.map) add_link_options(-mcpu=cortex-m7 -mthumb -mthumb-interwork -u _printf_float) add_link_options(-T ${LINKER_SCRIPT}) add_executable(${PROJECT_NAME}.elf ${SOURCES} ${LINKER_SCRIPT}) set(HEX_FILE ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.hex) set(BIN_FILE ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.bin) add_custom_command(TARGET ${PROJECT_NAME}.elf POST_BUILD COMMAND ${CMAKE_OBJCOPY} -Oihex $\u0026lt;TARGET_FILE:${PROJECT_NAME}.elf\u0026gt; ${HEX_FILE} COMMAND ${CMAKE_OBJCOPY} -Obinary $\u0026lt;TARGET_FILE:${PROJECT_NAME}.elf\u0026gt; ${BIN_FILE} COMMENT \u0026quot;Building ${HEX_FILE} Building ${BIN_FILE}\u0026quot;) Test ToolChain 依次选择 Settings → Build,Execution,Deployment → ToolChains 依次设置各个工具(如不在 PATH 中则需要配置路径) Download \u0026amp; Run 在配置部分新增 \u0026ldquo;OpenOCD Download and Run\u0026rdquo; 配置 GDB Port 处默认是 3333 Board Config file 部分增加对应的 \u0026ldquo;stlink.cfg\u0026rdquo; Debug 在配置部分新增 \u0026ldquo;Embedded GDB Server\u0026rdquo; 配置 Debugger 处写 arm-none-eabi-gdb 的可执行路径 Target Remote 处写 OpenOCD 对应 GDB 的端口，默认是 localhost:3333 GDB Server 处写 OpenOCD 的可执行路径 GDB Server args 处写 stlink.cfg 的内容，用 -f 参数分隔，如 -f interface/stlink.cfg -f target/stm32f7x.cfg 在代码中加入断点，开始调试， 并按下开发板的复位按钮 如果遇到端口被占用(如之前 openocd 启动了但没有正确退出等情况)，可用命令查看占用详情，并对对应的程序作终止处理。\nnetstat -ltnp | grep 6666 # openocd 默认会占用6666端口 ss -ltnp | grep 6666 # Arch Linux已弃用net-tools，改用iproute2 kill -9 \u0026lt;pid\u0026gt; SVD 在意法半导体官网下载对应芯片的 SVD 文件 在 Clion 调试中加载 SVD 文件 调试时可以显示对应外设的状态和相关的值 ","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/3-stm32-clion-develop/","tags":[],"title":"STM32 Clion Develop"},{"authors":[],"categories":[],"content":"Low Level Virtual Machine General LLVM(Low Level Virtual Machine)是一个开源的编辑器基础设施项目。\nLLVM 最初设计时，因为只想着做优化方面的研究，所以只是想搭建一套虚拟机，所以当时这个的全称叫 Low Level Virtual machine\n后来因为要变成编译器，官方就放弃了这个称呼，不过 LLVM 的简称还是保留下来了\nLLVM 提供了一组通用的编译工具和技术：\n编译器前端 优化器 代码生成器 链接器 LLVM 支持多种编程语言：\nC/C++ Objective-C/C++ Rust Swift IR LLVM 提供了灵活的中间表示（Intermediate Representation,IR）和强大的优化功能，使得编译器可以更高效地生成高质量的目标代码。IR 是 LLVM 编译快的原因之一，它不像 gcc 在每个阶段结束生成一些中间过程文件。\n在 LLVM 中，IR 有两种表示：\n可读的 IR 类似于汇编代码，其实它介于高等语言和汇编之间，这种表示的磁盘文件后缀为.ll； 是编写和调试优化器规则和转换的首选形式 二进制 IR 称作位码(bitcode)，磁盘文件后缀为.bc； 二进制形式是一种紧凑、可序列化的格式，可以在不丢失信息的情况下进行存储和传输 可以被后续阶段的 LLVM 工具直接读取和处理，也可以在不同系统之间进行跨平台的交流和共享 LLVM 还提供了一种称为\u0026quot;Memory Buffer\u0026quot;的数据结构，用于在内存中存储和传输 LLVM IR 的文本表示形式\n这种形式可以方便地在内存中进行读写和处理，但它并不是 LLVM IR 的一种独立形式。\nLLVM IR：\n不是直接对应于内存中的数据结构，而是一种抽象的中间表达形式 用于表示源代码的控制流、数据流以及各种指令和操作 在编译过程中，LLVM IR 可以在内存中进行操作和转换，但它并不是一种专门的内存格式。 可以在 Clang/LLVM 工具的参数中指定生成这些文件，通过 llvm-as 和 llvm-dis 来在两种 IR 之间做转换。\nClang Clang(Compiler Front End for LLVM)是一个开源的编译前端。\nC、C++、Objective-C 和 Objective-C++编译器前端。clang 主要负责将源代码转换为中间表示（LLVM IR），并将其传递给 LLVM 后端进行优化和生成目标代码。\n最初时，LLVM 的前端是 GCC，后来 Apple 立志自己开发了 Clang 取代 GCC\n不过现在带有 Dragon Egg 的 GCC 还是可以生成 LLVM IR，也同样可以取代 Clang 的功能\nLinker LLVM 的链接器是 lld 。\n","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/1-3-program-compilation-by-clang/","tags":[],"title":"Program Compilation by Clang"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Org 具体来说它的功能有：\n折叠 这个在 IDE 里是很常见的了，但是我所见到的大多限于对于函数的折叠。如果只是想写写提纲，草稿，这个功能就能很有效地帮助理清思路，和专助于正在写的章节。\n表格 表格在 org-mode 里实在是很便利，运用几个 \u0026lsquo;|\u0026rsquo; 就能很轻松地插入表格，排版了。另外 使用 ‘:=\u0026rsquo; 可以定义相关公式，完成求和，求平均值等计算。\n时间记录、日志 TODO， Deadline , 时间, 日期，在日志上一目了然。如果记录了时间节点，还能自动生成时间花费列表。配合 Python 的 matplotlib 库可以绘制统计图形。在 org 文件中配合 org-aganda 可以安排每天的日程。\n导出 org-mode 导出功能十分强大，从基本的 html ， latex 到 思维导图，gantt chart 基本能想到的应有尽有，当然原始的导出功能肯定不尽如人意，但 Elisp 高度的可定制性极大的增高了它的上限。\nASCII 的精简直观 最后回到本质，org-mode 提倡的宗旨是用简单的列表(plain list)管理生活的点点滴滴。它注重的是内容本身而不是花哨的外表。用得越多，越觉得，最简单的 ASCII 也能带来美的感受，美在朴素。\norg-capture 及时捕获你的灵感，记录生活中的点滴等等。\norg-babel 简单的说 Babel 可以让许多不同的语言一起工作，它可以执行不同语言的代码块，它很像一个集成的 jupyter notebook，但能够支持更多的语言，方便快捷。\n问题 snippets 插入日期 C-c . 插入日期。\n\\begin{equation} \\begin{aligned}\\\\ [9,10] \\rightarrow [34] \\\\ [2,8] \\rightarrow [91] \\\\ [4,7] \\rightarrow [82] \\end{aligned} \\\\ \\downarrow \\\\ \\begin{bmatrix} \\begin{bmatrix} 9 \u0026amp; 10 \\end{bmatrix}\\\\ \\begin{bmatrix} 2 \u0026amp; 8 \\end{bmatrix}\\\\ \\begin{bmatrix} 4 \u0026amp; 7 \\end{bmatrix} \\end{bmatrix} \\rightarrow \\begin{bmatrix} \\begin{bmatrix} 34 \\end{bmatrix}\\\\ \\begin{bmatrix} 91 \\end{bmatrix}\\\\ \\begin{bmatrix} 82 \\end{bmatrix} \\end{bmatrix} \\end{equation} ","permalink":"https://endlesspeak.github.io/docs/build/editorconfiguration/3-org/","tags":[],"title":"Emacs Org"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Handle A Guess 请求用户输入，处理输入，并检查是否符合预期。\nuse std::io; fn main() { println!(\u0026quot;Guess the number.\u0026quot;); println!(\u0026quot;Please input your guess.\u0026quot;); let mut guess = String::new(); io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026quot;Failed to read line.\u0026quot;); println!(\u0026quot;You guessed: {}\u0026quot;,guess); } 在这段程序中包含了下面的内容：\nprelude prelude 是 Rust 自动导入每个 Rust 程序的内容的列表 它保持尽可能的小，并专注于几乎在每个 Rust 程序中使用的东西，尤其是 traits trait 它是一种定义共享行为的机制，它定义一组方法或功能的规范 通过实现 trait，类型可以表达它们能够执行的操作或拥有的行为 trait 类似其他编程语言接口的概念，当然也有一些不同，这一点在后面讨论 println! 使用换行符打印到标准输出 如果给予的字符串参数为空，则仅打印换行符 如果写入 io::stdout 失败，则出现 panics 关联函数 String::new() 的 :: 表明 new 是 String 类型的一个关联函数 它是定义在特定类型的命名空间中的静态函数 它可以通过类型名称直接调用，而不必创建该类型的实例 引用 引用可以让代码的多个部分访问同一处数据，而无需在内存中多次拷贝 引用默认是不可变的 readline readline 将用户输入传递到字符串中，返回 io::Result Result 类型是枚举，成员包括 OK 和 Err ，它一般与 match 一起使用 expect 用于返回 Result 的值 如果值为 OK，则返回 OK 内部包含的值 如果值为 Err，就会出现 panics，其中 panic 消息包括传递的消息以及 Err 的内容 Generate A Rand Number 代码如下所示：\nuse std::io; use rand::Rng; fn main() { println!(\u0026quot;Guess the number!\u0026quot;); let secret_number = rand::thread_rng().gen_range(1..101); let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026quot;The secret number is: {}\u0026quot;, secret_number); println!(\u0026quot;Please input your guess.\u0026quot;); let mut guess = String::new(); io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026quot;Failed to read line\u0026quot;); println!(\u0026quot;You guessed: {}\u0026quot;, guess); } 注：gen_range 方法\n获得一个区间表达式（range expression）作为参数，并在区间内生成一个随机数 区间表达式采用的格式为 start..end，它 左开右闭 可以传入 1..101 或者传入 1..=100 Comparison 比较变量，代码如下所示：\nuse rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\u0026quot;Guess the number!\u0026quot;); let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026quot;The secret number is: {}\u0026quot;, secret_number); let mut guess = String::new(); io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026quot;Failed to read line\u0026quot;); let guess: u32 = guess.trim().parse().expect(\u0026quot;Please type a number!\u0026quot;); println!(\u0026quot;You guessed: {}\u0026quot;, guess); match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026quot;Too small!\u0026quot;), Ordering::Greater =\u0026gt; println!(\u0026quot;Too big!\u0026quot;), Ordering::Equal =\u0026gt; println!(\u0026quot;You win!\u0026quot;), } } 注：\n类型推断 Rust 是静态类型语言，具有类型推断，字面值可以自动推断 存在不同类型时需要指定类型 遮蔽 遮蔽允许我们复用变量的名字，而不是被迫创建两个不同变量 有关更多遮蔽的内容见 变量 小节 字符串方法 String.parse() 它将字符串解析成数字 由于可以解析成（返回）多种数字类型，因此需要指定类型 String.trim() 去除字符串的开头与结尾的空白字符 返回类型还是字符串 Loop and exit 生成循环和处理无效输入，代码如下\nuse rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\u0026quot;Guess the number!\u0026quot;); let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026quot;The secret number is: {}\u0026quot;, secret_number); loop { println!(\u0026quot;Please input your guess.\u0026quot;); let mut guess = String::new(); io::stdin() .read_line(\u0026amp;mut guess) .expect(\u0026quot;Failed to read line\u0026quot;); let guess: u32 = match guess.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; continue, } println!(\u0026quot;You guessed: {}\u0026quot;, guess); match guess.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; println!(\u0026quot;Too small!\u0026quot;), Ordering::Greater =\u0026gt; println!(\u0026quot;Too big!\u0026quot;), Ordering::Equal =\u0026gt;{ println!(\u0026quot;You win!\u0026quot;); break; } } } } 有必要解释一下：\n解析成功， Ok(num) 分支将返回解析得到的数字并将其赋值给 guess 变量 解析失败， Err(_) 分支会使用 continue 关键字跳过当前循环迭代 Denest Code 我们应该需要一点代码美学，以免过多的嵌套破坏代码的可读性。见 https://youtu.be/CFRhGnuXG-4\n解除嵌套的方法不外乎两种\n提炼(extraction) 将代码的嵌套部分提成单独的函数，并在本函数中调用\n反转(inversion) 将短结束的部分提前退出，这样可以减少嵌套层数\n修改后的代码如下所示：\nuse std::io; use rand::Rng; use std::cmp::Ordering; fn guess(secret_number: u32) -\u0026gt; i32 { println!(\u0026quot;Guess a number and Input:\u0026quot;); let mut guess = String::new(); io::stdin().read_line(\u0026amp;mut guess).expect(\u0026quot;Unable to read line.\u0026quot;); //shadow the guess variable let guess:u32 = match guess.trim().parse(){ Ok(num) =\u0026gt; num, Err(_) =\u0026gt; { println!(\u0026quot;Input invalid!\u0026quot;); return -1;//input failed,need reinput }, }; println!(\u0026quot;Your guess number is {}\u0026quot;,guess); match guess.cmp(\u0026amp;secret_number){ Ordering::Less =\u0026gt; println!(\u0026quot;Too Small!\u0026quot;), Ordering::Greater =\u0026gt; println!(\u0026quot;Too big!\u0026quot;), Ordering::Equal =\u0026gt; { println!(\u0026quot;Success!\u0026quot;); return 0;//guess success and stop }, } return 1;//continue guess without problem } fn main() { println!(\u0026quot;Guess number game.\u0026quot;); let secret_number = rand::thread_rng().gen_range(1..=100); println!(\u0026quot;The secret_number is {}\u0026quot;, secret_number); loop { match guess(secret_number){ 1 | -1 =\u0026gt; continue, 0 =\u0026gt; break, _ =\u0026gt; continue, } } } ","permalink":"https://endlesspeak.github.io/docs/docs/rust-programming-basic-doc/3-guessnumber/","tags":[],"title":"Guess Number"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"目标综述 在特征空间中找到一 分离超平面 能将实例分到不同类。\n当数据集 线性可分 时，有无数个分离超平面可将数据正确分开，支持向量机利用 间隔最大化 求解最优分离超平面，因此解是唯一的。\n对训练集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。对最难分的实例点(离超平面最近的点)也有足够大的确信度将它们分开，对未知新实例有很好的分类预测能力。\n通过拉格朗日对偶对原优化问题进行转化，使之更容易求解；\n当数据集 线性不可分 时，通过非线性变换的过程将其转化为线性问题。非线性变换可将输入空间中的超曲面模型对应特征空间（希尔伯特空间）中的超平面模型，通过在特征空间中求解线性支持向量机完成输入空间分类问题的学习。\n线性二分类模型 给定一组数据\\((x_1,y_1),(x_2,y_2),⋯,(x_m,y_m)\\)，其中 \\(x_i \\in R^d ,y \\in \\{-1,1\\}\\)。\n二分类任务的目标是希望从数据中学得一个假设函数\\(h:R \\rightarrow \\{-1,1\\}\\),使得 \\(h( x_ {1} )=y_ {i}\\)，即\n\\begin{align} h(x_ 1)=\\begin{cases}+1 \\quad y_{1}=+1;\\-1 \\quad y_{1}=-1;\\end{cases} \\end{align}\n更进一步，线性二分类模型认为假设函数的形式基于对特征$x_i$的线性组合，即\n\\begin{equation} h(x_i)=sign(\\omega^T\\cdot x_i+b) \\quad \\omega_i \\in R^d,b \\in R \\end{equation}\n线性二分类模型的目标是找到一组合适的参数\\((\\omega,b)\\), 使得\n\\begin{equation} ∀i.y_i(w^Tx _i+b)\u0026gt;0 \\end{equation}\n线性硬间隔支持向量机 线性支持向量机是一种线性二分类模型，需要找到满足定理 1 约束的划分超平面, 即\\((\\omega,b)\\)。其中：\n参数$ω$方向与超平面垂直，它是超平面的法向量。 参数$b$代表的是超平面的偏置，决定超平面与原点间的距离。 进一步来说，SVM 希望找到与各样本的间隔最大化的划分超平面。\n间隔 间隔用来刻画点到分类超平面的距离，距离的远近程度可以用于度量分类的准确性或正确程度。\n定义超平面到数据集的 函数间隔 为：\n\\begin{equation} \\hat\\gamma=\\underset{1,2,\u0026hellip;,m}{min}y_i(\\omega\\cdot x_i+b) \\end{equation}\n定义超平面到数据集的 几何间隔 为：\n\\begin{equation} \\gamma=\\underset{1,2,\u0026hellip;,m}{min}y_i(\\frac{\\omega}{\\Vert\\omega\\Vert}\\cdot x_i+\\frac{b}{\\Vert\\omega\\Vert}) \\end{equation}\n函数间隔和几何间隔的关系：\\(\\gamma=\\frac{\\hat{\\gamma}}{\\Vert\\omega\\Vert}\\)\n为什么这样定义函数间隔？\n在超平面$ω⋅ x+b=0$确定的情况下，$| ω⋅ x+b|$表示点距离超平面的远近。\n为什么需要引入几何间隔？\n因为相同比例缩放参数$ω,b$时，超平面在高维空间中的位置不会发生变化，但函数间隔变化了。\n因此需要将参数大小固定，如给分离超平面的参数添加 L2 范数约束后，其间隔表示式表示的度量不受缩放的影响。\n间隔最大化 约束最优化问题：\n\\begin{align} \u0026amp; \\underset{\\omega,b}{max} \\quad \\gamma \\\\ \u0026amp; s.t \\quad y_i(\\frac{\\omega}{\\Vert\\omega\\Vert}\\cdot x_i+\\frac{b}{\\Vert\\omega\\Vert})\\geq \\gamma, \\quad i=1,2,\u0026hellip;,N \\end{align}\n带入函数间隔与几何间隔的关系得：\n\\begin{align} \u0026amp; \\underset{\\omega,b}{max} \\quad \\frac{\\hat\\gamma}{\\Vert\\omega\\Vert} \\\\ \u0026amp; s.t. \\quad y_i(\\omega\\cdot x_i+b)\\geq \\hat\\gamma, \\quad i=1,2,\u0026hellip;,N \\end{align}\n由于函数间隔成比例改变对目标函数的优化无影响，故转为凸优化问题：\n\\begin{align} \u0026amp; \\underset{\\omega,b}{min} \\quad \\frac{1}{2}\\Vert\\omega\\Vert^2\\\\ \u0026amp; s.t. \\quad y_i(\\omega\\cdot x_i+b)-1 \\geq 0, \\quad i=1,2,\u0026hellip;,N\\\\ \\end{align}\n线性可分训练数据集的最大间隔分离超平面是存在且唯一的。\n支持向量 训练数据集的样本点与分离超平面距离最近的点称为支持向量。\n\\begin{equation} y_i(\\omega\\cdot x_i+b)-1 = 0 \\end{equation}\n在决定分离超平面的时候只有支持向量起效，其他实例点不起作用。\n正例所在的平行于分离超平面的超平面与负例所在的平行于超平面的超平面之间的距离称为间隔边界。\n间隔边界：\\(\\frac{2}{\\Vert\\omega\\Vert}\\)\n拉格朗日对偶 引入对偶的优点：\n不等式约束转为等式约束，使得对偶问题更容易求解； 自然引入核函数，进而推广到非线性分类的问题； 改变了问题的复杂度。由求特征向量转为求拉格朗日乘子，原问题下与样本维度有关，对偶问题只与样本数量有关； 求解高效， 拉格朗日乘子仅在支持向量中非 0 。 问：为什么拉格朗日乘子仅在支持向量中非 0？\n按 KKT 条件有： \\[ \\alpha^{*}_i\\geq 0\\quad\\alpha_i^{*}(y_i(\\omega\\cdot x_i+b)-1)=0 \\]\n若不是支持向量，则不在间隔边界上，则\\(y_i(\\omega \\cdot x_i+b)-1\u0026gt; 0\\)，故\\(\\alpha^*_i=0\\)\n若是支持向量，则在间隔边界上，则\\(y_i(\\omega \\cdot x_i+b)-1= 0\\)，故\\(\\alpha^*_i\u0026gt;0\\)\n拉格朗日函数：\n\\[ L(\\omega,b,\\alpha)=\\frac{1}{2}\\Vert\\omega\\Vert^2-\\sum\\limits_{i=1}^{N}\\alpha_iy_i(\\omega\\cdot x_i+b)+\\sum\\limits_{i=1}^{N}\\alpha_i \\]\n其中$α_i≥0\\quad i=1,2,\u0026hellip;,N$是拉格朗日乘子，$α=(α_1,α_2,\u0026hellip;,α_N)^T$为拉格朗日乘子向量。\n根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题：\n\\[ \\underset{\\alpha}{max}\\ \\underset{\\omega,b}{min}L(\\omega,b,\\alpha) \\]\n计算，化简，转换得到等价的对偶最优化问题：\n\\begin{align} \u0026amp; \\underset{\\alpha}{min}\\quad \\frac{1}{2}\\sum\\limits_{i=1}^{N}\\sum\\limits_{j=1}^{N}\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum\\limits_{i=1}^{N}\\alpha_i \\\\ \u0026amp; s.t. \\quad \\sum\\limits_{i=1}^N\\alpha_iy_i=0 \\\\ \u0026amp; \\quad \\quad \\quad \\alpha_i\\geq0,\\quad i=1,2,\u0026hellip;,N \\end{align}\n满足的 KKT 条件如下：\n\\begin{align} \u0026amp; \\nabla_\\omega L(\\omega^*,b^*,\\alpha^*)=\\omega^*-\\sum\\limits_{i=1}^{N}\\alpha_i^*y_ix_i=0\\\\ \u0026amp; \\nabla_b L(\\omega^*,b^*,\\alpha^*)=-\\sum\\limits_{i=1}^{N}\\alpha_i^*y_i=0\\\\ \u0026amp; \\alpha_i^*(y_i(\\omega^* \\cdot x_i+b^*)-1)=0, i=1,2,\u0026hellip;,N\\\\ \\\\ \u0026amp; y_i(\\omega^* \\cdot x_i+b^*)-1\\geq 0,i=1,2,\u0026hellip;,N\\\\ \\\\ \u0026amp; \\alpha_i^* \\geq 0,i=1,2,\u0026hellip;,N \\end{align}\n设$α^*=(α_1^*,α_2^*,\u0026hellip;,α_l^*)^T$是对偶最优化问题的解，则存在下标$j$使得\\(\\alpha_j^*\u0026gt;0\\)，且\n\\begin{align} \u0026amp; \\omega^*=\\sum\\limits_{i=1}^{N}\\alpha_i^*y_ix_i \\\\ \u0026amp; b^*=y_j-\\sum\\limits_{i=1}^{N}\\alpha_i^*y_i(x_i\\cdot x_j) \\end{align}\n特别地，若\\(\\alpha_i^*=0\\)，则\\(\\omega^*=0\\)，不是原始最优化问题的解。\n分离超平面写成 \\[ \\sum\\limits_{i=1}^{N}\\alpha_i^*y_i(x\\cdot x_i)+b^*=0 \\] 决策函数为 \\[ f(x)=sign(\\sum\\limits_{i=1}^{N}\\alpha_i^*y_i(x\\cdot x_i)+b^*) \\] 即分类决策函数只依赖于输入 x 和训练样本输入的内积。\n线性软间隔支持向量机 引入松弛变量\\(\\varepsilon_i\\geq0\\)，约束条件变为：\n\\[ y_i(\\omega\\cdot x_i+b)\\geq 1-\\xi_i \\]\n同时，对每个松弛变量，支付代价\\(\\epsilon_i\\)，则有凸优化问题：\n\\begin{align} \u0026amp; \\underset{\\omega,b}{min} \\quad \\frac{1}{2}\\Vert\\omega\\Vert^2+C\\sum\\limits_{i=1}^{N}\\xi_i\\\\ \u0026amp; s.t. \\quad y_i(\\omega\\cdot x_i+b)\\geq 1-\\varepsilon_i, \\quad i=1,2,\u0026hellip;,N\\\\ \u0026amp; \\quad \\quad \\quad \\varepsilon_i \\geq0, \\quad i=1,2,\u0026hellip;,N \\end{align}\n对偶问题是：\n\\begin{align} \u0026amp; \\underset{\\alpha}{min}\\quad \\frac{1}{2}\\sum\\limits_{i=1}^{N}\\sum\\limits_{j=1}^{N}\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum\\limits_{i=1}^{N}\\alpha_i \\\\ \u0026amp; s.t. \\quad \\sum\\limits_{i=1}^N\\alpha_iy_i=0 \\\\ \u0026amp; \\quad \\quad \\quad 0\\leq\\alpha_i\\leq C,\\quad i=1,2,\u0026hellip;,N \\end{align}\n且它的解、分离超平面、分类决策函数与硬间隔相同。\n支持向量 软间隔的支持向量要么在间隔边界上，要么在间隔边界与分离超平面之间，要么在误分类一侧。\n实例到间隔边界的距离：\\(\\frac{\\xi_i}{\\Vert\\omega\\Vert}\\)\n合页损失函数 最小化目标函数：\n\\[ \\sum\\limits_{i=1}^{N}[1-y_i(\\omega\\cdot x_i+b)]_++\\lambda\\Vert\\omega\\Vert^2 \\]\n前面是经验损失或经验风险，后面是**正则化项**。\n其中下标+表示函数：\n\\begin{equation} [z]_{+}= \\left\\{ \\begin{array}{lr} z,\\quad z\u0026gt;0 \u0026amp; \\\\ 0,\\quad z\\leq 0 \u0026amp;\\\\ \\end{array} \\right. \\end{equation}\n核函数与核技巧 若存在从输入空间到特征空间（希尔伯特空间）的映射，使得\n\\[ K(x,z)=\\phi(x)\\cdot\\phi(z) \\]\n其中$φ(x)$为映射函数。\n核技巧的想法是，只定义核函数\\(K(x,z)\\)，而不显式定义映射函数\\(\\phi(x)\\)。\n通常所说的核函数是正定核函数。正定核具有正定矩阵，即任意二次型都大于 0 的矩阵，行列式恒为正，特征值均为正等。\n常用核函数：\n多项式核函数 高斯核函数 字符串核函数 序列最小优化算法 SMO SMO 是一种启发式算法，基本思路是：所有变量的解都满足 KKT 条件即可，因为 KKT 是最优化问题的充要条件。它采用坐标梯度下降的思想：选择两个变量，固定其他变量，构建二次规划问题；\n为什么选择两个变量？因为存在约束：\n\\[ \\sum\\limits_{i=1}^{N}\\alpha_iy_i=0 \\]\n变量优化 SMO 将对偶问题转化为子问题：\n\\begin{align} \u0026amp; \\underset{\\alpha_1,\\alpha_2}{min}\\quad W(\\alpha_1,\\alpha_2)=\\frac{1}{2}K_{11}\\alpha_1^2+\\frac{1}{2}K_{22}\\alpha_2^2+y_1y_2K_{12}\\alpha_1\\alpha_2\\\\ \u0026amp; \\quad \\quad -(\\alpha_1+\\alpha_2)+y_1\\alpha_1\\sum\\limits_{i=3}^{N}y_i\\alpha_iK_{i1}+y_2\\alpha_2\\sum\\limits_{i=3}^{N}y_i\\alpha_iK_{i2}\\\\ \u0026amp; s.t. \\quad \\alpha_1y_1+\\alpha_2y_2=-\\sum\\limits_{i=3}^{N}y_i\\alpha_i\\\\ \u0026amp; \\quad \\quad \\quad0 \\leq \\alpha_i \\leq C,i=1,2 \\end{align}\n不等式约束使$α_1,α_2\\(在盒子\\)[0,C]×[0,C]$内； 等式约束使它们连成的直线在平行于盒子对角线的直线上。 由于$α_i$有取值范围，若最优点落在取值范围内，直接取值，否则取边界值。该过程称为剪辑。 先求沿着约束方向未经剪辑的解 再求剪辑后的解 引入函数对输入的预测值与真实输出之差的度量：\n\\[ E_i=g(x_i)-y_i=(\\sum\\limits_{j=1}^{N}\\alpha_jy_j(x_j\\cdot x_i)+b)-y_i \\]\n变量选择 外循环 违反 KKT 最严重的样本点； 检验样本点是否满足 KKT 条件； 内循环 希望目标函数具有足够大的变化；\\(max\\ |E_1-E_2|\\) 否则遍历间隔边界上的样本点； 每次完成两个变量优化后需要重新计算偏置$b$和\\(E_i\\) 最小二乘法 LSSVM 最小二乘法支持向量机将优化问题由非等式约束转为等式约束替换。\n\\begin{aligned} \u0026amp; \\underset{W,b}{min} \\quad \\frac{1}{2}\\Vert\\omega\\Vert^2+\\lambda\\sum\\limits_{i=1}^{N}\\xi_i^2 \\\\ \u0026amp; s.t. \\quad y_i(\\omega\\cdot x_i+b)=1-\\xi_i,\\quad i=1,2,\u0026hellip;,N \\end{aligned}\n其中，$λ$为正则化参数。\n对于非线性可分的训练样本，可以将原始样本从映射到更高维的线性可分的空间中。设非线性变换$ϕ (x_i)$将$x_i$映射到更高维空间中，则上述约束条件改为\n\\[ s.t. \\quad y_i(\\omega \\cdot \\varphi (x_i)+b)=1-\\xi_i \\ ,\\quad i=1,2,\u0026hellip;,N \\]\n拉格朗日函数为：\n\\[ \\mathcal{L}(\\omega,b,e,\\alpha)=\\frac{1}{2}\\Vert\\omega\\Vert^2+\\lambda\\sum\\limits_{i=1}^{N}e_i^2-\\sum\\limits_{i=1}^{N}\\alpha_i\\{[y_i(\\omega\\cdot \\varphi(x_i)+b)]-1+\\xi_i\\} \\]\n按 KKT 条件依次求偏导：\n\\begin{aligned} \u0026amp; \\frac{\\partial \\mathcal L}{\\partial \\omega}=0 \\Rightarrow \\omega=\\sum\\limits_{i=1}^N\\alpha_i y_i\\varphi(x_i)\\\\ \u0026amp; \\frac{\\partial \\mathcal L}{\\partial b}=0 \\Rightarrow \\sum\\limits_{i=1}^N \\alpha_i y_i=0\\\\ \u0026amp; \\frac{\\partial \\mathcal L}{\\partial \\xi_i}=0 \\Rightarrow \\alpha_i=\\lambda \\xi_i \\\\ \u0026amp; \\frac{\\partial \\mathcal L}{\\partial \\alpha_i}=0 \\Rightarrow y_i[\\omega \\cdot \\varphi(x_i)+b]-1+\\xi_i=0 \\ ,\\quad i=1,2,\u0026hellip;,N \\end{aligned}\n可通过矩阵运算求解$α=[α_1,\u0026hellip;,α_m]$和$b$：\n\\begin{equation} \\left[ \\begin{array}{c} 0 \u0026amp; \\vec{1}^T \\\\ 1 \u0026amp; \\Omega+\\frac{1}{\\lambda}E \\\\ \\end{array} \\right] \\cdot \\left[ \\begin{array}{c} b \\\\ \\alpha \\\\ \\end{array} \\right] =\\left[ \\begin{array}{c} 0 \\\\ y \\\\ \\end{array} \\right] \\end{equation}\n其中\\(\\vec{1}^T=[1,1,\u0026hellip;,1]^T\\)，$E$是单位矩阵，\\(Z=(\\varphi(x_1)y_1,\u0026hellip;,\\varphi(x_N)y_N)\\)，\\(\\Omega=ZZ^T\\)。\n求解得决策函数\n\\[ f(x)=sign(\\sum\\limits_{i=1}^N\\alpha_i y_i K(x,x_i)+b) \\]\n最小二乘法支持向量机模型中支持向量的拉格朗日乘子\\(\\alpha_i=\\lambda\\xi_i\\)，因此基本不为 0，几乎所有样本都是支持向量。\nLSSVM 的优点：运算迅速，计算简单；\nLSSVM 的缺点：\n最小二乘法支持向量机对异常点敏感； 最小二乘法缺少稀疏性。 ","permalink":"https://endlesspeak.github.io/docs/docs/machinelearning-doc/traddional-machine-learning/3-svm-derivation/","tags":[],"title":"支持向量机推导"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Project Init Project 从 github 上克隆代码，以此作为工作目录，克隆完成后进入工作目录。\ngit clone https://github.com/endlesspeak/rosracecar Racecar_ws cd Racecar_ws 配置环境变量，以便每次启动项目不必切换到工作目录。编辑 ~/.bashrc\nsource ~/Racecar_ws/devel/setup.bash Run Project 通过键盘控制测试小车，开启三个标签终端，依次执行下面的命令。\nroslaunch bringup racecar.launch rosrun racecar_description servo_commands.py rosrun racecar_description keyboard_teleop.py ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/ros-doc/3-racecarnotes/","tags":[],"title":"Race Car Project"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"ROS HelloWorld Create Project 创建项目的顺序如下：\n创建工作空间 将工作空间命名为 ROSRace\nmkdir -p ROSRace/src cd ROSRace catkin_make 创建功能包 将功能包命名为 helloworld ，并添加所需的依赖。\nroscpp 是用 C++ 实现的库； rospy 是用 python 实现的库； std_msgs 是标准消息库 cd src catkin_create_pkg helloworld roscpp rospy std_msgs Edit Source File 编辑源文件(C++)\ncd helloworld/src vim helloworld_c.cpp 输入以下内容：\n//包含ros的头文件 #include \u0026quot;ros/ros.h\u0026quot; //编写main函数 int main(int argc,char* argv[]){ //执行ros节点初始化 ros::init(argc,argv,\u0026quot;hello_node\u0026quot;); //创建ros节点句柄，非必须 ros::NodeHandle n; //控制台输出日志 ROS_INFO(\u0026quot;hello world!\u0026quot;); return 0; } 编辑源文件(Python)\ncd helloworld mkdir scripts # python 文件必须在该文件夹下 输入以下内容：\n#! /usr/bin/env python \u0026quot;\u0026quot;\u0026quot; Python 版 HelloWorld \u0026quot;\u0026quot;\u0026quot; import rospy if __name__ == \u0026quot;__main__\u0026quot;: rospy.init_node(\u0026quot;Hello\u0026quot;) rospy.loginfo(\u0026quot;Hello World!!!!\u0026quot;) chmod +x helloworld_py.py 编辑配置文件(C++) 编辑功能包下的 cmake 文件，~vim CMakeLists.txt~ ，修改以下内容:\nadd_executable( ${PROJECT_NAME}_node src/helloworld_c.cpp ) target_link_libraries( ${PROJECT_NAME}_node ${catkin_LIBRARIES} ) 注意：\n如 add_dependencies 未注释，则注释该项 需要修改源文件名与 add_executable 中的内容一致 如需修改生成的可执行文件名，可修改 project(helloworld) 中的内容 编辑配置文件(Python)\ncatkin_install_python(PROGRAMS scripts/helloworld_py.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) Compile and Excute 编译并执行步骤如下：\n回到工作空间目录 输入 catkin_make 编译所有 C++ 内容，python 文件是即时解释执行不需要编译 执行下面的命令，特别地，如不执行第二行，则会报找不到 helloworld 包。 roscore source ./devel/setup.bash # use zsh if you need # C++ rosrun helloworld helloworld_node # Package_name + target_name # Python rosrun helloworld helloworld_py.py Locale 解决乱码问题，以下方法任选一种。\n在 cpp 源文件中加入一行 setlocale(LC_ALL,\u0026quot;\u0026quot;); 在 cpp 源文件中加入一行 setlocale(LC_ALL,\u0026quot;zh_CN.utf8\u0026quot;); Terminal Reuse 在 ROS 中，需要频繁的使用到终端，且需要同时开启多个进程，因此需要用到终端复用工具。\nterminator tmux VSCode Extensions 首先建议 VSCode 安装原版而非开源的社区驱动版本，便于下载插件。\n其次建议安装下列插件：\nC/C++ Python ROS CMake 为使界面显示正常，=Arch Linux= 建议安装 ttf-ms-font\nUsage 创建工作空间和 HelloWorld 的步骤一样。\n编译 ROS 可使用快捷键 Ctrl+Shift+B 调用，选择 catkin_make:build ，点击右侧的齿轮，会自动生成 .vscode/task.json ，点击修改\n注意：如修改为下列内容\n\u0026quot;type\u0026quot; : \u0026quot;shell\u0026quot;, \u0026quot;command\u0026quot; : \u0026quot;catkin_make\u0026quot;, 则表示执行命令为 /usr/bin/zsh -c '...' ，通常该形式的命令不会从 .zshrc 中加载，因而不包含 /opt/ros/noetic/bin 环境变量\n对工作空间的 src 右键点击 create catkin packages 可以创建功能包，回答包名和依赖即可\n修改 .vscode/c_cpp_properties.json 的内容\n\u0026quot;cStandard\u0026quot; : \u0026quot;gnu17\u0026quot;, \u0026quot;cppStandard\u0026quot; : \u0026quot;c++17\u0026quot; Launch 使用 launch 一次性启动多个 ros 节点\n选择功能包，右击，添加一个 launch 文件夹\n选定 launch 文件夹，右击，添加一个 launch 文件，如 start_turtle.launch\n编辑 launch 文件内容\n\u0026lt;launch\u0026gt; \u0026lt;!--添加被执行的节点--\u0026gt; \u0026lt;!--乌龟GUI--\u0026gt; \u0026lt;node pkg=\u0026quot;turtlesim\u0026quot; type=\u0026quot;turtlesim_node\u0026quot; name=\u0026quot;turtle_GUI\u0026quot; /\u0026gt; \u0026lt;!--乌龟键盘控制--\u0026gt; \u0026lt;node pkg=\u0026quot;turtlesim\u0026quot; type=\u0026quot;turtle_teleop_key\u0026quot; name=\u0026quot;turtle_key\u0026quot; /\u0026gt; \u0026lt;!--HelloWorld--\u0026gt; \u0026lt;node pkg=\u0026quot;helloworld\u0026quot; type=\u0026quot;helloworld_node\u0026quot; name=\u0026quot;hello\u0026quot; output=\u0026quot;screen\u0026quot; /\u0026gt; \u0026lt;/launch\u0026gt; 其中：\nnode 是包含的某个节点 pkg 是功能包 type 是被运行的节点文件 name 是为节点命名 output 设置日志的输出目标 运行 launch 文件\nroslaunch helloworld start_turtle.launch ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/ros-doc/2-intergrateenvironment/","tags":[],"title":"Intergrate Environment"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"由于Gentoo Linux 配置显卡驱动需要额外设置内核，因此记录下配置的内容。\nKernel Dist Kernel 编辑 x11-drivers/nvidia-drivers 所需要使用的 use 选项，加入 dist-kernel 这一项。\nCustom Kernel 依次开启下列选项：\nCONFIG_MODULES CONFIG_MTRR CONFIG_VGA_ARB CONFIG_ACPI_IPMI CONFIG_AGP 内核版本 在 5.15 及以前的需开启 CONFIG_SYSFB_SIMPLEFB CONFIG_FB_SIMPLE 注意开启该选项需要关闭 Simple framebuffer device 在 5.15 以后的需开启 CONFIG_SYSFB_SIMPLEFB CONFIG_FB_SIMPLEDRM 依次关闭下列选项：\nCONFIG_FB_NVIDIA CONFIG_FB_RIVA CONFIG_DRM_NOUVEAU Install Use 推荐添加 tool 选项，如果为 wayland 安装，也可以加入 wayland 选项。\nEmerge 用此命令安装驱动 emerge -av x11-drivers/nvidia-drivers\nSettings Modules 输入 ~sudo vim /etc/modprobe.d/blacklist.conf~。\nblacklist nouveau blacklist lbm-nouveau options nouveau modeset=0 Config Generate Config 生成 nvidia prime config 文件\nmv /etc/X11/xorg.conf /etc/X11/xorg.conf.bak sudo nvidia-xconfig --prime CheckID 检查显卡的 PCI 地址 lspci 查找显卡前面的数字，与 /etc/X11/xorg.conf 中的是否相符。\nLaunch Config 若使用启动管理器，则编辑启动管理器的配置 例如使用 sddm ，则 vim /usr/share/sddm/scripts/Xsetup 若使用窗口管理器，则 vim .xinitrc 然后加入下面的内容。\nxrandr --setprovideroutputsource modesetting NVIDIA-0 xrandr --auto Modprobe Load in kernel as module 将 nvidia 模块加入内核，由于该驱动是闭源软件，不能直接编译进内核，而必须作为模块加载。\n每次重新编译内核之后，都需要重新部署。\nemerge -av @module-rebuild 重新加入内核，若第一次加入内核，只需执行最后的命令。\nlsmod | grep nvidia sudo rmmod nvidia sudo modprobe nvidia Load at startup 加载 nvidia 模块有多种设置办法。\n通过 grub 向内核传递参数 输入 sudo vim /etc/default/nvidia 输入内容 # Append parameters to the linux kernel command line GRUB_CMDLINE_LINUX=\u0026quot;nvidia-drm.modeset=1\u0026quot; 在配置文件中设置，让内核自动加载 输入 sudo vim /etc/modules-load.d/nvidia.conf 输入内容 nvidia 输入 sudo vim /etc/modprobe.d/nvidia-drm.conf 输入内容 options nvidia-drm modeset=1 在启动图形界面前加载 输入 vim ~~/StartXorg.sh #!/bin/bash sudo modprobe nvidia_drm nvidia_modeset nvidia \u0026amp;\u0026amp; startx 添加执行权限后，每次用该脚本启动。 Reference https://wiki.gentoo.org/wiki/NVIDIA/nvidia-drivers\n","permalink":"https://endlesspeak.github.io/docs/build/operating-system-configuration/linux-technology-5-3-gentoo-nvidia/","tags":[],"title":"Gentoo Linux Nvidia 显卡驱动"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Linux内核的配置大同小异，但是Gentoo Linux 官方软件源提供了多种内核的源码，并且配置多内核之间的切换非常方便，而Arch也提供软件包的形式下载或自行克隆仓库，因此以Gentoo/Arch下配置为例进行说明。\n写在前面 参考文献 LINUX 内核技术手册 LINUX KERNEL IN A NUTSHELL Linux-4.4-x86_64 内核配置选项简介 参阅更多 www.jinbuguo.com 写作动机 工作应用 嵌入式实时操作系统需要裁剪内核以获得专用性、适配性和性能 定制内核是成为 Linux 内核开发者的基本任务 个人应用 Linux From Scratch Special Hardware Adjustment 构建内核 源码获取 Gentoo 官方以软件包的形式提供内核源码，因此可用 emerge 直接安装。\nemerge -av sys-kernel/gentoo-source\remerge -av sys-kernel/gentoo-kernel\remerge -av sys-kernel/genkernel\rArch 官方提供的内核是编译过的，如需获得内核源码，需在 https://wiki.archlinux.org/title/Kernel 处选择版本，然后下载或克隆下来。\ngit clone https://github.com/archlinux/linux.git ./src/linux-5.19 --depth=1\rGentoo 由于 eselect 的存在，可以将源码保存到 /usr/src 目录下；而 Arch 由于需要手动克隆，因此建议放到 ~ 下。\n配置 通过下面的命令配置内核，生成的配置文件为 .config 。\n最基本的方法 使用 make config ，内核配置程序将逐步跟踪每一个配置选项并向用户询问，回答方式是 [y/n/m/?] y 直接构建为内核一部分； n 不构建； m 构建成模块，按需加载； ? 打印帮助\n使用默认配置选项 make defconfig 或 make ${PLATFORM}_defconfig 基于某种体系结构的一般性选项。 make localmodconfig 针对当前硬件进行适配性优化，可选的组件以模块方式加载。 make localyesconfig 对所有可选的组件均构建成为内核的一部分。 make oldconfig 根据之前的配置自动回答，仅向用户询问新配置项。 对所有配置选项统一操作 make allyesconfig 尽可能所有配置项均编译进内核 make allmodconfig 尽可能所有配置项都以模块方式构建 make allnoconfig 尽可能所有配置项都不构建 make randconfig 是否选择构建配置项交给天意。 make tinyconfig 构建一个可能的最小内核。(除开配置项外还有其他的缩减) 手动配置 make menuconfig 或 make nconfig 命令行配置方法，适用于 tty 环境，特别地，后者界面中斜体表示选中 make xconfig 或 make gconfig 图形化配置方法，前者基于 QT 后者基于 GTK 构建 全部构建 特别地，不应该在 root 权限下构建内核，而应该使用权限代理工具，如 sudo 或 doas\nmake #单线程\rmake -j6 #多线程\rmake -j6 modules_install #安装构建好的模块\rmake install #安装内核映像\r部分构建 指明特定的构建位置 make drivers/usb/serial 构建模块 make M=dirvers/usb/serial 链接合并 make 输出位置 例如，如果源码保存在只读位置上；或需要以普通身份构建内核，而源码在系统目录中，执行下面的命令：~make O=~/Develop/src/linux~\n交叉编译 交叉编译的意思是编译环境和运行环境不同。 内核的交叉编译特性允许更强大的机器为较小的嵌入式系统构建内核。\nmake ARCH=x86_64 defconfig\rmake ARCH=arm CROSS_COMPILE=/usr/bin/arm-linux-\r编译器 如需选择其他编译器程序，请输入： make CC=\u0026quot;ccache gcc\u0026quot; make CC=\u0026quot;ccache distcc\u0026quot;\n清理构建 make clean 移除几乎所有生成的文件，但保留配置文件和足够的构建支持以构建外部模块 make mrproper 移除所有生成的文件，包括配置文件和一些备份文件 make distclean 移除 所有 生成的文件，包括任何可能的补丁文件等 升级构建 获取新的源代码（可以重新克隆，也可以直接从远程合并） 无论如何，避免以为源码树打 patch 的方式更新。如遇冲突，工作量太大。 make oldconfig 配置驱动 发行版配置 各个发行版都提供内核配置文件，它们保存在 /proc/config.gz 中。如需以该配置作为基础配置内核，运行下面的命令\nzcat /proc/config.gz \u0026gt; ~/Develop/src/linux\rcp /prco/config.gz ~/Develop/src/linux\rgzip -dv config.gz\r设备查找 查找驱动名称 通过下面的脚本查找硬件设备所依赖的内核驱动的名称。\n#!/bin/sh\r#\r# Find all modules and drivers for a given class device.\r#\rif [ $# != \u0026quot;1\u0026quot; ] ; then\r# $# 表示的是传递给脚本或函数的参数个数(argc)\recho\recho \u0026quot;Script to display the drivers and modules for a specified sysfs class device\u0026quot;\recho \u0026quot;usage: $0 \u0026lt;CLASS_NAME\u0026gt;\u0026quot;\recho\recho \u0026quot;example usage:\u0026quot;\recho \u0026quot; $0 sda\u0026quot;\r# $0 表示的是当前脚本的文件名\recho \u0026quot;Will show all drivers and modules for the sda block device.\u0026quot;\recho\rexit 1\rfi\rDEV=$1\r# $1表示的是传递给脚本或函数的参数(在本脚本中只接受一个参数)\rif test -e \u0026quot;$1\u0026quot;; then\r# test -e测试文件是否存在，这里测试是否是当前目录文件\rDEVPATH=$1\relse\r# find sysfs device directory for device\r# 从 /sys/class 目录查找设备\rDEVPATH=$(find /sys/class -name \u0026quot;$1\u0026quot; | head -1)\r# find [path] -name [filename] 根据设备名在对应路径查找\r# 管道 head -1显示的是第一个结果\rtest -z \u0026quot;$DEVPATH\u0026quot; \u0026amp;\u0026amp; DEVPATH=$(find /sys/block -name \u0026quot;$1\u0026quot; | head -1)\r# test -z当且仅当字符串是0时返回真，否则返回假\r# 当前一条语句顺利执行，则此处短路；前一条语句无结果才继续执行后面\rtest -z \u0026quot;$DEVPATH\u0026quot; \u0026amp;\u0026amp; DEVPATH=$(find /sys/bus -name \u0026quot;$1\u0026quot; | head -1)\rif ! test -e \u0026quot;$DEVPATH\u0026quot;; then\recho \u0026quot;no device found\u0026quot;\rexit 1\rfi\rfi\recho \u0026quot;looking at sysfs device: $DEVPATH\u0026quot;\rif test -L \u0026quot;$DEVPATH\u0026quot;; then\r# resolve class device link to device directory\r# test -L 检查字符串是否存在且是链接文件\rDEVPATH=$(readlink -f $DEVPATH)\r# readlink 打印解析的符号链接或规范文件名\r# -f 递归跟随给出文件名的所有符号链接以标准化，除最后一个外所有组件必须存在\recho \u0026quot;resolve link to: $DEVPATH\u0026quot;\rfi\rif test -d \u0026quot;$DEVPATH\u0026quot;; then\r# resolve old-style \u0026quot;device\u0026quot; link to the parent device\r# test -d 检查是否是目录类型\rPARENT=\u0026quot;$DEVPATH\u0026quot;;\rwhile test \u0026quot;$PARENT\u0026quot; != \u0026quot;/\u0026quot;; do\rif test -L \u0026quot;$PARENT/device\u0026quot;; then\rDEVPATH=$(readlink -f $PARENT/device)\recho \u0026quot;follow 'device' link to parent: $DEVPATH\u0026quot;\rbreak\rfi\rPARENT=$(dirname $PARENT)\r# dirname是寻找当前目录的上级目录\rdone\rfi\rwhile test \u0026quot;$DEVPATH\u0026quot; != \u0026quot;/\u0026quot;; do\rDRIVERPATH=\rDRIVER=\rMODULEPATH=\rMODULE=\rif test -e $DEVPATH/driver; then\rDRIVERPATH=$(readlink -f $DEVPATH/driver)\rDRIVER=$(basename $DRIVERPATH)\r# basename 是去除路径得到文件名\recho -n \u0026quot;found driver: $DRIVER\u0026quot;\rif test -e $DRIVERPATH/module; then\rMODULEPATH=$(readlink -f $DRIVERPATH/module)\rMODULE=$(basename $MODULEPATH)\recho -n \u0026quot; from module: $MODULE\u0026quot;\rfi\recho\rfi\rDEVPATH=$(dirname $DEVPATH)\rdone\r查找内核选项 通过上面脚本查找到的硬件设备对应的内核驱动名称，到内核的源码树中读取 Makefile 并从中找到对应的真正的内核选项名称。\nfind -type f -name Makefile | xargs grep \u0026quot;ModulesName\u0026quot;\r特别地：\n有些选项的内核驱动名是以下划线连接的，而在内核选项名称中是以横线连接，因此寻找时需要尝试。 有些设备是系统内核自行创建的虚拟设备(逻辑设备)，因此脚本查找不到物理驱动(因为对逻辑设备来说本来就不需要物理驱动) 查找到内核选项名称后，进入配置界面，通过搜索查看对应需要配置的选项。\n快速查找设备 通过下面的脚本自动化查找硬件驱动，弊端是会掺杂很多无关的驱动。\n#!/bin/bash\rfor i in `find /sys/ -name modalias -exec cat {} \\;`; do\r/sbin/modprobe --config /dev/null --show-depends $i ;\rdone | rev | cut -f 1 -d '/' | rev | sort -u\r脚本解释：\n查找 /sys 下名称为 modalias 的所有文件 modalias 是一个 sysfs 技巧，它将硬件信息导出到该文件；参考 wiki.archlinux.org/title/Modalias 依次查看找到的文件，其中 {} 是占位符，表示找到的文件的名字； 其中用转义 \\; 表示 -exec 的结束，因为 shell 已使用 ; 作为命令分隔符； 调用 /sbin/modprobe 检查内核依赖，列出模块的依赖项(包括模块本身)，使用缺省设置 反转两次字符，在两次反转之间取第一个字段，分隔符是斜杠，目的是得到最后一段字符 将结果排序输出，=-u= 表示 unqiue ，删除重复行 添加固件 Gentoo 和 Arch 支持通过安装软件包组的方式安装固件。安装完成的路径在 /lib/modules\nsudo emerge sys-kernel/linux-firmware\rsudo pacman linux-firmware\r向内核中添加固件的步骤： Device Drivers -\u0026gt; Generic Driver Options -\u0026gt; Firmware loader -\u0026gt; Build named firmware blobs into the kernel binary\n特别地，只需要填写固件名，构建时系统会自动去源码目录下的 ./modules 下去寻找，需要更改目录为 /lib/modules ，同时多个固件之间以空格隔开。\n如果硬件驱动是直接编译进内核，且无法正常工作，则需要将固件编译到内核中。因此硬件不能正常工作时：\n排查问题 lspci -k 观察硬件驱动是否正确加载 sudo dmesg | grep \u0026quot;error\u0026quot; 解决办法 尝试把问题所在的硬件驱动编译成模块重试 尝试将固件编译进内核，例如 regulatory.db 尝试查找资料，有的硬件需要其他操作 如笔记本 3.5mm 耳机接口需要在 /etc/modprobe.d/ 中单独编辑配置，参考 Correctly Detected Microphone 定制内核 General Setup Kernel compression mode LZ4 高压缩比的同时性能最强 XZ 极高压缩比，但性能有损失 POSIX Message Queues 在 POSIX 消息队列中，每条消息都有一个优先级，它决定了进程接收消息的先后顺序。 如果你想编译和运行那些使用\u0026quot;mq_*\u0026ldquo;系统调用的程序，或者需要使用 Docker 容器,就必须开启此选项。 POSIX 消息队列可以作为\u0026quot;mqueue\u0026quot;文件系统挂载以方便用户对队列进行操作。不确定的选\u0026quot;Y\u0026rdquo;. Enable process_vm_readv/writev syscalls 提供 process_vm_readv 和 writev syscalls 系统调用 允许程序以正确的优先级直接读或写另一进程的地址空间 uselib syscall 建议禁止，因为现在大部分人在用 glibc 而不是 libc5 或更早 Auditing support 提供应用于内核子系统的审计基础设施，例如 SELinux 等等 有关审计系统调用的支持包含在支持它的体系结构中 Timers subsystem Timer tick handling Periodic timer ticks(constant rate,no dynticks) 强制按固定频率触发时钟中断，最耗电，当然性能最好 Idle dynticks system(tickless idle) 空闲状态不产生不必要的时钟中断，降低处理器能耗 Full dynticks system(tickless) 即使在忙碌状态也尽可能关闭所有时钟中断 High Resolution Timer Support 高精度定时器(hrtimer)用于取代传统 timer wheel(基于 jiffies 定时器)的时钟子系统 可以降低与内核其他模块的耦合性,还可以提供比 1 毫秒更高的精度(因为它可以读取 HPET/TSC 等新型硬件时钟源) 可以更好的支持音视频等对时间精度要求较高的应用，如 pulseAudio 等等，因此建议选\u0026quot;Y\u0026quot; 特别地，此处\u0026quot;定时器\u0026quot;是指\u0026quot;软件定时器\u0026quot;,而不是主板或 CPU 上集成的硬件时钟发生器(ACPI PM Timer/HPET Timer/TSC Timer) Preemption Model 内核抢占模式 No Forced Preemption 禁止内核抢占，适合服务器、科学计算 Voluntary Kernel Preemption 自愿内核抢占，提高响应速度，对吞吐量有影响 Preemptible Kernel 主动内核抢占，允许抢占所有内核代码，适合实时操作系统、高响应桌面环境，但对吞吐量的影响也更大 CPU/Task time and stats accounting CPU time accounting Simple tick based cputime accounting 简单的基于滴答的统计,适用于大多数场合 Full dynticks CPU time accounting 利用上下文跟踪子系统,通过观察每一个内核与用户空间的边界进行统计 该选项对性能有显著的不良影响,目前仅用于完全滴答子系统的开发调试 BSD Process Accounting 用户空间程序可以要求内核将进程的统计信息写入一个指定的文件 主要包括进程的创建时间/创建者/内存占用等信息 内核开发者认为这通常是一个好主意，建议选择 Namespaces support 命名空间支持.主要用于支持基于容器的轻量级虚拟化技术 UTS namespace uname()系统调用的命名空间支持 IPC namespace 进程间通信对象 ID 的命名空间支持 User namespace 允许容器使用 user 命名空间 建议同时开启 CONFIG_MEMCG 和 CONFIG_MEMCG_KMEM systemd 服务单元依赖该项 PID namespaces 进程 PID 命名空间支持 Network namespaces 网络协议栈的命名空间支持，systemd 服务单元依赖该项。 Checkpoint/restore support 在内核中添加\u0026quot;检查点/恢复\u0026quot;支持 添加一些辅助的代码用于设置进程的 text, data, heap 段,并且在 /proc 文件系统中添加一些额外的条目 用于检测两个进程是否共享同一个内核资源的 kcmp()系统调用依赖于它 使用 systemd 建议开启此项 使用 intel 核显驱动 mesa 建议开启此项 Automatic process group scheduling 每个 tty 动态地创建任务分组(cgroup)，可以降低高负载情况下的桌面延迟 桌面用户建议开启，而服务器建议关闭. Initial RAM filesystem and RAM disk (initramfs/initrd) support 初始内存文件系统，占用额外的容量和性能。 Compiler optimization level 编译优化级别 Optimize for performance O2 级别的优化 Optimize for size Os 级别的优化，可以得到更小的内核但运行速度更慢 通常用于专用操作系统，例如嵌入式系统 Processor type and features 中央处理器(CPU)类型及特性\nSymmetric multi-processing support 激活对 SMP(对称多处理器)的支持。如果是多个 CPU(包括多个 CPU 核心)选择此项。 Enable MPS table 仅古董级 SMP 系统需要，64 位系统支持 ACPI，因此可以安全地关闭 x86 CPU resource control support 启用 x86 CPU 资源控制支持，为 CPU 的系统资源的分配和监控提供支持。 Intel 称之为 Intel 资源控制器技术 AMD 称之为 AMD 平台服务质量 Support for extended (non-PC) x86 platforms 支持非标准的 PC 平台: Numascale NumaChip, ScaleMP vSMP, SGI Ultraviolet 绝大多数情况下不会使用这些平台 Intel Low Power Subsystem Support 为 Intel Lynx Point PCH 或更高级别芯片提供因特尔低电量子系统支持 Linux guest support 如果该内核在虚拟机中运行，开启本选项，否则就关闭 Processor family 按实际使用的处理器类型进行选择。 Generic-x86-64 表示通用于所有 x86-64 平台 Core 2/newer Xeon 支持 Core2 之后的所有 IntelCPU，包括 I3，I5，I7，I9 Opteron/Athlon64/Hammer/K8 支持 AMD 类型的 CPU Maximum number of CPUs 支持的最大逻辑 CPU 数量 Multi-core scheduler support 针对多核 CPU 进行调度策略优化 会略微增加日常开支 对计算机不一定会很有用，可能对 CPU 集群更有效 Reroute for broken boot IRQs 对某些(陈旧的)芯片组 bug 的修复功能 Machine Check / overheating reporting CPU 检测到硬件故障时通知内核，以使内核采取相应的措施 只需要开启对应 CPU 的支持(Intel or AMD) Machine check injector support MCE 注入支持，仅用于内核调试 Performance monitor support 对 CPU 进行性能监控的框架支持 只需要开启对应 CPU 的支持(Intel or AMD) IOPERM and IOPL Emulation 提供设置端口权限的系统调用，以获取对端口进行 I/O 操作权限 CPU microcode loading support CPU 的微码支持，提高 CPU 的稳定性 Enable 5-level page tables support 5 级页表支持仅在使用很大的内存(64TiB 物理地址空间或 256TiB 逻辑地址空间)和极高线程时才建议启用 开启后支持 4PiB 物理地址空间或 128PiB 逻辑地址空间 即使是计算机集群或超级计算机，对其中的单个计算机也很少有如此高内存的情况(当然确实存在) 该选项是对未来大内存地址空间的一种实现目标 NUMA Memory Allocation 开启 NUMA(Non Uniform Memory Access) 支持 虽然说集成了内存控制器的 CPU 都属于 NUMA 架构，但对于大多数只有一颗物理 CPU 的个人电脑而言，即使支持 NUMA 架构，也没必要开启此特性. 可以参考 SMP/NUMA/MPP 体系结构对比 SMP for Symmetric multi-processor NUMA for Non Uniform Memory Access MPP for Massive Parallel Processing 对于不支持\u0026quot;虚拟 NUMA\u0026quot;或\u0026quot;虚拟 NUMA\u0026quot;被禁用的虚拟机(即使所在的物理机是 NUMA 系统)，应该关闭此项 Check for low memory corruption 低位内存脏数据检查，可关可不关 需要该选项与 memory_corruption_check=1 内核引导参数配合使用 通过开启 Set the default setting of memory_corruption_check 选项设置默认开启上述选项 该选项的原理是在 BIOS 存在问题时： 每 60s 扫描一次 扫描周期可通过 memory_corruption_check_period 内核参数调整 扫描范围是 0-64k 内存地址 扫描范围可通过 memory_corruption_check_size 内核参数调整 Memory Type Range Register support 存储器类型范围寄存器支持 其下级选项 MTRR cleanup support 是将 MTRR 内存布局由连续转为离散，以利于 X 驱动添加写回条目 MTRR cleanup enable value 建议图形界面用户设为\u0026quot;1\u0026quot;，仅在开启后导致无法正常启动或者显卡驱动不能正常工作的情况下才需要关闭 MTRR cleanup spare reg num 指示内核可供清理或修改的内存段个数(参考 /proc/mtrr) 通常保持默认值\u0026quot;1\u0026quot;，修改通常是为了解决某些 MTRR 故障。 Memory Protection Keys 内存保护密钥提供一种用于强制执行基于页面的保护，但在应用程序更改保护域时不需要修改页面表 TSX enable mode Intel 事务扩展技术是 intel 为旗下的 CPU 开发的一项优化指令集 存在僵尸负载漏洞（ZombieLoad） 开启 TSX 后，在编译程序时速度有小幅度的提升 牺牲内核安全性换取性能 kexec system call 提供系统调用，允许在运行某内核后关闭它本身并运行另一个内核，即使不是 Linux 内核 由于其所依赖的硬件接口在快速变化，因此无法给出好的建议 kernel crash dumps 依赖于 kexec 系统调用，因此应对两者作相同的选择 Mitigations for speculative execution vulnerabilities 缓解或修复推断性执行漏洞的内核补丁\nAvoid speculative indirect branches in kernel CPU 会提前执行 jmp 或 call 等跳转指令的下一句，原理是将该句存到 RSB 栈中 病毒可能展开 CPU 预测分支执行，因此需要在该句之后添上一端无用的死循环代码，使 CPU 预测分支执行无用化 redpoline 因此而生，显然该补丁会带来性能损失 Enable IBPB on kernel entry 为内核编译 retbleed=ibpb 补丁 Enable IBRS on kernel entry 为内核编译 spectre_v2=ibrs 补丁 Power management and ACPI options Suspend to RAM and standby 即休眠到内存。系统休眠后，除了内存之外，其他所有部件都停止工作，重开机之后可以直接从内存中恢复运行状态 通过命令 echo mem \u0026gt; /sys/power/state 使用此功能 Hibernation (aka \u0026lsquo;suspend to disk\u0026rsquo;) 即休眠到硬盘。其他同上 通过命令 echo disk \u0026gt; /sys/power/state 使用此功能，前提是有内核引导参数 resume=/dev/swappartition Opportunistic sleep 激进的休眠方案，来源于安卓。理念是只要不工作，就开始休眠。 ACPI(Advanced Configuration and Power Interface) 高级配置与电源接口，包括了软件和硬件方面的规范,目前已被软硬件厂商广泛支持,并且取代了许多过去的配置与电源管理接口 CPU Idle 该指令可以让 CPU 在空闲时\u0026quot;打盹\u0026quot;以节约电力和减少发热 只要是支持 ACPI 的 CPU 就应该开启，又由于所有 64 位 CPU 都已支持 ACPI,所以开启 Cpuidle Driver for Intel Processors 该选项是专用于 Intel CPU 的 cpuidle 驱动 CONFIG_CPU_IDLE 则可用于非 Intel 的 CPU. Binary Emulations IA32 Emulation 提供兼容运行 32 位的应用程序支持(multilib)，建议开启。 x32 ABI for 64-bit mode 建议禁止 General architecture-dependent options Kprobes 主要用于内核调试，允许追踪几乎任何内核地址并执行回调函数 Optimize very unlikely/likely branches 启用透明的分支优化，使得执行几乎总是正确/错误的分支条件更少； 某些性能敏感的内核代码都有这样的分支并支持该优化技术 例如跟踪点、调度程序、网络、基于内核的虚拟机(KVM)等 此技术降低了开销，更多的是对处理器的分支预测施加压力，通常会使内核速度更快，而条件的更新速度则更慢，但这种情况总是非常罕见的 Enable seccomp to safely execute untrusted bytecode 启用 seccomp 安全执行不可信任代码 仅嵌入式系统应当否决 Use a virtually-mapped stack 该选项使用带保护页的虚拟映射内核堆栈，它的作用是立即捕获内核堆栈溢出而不是在造成难以诊断的损失之后。 开启需要支持一些条件，详见选项说明。 Enable loadable module support 激活可加载模块支持\nForced module loading 允许使用 modprobe --force 命令，它将在不校验版本信息的情况下强制加载模块，建议关闭 Module unloading 允许卸载已经加载的模块 如果将模块静态编译进内核中，那么内核的执行效率会更好 如果代码作为动态模块加载，那么不使用时可以减少内核的内存使用并减少启动的时间，然而内核和模块在内存上相互独立又会影响内核的执行性能 Forced module unloading 允许使用 rmmod -f 强制卸载正在使用的模块，建议关闭 Module versioning support 允许当前内核使用为其他内核版本编译的模块,可能会造成系统崩溃，建议关闭 Executable file formats 可执行文件格式/仿真\nKernel support for ELF binaries ELF 是最常用的跨平台二进制文件格式,支持动态连接,支持不同的硬件平台,支持不同的操作系统. Write ELF core dumps with partial segments 当打算在此 Linux 上开发应用程序或者帮助调试 bug 时开启 Kernel support for scripts starting with #! 支持以 #!/path/to/interpreter 运行的脚本 务必选 Y，除非你知道你自己在做什么 Kernel support for MISC binaries 允许插入二进制封装层到内核中 理论上允许直接运行 Java,.NET,Python,Emacs-lisp 等等 Enable the block layer 激活块设备支持\nPartition Types 支持不同的磁盘分区格式，务必选择此项 IO Schedulers 快速响应的实时系统可以选择 BFQ I/O scheduler ，即 BFQ 调度器 在开启了 BFQ 的条件下，可以禁用另外两个调度器 Memory Management options Support for paging of anonymous memory (swap) 使内核支持虚拟内存，即交换分区 仅在 PC 上使用，嵌入式系统不应开启，因为嵌入式系统主要使用 flash ，磁盘寿命远大于闪存 SLAB allocator 选择内存分配器 SLAB 该内存分配器在大多数情况下都具有良好的适应性 SLUB SLUB 与 SLAB 兼容,但通过取消大量的队列和相关开销,简化了 slab 的结构 在多核时 SLUB 拥有比 SLAB 更好的性能和更好的系统可伸缩性 Low address space to protect from user allocation 建议设置为 65536 Transparent Hugepages support 允许内核使用大页面和大快表，能够提高应用程序计算性能 原理是 加快内存分配期间的缺页中断速度 减少快表未命中的数量 加快页表的整体遍历(主要开销是换页而非向下查找) Enable idle page tracking 此功能允许估计在给定时间段内未触及的用户页面的数量，该信息可用于调整内存 cgroup 限制或计算集群内的放置作业。 检查选项 Basic CONFIG_FB FB for framebuffer 帧缓冲设备是对图形硬件的抽象 它把屏幕上的所有像素点都直接映射到一段线性的内存空间，为软件提供了访问图形硬件的统一接口，软件不需要了解硬件的底层细节(例如寄存器)，只要简单的改变相应内存位置的值，就能改变屏幕上显示的内容(颜色/亮度等) Xorg 的高度可移植性根源于此，图形界面用户必选 CONFIG_FRAMEBUFFER_CONSOLE 基于 Framebuffer 的图形模式控制台 KMS 特性依赖于它.CJKTTY 补丁也依赖于它 桌面用户必选\u0026quot;Y\u0026quot;(使用了 CONFIG_DRM_*的用户必须开启) 服务器以 UEFI 方式启动的也必选\u0026quot;Y\u0026quot;. CONFIG_FW_LOADER 向内核中编译固件 CONFIG_EXTRA_FIRMWARE CONFIG_EXTRA_FIRMWARE_DIR Networking support CONFIG_PACKET CONFIG_UNIX CONFIG_INET CONFIG_NETFILTER Netfilter 可以对数据包进行过滤和修改,可以作为 防火墙(packet filter or proxy-based) 网关 NAT 代理 proxy 网桥 NET_REDIRECT IPTABLES 参考 GentooWiki-iptables NFTABLES 参考 GentooWiki-nftables NAT NETFILTER_XT_NAT NET_ACT_NAT NF_NAT NF_NAT_FTP NF_NAT_IRC NF_NAT_MASQUERADE NF_NAT_REDIRECT 建议搜索 REDIRECT ，将所有实现网络透明代理的均选中 NFT_NAT PPP 参考 GentooWiki-PPP Graphics support CONFIG_AGP GART(图形地址重映射表)可以看做一种被各种显卡(不只是 AGP 显卡,还包括 PCI-E 显卡与集成显卡以及核心显卡)使用的\u0026quot;伪 IOMMU\u0026quot;(参见 CONFIG_GART_IOMMU 选项),它将物理地址不连续的系统内存映射成连续的\u0026quot;显存\u0026quot;供 GPU 使用 CONFIG_AGP_AMD64 提供 AMD 支持 CONFIG_AGP_INTEL 提供 Intel 支持 CONFIG_AGP_SIS 提供 SIS 芯片组支持 CONFIG_AGP_VIA 提供 VIA 芯片组支持 CONFIG_VGA_SWITCHEROO 用于多个显卡之间的切换 CONFIG_DRM Direct Rendering Manager 管理的是 Direct Rendering Infrastructure 主要用于硬件 3D 加速 CONFIG_SYSFB_SIMPLEFB 使用 VESA 和 UEFI 建议选择 CONFIG_DRM_SIMPLEDRM CONFIG_FRAMERBUFFER_CONSOLE 见前文 CONFIG_LOGO 启动时显示 LOGO Nvidia 有关英伟达显卡的问题，参阅文档。 Sound Card support 如果是笔记本，建议以模块形式编译本部分(尤其是 ALSA)\n","permalink":"https://endlesspeak.github.io/docs/build/operating-system-configuration/linux-technology-5-4-kernel/","tags":[],"title":"Linux Kernel Configuration"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Note Gentoo Linux是一个快速、现代的元发行版，它的设计简洁、灵活。具有自由、高性能、开放和稳定等优点。\nMotivation 自由 高度自由的选择，用户可以选择自己想要的组件 性能 通过编译期优化和链接期优化获得更好的使用体验，更差的安装体验 开放 大部分软件均以源码的形式发布，编译和安装，不对用户隐藏细节 稳定 滚动更新，但是是在保证稳定的基础上，除非破坏，否则基本不会崩溃 Reference Additional Gentoo Installtion ISO 并非不能使用 mount 操作步骤确实比其他发行版更复杂 fstab 可下载 gentoo 官方提供的 genfstab ，不必手动生成 init 系统的选择 Systemd 是目前主流的 init 系统，相当多的发行版正在使用，这包括 debian , redhat, arch, nixos 等等。 openRC 是 Gentoo 官方推荐的 init 系统 优点是可移植（移植到 freeBSD 或其他 unix 系统上） 缺点是管理的内容没有 systemd 丰富，需要设置更多的内容。 Requirement Hardware 由于绝大多数软件均需要通过源码编译，因此硬件不能过低。 我的配置是 Core I5-8250U,Mem 8GiB,Disk 120GiB Psychological expectation 不可避免地，源码编译会消耗大量的时间和精力，优化软件亦然。 因此确保： 你是狂热的开源软件爱好者/Linux 爱好者； 编译和优化所消耗的时间在你的承受范围内。 Start Network Gentoo 从软件仓库下载所有软件的源码（当然，基本的安装和编译环境仍由 gentoo 提供）因此连接互联网是必须的步骤\n有线网 dhcpcd 即可联网，否则参见 Reference 中的详细步骤。 建议尽量使用有线网络而非无线网络，因为内核中可能没有无线网卡驱动。 无线网 iw dev 或者 iwctl 配置无线网络。 最推荐的是 nmtui ，该命令属于 NetworkManager 软件包。 测试网络 使用 ping 命令，注意该命令发送的是 ICMP 报文，只能确保存在本机到远端的物理通路，但是仍然有可能无法连接互联网。 PreInstallation Installation media 安装介质的选择通常是 U 盘，特别地， 镜像写入方式没有明确限制 ，推荐使用 ISO 镜像。\nLinux 上可以选择 DD 镜像方式写入 dd if=\u0026lt;iso文件\u0026gt; of=/dev/\u0026lt;device\u0026gt; bs=1M status=progress Windows 上可以选择 Rufus 或者 UltraISO User Account 安装介质进入的 liveCD 系统通常不需要额外添加用户，但是如果需要使用额外的服务除外。\npasswd # 修改root用户密码 useradd -m -G wheel leesin # 添加用户，带有home目录，且在wheel用户组中 passwd leesin # 修改添加的账户的密码 由于 Gentoo Linux 的安全设置，设置的密码很可能因不够复杂而被系统拒绝，可以手动修改复杂程度规范，也可以在系统主机中设置 use 变量\nnano -w /etc/security/passwdqc.conf 说明：\ngentoo 的 livecd 默认只带有 nano arch 的 livecd 带有 vim，因此使用 arch 的 livecd 安装 gentoo 是一个好选择 Service 安装时需要查看文档 切换到 tty2 ，使用 root 或刚刚创建的用户登录。 使用 links ，访问 gentoo 的安装 wiki 。 安装时需要 SSH 远程登录 编辑 /etc/ssh/sshd_config 确保 PermitRootLogin yes ss -ntlp 查看 port 是否启用默认的 22 端口，也可以开启其他端口 IP 地址确认 如果是虚拟机，例如 VirtualBox： 依次点选 设置 端口转发，新增端口转发规则 主机端口只需要不和已有的端口冲突 子系统端口选择默认的 22，也可以设置其他的端口 如果是物理机，则需要额外的一台计算机： 连接到同一局域网 系统主机通过 ip address 查看 IP 地址 工具主机通过该地址连接 SSH 连接 假设 IP 地址为 192.168.2.1 ssh root@192.168.2.1/24 ssh -p 22 root@192.168.2.1/24 Partition 首先观察硬盘上所有的块设备。\nfdisk -l lsblk 然后判断电脑的引导方式和分区表类型。 引导模式分为 BIOS 和 UEFI 两种；分区表类型分为 MBR 和 GPT 两种。\nWindows 下\n判断电脑的引导模式 在运行对话框中输入 msinfo32 在弹出的系统信息(或在控制面板 / 系统与安全 / 管理工具 / 系统信息)中寻找到 BIOS 模式项，观察是否是 UEFI。 判断磁盘的分区类型 右击我的电脑 / 管理 / 右击磁盘管理 / 属性，在弹出的对话框中会显示磁盘分区形式 Linux 下 判断电脑的 BIOS 引导模式及分区类型\n法一，通过内核暴露的环境信息验证 ls /sys/firmware/efi/efivars 法二，通过磁盘上的分区格式验证 fdisk -l 检查是否有 EFI 分区格式，是否有 gpt 字样。 MBR 什么?你居然还在用 MBR ，哦我的天哪，我建议你立刻停止这种行为，除非你愿意去看看官方 wiki!\nGPT 一般地，分区需要指定至少 2 个挂载点，即 /boot 和 / 对于拥有一块固态硬盘，一块机械硬盘的电脑来说，挂载点通常如下：\n挂载点 文件系统 挂载位置(块设备) 挂载用途 大小 / ext4 /dev/sda6 根分区 记录几乎所有的内容 120GiB /boot fat32 /dev/nvme0n1p1 引导分区 引导进入系统 300MiB 分区命令 cfdisk /dev/nvme0n1 和 cfdisk /dev/sda 格式化命令\nmkfs.fat -F 32 /dev/nvme0n1p1 mkfs.ext4 /dev/sda6 开启交换文件(也可以设置交换分区)\ndd if=/dev/zero of=/mnt/gentoo/swapfile bs=1M count=8192 status=progress cd /mnt/gentoo chmod 600 ./swapfile mkswap ./swapfile swapon ./swapfile swapon --show 在完成安装后记得检查 /etc/fstab\n/swapfile none swap defaults 0 0 Mount 依次挂载。 特别地，如果 /dev/nvme0n1p1 带有 windows boot manager，一定要备份！\nmkdir --parents /mnt/gentoo/boot mount /dev/sda6 /mnt/gentoo mount /dev/nvme0n1p1 /mnt/gentoo/boot Stage 从镜像站中下载一个 stage 包。\n使用 links 使用 lynx wget curl 推荐地址 https://mirrors.tuna.tsinghua.edu.cn/gentoo/releases/amd64/autobuilds/\ntar xpvf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner 说明：\nxattrs: 开启扩展属性支持。 xattrs-include: 通过规则（通常是正则表达式的方式）指定需要开启扩展属性支持的文件。 Optimize Gentoo 需要指定编译参数，合适的优化能带来更强的使用体验。\n由于篇幅有限，不可能介绍所有的优化选项；特别地，优化标志不是越多越好，激进的在系统范围上使用的优化标志会伤害应用程序，因此三思而后行。\n有关 make.conf 的全部内容可以通过 man 5 make.conf 查找，这里仅介绍一些比较常用的配置。\n输入 vim /mnt/gentoo/etc/portage/make.conf\n# 为所有语言设置编译标志 COMMON_FLAGS=\u0026quot;-march=native -O2 -pipe\u0026quot; # 为两个变量使用相同的设置 CFLAGS=\u0026quot;${COMMON_FLAGS}\u0026quot; CXXFLAGS=\u0026quot;${COMMON_FLAGS}\u0026quot; COMMON_FLAGS -march=native CPU 指令集 不同的 CPU 支持不同的指令集，执行代码的方式也不相同。 该选项指明了编译器应该为系统的处理器架构生成何种代码。 通过 gcc -c -Q -march=native --help=target 或 cat /proc/cpuinfo 返回的结果填写本机需要的处理器架构，也可以直接使用默认值 -march=native -O2 该选项指明的 gcc 的优化级别标志，每提高一个优化等级都将激活大量的优化标志。主要有以下等级： -O0 完全关闭优化 不启用优化将导致某些程序无法正常工作，仅调试 -O1 最基本的优化 -O2 推荐的优化级别 推荐在系统范围内开启此项优化，并开启 -O3 中一些比较安全的选项。 -O3 可能的最高优化级别 特别需要注意，提高优化级别并不意味着性能一定随之提高，事实上过高的优化将导致汇编语言完全不可执行，从而使程序无法正常运行。 高优化级别将占用大量的内存。 -Os 优化代码大小 基于 -O2 且激活了在该级别上不会增加代码生成大小的选项，在小磁盘或小缓存机器上使用。 -Og 该选项是在 -O0 的级别上进行的优化 一般用于快速编译和调试，提供合理水平的运行时性能，禁用了可能干扰调试的优化 -Ofast 基于 -O3 并增加了额外的优化选项 此优化等级违反了严格的标准合规性，不建议使用。 -O4? 现实是高于 3 的级别没有效果，编译器可以接受这些标志，但实际上没有做 -O3 以外的任何事情。 -pipe 该选项用于提高编译速度，在编译的不同阶段使用管道而不是临时文件，代价是占用更多的内存。如果内存小于 4GB (当然小于 4GB 不推荐使用 gentoo)应当关闭该选项。 -fomit-frame-pointer 该选项将不把 frame pointer （栈帧指针）保存在寄存器中，旨在减少生成的代码大小。使用该选项将会使程序调试变得困难或几乎不可能。 该选项在 -O2 时开启。 -finline-functions 允许编译器选择某些简单的函数在其被调用处展开，比较安全的选项，特别是在 CPU 二级缓存较大时建议使用。 该选项在 -O3 时开启。 -funswitch-loops 将循环体中不改变值的变量移动到循环体之外。该选项可能导致问题。 该选项在 -O3 时开启。 -fgcse-after-reload 为了清除多余的溢出，在重载之后执行一个额外的载入消除步骤。 该选项在 -O3 时开启。 -fgraphite-identity 该选项可开启 gcc 编译时的 Graphite 优化，而且不会干扰 gcc 本身在编译程序时的优化判断。建议开启。 开启条件：在 use 中指定 graphite 后重新编译 gcc -floop-nest-optimize 启用基于 isl 的循环嵌套优化器。这是一个基于 Pluto 优化算法的通用循环嵌套优化器。它计算针对数据局部性和并行性优化的循环结构。 这个选项是实验性的。 -fno-math-errno 任何 -O 选项都不会启用此选项，因为它可能导致依赖于 IEEE 或 ISO 数学函数规则/规范的精确实现的程序输出不正确。 然而，对于不需要这些规范保证的程序，它可能会产生更快的代码。 -fno-trapping-math 假设浮点运算不生成用户可见的陷阱的情况下编译代码。这些陷阱包括除零、溢出、下溢、不精确结果和无效操作。 此选项要求 -fno 信号 NAN 有效。例如，如果依赖于“不间断”的 IEEE 算法，设置此选项可能允许更快的代码。 任何 -O 选项都不应启用此选项，因为它可能会导致依赖于 IEEE 或 ISO 数学函数规则/规范的精确实现的程序输出错误。 -fno-align-functions 通过设置 函数不对齐 提高编译速度。 函数对齐是指将函数的开头与大于或等于 n 的下一个二次幂对齐，最多跳过 m-1 个字节，以确保 CPU 至少可以获取函数的前 m 个字节，而不会越过 n 字节对齐边界。 -fno-align-loops 通过设置 循环不对齐 提高编译速度。 循环对齐是指将循环对齐到二次幂边界。 -fno-align-jumps 通过设置 跳跃时循环不对齐 提高编译速度。 跳跃时循环对齐是指将分支目标与二次方边界对齐，用于只能通过跳跃到达目标的分支目标。 -fno-align-labels 通过设置 标签不对齐 提高编译速度。 标签对齐是指将所有分支目标对齐到二次幂边界。 -fno-stack-protector 禁用 堆栈保护检查 以提高编译速度。这是以牺牲程序安全性为代价换取性能的设置。与 use=\u0026quot;-ssp\u0026quot; 配合使用。 堆栈保护检查是生成额外的代码来检查缓冲区溢出，例如堆栈粉碎攻击等。 该选项在 gcc 手册上仅解释了非 no 选项，默认开启。 -fno-semantic-interposition 禁用 动态链接器插入符号 ，以使得编译器能够执行过程间传播、内联和其他优化。 该选项在 gcc 手册上仅解释了非 no 选项，默认不开启。 -fno-common 要求编译器直接为变量分配空间。 -fcommon 要求编译器将变量放置在“公共”存储中。 -fipa-pta 进行过程间指针分析和过程间修改和参考分析。 此选项可能会导致在大型编译单元上使用过多的内存和编译用时。 因此默认情况下，它在任何优化级别都不会启用。 -fno-plt 不要将 PLT 用于与位置无关的代码中的外部函数调用。 此选项可能会导致生成更高效的代码，但也有可能导致编译出错。 Other FLAGS RUST_FLAGS 使用 -C 向 Rust 传递编译优化选项\nRUST_FLAGS=\u0026quot;-C opt-level=2 -C target-cpu=skylake\u0026quot; LD_FLAGS 使用 -Wl, 向链接器传递选项\nLDFLAGS=\u0026quot;-Wl,-O2 -Wl,--as-needed -Wl,--hash-style=gnu -Wl,--sort-common -Wl,--strip-all\u0026quot; \u0026ndash;as-needed 链接器会检查所有的依赖库，没有实际被引用的库，不写入可执行文件头。\n\u0026ndash;hash-style=gnu\n设置链接器哈希表的类型。默认是 sysv ，可以设置成 gnu ，也可以设置成 both 。 DT_HASH 是 ELF (Linux 可执行程序的文件类型)中的一个 sections，保存了用于查找符号的散列表，以支持符号表的访问，提高符号的搜索速度。 gnu.hash 提​供了​与 hash 段​相​同​的​功​能​；但​是与 hash 相比，增加了某些限制（附加规则），​带​来​了​ 50% 的​动​态​链​接​性​能​提​升，代价是不兼容。 \u0026ndash;sort-common 把全局公共符号按照大小排序后放到适当的输出节，以防止符号间因为排布限制而出现间隙。\n\u0026ndash;strip-all 从输出文件中忽略所有符号信息。\n\u0026ndash;static 不链接共享库（推迟到运行时）以提高链接速度，降低运行速度。\n可以选用其他链接器如 lld 或 gold 替代默认的 bfd 链接器，这可以适当加快链接速度。\n但是这样做可能导致在编译大型程序或底层程序时出错，例如 gcc ， glibc ， webkit ， qtwebengine\n设置方法：\nemerge -av lld LD_FLAGS=\u0026quot;-fuse-ld=lld\u0026quot; LD=/usr/bin/lld \u0026ndash;export-dynamic 此标志告诉链接器将所有符号添加到动态符号表中。\n\u0026ndash;whole-archive 将在其后面出现的静态库包含的函数和变量输出到动态库中。这通常用于将存档文件转换为共享库，强制将每个对象包含在生成的共享库中。\n-ljemalloc 特别不推荐在全局范围内使用 -ljemalloc （需要额外安装 jemalloc ),可能导致问题。\nMAKEOPTS 该选项设置并行编译的数量。\n-jX 指代并行编译的数量 建议每个 job 至少有 2 GiB RAM （所以 8 GiB 内存最多设置 -j4 ）。 避免内存溢出，根据可用内存降低 job 数量；如果内存足够，那么设置值一般在 CPUs+1 到 2*CPUs+1 之间。 -lX 指代平均并行编译的数量（保证不会超载） GENTOO_MIRRORS 设置 gentoo 源。\nGENTOO_MIRRORS=\u0026quot;https://mirrors.ustc.edu.cn/gentoo https://mirrors.tuna.tsinghua.edu.cn/gentoo\u0026quot; 注意 gentoo 源不是必须的，因为 gentoo portage 源提供的 ebuild 会指示软件源码的下载地址。 但是仍然推荐加入 gentoo 源，以缓解上游镜像仓库的压力，同时也能加快关键软件源码下载的速度。\nUSE\n如何知道一个软件包有哪些 use 选项？\nemerge -av app-portage/gentoolkit lto pgo graphite 为编译器开启三项优化 特别地，为了防止在全局开启上述优化选项导致程序不可用，将该部分单独配置。 输入 vim /etc/portage/package.use/gcc 并输入以下内容，注意后面几项是可选的。\nsys-devel/gcc lto pgo graphite objc objc++ valgrind -ssp emerge -av gcc X xorg 在编译软件时增加 X 和 xorg 支持，如果使用 xorg 环境建议全局开启。\nwayland 在编译软件时增加 wayland 支持，该项可以不开启。\n其他可选项\n最小化推荐的选项 use=\u0026quot;systemd dbus\u0026quot; 窗口管理器推荐的选项 use=\u0026quot;alsa pulseaudio policykit\u0026quot; 桌面环境推荐的选项 use=\u0026quot;udev kde gnome gtk qt4 qt5\u0026quot; 使用文件管理器 use=\u0026quot;udisks archive\u0026quot; 图形渲染器 use=\u0026quot;gles2 opengl glx vulkan nvidia\u0026quot; 中文支持 use=\u0026quot;cjk\u0026quot; 音视频可选支持 use=\u0026quot;ffmpeg\u0026quot; 远程登录可选支持 use=\u0026quot;openssl\u0026quot; 禁用复杂密码策略 use=\u0026quot;-passwdqc\u0026quot; 查看全局 USE 选项\nemerge --info | grep ^USE ACCEPT_KEYWORDS 一般支持的是 amd64 ，更加激进的选项是 ~amd64 。 注意后者表示软件版本尚未接受稳定性测试或软件表现不稳定。\nACCEPT_LICENSE 设置支持的开源协议。可以根据其授权协议接受或拒绝安装软件。 设置成 ACCEPT_LICENSE=\u0026quot;*\u0026quot; ，会少很多麻烦。\nGRUB_PLATFORMS 如果使用 GRUB ，那么可以设置成 GRUB_PLATFORMS=efi-64\nEMERGE_DEFAULT_OPTS 为 emerge 加入默认选项，这样就不必每次输入命令的时候都加入这些选项。\n\u0026ndash;keep-going 即使某一个软件或软件依赖安装出错，也尽可能向下执行（以继续安装其他软件或该软件的其他依赖） \u0026ndash;with-bdeps \u0026lt;y|n\u0026gt; 在依赖项计算中，引入不严格要求的构建时依赖项 \u0026ndash;jobs \u0026ndash;load-average 这些选项与 MAKEOPTS 同时使用时，有效的 job 数量可以指数式加速 L10N 指示计算机的语言支持。\nL10N=\u0026quot;en-US zh-CN en zh\u0026quot; VIDEO_CARDS 指示计算机的显卡支持。例如 UHD Graphics 630 属于 Gen8-Gen9。1\nVIDEO_CARDS=\u0026quot;intel nvidia\u0026quot; ALSA_CARDS 指示计算机的声卡支持。\nALSA_CARDS=\u0026quot;hda-intel\u0026quot; INPUT_DEVICES 指示计算机的输入设备支持。\nINPUT_DEVICES=\u0026quot;libinput synaptics\u0026quot; LLVM_TARGETS 如果你不知道 LLVM 是什么，那么略过此步骤。\nLLVM_TARGETS=\u0026quot;X86 NVPTX\u0026quot; #nvidia可开启NVPTX而A卡可开启AMDGPU ABI_X86 如果不知道 wine-staging 和 lutris ，那么略过此步骤。\nABI_X86=\u0026quot;64 32\u0026quot; FEATURES 仅介绍 ccache ，用于编译时出现错误或意外中断，下次编译时 ccache 可以直接命中缓存，节约编译时间。 在安装 emerge -av dev-util/ccache 之前不要加入下列内容。\nFEATURES=\u0026quot;ccache\u0026quot; CCACHE_DIR=\u0026quot;/var/cache/ccache\u0026quot; 修改文件夹的属主和权限\nmkdir -p /var/cache/ccache chown -R root:portage /var/cache/ccache chmod -R 2775 /var/cache/ccache 作一些基本配置，具体可参见 wiki 上的描述2。 vim /var/cache/ccache/ccache.conf\nmax_size = 2G umask = 002 cache_dir_depth = 3 CPU_FLAGS_X86 可以在这里直接加入计算机 CPU 的指令集，以达到优化的目的。 需要先安装软件包 cpuid2cpuflags ，输入命令： emerge --ask app-portage/cpuid2cpuflags 执行 cpuid2cpuflags ，将获得的 CPU 指令集填写到 make.conf 中。\n一切都修改完成，完成 chroot 且同步软件仓库后：\n重装 gcc 也可以额外装 gcc 版本 下载一个编辑器 比如说 vim 或 neovim 或 emacs ，否则就等着 chroot 之后用 nano Chroot Software Source 建立软件源文件夹并拷贝默认配置。\nmkdir --parents /mnt/gentoo/etc/portage/repos.conf cp /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf 注意同步方式的区别：\nrsync\nrsync 是文件同步程序，能够高效地进行文件传输和目录同步。 默认在新安装的 Gentoo 系统上开启，可开启 rsyncd 守护进程。 rsync 的缺点是同步时镜像服务器压力较大，而且自建的 overlay 通过 rsync 部署较困难。 特别地，如果重建 glibc 后 rsync 停止工作，需要重建 rsync emerge -av --oneshot net-misc/rsync git\ngit 是 overlay 的主流同步方式。 同步过程中可以记录提交历史，有助于在软件遇到问题时及时回退软件仓库。 由于 github/gitlab 等网站可便捷地提供 git 远程服务，因此 git 同步是自建 overlay 的主流同步方式。 由于记录了较多的提交历史，在使用一段时间后 git 仓库会变的特别大，而且提交历史大部分对用户是无价值的。 首先用 rsync 同步 Gentoo Portage 源的 Gentoo Overlay 编辑 vim /etc/portage/repos.conf/gentoo.conf 关于该文件，可以 man portage 查找配置选项。\n[DEFAULT] main-repo = gentoo [gentoo] location = /var/db/repos/gentoo sync-type = rsync sync-uri = rsync://rsync.gentoo.org/gentoo-portage auto-sync = yes sync-depth = 2 在同步软件仓库之后 可以下载 git。 如需使用 git 同步，删除 /var/db/repos/gentoo 然后将同步方式改为 git 重新同步。 特别地，同步软件仓库需要在挂载和 chroot 之后进行。\nsync-type = git sync-uri = https://mirrors.tuna.tsinghua.edu.cn/git/gentoo-portage.git DNS cp --dereference /etc/resolv.conf /mnt/gentoo/etc/ --dereference 保证复制的是真正的文件内容而不是符号链接。 事实上我的电脑只添加了 nameserver 192.168.1.1\nMount mount --types=proc /proc /mnt/gentoo/proc mount --rbind /sys /mnt/gentoo/sys mount --rbind /dev /mnt/gentoo/dev mount --bind /run /mnt/gentoo/run mount --make-rslave /mnt/gentoo/sys mount --make-rslave /mnt/gentoo/dev mount --make-slave /mnt/gentoo/run mount --types tmpfs --options nosuid,nodev,noexec shm /dev/shm chmod 1777 /dev/shm /run/shm 说明：\nmount \u0026ndash;types\n提供的文件系统可以在 /proc/filesystems 和 /lib/modules/$(uname -r)/kernel/fs 中找到。 一般来说提供下列文件系统: ext2 ext3 ext4 xfs btrfs vfat sysfs proc nfs cifs 我理解的需要通过文件系统来绑定 /proc 的原因： /proc 是内核暴露信息的位置，stage3 安装的内核和 livecd 中的内核不同，如果采用绑定方式，则后续无法从 /proc 中获取到当前内核的信息。\nmount \u0026ndash;bind\nbind 是绑定，即从 livecd 中将指定的文件绑定到指定位置 可从用户层面理解为硬链接，但原理不同，首先链接关系存在于内存（即临时的），其次被挂载的位置的下级目录将被暂时隐藏 mount \u0026ndash;bind 仅绑定一级目录 mount \u0026ndash;rbind 可以递归的绑定子目录(r for recursive) 我理解的绑定方式不同的原因 /run 是临时文件系统，用于启动系统的守护进程并存储系统的临时运行时文件，livecd 系统和后续安装的系统的运行时文件可能不同 /dev 和 /sys 包含的是系统信息（如设备文件等等），通常这些信息不会发生变化，因此直接递归绑定 mount \u0026ndash;make-slave 是设置从属挂载；\u0026ndash;make-rslave 是设置递归从属挂载\n目前支持标记挂载及其子装载为共享、私有、从属或不可绑定。 共享挂载提供了创建该挂载的镜像的能力，例如在任何镜像中的装载和卸载将传播到另一个镜像。 从属挂载即从其主挂载中接收传播的动作，但反过来不行。 私有挂载不携带传播能力。 不可绑定的挂载是专用挂载，它不能通过绑定操作克隆。 chroot /mnt/gentoo /bin/bash source /etc/profile #这是最重要的一步 export PS1=\u0026quot;(chroot) ${PS1}\u0026quot; Portage Update portage datebase 在本步进行之后才可进行 安装任何软件 的操作。\nemerge-webrsync #速度快，rsync emerge --sync #更新更新 Read News eselect news list eselect news read eselect news purge Select Profile 推荐使用 desktop profile，注意应和选择的 init 系统保持一致。 当然也可以使用最小化的 profile，这就意味着需要自己处理很多 use 选项和软件问题。\neselect profile list eselect profile set X #选择恰当的profile Software source gentoo 提供软件安装的仓库 overlay，如果需要添加某些软件，应当先将其所在的 overlay 添加到本地。\n官方建议选用的添加软件仓库的工具是 eselect-repository，而 layman 目前不被建议使用。\n建议添加的 overlay: gentoo-zh guru benzene-overlay\nemerge -av dev-vcs/git app-eselect/eselect-repository doas sudo eselect repository list eselect repository enable X emerge --sync gentoo-zh Upgrade System 在更新系统之前，可考虑是否需要从 stage1 开始重建至 stage3。（见下节）\nemerge --ask --verbose --update --deep --newuse @world emerge -avuDN @world 在以后每次更新系统都可以使用上面的命令，也可以用下面的命令\nemerge --ask --verbose --update --deep --changed-use @world emerge -avuDU @world 区别：\nnewuse 检查包括当前系统使用的所有 use 选项以及 ebuild 文件中 use 选项的变化，而后对所有变动项所在的软件进行安装 changed-use 检查当前系统使用的所有 use 选项的变化，对变动项所在的软件进行安装。 每次运行完更新之后，推荐运行\nemerge --depclean emerge --ask --verbose --emptytree --with-bdeps=y @world Systemd ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime vim /etc/locale.gen locale-gen eselect locale list eselect locale set X env-update \u0026amp;\u0026amp; source /etc/profile \u0026amp;\u0026amp; export PS1=\u0026quot;(chroot) ${PS1}\u0026quot; BootStrap 特别注意，本部分是可选的，供参阅。 本部分用于从头开始构建所有的内容，类似 linux from stratch 这可能需要相当长的一段时间。整个过程的重点是 保证二进制文件的完整性 。\nstage stage 1 从第 1 阶段的 tarball 开始，必须使用现有的（二进制）主机系统工具链； 在/var/db/repos/gentoo/scripts/bootstrap.sh 脚本的指导下构建基本工具链（GCC、标准 C 库等）这会产生： stage 2 在这里，需要使用新工具链来构建（构建）核心@world 包集。这会产生： stage 3 其中工具链已被引导，重要的系统二进制文件和库已使用它编译。 现在，Gentoo 发行版的默认部分提供了这样一个 stage 3 系统目录的 tarball（stage 1 和 stage 2 tarball 不再可供最终用户使用）。 stage1 to stage2 切换到 bootstrap 目录，然后进行虚拟运行以查看提供的 bootstrap.sh 脚本将要做什么。\neselect locale set X #必须设置成C cd /var/db/repos/gentoo/scripts ./bootstrap.sh --pretend 目前 bootstrap.sh 的问题在于：\n将要重建的 libc 属于虚拟包\n虚拟包即本身无任何内容，但是依赖其他包，安装虚拟包事实上就是安装其所依赖的包 重建虚拟包将不会对已安装的被实际依赖的包做任何操作 为了重建已安装的被实际依赖的包做如下操作 -[[ -z ${ myLIBC } ]] \u0026amp;\u0026amp; myLIBC = \u0026quot; $( portageq expand_virtual / virtual/libc ) \u0026quot; +[[ -z ${ myLIBC } ]] ; myLIBC = \u0026quot; $( portageq expand_virtual / virtual/libc ) \u0026quot; 去掉\u0026amp;\u0026amp;使得以下语句无条件执行，加入分号使得其他部分不受影响。 将要重建的 gcc 应当具有现代特征 openmp\nexport USE=\u0026quot;-* bootstrap ${ALLOWED_USE} ${BOOTSTRAP_USE} openmp\u0026quot; !!! CONFIG_PROTECT is empty 警告说，如果要安装的任何包试图覆盖它们，引导过程将不会保留可能已修改的任何配置文件。 这主要包括两个文件 /etc/locale.gen 和 /etc/conf.d/keymap (如果有的话）\ncp -v /etc/locale.gen{,.bak} 说明：由于 bootstrap.sh 文件作为 Gentoo ebuild 主存储库的一部分存在，因此任何更改将在下次同步时被覆盖。然而因为我们现在只想重建我们的系统，所以这不是问题（但你当然可以在此时复制修改后的 bootstrap.sh 文件，如果你愿意的话。\n一切就绪，开始执行 ./bootstrap.sh 该命令将重建 portage ，如果没有报错，将重建 gcc 和 zlib 等。\n若未重建 gcc ，根据警告提示补全当前系统里缺少的 use 选项： 特别地，对 gcc 的 use 选项在 /etc/portage/package.use/gcc 中单独修改。\n然后重建整个交叉编译工具链（即 bootstrap 中提示需要安装的软件）。\n若已重建 gcc ，检查 gcc 的配置，验证是否重建 gcc\ngcc-config --list-profiles 如果这一步提示当前配置无效，执行下面的命令：\ngcc-config 1 env-update \u0026amp;\u0026amp; source /etc/profile \u0026amp;\u0026amp; export PS1=\u0026quot;(chroot) $PS1\u0026quot; 上一步的环境更新完成后，手动重建交叉编译工具链，结束后重新运行一次检测\nemerge -av --oneshot sys-devel/libtool binutils llvm clang libc glibc ./bootstrap.sh stage2 to stage3 当上一阶段提示系统已经成功 bootstraped 后，执行下面的命令\nemerge -e @system emerge -avuDN @world 所有的工作做完之后，还原文件\nmv -v /etc/locale.gen{.bak,} locale-gen eselect locale list eselect locale set X Kernel firmeware 相当多的设备需要先在系统上安装附加的固件才能正常运行，因此 sys-kernel/linux-firmware 几乎是必须的。 另外可能还需要安装微码(为 CPU 提供的固件更新)，因此 sys-firmware/intel-microcode 需要安装（AMD 的微码包含在固件中）。\nkernel gentoo-source genkernel initramfs vanill-kernel xanmod-kernel 我强烈推荐第一次安装的 Linux 爱好者 先装二进制内核 ，原因如下：\n如果你第一次配置自己的内核，你可能将它弄的一团糟；\n如果在 1 小时，1天甚至一周的时间内你仍然没有获得一个可用的内核，你的信心会受到巨大的打击；\n如果在新系统上有某些功能不可用，你无法排除是否属于内核的原因。\nvim /etc/portage/package.use/kernel sys-kernel/gentoo-kernel-bin -initramfs\nemerge -av sys-kernel/gentoo-kernel-bin 尽管你可能不知道如何配置内核，但是如果你想体验一下如何编译它，具体的配置选用官方定义好的版本，这是可以的：\nemerge -av sys-kernel/gentoo-kernel eselect kernel list eselect kernel set 1 cd /usr/src/linux make mrproper #类似 make clean make -jX \u0026amp;\u0026amp; make -jX modules_install make install System fstab 建议使用 UUID 而不是 Label 定义以确保唯一性。\nemerge -av sys-fs/genfstab genfstab -U / \u0026gt;\u0026gt; /etc/fstab genfstab -U /mnt/gentoo \u0026gt;\u0026gt; /mnt/gentoo/etc/fstab # arch自带的genfstab从ISO生成可能不行 hostname hostnamectl hostname LeeSin echo 'LeeSin' \u0026gt; /etc/hostname vim /etc/hosts Network 介绍两种网络配置办法。\nNetworkManager emerge -av net-misc/dhcpcd systemctl enable --now dhcpcd emerge -av net-misc/networkmanager 需要为 networkmanager 开启一些 use 选项，否则在后续使用中可能遇到代理等问题。 输入 vim /etc/portage/package.use/network\nnet-misc/networkmanager concheck dhcpcd gnutls gtk-doc introspection iptables nftables policykit ppp systemd tools wext wifi 为 networkmanager 安装前端软件，如 nm-applet 等。（KDE 或 gnome 提供了前端组件）\nNetworkd \u0026amp; Iwd Networkd 适用 systemd 系统。\nemerge -av net-wireless/iwd net-misc/dhcpcd systemctl enable iwd dhcpcd systemd-networkd Networkd\n查看以太网接口名称，可用 ip link 或 networkctl list 查看。 输入 vim /etc/systemd/network/20-wired.network\n[Match] Name=enp4s0 # 替换为前述命令得到的接口名 [Network] DHCP=ipv4 如需配置静态 IP 或者其他高级配置，参见 ArchWiki3\nIwd\n输入 iwctl 进入交互式命令行。（退出可用 C-d 发出 EOF 信号）\nhelp 查看帮助 device list 列出所有设备 station list 列出所有无线设备 station device scan 扫描网络 station device get-networks 列出可用网络 station device connect SSID 连接指定网络 详细内容参阅 ArchWiki4\n特别地，若无设备列出，考虑以下原因：\nrfkill list 检查无线设备是否被禁用，若被禁用，~rfkill unlock wifi~ 启用该设备。 lspci -k 检查无线设备是否有驱动 Systemd setup 设置 machine-id 对于使用 systemd-boot 的用户有帮助\nsystemd-firstboot --prompt --setup-machine-id systemd preset-all SSHD systemctl enable sshd Time Linux 将系统时钟视为 UTC，并将当前时间设置为 UTC+8 Windows 则将系统时钟视为 RTC，并将当前时间设置为该时间。 可以设置 Linux 系统使用 RTC 硬件时钟，也可以设置 windows 将硬件时钟视为 UTC timedatectl set-rtc true systemctl enable systemd-timesyncd User passwd useradd -m -G users,wheel,audio,video -s /bin/bash leesin passwd leesin Boot 检查一下你的计算机是否有启动引导器，即开机的时候尝试按 ESC 键。如果有启动引导器，事情会好办很多。\nGrub emerge -av sys-boot/grub grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=gentoo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=gentoo emerge -av sys-boot/os-prober 输入 vim /etc/default/grub\nGRUB_DISABLE_OS_PROBER=\u0026quot;false\u0026quot; GRUB_CMDLINE_LINUX=\u0026quot;init=/usr/lib/systemd/systemd loglevel=5 nowatchdog\u0026quot; # 如果不需要debug,可以启用quiet # nowatchdog 可以显著提升关机速度 grub-mkconfig -o /boot/grub/grub.cfg Other LILO efibootmgr systemd-boot syslinux Exit and Reboot exit cd / umount -lRv /mnt/gentoo reboot rm /stage3-*.tar.* -l 指的是懒卸载，比较安全 -R 指的是递归卸载 -v 指的是显示卸载内容 Reference https://wiki.gentoo.org/wiki/Handbook:Main_Page/zh-cn/ https://bitbili.net/gentoo-linux-installation-and-usage-tutorial.html https://blog.bugsur.xyz/gentoo-handbook-installation Sakaki Bootstrap Intel处理器及图形显卡\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nCcache配置\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSystemd-networkd 配置\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIwd配置\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://endlesspeak.github.io/docs/build/operating-system-installation/linux-technology-3-3-gentoo-linux-installation/","tags":[],"title":"Gentoo Linux 物理机安装与配置"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"原理 支持向量机使用的是什么类型的间隔？为什么？\n使用几何间隔定义。 因为函数间隔只需要成比例的改变w和b，函数间隔就会发生变化，而实际分类超平面并未变化。 对超平面的w和b加上规范化约束，除以w的L2范数，可以使得间隔是确定的。 最后通过几何间隔和函数间隔之间的关系转化最优化问题。 为什么需要间隔最大化？\n对训练集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。对最难分的实例点(离超平面最近的点)也有足够大的确信度将它们分开，对未知新实例有很好的分类预测能力。\n简要描述一下支持向量机的原理\n支持向量机学习的结果是在高维空间中划分出一条分类超平面（同时也是判别函数），得到一个约束最优化问题，求解以得到分类超平面的各个参数； 通过非线性变换将问题转化为线性问题，使用的是高斯核函数/径向基核函数； 求解参数使用序列最小优化算法； 其中，线性分类中y=wx+b，w是行向量，x是列向量，b是一个数； 支持向量机的损失函数是：合页损失函数； 支持向量机有三宝，间隔（几何间隔转为函数间隔），对偶（拉格朗日对偶），核技巧。 简要描述一下核函数原理\n核函数应用在支持向量机需要由线性空间推广到非线性空间的场景。\n支持向量机通过非线性变换$φ(x)$，将输入空间映射到高维特征空间，由此将输入空间中的超曲面模型对应特征空间（希尔伯特空间）中的超平面模型，从而求解特征空间中的线性支持向量机完成输入空间分类问题的学习。\n如果支持向量机的求解只用到内积运算，而在低维输入空间又存在某个内积函数$K(x_1, x_2)$ ，它恰好等于在高维空间中这个内积，即$K(x_1,x_2)=φ(x_1)⋅φ(x_2)$。那么支持向量机就不用计算复杂的非线性变换，而由这个函数$K(x_1, x_2)$直接得到非线性变换的内积。\n该内积函数$K(x_1, x_2)$称为核函数，变换过程称为核技巧。\n简要描述一下序列最小优化算法：\n序列最小优化算法是一种启发式算法。如果所有的变量都满足最优化问题的KKT条件，那么最优化问题的解就得到了。（KKT条件是最优化问题的充要条件） 先固定N-2个变量，迭代2个变量，重复直到收敛；外层选择违反KKT条件程度最大的点，内层循环使另一个变量产生足够大的差异（具体实现上是选择差值最大$|E_2-E_1|$的变量；选择边界变量；随机选择变量），最后更新阈值和差值。 简要描述一下最小二乘法算法\n最小二乘法将所有训练点视为支持向量，因为$\\alpha_i=\\gamma e_i \\neq 0$； 利用等式约束代替不等式约束； 求解线性方程组代替求解非线性方程组，简化计算； 求解矩阵方程，得到变量的值； 参数\n高斯径向基核函数公式为 $$\rK(x_1,x_2)=exp\\{-\\frac{\\Vert x_1-x_2\\Vert^2}{\\sigma}\\}\r$$ 径向基核的参数$\\sigma$，取值影响着分类超平面的复杂程度：\n参数越小，深远，过拟合；\n参数越大，浅近，欠拟合。\n惩罚因子C的取值综合了经验与结构风险：\n参数越大，扭曲，过拟合；\n参数越小，平滑，欠拟合。\n实现思路 计算核函数矩阵第i列的值\n输入：训练集train，核函数选项kernelOption（列表，包括核函数类型和参数）\n算法：\n$K(x_i,x_j)=exp{-\\frac{\\Vert x_i-x_j\\Vert^2}{2\\sigma^2}}$，其中$x_i,x_j$是样本； 根据训练集获得训练集的第i行内容，每行减去第i行逐个计算每个元素； 输出：核函数矩阵；\n其中创建零矩阵的代码为numpy.mat(zeors(n,n))\nSVM数据结构：\n样本\n样本分类标签\n惩罚系数\n迭代终止条件\n拉格朗日因子 $num\\times 1$ 的列向量\n核函数矩阵 $num \\times num$的矩阵\n样本误差缓存 $num\\times2$的矩阵\n需要缓存旧误差和新误差\n计算$\\alpha_1$\n计算$\\alpha$的误差$E_k$并更新误差缓存\n公式如下： $$\rE_k=\\sum\\limits_{i=1}^{N}\\alpha_iy_iK_i1+b-y_k\r$$ 向量对应元素相乘得到向量的代码为numpy.mutiply(matA,matB)\n向量对应元素相乘再相加得到数的代码为matA * matB\n$\\alpha$更新缓存为$[1,E_k]$\n","permalink":"https://endlesspeak.github.io/docs/docs/machinelearning-doc/traddional-machine-learning/3-svm/","tags":[],"title":"支持向量机问题"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"专业问题 谈谈你对大数据的认识\n大数据，或称巨量资料。是具有如下特点的信息资产。\n数据量大 增长速度快 形式多样 大数据的类型：\n结构化数据\n半结构化数据\n非结构化数据\n非结构化数据越来越成为数据的主要部分。\n大数据所涉及到的数据量规模巨大且信息密度低，无法通过传统软件工具在合理时间内处理。相较于传统数据来说，处理大数据所需要的处理模式和流程等方面的要求更高。\n大数据的关键在于提高对数据的处理能力，通过“加工”对数据进行提纯，实现数据的“增值”。主要采用分布式技术和数据挖掘等。\n所用到的分布式技术包括：\n分布式文件存储 分布式计算技术 分布式数据库（非关系型数据库） 非关系型数据库：\n去掉关系数据库的关系型特性，数据之间无关系，容易扩展 数据库结构简单，读写速度快，性能强大 数据格式自定义，只需要使用约定好的格式进行存储，如Json、哈希表、列存储、图形存储等。 JSON：\n一种轻量级的数据交换格式，易于阅读和编写 由对象、数组、数字、字符串或者字面值(false,null,true)组成 谈谈你对数据挖掘的认识\n数据挖掘是指通过分析数据，从大量数据中揭示出隐含的、先前未知的并有潜在价值的信息的非平凡过程。\n收集数据\n存储与集成\n存储数据，同时尝试将多种数据源的数据组合；\n选择与处理\n对数据的处理包括审核、筛选、变换；\n审核包括完整性和适用性； 筛选则是纠正或抛弃错误数据； 变换和统一成适合挖掘的形式； 计算与挖掘\n根据数据的内容和特点建立对应的数据模型或数据模式，需要大量的计算\n评估与决策\n评估建立的模型，解释模型的价值，利用模型揭示的规律进行预测等，利用可视化技术表示模型\n大数据和机器学习之间有什么联系？\n我的理解是，机器学习是实现大数据的工具，大数据的价值通过机器学习等技术得以体现；\n机器学习研究的是能通过经验自动改进的计算机算法，它在经验学习中改善具体算法的性能；\n在大数据量的基础上，通过机器学习，不断发掘其中蕴含的有用的信息，其处理的数据越多，机器学习就越能体现出优势，包括更好的问题解决方案或性能的提升，如自然语言处理、语音识别、图像设别、天气预测等。\n谈谈你对云计算的认识\n云计算又称为网格计算，是分布式计算的一种。\n分解计算任务：将数据计算程序分解 分发计算任务：控制各个服务器运行计算 合并计算结果 现代云计算技术包括：\n分布式计算\n效用计算\n负载均衡\n并行计算\n网络存储\n网络存储是一种特殊的专用数据存储服务器或相关的存储技术。\n虚拟化\n谈谈你对虚拟化的认识\n虚拟化是指计算元件虚拟，包括：\n硬件虚拟\n硬件虚拟化技术直接应用在硬件设计上，如内存虚拟化技术，扩大逻辑容量；\n软件虚拟\n介于硬件和操作系统之间\n模拟不同的指令集，从而在单CPU上模拟多CPU运行\n在同一平台运行不同的操作系统\n运行在操作系统之上 Wine，JVM/JRE\n提供虚拟环境，专用于安装或运行软件\n谈谈你对区块链的认识\n区块链是一种共享数据库，存储于其中的数据或信息具有如下特征：\n不可篡改、不可伪造\n必须掌控全部数据结点的一半以上才可能修改\n具有访问记录且可以追溯\n数字签名进行认证和记录\n相关技术及非私有信息公开透明\n相关技术是开源的，除私有信息外都是开放的\n用分布式技术生成和更新数据\n去中心化，通过分布式技术进行存储和计算；各个结点可以对信息进行验证、传递和管理。\n利用密码学保证数据传输和访问的安全\n相对独立，基于某种安全的非对称密码学算法规范\n区块链是数字世界现实化的核心支撑。\n谈谈你对元宇宙的认识\n元宇宙是把网络、硬件终端和用户合并的虚拟现实系统。\n它是扩展现实、虚拟现实、区块链、云计算、数字孪生技术的概念具化。\n现实世界的数字化、虚拟化\n现实世界的数字化复制物，如数字人民币；\n数字世界的现实化\n数字世界的现实化创造物；如数字孪生技术、区块链技术；\n在空间维度上虚拟，时间维度上真实\n利用扩展现实(XR)或虚拟现实(VR)技术提供沉浸式体验；\n谈谈你对5G的认识\n第五代通信技术，主要特点是高速率，低时延，大连接；实现经济社会数字化、网络化、智能化；\n高速率指峰值速率10-20Gbit/s 空中接口时延低至1ms 解决人与人、人与物、物与物之间的通信问题，满足物联网应用的需求； 谈谈你对物联网的认识\n物联网是互联网基础上延伸和扩展的网络，实现人、机、物的互联互通。\n谈谈你对机器学习和深度学习的认识，它们之间的区别是什么？\n机器学习是利用经验改善系统性能，是一个通过提供的数据学得对应关系的过程。\n深度学习是机器学习的一个分支，一般具有深层非线性网络结构，能形成更加复杂的模型函数拟合。\n传统的机器学习算法和深度学习算法主要是在特征提取方面存在差异，传统机器学习属于浅层结构，主要由人工进行特征提取，复杂程度有限，而深度学习算法具备的深层结构能提取更加复杂的特征，进而使权重学习更加有效。\ngraph LR\rB[输入]--\u003e|传统机器学习|C[人工特征提取] B--\u003e|深度学习|D[基础特征提取]\rC--\u003eE[权重学习]\rE--\u003eF[预测结果]\rD--\u003eG[多层复杂特征提取]\rG--\u003eE\r谈谈你对C和Java的认识，它们之间有什么区别？\n从编译角度说，C是编译型语言，通过编译器获得二进制文件，直接执行；而Java是混合型语言，需要先编译成java字节码，然后交由JVM虚拟机进行解释执行； 应用场景不同。Java语言属于“全场景”编程语言之一，可以应用于Web开发、Android开发、大数据开发等场景，而C语言的应用场景则相对比较集中，主要应用于操作系统开发和嵌入式开发领域。 技术体系不同。Java是面向对象编程语言，虽然也借鉴了C语言的很多写法，但是在技术体系的设计上更注重可移植性、安全性和可扩展性，所以Java语言更契合互联网的应用环境，这也是Java在互联网时代得到快速发展的一个重要原因。由于Java语言极强的扩展性能，所以Java语言可以在互联网时代、移动互联网时代和大数据时代都能够找到自己的位置。 发展道路不同。虽然Java语言的出现要比C语言晚一些，但是Java语言的发展道路与C语言还是具有明显的区别，或者说Java的开发人员并不是想让Java取代C语言。Java语言的发展道路主要可以体现出三个特点，第一是跨平台；第二是资源整合能力强；第三是并发处理能力强。可以说Java语言在设计上是希望解决C语言之上的问题，也就是网络问题。 XXX\n个人问题 本部分内容与英语面试大部分问题相同，准备的答案尽可能统一。\n报考相关 你为什么考研而不是找工作？（见英语面试题1）\n科学技术的知识是没有限制的。因此，随着我对这一领域的深入研究，我对知识的渴望将永远不会停止。\n计算机科学与技术是一类博大精深的科学，我希望在其中能提高自己的认知能力、自我学习能力、独立思考能力和批判性思维能力，扩宽视野和范围，学习到更多的知识。\n当然，我更希望我能为这门科学做一点小小的贡献。所以我认为毕业后继续深造而不是去工作是很有必要的。\n你为什么选择计算机科学与技术而非软件工程？（见英语面试题2）\n我认为软件工程是一种程序开发范式，而计算机科学与技术是一门博大精深的科学。\n我在本科的学习中了解了如何规范化开发软件，现在我应该学习如何利用科学技术和编程知识去实现软件。因此我选择计算机科学与技术，希望探索更高更深的科学技术领域，并能够通过这种方式实现系统的知识获取。\n你为什么选择我们学校？（见英语面试题3）\n在贵校深造一直是我的梦想。我最初被贵校的高声誉所吸引。我有一个同学曾在贵校学习，在与他交流后，我对贵校浓厚的学术氛围和教授的责任心印象更加深刻。这一切都坚定了我的决心，要尽我最大的努力在这里开始我的学习。\n你对电子科技大学的印象如何?（见英语面试题4）\n电子科技大学是全国重点大学之一，是国内外现代社会大学科学技术协调发展的前沿阵地。\n你是否有出国留学的打算？（见英语面试题5）\n我之前有了解过，出国留学对成绩和专业素质都有一定的要求，如果有机会的话，我会试一试。\n你对选择导师有什么想法？（见英语面试题6）\n我有提前了解过各个科研团队，对这些未知的领域都很感兴趣。不过在选择导师方面我没有什么特别的想法，每个导师都有自己独特的学术方法和特点，我所做的就是尽可能提升自己，争取让适合的导师选到我。\n是否考虑读博？（见英语面试题7）\n有这方面的想法，如果能力满足且有机会读博的话，我非常感激。我希望通过硕士研究生三年的学习和积累，掌握学术研究所需要的各种能力，能在自己感兴趣的领域钻研，在学术道路上走的更远更长。\n你周围的人如何看待计算机科学与技术/软件工程？（见英语面试题8）\n他们通常不能区分计算机科学与技术和软件工程之间的差异，但他们都认为计算机专业在如今社会很多岗位都有很好的结合性，从事计算机工作的人通常被看作是高素质复合型人才。\n个人问题 你认为你的最大优点和最大缺点是什么？\n你之前有参加过培训机构的培训吗？\n如果你不幸被刷,你会怎么办?你愿意来读非全日制吗?\n复试是筛选过程，被刷意味着我的能力不足，我会认真反思自己的不足之处，对缺陷之处进行查漏补缺，力求在后续做到更加优秀，更加完美。\n我读研究生的决心不会改变，但是不想做将军的士兵不是好士兵。\n人的价值不仅仅取决于他自己，也依赖于社会。因此我可能会考虑通过调剂的方式实现目标。\n未来规划 如你能顺利考入我校研究生，你对今后2-3年的学习规划是什么？\n首先，我会认真夯实编程语言基础，迅速掌握C++的STL、C++11和C++17等新特性和技术，为未来的编程开发作准备； 其次，就是努力掌握研究生阶段的知识，多进行算法、编程能力方面的训练，多思考知识的应用化； 第三，就是多读文献，了解前沿发展方向，多做探索性的工作，努力将学习的知识转化为研究成果； 你今后想从事什么方向的学习?为什么?\n本科学习 介绍一下你的大学？\n我本科就读于长安大学，长安大学位于六朝古都西安。\n校园是一个长方形，图书馆是校园里最高的建筑，座位在长方形的中心。\n图书馆的东北方向是宿舍，西北方向是汽车试验场，西南方向是教学楼，东南方向是实验室。\n我很欣赏校园的风景。学校有两个人工湖，教学楼依湖而建。在这样的环境中学习会感到轻松和快乐。\n简要讲述下你的本科毕业论文？\n我的毕业设计是利用决策树、支持向量机和前馈神经网络来解决分类问题。\n决策树在每个决策中选择最优属性进行划分，得到最终结果。\n支持向量机的目的是在高维空间划分分类超平面。\n通过阅读相关论文我了解了一些进阶实现版本：\n最小二乘支持向量机遵循结构风险最小化原则，简化了计算。 它的加权版本解决了对异常值的敏感性问题，并减少了错误。 前馈神经网络通过计算输出值与实际值之间的误差来校正各层的权值。\n你本科成绩怎么样?本科排名怎么样?为什么这门课挂科了?\n本科成绩概括为部分突出，整体中等。\n专业方面，你读过哪些书？\nK \u0026amp; R C\n你本科最感兴趣的一门课是什么?说一说你对这个课程一些自己的理解。\n你学习过什么编程语言?你为什么学习该编程语言?\n你在过去的编程中,遇到的最困难的事是什么?你是如何解决的?\n一般来说学习了一种新的算法思想，尝试在具体实现它的时候，都会显得十分困难。\n最困难的是刚学会支持向量机的原理，想要通过numpy进行实现的时候，有种两眼一抹黑，不知道该怎么办的感觉。\n解决的方法是查阅更多的资料，参考其他人的实现方法，照猫画虎进行仿写。\n你是否有个人技术博客?\n是的，我有个人技术博客，尝试过很多现成的框架搭建，比如hexo，hugo，vuepress等等。\n开始部署在gitee上，随着gitee逐渐加大了对页面的审核，部署很容易失败，正在考虑迁移到github上。\n它们的主要区别是hexo使用nodejs编写，hugo使用go实现，nodejs是面向对象的高级解释型语言，而go是一种编译型语言。Vuepress则是使用Vue和webpack实现。\n比较熟悉的开发工具是什么?\n大一大二使用C++编写程序的时候，主要用的是Visual Studio; 大三使用Java编写程序的时候，主要用的是Eclipse; 大四使用Python编写程序的时候，主要用的是VS Code; 其他的开发工具也能够使用，比如Jet Brains公司的Web Storm，IDEA，还有轻量级的开发工具DevC++，以及文本编辑器vim和emacs也略会。 其他问题 介绍一下你的家庭？\n我的家庭有三个成员，我的父母和我。总体来说，我的家庭是温暖和谐的。\n我父亲是电梯行业的一名中级工程师。从我记事起，他就一直在辅导我学习。他经常告诉我，态度决定成就。每个阳光明媚的周末他都会去钓鱼。他认为，钓鱼不仅可以训练人们的耐心，还能让人们感到轻松舒适。\n我妈妈是工厂的产品检验员。无论是工作还是生活，她总是一丝不苟。谨慎是避免犯错误的唯一方法。在她的影响下，我总是反复检查我的重要工作。\n介绍一下你的家乡？\n我的家乡在随州，位于湖北省的北部。北接襄阳，南连武昌，西眺荆门，东迎信阳。举世闻名的编钟就是在这里出土的。同时，据传它还是炎帝神农故里，另战国时期曾侯乙的陵墓也坐落此地。\n此外，随州盛产专用汽车。它被称为专用汽车之乡。城东自北向南的大片开发区，全是专用汽车制造厂。\n城区有涢水和㵐水两大水系交汇，古城环山绕水，灵气氤氲而风景秀美。\n介绍一下你的大学？（见本科学习面试题1）\n//多线程是宏观上同时运行，微观上并行运行，多线程运行的环境是同一环境，共享存储空间。\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/comprehensiveinterview/","tags":[],"title":"综合问题"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"词法分析 什么是形式语言？\n人们把用一组数学符号和规则来描述语言的方式称为形式描述；\n把所用的数学符号和规则称为形式语言。\n说明词法分析器的作用？\n主要任务：读入输入字符，将它们组成词素，生成并输出词法单元序列，提供给语法分析使用。\n辅助任务：\n过滤注释和空白； 将各阶段发现的错误与源程序位置联系起来； 划分词法分析和语法分析的原因？\n简化编译器的设计； 提高编译器的效率； 增强编译器的可移植性； 什么是词法单元、模式、词素？\n词法单元由一个词法名和一个可选的属性值组成； 模式描述一个词法单元的词素可能具有的形式； 词素是源程序中的一个字符序列； 串和语言的相关概念\n字母表：符号的有限集合； 串：字母表中符号的有穷序列； 串的长度：出现在串中的符号个数； 语言：字母表上的一个串集合； 句子：属于语言的串； 串的运算\n连接：串是同一字母表，直接拼接； 积：串与自身的n-1次连接； 语言的运算\n和：$L∪M = {s | s∈L 或 s ∈M}$ 连接（积）：$LM = {st | s∈L 且 s ∈M}$ 指数：$L^0$是${\\epsilon}$，$L^i$是$L^{i-1}L$ 闭包：$L^*=L^0 \\cup L^1 \\cup L^2 \\cup \u0026hellip;$ 正闭包：$L^+=L^*-{\\epsilon}=L^1 \\cup L^2 \\cup \u0026hellip;$ 正则表达式\n用于匹配一系列符合某种规则的字符串，它表示的语言叫做正规集合。\n$(r)|(s)$是正则表达式，表示$L(r) \\cup L(s)$ $(r)(s)$是正则表达式，表示$L(r)L(s)$ $(r)^$是正则表达式，表示语言$(L(r))^$ 约定如下： 闭包运算（算符*）具有最高的优先级，并且是左结合。特别地，具有幂等性； 连接的优先级次之，也是左结合； 或运算的优先级最低，同样是左结合 正则定义\n对正则表达式命名，并用这些名字定义正则表达式。\n正则表达式的扩展\n+表示正闭包 ? 表示零个或一个出现 $r|\\epsilon$ 字符类缩写$[a_1a_2..a_n]$或$[a-z]$ 状态转换图\n用于识别或接受一定的字符串。\n*代表最后一个字符不属于字符串，输入需要回退一个位置。\n有关超前搜索，特别地，\n所有基本字都是保留字，用户不能用它们作自己的标识符； 基本字作为特殊的标识符来处理，使用保留字表； 基本字、标识符和常数直接没有确定的运算符或界符，则必须使用一个空白符作间隔； 有穷自动机\n有穷自动机是识别器，能对输入串回答“是”或“否”；\n分类：\n不确定的有穷自动机 NFA 确定的有穷自动机 DFA NFA与DFA能够识别的语言集合相同。\n不确定的有穷自动机\n与状态转换图的区别：\n同一个字符可以标记同一个起始状态到多个目标状态的转换； 边不仅可以是输入字母表中的符号，也可以是空符号串 语法分析 什么是文法？什么是上下文无关文法？\n描述语言的语法结构的形式规则称为文法。\n四元组$G=(V_T,V_N,S,P)$\n$V_T$是终结符集合 $V_N$是非终结符集合，且$V_T \\cap V_N=\\varnothing$ $S$是文法的开始符号，$S ∈ V_N$，开始符号必须在某个产生式左部出现一次 $P$是产生式集合（有限）形式为$P→\\alpha,P∈V_N,\\alpha∈(V_T \\cup V_N)^*$ 上下文无关文法是四元组，且文法中所有产生式的左边只有一个非终结符。\n上下文无关体现在：无论非终结符前后的串是什么，只要它在文法定义内有某产生式，就可以使用该产生式进行推导。\n什么是句型、句子、短语、句柄、素短语？\n句型：如果$S\\Rightarrow*\\alpha，\\alpha∈(V_T \\cup V_N)^*$，则称$α$是G的一个句型\n句型中既可以有终结符，又可以有非终结符，还可以有空串\n句子：不包含非终结符的句型（句型的一个完全的推导实例）\n短语：句型的分析树中的每一棵子树（一个结点不算子树）的所有叶结点所组成的符号串称为该句型的一个短语\n直接短语：句型分析树只有父子两代结点的子树（简单子树）\n句柄：句型的分析树中最左简单子树为该句型的句柄。\n这取决于推导方法是最左推导还是最右推导，或者取决于是自顶向下还是自底向上。\n素短语：是指一个短语至少包含一个终结符，并且除它自身之外不再包含其他短语。\n左递归的消除\n消除立即左递归\n$A→A\\alpha_1|A\\alpha_2|\u0026hellip;|A\\alpha_m|\\beta_1|\\beta_2|\u0026hellip;\\beta_n$\n$A→\\beta_1A\u0026rsquo;|\\beta_2A^{\u0026rsquo;}|\u0026hellip;|\\beta_nA^{\u0026rsquo;}$\n$A\u0026rsquo;→\\alpha_1A\u0026rsquo;|\\alpha_2A\u0026rsquo;|\u0026hellip;|\\alpha_mA\u0026rsquo;|\\epsilon$\n消除两步及以上的左递归\n排列非终结符$A_1,A_2,\u0026hellip;A_n$\n从1到n的每个i，从1到i-1的每个j\n将每个$A_i→A_j\\gamma$替换成$A_i→\\delta_1\\gamma$\n消除立即左递归\n提取左公因式\n将产生式 $A\\rightarrow\\alpha\\beta_1|\\alpha\\beta_2|..|\\alpha\\beta_n|\\gamma$ 替换为：\n$A\\rightarrow\\alpha_1A\u0026rsquo;|\\gamma$ $A\u0026rsquo;\\rightarrow\\beta_1|\\beta_2|\u0026hellip;|\\beta_n$ 递归下降语法分析\n从开始符号开始，对每一个文法中的每一个非终结符号，都根据相应的产生式的右边出现的非终结符，调用对应的过程，识别该非终结符号所表示的语法范畴，最终实现自顶向下语法分析。\n自顶向下语法分析的缺陷\n不能处理左递归 需要复杂的回溯 难以报告出错的确切位置 低效 First集和Follow集\n简而言之：\nFIRST(α)是可从α推导得到的串的首符号的终结符号集合，其中α是任意的文法符号串\n算法：\nX是终结符号，则$FIRST(X)=X$； X是产生式，且$X\\rightarrow Y_1Y_2\u0026hellip;Y_n$，若a在FIRST($Y_i$)中，且$\\epsilon$在FIRST($Y_1$)，FIRST($Y_2$)，\u0026hellip;，FIRST($Y_{i-1}$)中，则把a加入FIRST(X)，如果$\\epsilon$在所有的FIRST($Y_i$)中，则加入$\\epsilon$ 到FIRST(X)中； 如果$X→\\epsilon$是产生式，将$\\epsilon$加入FIRST(X)中。 FOLLOW(A)是可能在句型中紧跟在A右边的终结符号集合，其中A是非终结符号。\n注：这里假设结束标记#不是任何文法的符号。\n算法：\n对于文法开始符号S，令$∈FOLLOW(S)\n$是输入串的结束符；\n如果$A\\rightarrow \\alpha B \\beta$，则将FIRST(β)中除ε以外的符号都放入到FOLLOW(B)中，即： $$\rFIRST(\\beta) －\\{\\epsilon\\} ⊆FOLLOW(B)\r$$ 如果$A\\rightarrow \\alpha B$，或$A\\rightarrow \\alpha B \\beta$，其中FIRST(β)中包含ε（$\\beta \\Rightarrow *\\epsilon$），则将FOLLOW(A)中所有符号都放入到FOLLOW(B)中，即： $$\rFOLLOW(A) ⊆FOLLOW(B)\r$$ LL文法和LR文法\nLL(1)文法是自顶向下分析法\n自顶向下：从开始符号出发，根据产生式推导给定的句子，用推导，最右推导是规范推导。\nLR(0),LR(1),SLR(1),LALR(1)是自底向上分析法\n自底向上：从给定的句子归约到文法的非终结符号，用归约，最左归约是规范归约。\nLL(1)文法\nL表示从左到右扫描，L表示产生最左推导，1表示作决定时每次向前看1个输入符号。\n对于产生式$A \\rightarrow \\alpha | \\beta$，需要满足条件：\n不存在终结符号a使得α和β都能推导出以a开头的串 $$\rFIRST(\\alpha) \\cap FIRST(\\beta)=\\varnothing\r$$ α和β最多只有一个可以推导出空串\n若$\\beta \\Rightarrow *\\epsilon$ $$\rFIRST(\\alpha) \\cap FOLLOW(A)=\\varnothing\r$$ 特点：\n无公共左因子 无二义性 无左递归 LR(0)\nL表示从左到右扫描，R表示反向构造一个最右推导序列，0表示作决定时每次向前看0个符号。\nLR(1)\nSLR(1)\nLALR(1)\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/compilersprinciples/","tags":[],"title":"编译原理"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　回到真武殿后的弟子居中，张慎峰将自己房间的门窗尽皆关闭，而后拉上屏风帐幔，在自己屋中点亮烛火，这才小心翼翼地将师尊留给自己的古籍和自己之前捡到的那本书拿出。看着两本古籍，张慎峰陷入了思索：自己明明没有修炼过紫霞功这等极品功法，为何师尊会说自己的紫霞功已然筑基？\n自己的人生经历非常简单，由于自幼体弱，难以适应长途颠簸，故在自己十四岁时，父母为谋生计背井离乡，而将自己送入真武山门下的附属世家陈家，作一名杂役仆。而后因自己能吃苦耐劳，又兼行事沉稳，干活没出过岔子，被陈家举荐拜入真武门墙。\n然而在入门测试之时，因自己所挣银两尽皆捐给陈家外的几名乞丐，无法给武道院当值的年轻道士朱武阳缴纳“斡旋费”，又不肯许下赊欠日后归还的诺言，被朱武阳那厮一怒之下“发配”到了杂役院。\n打扫山间林道两个月，本以为此生再无出头之日，却不想竟在真武山隐仙道下拾得一本泛黄的古书，习练一年又四个月后，还是在隐仙道，打扫山道时，又恰巧遇到轻功落地的潇湘子，并被他老人家收为记名弟子。\n不过，当时潇湘子只是将张慎峰转到武道院，并未告知众弟子张慎峰乃他潇湘子之徒，故一众真武弟子皆以为张慎峰尚未拜师。平素潇湘子讲经论道、洗筋伐髓，运功传功，尽按其随性洒脱的风格设在无人的山岩密林之中，除张慎峰的一干师兄知道他是潇湘子的亲传弟子外，其余人等皆毫不知情。\n张慎峰思来想去，自己人生中可以称得上奇遇的，也就只有那本在隐仙道下拾到的古籍《四象诀》了。可是，自己和其他真武弟子一起在真武殿修习公开课业时，教席曾经提过，《四象诀》是一部非常普通几乎可以称之为不入流的内功心法，其改良版本《四相诀》则勉强可以称得上是中乘，而自己拿到的那本古籍名字就叫四象诀，既然自己修炼的是不入流的功法，怎么会和紫霞功扯上联系呢？\n紫霞功，紫霞功……张慎峰突然觉得紫霞功这三字有种莫名的熟悉感，他连忙拿着《四象诀》，从开头开始向后扫视，目光到处，只见书上写着：“诀曰：紫气蕴功，执象生霞。霞生四象，四象生万物。功蕴灵道，道法自然……”嗯？这本四象诀功法的开篇貌似总是有意无意地提到紫霞这两个字！难道，这里面真有玄虚？张慎峰连忙仔细观视，一个字一个字地审阅，发现这部心法口诀每隔一句的第一个字能够连起来读，而连起来，赫然就是：紫霞功……\n发现这个奥秘之后，张慎峰连忙抑制住自己内心的激动，深深吸气，而后按照发现的规律，按图索骥，取纸笔将这部功法的一三五等奇数句尽皆摘抄到自己的书卷中。\n随着摘抄到了最后一句，张慎峰又发现了问题：紫霞功功法口诀显然还没有结束，然而四象诀已经彻底到了尾声。这是为什么呢？四象诀的功法应该是很容易就能查到的，这部四象诀的功法读起来非常顺畅，应当不存在是残本之说。那既然四象诀的口诀没有缺漏，隐藏在其中的紫霞功难道就只有残篇不成？或者，功法中还有自己尚未发现的秘密？张慎峰拿出一大摞纸，开始仔仔细细拆分誊写四象诀口诀的每一句话，字斟句酌地研究起来。\n红日逐渐升至天空正中，而后西斜，一直到太阳落山，张慎峰的小屋一直房门紧闭，毫无动静，夜色降临，才能看见房中隐约透出灯火。\n……\n翌日清晨，天刚蒙蒙亮，张慎峰便急急忙忙地出了门，赶往太极道场中央练习功法。平日张慎峰虽然也是刻苦修炼，但却没有今日起的如此之早。这是因为按照功法所言，紫霞功在朝霞和晚霞下修行最佳。而决定在太极道场的中央，则是因为中央乃阳光最集中之地，在圆心处修行，有事半功倍的效果。\n经过昨天一天一夜的研究，张慎峰已然发现了四象诀中的奥秘所在。首先是每隔一句的句首能够连字成句，构成紫霞功的功法开篇，而后便是每句话的句末倒着也能够连字成句，构成功法结尾，第三，便是在讲解四象诀功法运行机理的部分，每句第二个字能够连字成句，而倒过来每句的第二个字亦能够连字成句，这部分连接起来，便是紫霞功的功法运行机理……如是有六七条规律，综合起来，经过张慎峰的排序整理，竟真的是一部紫霞功心法口诀！而且读起来还比较完整，即使不是整部功法，也应该是功法的整个上篇。张慎峰平素里向来行事稳重，不以物喜，不以己悲，喜怒不形于色，今日也不例外，即使此口诀按师尊所述是无价之宝，张慎峰也并未得意忘形，而是脸色如常般开始按照紫霞功心法口诀练功。\n“紫霞功，起于灵台，收于识海，韧如精丝，绵如云霞，至阴至柔，至阳至刚，功启《易》理，源于无极。灌注周身，可震外敌……”此际天尚未完全明亮，太极道场上空无一人，只有张慎峰盘坐在太极道场的最中央，口念功诀，气沉丹田，吸收吐纳，周天循环。随着张慎峰完整地念过一边紫霞功功诀，在经脉中运行一个大周天循环之后，他惊讶的发现，自己对紫霞功的掌握竟很快达到了融会贯通的程度，并且自己没有丝毫不适感，灵台清净，识海空明，并没有走火入魔之兆。\n发现这一点之后，即使是以张慎峰的城府也不禁露出了笑容，功法乃可遇不可求之物事，既有绝品上乘功法紫霞功在手，何愁武道不成？自己的人生经历甚至都会由此而改变。远的不谈，光就紫霞功成这一条，自己以后就绝不可能再偏安一隅，更不会再以作杂役谋生了。\n想到这里，张慎峰开声吐气，悠然吟道：“凤凰鸣矣，于彼高冈。梧桐生矣，于彼朝阳。紫霞之于我，真可谓适逢其时，恰到好处。”说罢，准备继续打坐修行。然而,就在此时，一阵淡然舒缓的声音响起,打破了之前的宁静：“好一个凤凰鸣于高冈，梧桐生于朝阳。师弟真是好文采，令我大开眼界。”\n张慎峰抬头望去，见说话之人束白冠，着白袍，有几分白衣胜雪的意味。此人亦是真武弟子，师从律令阁执掌，为其亲传弟子，唤作燕书磐。张慎峰虽然平时并不和大家一起练功，但却对其嚣张跋扈，仗势欺人的性格早有耳闻。其实，单论实力来说，燕书磐并不算得三代弟子之中的顶尖，然而，律令阁是真武派的五大派系之一，平日负责维持真武门规，处理一切违规事件，地位相当于江湖世家的刑堂、执法堂。作为律令阁主的亲传弟子，燕书磐尾巴翘上天也就无可厚非了。\n不待张慎峰开口，燕书磐附庸风雅道：“盖身不动，则精固而水朝元；心不动，则气固而火朝元；真性寂，则魂藏而木朝元；妄情忘，则魄伏而金藏元；四大安和，则意定而土朝元。此谓五气朝元，皆聚于顶也。我观师弟练功，竟有几分三花聚顶，五气朝元的意味，实在是令我辈愧不能及，愧不能及啊。”\n三花聚顶，五气朝元？这些词语形容的乃是功法练至大成之时，行云流水、信手拈来，即将证得法身的境界。然而用在这里，讽刺之意极其明显，分明是说他张慎峰不会修行。张慎峰心如明镜，面色却如常，拱手道：“燕师兄谬赞了，不知适才出言，是有事相询，还是有何见教？”\n燕书磐顿时感觉自己一拳打在了棉花上，心道这师弟真真是不知天高地厚，就凭你一个普普通通的三代弟子，一没有名师指引，二没有修炼资源，我拿三花聚顶五气朝元讽刺你，你居然还照单全收，跟我扯什么“谬赞”，要么是脑子缺根筋，要么就是故意为之。\n不过，燕书磐压根没往这是张慎峰故意为之那方面想，在他眼中，真武山中的三代弟子他基本都认得，眼前这位着灰袍的寒酸家伙眼生的很，想是近来才入的武道院。他燕书磐出言讥讽倒不是欺生，而是因为这位不识抬举的家伙今天坐在了太极道场的正中央——这可一直都是他燕书磐的位置，平日武道院的弟子谁人不知，那个不晓？偏偏今日来了个“刚入门”的愣头青，居然抢到他前面坐到了这里，是可忍，熟不可忍？\n其实，张慎峰入武道院已经有一年多光景了，之前，张慎峰传承师尊潇湘子的随性洒脱，率性自如的思想，喜在山野荒郊练功，到太极道场练功这还是头一次，也难怪燕书磐不认得他。\n燕书磐大马金刀地坐在张慎峰旁边，开口道：“我倒是无事相询，只是有些道理，想与张师弟讨论一番，还望师弟给我几分薄面，听我絮叨絮叨：所谓没有规矩，不成方圆，又所谓先入为主，先来后到，此皆为古之定制，不可肆意违之，师弟以为然否？”\n张慎峰听燕书磐这么说，就明白他心里打着什么算盘了。心中好笑，嘴上却顺着他的话，连连称是：“师兄所言是极，却不知师兄乍然谈及先来后到，是何意思，还请示下。”\n我把你个愣头愣脑反应迟钝的呆头师弟！燕书磐一口气差点梗住喉咙。心道：我都这么说了你居然还问我是何用意，难不成我还会和你闲聊不成？燕书磐也不废话了，直截了当地说：“师弟，太极道场的中央一直是我打坐行功之处，我在此行功已旬月有余。先来后到，师弟若要打坐练功的话，还是另觅他处吧。”\n“燕师兄此言差矣。”张慎峰说道，“先来后到的意思，应该是先来为主，后来为客，今日我天不亮便已坐在此处，而师兄却在太阳升起之后才姗姗来迟，师弟我是主，师兄你乃客，按理说应该是师兄你应该另觅他处才对，怎么师兄你寥寥数语，便移形换位，反客为主了？”\n燕书磐听得他如此说，心中一股无名火直往上窜。明明是一名普通的真武弟子，放在平常自己咳嗽两声，谁敢不让道？今日自己都出言明示了，他居然还真辩驳起来了？何时律令阁在门派中说话这么不好使了？他也顾不得维系之前的形象了，如果今日连一个愣头青都拿不下来，以后在真武山还会有人会把自己当回事吗？燕书磐双手捏得骨骼噼啪作响，发出一阵令人牙酸的声音，森然威胁道：“听师弟的意思，是不打算让这个位置给我了？”\n“非也非也。”张慎峰摆摆手，微笑道：“师兄强行要占我之位，师弟让给你便是，师兄道行远在我之上，在这太极道场中央肯定是事半功倍，若是我占了师兄的位置，打扰了师兄修行，那可是担当不起啊，我另觅他处便是，后会有期。”说罢，张慎峰就站起来，准备往外走。\n听张慎峰这么一说，燕书磐更加烦躁了。这段话乍听起来像是服软，实际上把燕书磐里外里讽刺了个遍，外层含义是讽刺他蛮横无理，内层含义是讽刺他修行也是半吊子水桶——没什么东西只会煞有介事讲求形式。他虽然如愿拿到了位置，但是听了张慎峰这么一段，感觉自己像是猪八戒照镜子——里外不是人，全身都不自在起来。忍一时越想越气，退一步越想越亏，于是他大声喝住张慎峰：“慢着！师弟，你占我位置许久，枉我给你讲了许多道理，你竟恶语相向，阴阳怪气，着实可恨，难道，师弟不向我道歉就准备走吗？”\n“道歉？”张慎峰反讥道，“师兄道行微末却偏偏要在太极道场中央修行，即使用占着茅坑不拉屎形容也并不过分吧？既然我说的恰到好处，你不思改过自新也就罢了，还要我道歉，胡搅蛮缠，好似市井小人一般，得寸进尺，难道师兄以为张某可欺？”\n“站住！我和你拼了！”燕书磐大吼一声，之前的斯文形象荡然无存。\n若是平日，以张慎峰的性格，绝不会与其他真武弟子动手，一般来说，山上弟子大多谦和，不会当面恶言相向，而张慎峰行事又十分谨慎，轻易不在旁人面前暴露自身实力。\n然而，师尊提及的紫霞功和八荒诀让张慎峰的心态发生了变化：首先，既然习练这等上乘功法，自己就必须崭露头角，否则，自己以庸者身份习练上乘功法，难免让其他弟子议论，即使师尊出面，也无法服众；\n其次，师尊提到，自己的紫霞功已然筑基，而今日又已熟读紫霞功功法口诀，即使是自己独自修炼，也肯定会试一试这上乘功法的威力，更别说有一现成的活靶子练手了；\n其三，燕书磐虽是律令阁阁主的弟子，却并非出类拔萃，换言之，即使今日动手，那也是弟子之间的摩擦，律令阁阁主擅自动用执法特权，插手小辈之间的矛盾，会遭人非议，反过来，燕书磐平素仗势欺人，若是受伤也是咎由自取，与人何尤？即使动手，师尊也会站在自己这边。　最后，也是最重要的，那就是树活一张皮，人争一口气，无缘无故忍让退缩，即使不生心魔，也会脸面丢尽，无法抬头。\n一念及此，张慎峰故意微笑道：“师兄嘶吼功夫果然了得，大家都是练心法，唯独师兄却习练这种刚猛霸道的外家功夫，正是鸡立鹤群，出类拔萃啊，失敬失敬，若是没什么指教，师弟我就先行告辞了。”\n燕书磐早已怒不可遏，张慎峰的话就像压死骆驼的最后一根稻草，又 如点燃火药桶的一粒火星。燕书磐抽出木剑，道：“今天师兄我就教教你如何好好说话，让你学一学该怎么道歉！” 说罢急速欺身而来。\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch2/","tags":[],"title":"第二章 是非"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"进程与线程 进程的概念与特征 进程的概念 引入\n为实现操作系统的并发性和共享性，引入进程。\n概念\n进程是具有独立功能的程序在某个数据集合上的一次执行过程。\n进程是进程实体（进程映像）的运行过程，是系统进行资源调度和分配的独立单位。\n进程映像/进程实体\n由程序段，相关数据段，进程控制块PCB构成进程映像。进程映像是反应了进程在某一时刻的状态，因此进程映像是静态的；进程是动态的。\nPCB是进程的唯一标识\n在进程的整个生命周期中，系统总是利用PCB描述进程的基本情况和运行状态，进而控制和管理进程。即系统根据PCB感知进程的存在。因此称PCB是进程存在的唯一标识。\n进程的特征 动态性\n动态性是进程最基本的特征。\n并发性\n注意：并发使进程失去封闭性。所谓封闭性是指程序执行结果只取决于程序本身，不受外界影响；失去封闭性则在不同的外界因素下（如执行速度不同）结果也不同。\n独立性\n异步性\n异步性导致执行结果不可再现。为此必须配置进程同步机制。\n结构性\n每个进程都配置一个PCB。结构上由程序段，相关数据段，进程控制块组成。\n进程组织 进程内部，进程由下列部分组成：\nPCB 进程描述信息 PID、UID 进程控制管理信息 进程当前状态、进程优先级 资源分配清单 内存地址指针、IO设备信息 处理机相关信息 处理机中各寄存器值 程序段 数据段 C语言编写的程序使用内存时分为三个段、正文段、数据堆段核数据栈段。代码和静态赋值在正文段，动态分配的数据在堆段，临时使用的变量（实参、未赋值的变量）在栈段。\n进程之间，进程组织方式如下：\n链接方式 按照进程状态将PCB分为多个队列 OS持有指向各个队列的指针 索引方式 根据进程状态将PCB分为多个索引表 OS持有指向各个索引表的指针。 进程的状态与转换 进程五状态模型：创建态（新建态）、就绪态、运行态、阻塞态、结束态（终止态）。\n基本三状态\n运行态\n就绪态\n资源分配完毕准备就绪，等待上处理机运行。调度则变为运行态。\n阻塞态\n缺乏所需资源或正在等待事件发生，不具备上处理机运行资格。得到所需资源或事件发生后转为就绪态。\n状态切换\n运行→就绪\n发生调度，如时间片到，或高优先级进程抢占处理机。\n运行→阻塞\n进程需要等待资源或产生事件，例如系统调用，缺页故障等。\n运行→阻塞是进程的主动行为。\n就绪→运行\n发生调度，如分配时间片。\n阻塞→就绪\n进程所需资源或所等待事件已满足，如系统调用返回，内存中已获得新页。\n阻塞→就绪是进程的被动行为。\n进程控制 进程控制由不允许中断的程序实现，称该程序段为进程控制原语。原语是不可分割的基本单位。\n原语利用关中断和开中断两个特权指令实现其原子性。\n进程控制原语的执行内容不外乎下列三种：\n检索或申请、分配、更新、删除PCB 将PCB插入相关队列 分配或回收系统资源 进程控制原语实现下列功能：\n进程创建\n创建事件：终端用户登录、作业调度、系统提供服务、用户程序请求等事件都会创建进程。\n干扰项：设备分配，只需要设置相应的数据结构即可实现。\n申请和分配PCB（PCB是有限的） 分配资源 初始化PCB 将PCB插入就绪队列 进程撤销\n撤销事件：进程运行正常结束、异常结束、外界干预等。\n检索将被终止的PCB\n若尚在运行，立刻剥夺CPU，分配CPU给其他进程\n终止其所有子进程\n注：该步一般情况下执行，但也存在不终止任何子进程的可能（如创建守护进程），也存在未终止所有进程的可能（如子进程转为孤儿进程被init进程收养）\n回收资源，或归还父进程，或归还操作系统\n从所在队列中删除该进程PCB\n进程阻塞和唤醒\n阻塞事件：等待分配资源、等待其他进程完成工作等。\n检索将被阻塞的PCB 保护现场，转为阻塞态，暂停运行 将PCB插入对应事件的等待队列 唤醒事件：等待的事情已发生。\n检索PCB，在对应事件的等待队列中 从等待队列中移除PCB，设为就绪态 将PCB插入就绪队列 特别注意：由何事阻塞，就由何事被唤醒。“解铃还须系铃人”。\n进程切换\n切换事件：时间片到，更高优先级抢占，进程请求服务或请求资源而阻塞，进程终止。\n将运行环境信息存入PCB\n具体包括保存处理机上下文（或进程上下文，包括必要的寄存器数据等），更新PCB信息等\n将PCB移入相应的队列\n选择另一个进程执行，并更新PCB\n根据PCB恢复新进程所需的运行环境\n表：僵尸进程、孤儿进程、守护进程的区分\n进程类型 详细释义 孤儿进程 父进程退出，子进程还在运行，则这些子进程被init进程收养，称之为孤儿进程。此时它们的父进程就是init进程。 僵尸进程 子进程退出，父进程还在运行，父进程不收集子进程的状态信息，致使子进程的PCB仍然在系统中存留，称之为僵尸进程。 守护进程 用户层守护进程的父进程创建出守护进程后会先于守护进程退出，因此用户层守护进程是由init进程收养的孤儿进程；内核层的守护进程的父进程不是init进程。 表：处理机模式转换与进程状态切换以及调度的区别\n名词 详细释义 处理机模式转换 CPU从用户态到内核态，或者从内核态到用户态。处理机模式转换时，处理机逻辑上可能还在同一进程上运行，如系统调用等，该情况下返回进程继续执行时无需当前进程的环境信息。 进程切换 改变当前在CPU上运行的进程，当前进程的环境信息也需要改变。 处理机调度 处理机调度是一种决策行为，进程切换是一种实际执行行为。一般地，先有资源和CPU调度，然后发生进程的切换。 进程通信 必要性：各进程拥有的地址空间相互独立，且为了保证安全，相互不能访问其他地址空间。\n进程通信分为低级通信方式和高级通信方式。\n低级通信 即进程同步，其中的信号量同步称为PV操作。\n高级通信 共享存储 图：进程←→共享空间←→进程\n通信进程间存在一块可以直接访问的共享空间，进程可以使用同步互斥工具进行互斥访问、读写。\n共享存储分为两种：\n低级共享方式：基于数据结构的共享；数据结构受操作系统控制。 高级共享方式：基于存储区的共享；数据形式、存放位置由进程控制。 消息传递 进程间通信的内容是格式化的消息。通过发送消息和接受消息两个原语进行数据交换。\n直接通信方式\n发送进程直接把消息直接发送给接受进程，挂到接受进程的消息缓冲队列上。\n图：进程←→进程\n间接通信方式\n发送进程把消息发送到某个中间实体（称之为信箱）接受进程从中间实体取得消息。\n该通信方式又称为信箱通信方式。\n管道通信 管道：用于连接一个读进程和一个写进程以实现它们之间通信的共享文件，又称pipe文件。\n半双工通信\n因此为实现双向同时传输需要设置2个管道。\n各进程互斥访问\n管道写满，写阻塞，且未满不许读；管道读空，读阻塞，且未空不许写。\n读后即弃，阅后即焚。读进程最多只能有一个，防止数据读错的情况。\n管道通信需要提供互斥、同步以及确定对方存在。\n线程概念和多线程模型 线程概念 线程：基本的CPU执行单元，程序执行的最小单元。\n传统进程机制中，进程是资源分配、调度的基本单位。\n引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。\n线程与进程 表：进程与线程的比较\n进程 线程 调度 进程间线程切换引起进程切换；进程内线程切换不会引起进程切换。 线程是独立调度的基本单位。 资源 进程是拥有资源和资源分配的基本单位 线程基本不拥有资源 并发性 进程可以并发执行 线程可以并发执行 系统开销 创建和切换进程开销很大 创建和切换线程开销很小 地址空间和其他资源 进程间地址空间相互独立 线程间共享地址空间，共享进程的资源 通信 进程间通信需要进程同步互斥手段辅助 线程间可以直接读写进程的数据段 线程属性 线程拥有线程控制块TCB，同一进程的多个不同内核级线程可以各自独立占用多个CPU从而缩短进程整体的处理时间。\n线程在生命周期内也有阻塞态、就绪态和运行态三种基本状态。\n同一个系统的进程/线程可以由系统调用的方式被不同的进程/线程多次使用。\n线程实现方式 用户级线程\n实现：由应用程序通过线程库实现，对操作系统透明，即操作系统不知道用户级线程的存在。因此操作系统无从对其进行调度。\n内核级线程\n实现：线程管理的所有工作由操作系统内核完成\n严谨地说，内核级线程是处理机调度的单位。\n多线程模型\n多对一模型\n多个用户级线程映射到一个内核级线程管理。\n优点：开销小，效率高；线程切换不需要CPU变态。\n缺点：单个线程阻塞会导致整个进程阻塞，且多个线程不可在多核上并行运行。\n一对一模型\n一个用户级线程映射到一个内核级线程管理。\n优点：单个线程阻塞，其他线程仍可继续执行，并发能力强。\n缺点：成本高，开销大，线程切换需要CPU变态。\n多对多模型\nn个用户级线程映射到m个内核级线程上，要求m≤n。\n优点：见1与2，同时又克服了1与2的缺点。\n处理机调度 作业：用户在一次解题或一个事务处理过程中，要求计算机系统所做工作的集合，包括用户程序所需数据及命令等。\n进程同步 死锁 ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/operating-system/process-manage/","tags":[],"title":"进程管理"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"线性表定义 线性表是：①具有相同数据类型的$n(n\\ge 0)$个数据元素 ②有限 ③序列。\n特别地，当数据元素个数$n=0$时，线性表是空表； 非空线性表中位序表示第$i$个数据元素，从1开始； 相同数据类型→每个元素占用相同大小的存储空间； 序列→逻辑上具有顺序，除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继； 循环链表是否是线性表？是的。具体来说，循环链表是存储结构，线性表是逻辑结构，线性与否是从逻辑结构来划分的。链表在逻辑上均属于线性结构。循环链表与线性表属于不同层次，是线性表的特殊存储方式。 线性表顺序表示 线性表的顺序存储又称顺序表。逻辑上相邻的元素在物理上也相邻。随机存取。\n线性表链式表示 线性表的链式存储又称为单链表。顺序存取。\n表：头结点和头指针的区别\n名词 详细释义 头结点 头结点是带头结点链表中的第一个结点，结点内通常不存储信息。 头指针 头指针始终指向链表的第一个结点。 设置头结点的原因（必要性）\n由于第一个数据结点的位置被存放在头结点指针域中，因此对链表第一个位置上的操作与表在其他位置上的操作一致。 无论链表是否为空，其头指针都指向头结点的非空指针，因此空表和非空表的处理也就统一了。 循环链表 ※ 若对单链表的操作通常发生在表头或表尾，则可考虑循环单链表不设头指针而仅设尾指针。\n顺序表和链表的比较 结构上： 逻辑结构：两者都是线性结构； 物理结构：顺序存储时逻辑上相邻的元素物理上也相邻；链式存储时逻辑上相邻的元素物理上不一定相邻。 读写方式 ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/linear-list-terms/","tags":[],"title":"线性表基本概念"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Man Who 阅读who的联机帮助：\nman who 通过阅读联机帮助，发现已登录的用户信息放在/var/run/utmp或者/var/log/wtmp中。\n搜索联机帮助：\nman -k utmp man -k wtmp 返回的是：\nutmp (5) - 登录记录（login records） wtmp (5) - login records 阅读utmp的联机帮助：\nman 5 utmp 可以发现文件中保存的是结构数组，数组元素是utmp类型的结构。\nUTMP utmp UTMP_FILE的定义在/usr/include/utmp.h中。\n/* utmp.h */ /* Compatibility names for the strings of the canonical file names. */ #define UTMP_FILE _PATH_UTMP #define UTMP_FILENAME _PATH_UTMP #define WTMP_FILE _PATH_WTMP #define WTMP_FILENAME _PATH_WTMP 其中，变量_PATH_UTMP和_PATH_WTMP的定义在/usr/inlcude/paths.h中。\n#define\t_PATH_UTMP\t\u0026quot;/var/run/utmp\u0026quot; #define\t_PATH_WTMP\t\u0026quot;/var/log/wtmp\u0026quot; 所以，UTMP_FILE即为/var/run/utmp ，注意此文件不是文本文件，无法直接读取。\nstruct utmp的定义在/usr/include/utmp.h中。\nstruct utmp { short int ut_type; /* type of login */ pid_t ut_pid; /* pid of login process */ char ut_line[UT_LINESIZE]; /* device name of tty - \u0026quot;/dev/\u0026quot; */ char ut_id[4]; /* init id or abbrev. ttyname */ char ut_user[UT_NAMESIZE]; /* user name */ char ut_host[UT_HOSTSIZE]; /* hostname for remote login */ struct exit_status ut_exit; /* The exit status of a process marked as DEAD_PROCESS. */ long int ut_session; /* session ID, used for windowing*/ struct timeval ut_tv; /* time entry was made. */ int32_t ut_addr_v6[4]; /* IP address of remote host. */ char pad[20]; /* Reserved for future use. */ }; //注意有一行宏定义 /* Backwards compatibility hacks. */ #define ut_name\tut_user //因此也可以使用ut_name作为登录用户名的别名 exit_status struct exit_status的定义在/usr/include/utmp.h中。\nstruct exit_status { short int e_termination;\t/* Process termination status. */ short int e_exit;\t/* Process exit status. */ }; timeval Implement 略过介绍性的内容，utmp结构包含8个成员变量，而who命令使用到的是下面4个：\nut_user 登录名 ut_line 设备名 ut_time 登录时间 ut_host 登录的远程计算机名字 思路：\ngraph LR A[打开utmp]--\u0026gt;B[读取utmp记录] B--\u0026gt;C[实例化utmp对象] C--\u0026gt;B C--\u0026gt;D[关闭utmp] File API 已经知道getc和fgets函数可以从文件中读取字符或字符串，但读取数据结构中的信息效率太低。\n寻求联机帮助手册：\nman -k file | grep read man 2 read 由此可知，通过open()，read()，close()三个系统调用从utmp文件中取得用户登录信息。\nopen open的基本用法：\n目标：打开一个文件 头文件：#include\u0026lt;fcntl.h\u0026gt; 函数原型：int fd = open(char * name,int how) 参数： name 文件名 how 只读O_RDONLY，只写O_WRONLY，可读可写O_RDWR 返回值：-1表示错误，int表示成功返回。 打开后返回的正整数叫文件描述符，通过该唯一标识建立进程和文件之间的连接。不同的文件打开的文件描述符不同，同一文件的不同打开对应的文件描述符也不同。\nread read的基本用法：\n目标：把数据读取到缓冲区\n头文件：#include\u0026lt;unistd.h\u0026gt;\n函数原型：ssize_t numread = read(int fd,void * buf,size_t qty)\n有关ssize_t和size_t见于stddef.h中。\n在32位系统中长度为4个字节：\ntypedef unsigned int size_t; typedef signed int ssize_t; 在64位系统中长度为8个字节：\ntypedef unsigned long size_t; typedef signed int ssize_t; 参数：\nfd 文件描述符 buf 用来存放数据的目的缓冲区 qty 要读取的字节数 返回值：-1表示错误，numread表示成功读取的字节数。\n如果要求读取的字符超出了文件的长度，则numread返回0。\nclose close的基本用法：\n目标：关闭一个文件 头文件：#include\u0026lt;unistd.h\u0026gt; 函数原型：int result = close(int fd) 参数：fd 文件描述符 返回值：-1表示错误，0表示成功关闭。 Programming 根据思路，编写代码如下：\n/* * who.c 首次实现版本，通过读取utmp文件展示结果实现who功能 */ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;utmp.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt;//open() #include\u0026lt;unistd.h\u0026gt;//read(),close() #define SHOWHOST//用于包含输出远程主机的登录 void show_info(struct utmp * utmpbufferprint); int main() { struct utmp current_record;//实例化的\u0026quot;对象\u0026quot;，将读出的数据赋给它 int utmpfd;//文件描述符 int reclen=sizeof(current_record);//该结构的长度 if((utmpfd=open(UTMP_FILE,O_RDONLY))==-1)//UTMP_FILE是utmp.h中的宏定义 { perror(UTMP_FILE); //perror(s)用来将上一个函数发生错误的原因输出到标准设备(stderr)。 //参数 s 所指的字符串会先打印出，后面再加上错误原因字符串。 exit(1);//以异常情况退出 } //current_record是utmp类型，取地址运算符后是utmp*类型 //reclen保证每次读一个结构体长度的数据 //判断是否与结构体长度相等，当需读取长度大于当前文件长度时（只可能发生在最后一次读取）抛弃本次读取 while(read(utmpfd,\u0026amp;current_record,reclen)==reclen)//循环打印，确保所有用户都列出 { show_info(\u0026amp;current_record); } close(utmpfd); return 0; } 显示登录信息函数：\nint show_info(struct utmp * utmpbufferprint){ printf(\u0026quot;%-8.8s\u0026quot;,utmpbufferprint-\u0026gt;ut_name); /* * 1.ut_name 扩展到 ut_user 见前文 * 2.-代表左对齐，+代表右对齐 * 3.8代表字符宽度的最小值 * 4.\u0026quot;.8\u0026quot;代表将要打印的字符的最大数目 * 通过限制打印的最小值和最大值保证输出字符串长度为8 */ printf(\u0026quot; \u0026quot;); printf(\u0026quot;%-8.8s\u0026quot;,utmpbufferprint-\u0026gt;ut_line); printf(\u0026quot; \u0026quot;); showTime(utmpbufferprint-\u0026gt;ut_time); printf(\u0026quot; \u0026quot;); #ifdef SHOWHOST if(utmpbufferprint-\u0026gt;ut_host[0]!='\\0')//检查ut_host字符串是否为空 printf(\u0026quot;(%s)\u0026quot;,utmpbufferprint-\u0026gt;ut_host); #endif printf(\u0026quot;\\n\u0026quot;); return 0; } Improvement 系统所带的who命令只列出已登录用户的信息，而上述代码还会显示其他的信息。\n简单的思路是过滤掉用户名为空的记录，但是有些记录用户名为LOGIN，这显然不是一个真实的用户。因此需要更加详细地区分用户类型。\nut_type ut_type在/usr/include/utmp.h中定义：\n/* Values for the `ut_type' field of a `struct utmp'. */ #define EMPTY\t0\t/* No valid user accounting information. */ #define RUN_LVL\t1\t/* 系统的运行级别 The system's runlevel. */ #define BOOT_TIME\t2\t/* 系统启动时间 Time of system boot. */ #define NEW_TIME\t3\t/* 系统时钟改变后的时间 Time after system clock changed. */ #define OLD_TIME\t4\t/* 系统时钟改变的时间 Time when system clock changed. */ #define INIT_PROCESS\t5\t/*由init进程生成的进程 Process spawned by the init process. */ #define LOGIN_PROCESS\t6\t/* Session leader of a logged in user. */ #define USER_PROCESS\t7\t/* Normal process. */ #define DEAD_PROCESS\t8\t/* 终止进程 Terminated process. */ #define ACCOUNTING\t9 由该结构可知，当ut_type的值为7(USER_PROCESS)的时候，表明它是已经登录的用户。\n对原程序做如下的修改：\nvoid show_info(struct utmp * utbufferprint){ if(utbufferprint-\u0026gt;ut_type!=USER_PROCESS) return; //以下是原来的代码 //... } timeval 接下来要以正确的格式显示时间。\nman -k time | grep -i transform man -k time | grep -i convert 其中，-i是忽略大小写差异。\nLinux时间存储方式是time_val数据类型。以整数表示，数值是从1970年1月1日0时至今的总秒数，\n在/usr/include/sys/time.h中包含了头文件/usr/include/bits/types/struct_timeval.h\nstruct timeval的定义在该头文件中。\nstruct timeval{ __time_t tv_sec;/* Seconds 秒 */ __suseconds_t tv_usec;/* Microseconds 微秒 */ }; typedef __time_t time_t; 一般由函数int gettimeofday(struct timeval *tv, struct timezone *tz)获取系统的时间\n在源代码中使用了ctime()是因为utbufp-\u0026gt;ut_time的值是距离1970.1.1的秒数总和，是长整形，要把其转换为易读的时间格式。\n","permalink":"https://endlesspeak.github.io/docs/docs/develop-doc/linux-utils-program/2-who/","tags":[],"title":"编写Who命令"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"GPIO GPIO 是通用型输入输出，可以输入或输出高低电平。高电平是 3.3V，低电平是 0V。\nOutput 输出控制器接两个 MOS 管，一个 PMOS 管，一个 NMOS 管。\nNo Q1 Q2 Status 1 打开 关闭 高电平 2 关闭 打开 低电平 3 打开 打开 短路/不可用 4 关闭 关闭 浮空/高阻态 三种可用的 MOS 管状态将输出分为了推挽输出和开漏输出。\n其中，序号 1 和 2 组成了推挽输出，序号 2 和 4 组成了开漏输出。一般地，开漏输出需要搭配上拉电阻，以在高阻态时输出高电平，由于输出引脚并非直连电源电压，而是外部上拉电阻提供电压，因此开漏输出能够减小噪声对输出信号的影响。\n使用推挽输出的场景较多，一般需要高低电平的场景都可以选择推挽输出，尤其是无上拉电阻的时候，建议选择推挽输出；在多个 IO 输出接到一个 IO 输入时（线与）需要选择开漏输出。\n此外，对于接口电平转换，同供电电平选择推挽输出，不同供电电平选择开漏输出。\nLED Macro 下面是定义 LED 的相关引脚代码\n#define LED1_Pin GPIO_PIN_0 #define LED2_Pin GPIO_PIN_1 #define LED1_GPIO_Port GPIOB #define LED2_GPIO_Port GPIOB 下面是定义 LED 的相关逻辑代码\n#ifdef LED1_Pin #define LED1_ON() HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET) #define LED1_OFF() HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_SET) #define LED1_Toggle() HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin) #endif #ifdef LED2_Pin #define LED2_ON() HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,GPIO_PIN_RESET) #define LED2_OFF() HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,GPIO_PIN_SET) #define LED2_Toggle() HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin) #endif KEY Macro 下面是定义 KEY 的相关代码\n#define KEY_UP_Pin GPIO_PIN_0 #define KEY_RIGHT_Pin GPIO_PIN_3 //实际上是KEY0 #define KEY_DOWN_Pin GPIO_PIN_2 //实际上是KEY1 #define KEY_LEFT_Pin GPIO_PIN_13 //实际上是KEY2 #define KEY_UP_GPIO_Port GPIOA #define KEY_RIGHT_GPIO_Port GPIOH #define KEY_DOWN_GPIO_Port GPIOH #define KEY_LEFT_GPIO_Port GPIOC Polling 下面是一段轮询检测按键是否按下的代码，其中 KEYS 和 key_wait_aways 变量定义如下：\ntypedef enum { KEY_NONE = 0, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, } KEYS; const uint8_t key_wait_always = 0; 轮询检测代码如下，其中KEY_LEFT、KEY_RIGHT、KEY_DOWN都是低电平触发的。\nKEYS ScanPressedKey(uint32_t timeout){ uint32_t tickstart = HAL_GetTick(); const uint8_t btn_delay = 20; while(1){ #ifdef KEY_UP_Pin if(HAL_GPIO_ReadPin(KEY_UP_GPIO_Port,KEY_UP_Pin)==GPIO_PIN_SET){ HAL_Delay(btn_pre_delay); if(HAL_GPIO_ReadPin(KEY_UP_GPIO_Port,KEY_UP_Pin)==GPIO_PIN_SET){ return KEY_UP; } } #endif #ifdef KEY_LEFT_Pin if(HAL_GPIO_ReadPin(KEY_LEFT_GPIO_Port,KEY_LEFT_Pin)==GPIO_PIN_RESET){ HAL_Delay(btn_pre_delay); if(HAL_GPIO_ReadPin(KEY_LEFT_GPIO_Port,KEY_LEFT_Pin)==GPIO_PIN_RESET){ return KEY_LEFT; } } #endif #ifdef KEY_RIGHT_Pin if(HAL_GPIO_ReadPin(KEY_RIGHT_GPIO_Port,KEY_RIGHT_Pin)==GPIO_PIN_RESET){ HAL_Delay(btn_pre_delay); if(HAL_GPIO_ReadPin(KEY_RIGHT_GPIO_Port,KEY_RIGHT_Pin)==GPIO_PIN_RESET){ return KEY_RIGHT; } } #endif #ifdef KEY_DOWN_Pin if(HAL_GPIO_ReadPin(KEY_DOWN_GPIO_Port,KEY_DOWN_Pin)==GPIO_PIN_RESET){ HAL_Delay(btn_pre_delay); if(HAL_GPIO_ReadPin(KEY_DOWN_GPIO_Port,KEY_DOWN_Pin)==GPIO_PIN_RESET){ return KEY_DOWN; } } #endif if(timeout!=key_wait_always){ if((HAL_GetTick()-tickstart)\u0026gt;timeout) break; } } } 主函数中代码如下：\nKEYS cur_key = ScanPressedKey(100); const uint8_t btn_post_delay = 200; switch (cur_key) { case KEY_UP: LED1_ON(); LED2_ON(); printf(\u0026quot;KEY_UP input.\\n\u0026quot;); break; case KEY_LEFT: LED1_Toggle(); printf(\u0026quot;KEY_LEFT input.\\n\u0026quot;); break; case KEY_RIGHT: LED2_Toggle(); printf(\u0026quot;KEY_RIGHT input.\\n\u0026quot;); break; case KEY_DOWN: LED1_OFF(); LED2_OFF(); printf(\u0026quot;KEY_DOWN input.\\n\u0026quot;); break; default: printf(\u0026quot;No input keys.\\n\u0026quot;); break; } HAL_Delay(btn_post_delay); Reuse code Main Function call 首先使用函数调用的方式优化代码，将主函数中冗长的switch语句变为新函数，然后手动调用该函数。\n-Og -g 下大小增加了32B -Ofast -g 下大小不变 Macro Extend 宏展开的方法\n#define IS_KEY_UP_PRESSED() (HAL_GPIO_ReadPin(KEY_UP_GPIO_Port, KEY_UP_Pin) == GPIO_PIN_SET) #define IS_KEY_RIGHT_PRESSED() (HAL_GPIO_ReadPin(KEY_RIGHT_GPIO_Port, KEY_RIGHT_Pin) == GPIO_PIN_RESET) #define IS_KEY_DOWN_PRESSED() (HAL_GPIO_ReadPin(KEY_DOWN_GPIO_Port, KEY_DOWN_Pin) == GPIO_PIN_RESET) #define IS_KEY_LEFT_PRESSED() (HAL_GPIO_ReadPin(KEY_LEFT_GPIO_Port, KEY_LEFT_Pin) == GPIO_PIN_RESET) if (IS_KEY_UP_PRESSED()) { HAL_Delay(btn_pre_delay); if (IS_KEY_UP_PRESSED()) { return KEY_UP; } } if (IS_KEY_LEFT_PRESSED()) { HAL_Delay(btn_pre_delay); if (IS_KEY_UP_PRESSED()) { return KEY_LEFT; } } if (IS_KEY_RIGHT_PRESSED()) { HAL_Delay(btn_pre_delay); if (IS_KEY_RIGHT_PRESSED()) { return KEY_RIGHT; } } if (IS_KEY_DOWN_PRESSED()) { HAL_Delay(btn_pre_delay); if (IS_KEY_DOWN_PRESSED()) { return KEY_DOWN; } } -Og -g 下大小增加了144B -Ofast -g 下大小减少了4B Mutiple Funtion Call 多次函数调用\nuint8_t is_key_pull_down_pressed(GPIO_TypeDef* gpio_port, uint16_t gpio_pin) { return (HAL_GPIO_ReadPin(gpio_port, gpio_pin) == GPIO_PIN_SET); } uint8_t is_key_pull_up_pressed(GPIO_TypeDef* gpio_port, uint16_t gpio_pin){ return (HAL_GPIO_ReadPin(gpio_port,gpio_pin) == GPIO_PIN_RESET); } //省略函数形参 if(is_key_pull_down_pressed(KEY_UP_GPIO_Port,KEY_UP_Pin)){ HAL_Delay(btn_pre_delay); if(is_key_pull_down_pressed(KEY_UP_GPIO_Port,KEY_UP_Pin)){ return KEY_UP; } } if(is_key_pressed(KEY_LEFT_GPIO_Port,KEY_LEFT_Pin)){ HAL_Delay(btn_pre_delay); if(is_key_pull_up_pressed(KEY_LEFT_GPIO_Port,KEY_LEFT_Pin)){ return KEY_LEFT; } } if(is_key_pull_up_pressed(KEY_LEFT_GPIO_Port,KEY_LEFT_Pin)){ HAL_Delay(btn_pre_delay); if(is_key_pull_up_pressed(KEY_LEFT_GPIO_Port,KEY_LEFT_Pin)){ return KEY_LEFT; } } if(is_key_pull_up_pressed(KEY_RIGHT_GPIO_Port,KEY_RIGHT_Pin)){ HAL_Delay(btn_pre_delay); if(is_key_pull_up_pressed(KEY_RIGHT_GPIO_Port,KEY_RIGHT_Pin)){ return KEY_RIGHT; } } Inline Function Call 内联函数调用\nstatic inline uint8_t is_key_pressed(void) { return (HAL_GPIO_ReadPin(KEY_UP_GPIO_Port, KEY_UP_Pin) == GPIO_PIN_SET); } if (is_key_pressed()) { HAL_Delay(btn_pre_delay); // 等待按键稳定 if (is_key_pressed()) { return KEY_UP; } } Combined Function Call 合并函数调用\nbool is_key_pressed(uint16_t gpio_pin_set_status,GPIO_TypeDef* gpio_port,uint16_t gpio_pin){ if(HAL_GPIO_ReadPin(gpio_port,gpio_pin) == gpio_pin_set_status){ HAL_Delay(btn_pre_delay); if(HAL_GPIO_ReadPin(gpio_port,gpio_pin) == gpio_pin_set_status) return true; } } Template C++函数模板调用\ntemplate\u0026lt;typename GPIO_Port, typename GPIO_Pin\u0026gt; bool is_key_pressed() { return (HAL_GPIO_ReadPin(GPIO_Port, GPIO_Pin) == GPIO_PIN_SET); } if (is_key_pressed\u0026lt;KEY0_GPIO_Port, KEY0_Pin\u0026gt;()) { HAL_Delay(20); // 等待按键稳定 if (is_key_pressed\u0026lt;KEY0_GPIO_Port, KEY0_Pin\u0026gt;()) { return KEY_0; } } ","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/4-stm32-ledkey/","tags":[],"title":"STM32 LED \u0026 KEY"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"NixOS Linux是一个精确、纯净、可信赖、可重部署的发行版，它的设计包含一些独立的特性。\nReference 参考资料如下：\nNixOS 中文网 NixOS Manual Start Network Configuration NixOS 使用 wpa_supplicant 作为无线守护程序，因此可以使用交互式命令行或配置文件的形式进行网络连接\nPassphrase 可以用 wpa_passphrase 生成一个用于连接 WIFI 的配置文件\nwpa_passphrase XXX_wifi password \u0026gt; ~/.internet.conf 而后使用 wpa_supplicant 连接网络\nwpa_supplicant -c internet.conf -i wlan0 \u0026amp; 如果需要额外指定网卡，可以使用 -D 选项指定。\nCommand Line 使用下面的命令进入命令行交互模式：\nsudo systemctl start wpa_supplicant sudo wpa_cli 在交互模式下使用如下步骤连接：\n\u0026gt; add_network #0 \u0026gt; set_network 0 ssid \u0026quot;WIFI's SSID\u0026quot; #OK \u0026gt; set_network 0 psk \u0026quot;WIFI's password\u0026quot; #OK \u0026gt; set_network 0 key_mgmt WPA-PSK #OK \u0026gt; enable_network 0 #OK Change Channel 更换频道的目的是用国内源先把NixOS跑起来。\nsudo -i nix-channel --add https://mirrors.ustc.edu.cn/nix-channels/nixpkgs-unstable nixpkgs # 订阅镜像仓库频道 nix-channel --add https://mirrors.ustc.edu.cn/nix-channels/nixos-23.11 nixos # 请注意系统版本 nix-channel --list # 列出频道 nix-channel --update # 更新并解包频道 nixos-rebuild --option substituters \u0026quot;https://mirror.sjtu.edu.cn/nix-channels/store\u0026quot; switch --upgrade # 临时切换二进制缓存源，并更新生成 最后一步也可以不执行，而是在安装系统时一并执行。特别地，即使使用国内源，也可能存在特定的依赖关系致使没有对应的二进制包存在，建议使用手机热点的方式进行连接。\nPartition 可以使用下面的命令查看磁盘和文件系统情况：\ndu 查看指定目录或文件的磁盘使用情况，若不给定参数则显示当前目录 du -h 显示友好信息，会递归地显示每个目录的大小 du -h --max-depth=1 可以限定深度显示 df 查看文件系统磁盘使用情况和剩余空间 df -h 显示友好信息 df -T 显示各分区的类型 df -t ext4 限制显示类型 df -x tmpfs 排除显示类型 df -h | grep -v \u0026quot;/dev/loop\u0026quot; 排除 /dev/loop 使用情况 lsblk 用于列出系统中所有的块设备，这包括sysfs 文件系统和udev 数据库 lsblk -a 显示所有块设备，主要会增添显示逻辑块设备 lsblk -f 显示更详细的信息 fdisk 用于操作分区表 fdisk -l 显示分区表信息 fdisk -x 更详细地显示 fdisk [device] 对指定分区进行交互式操作 挂载分区后，对分区进行格式化操作\nmkfs.ext4 -L NixOS /dev/nvme0n1p8 mkfs.fat -F 32 /dev/nvme0n1p7 如果忘记给根分区打上标签，可以事后使用 e2label 补上。\ne2label /dev/nvme0n1p8 -L NixOS e2label /dev/nvme0n1p8 Settings Basic Configuration 在新机器上生成默认配置的命令如下：\nnixos-generate-config --root /mnt 如果仅需要硬件配置，可以将其从标准输入输出重定向到文件\nnixos-generate-config --show-hardware-config \u0026gt; /etc/nixos/hardware-configuration.nix Driver Configuration Nvidia 参考 NixOS Wiki Nvidia 的配置，错误的显卡配置会导致无法进入图形界面 仅含独立显卡的机器只需要安装独立显卡驱动 核显与独显组合则需要配置PRIME方案 UUID 硬盘的UUID在每次格式化后都会刷新 注意区分 FileSystem UUID 和 Partition UUID ，NixOS使用前者 挂载所需的分区后建议由NixOS自动生成硬件配置 Software 至少需要保证重建后的NixOS网络连通 network.wireless.enable = true; # use wpa_supplicant network.networkmanager.enable = true; # use networkmanager environment.systemPackage = with pkgs;[ git # flakes required firefox neovim curl # flakes required pciutils usbutils nix-prefetch-git # nix-prefetch-url already installed ]; Build System 一般运行两次重建命令：\n使用默认配置把系统先跑起来，然后打开实验性质的选项：\nnix.settings = { substituters = lib.mkForce [ \u0026quot;https://mirrors.cernet.edu.cn/nix-channels/store\u0026quot; ]; experimental-features = [\u0026quot;nix-command\u0026quot; \u0026quot;flakes\u0026quot;]; }; 导入配置，重建系统\n","permalink":"https://endlesspeak.github.io/docs/build/operating-system-installation/linux-technology-3-4-nixos-linux-installation/","tags":[],"title":"NixOS Linux 物理机安装与配置"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Organization Form Related works 我们通常可以有如下几种形式来管理配置文件：\n单文件法 模块化法 将所有配置文件模块化，通过 init.el 来统一加载； 将所有配置文件通过 org 文件来管理，通过 org-babel-load-file 函数来加载； 将所有配置文件通过 org 文件来管理，通过 tangle 的技术实现模块化； Contributions 本文所用的方法是：\n将配置文件交给 org 管理，实现模块化； 通过 tangle 技术编译生成配置文件； 生成的配置结构与方法一完全相同 Advantage 使用 Org mode 来管理所有的配置文件的好处：\n通过 Org mode 强大的文学编程功能，我们可以让我们的配置文件更加清晰有序 可以添加很多注释之外的资料、链接等，让配置更加易读和可管理 Organization Structure File Structure 首先备份已有的配置到其他文件夹，而后在 ~/.emacs.d 文件夹中建立 config 目录。\n稍后所有的 org 配置文件都会放到 config 目录中，它们的结构基本与外层的 el 文件相同。\nTangle Org mode 提供了 org-babel-tangle ，它能够自动的将代码块里的代码，写入到指定的文件里去。\n它的配置方式有两种：\n可以在代码块的参数行配置 tangle 参数 可以在 org mode 的标题行添加标题参数配置 Org Title 方法一： 在标题行下方，通过 :PROPERTIES: 和 :END: 包裹的区域，即 属性抽屉 里，添加 :HEADER-ARGS: 行 通过 :tangle 后加上指定自动写入的文件路径，来配置这个标题行下所有的代码块的自动写入行为 方法二： 在标题栏下方，通过 #+PROPERTY 属性加入 header-args 参数 通过 :tangle 后加上指定自动写入的文件路径，来配置这个标题行下所有的代码块的自动写入行为 下面给出两个例子，演示如何在标题栏通过标题参数来配置 tangle\n每个 org 文件按统一的格式编写开头，必要的内容如下：\n:PROPERTIES: :HEADER-ARGS: :tangle XXX.el :lexical t :END: Nasyxx 佬的写法是下面这样的：\n#+PROPERTY: header-args:emacs-lisp :tangle (concat temporary-file-directory \u0026quot;XXX.el\u0026quot;) :lexical t 因而我的配置如下，其中我没有用到 (concat temporary-file-directory \u0026quot;str\u0026quot;) 部分，因此这样写是不必要的。\n:PROPERTIES: :HEADER-ARGS: :tangle (concat temporary-file-directory \u0026quot;XXX.el\u0026quot;) :lexical t :END: 而后可以添加代码块，语言设为 emacs-lisp ，并在代码块中编写配置代码。\n特别地，全局代码块写入肯定存在意外：\n如果有一个代码块不想写入文件，在代码块参数行追加 :tangle no 如果有一个子标题下的所有代码块均不想写入文件，则给子标题加参数 :HEADER-ARGS: :tangle no By Code Block 下面的例子展示如何在代码块层级配置 tangle\n在代码块写语言类型的这一行，添加 :tangle 参数，后加目标写入文件\n#+begin_src emacs-lisp :tangle ~/.emacs.d/test.el (+ 1 2) #+end_src Compilation 代码块写好之后，如何执行写入操作呢？本部分提供两种思路：\n手动 tangle 动作进行写入：对每个 org 文件执行 org-babel-tangle 命令 编写 makefile ，使用命令进行“编译” Basic 在本文的场景中，写入的原理是利用 emacs 的 ob-tangle 模块。\norg-babel-tangle 用于提取源代码块并将其保存到指定文件中的命令 org-babel-tangle-publish 是一个扩展命令，用于将源代码块从 org 文件中提取并发布到指定目录中 Command 使用下面的命令可以批量进行写入：\nparameter1 = \u0026quot;(progn (require 'ob-tangle) (setq org-confirm-babel-evaluate nil))\u0026quot; parameter2 = '(org-babel-tangle-publish t \u0026quot;XXX.org\u0026quot; \u0026quot;XXX.el\u0026quot;)' emacs -Q --batch --eval $parameter1 --eval $parameter2 Makefile 将配置文件通过 makefile 统一进行写入，也可以使用 shell 脚本。\n# 定义 EM 和 EE 变量 EM ?= emacs EE ?= $(EM) -Q --batch --eval \u0026quot;(progn (require 'ob-tangle) (setq org-confirm-babel-evaluate nil))\u0026quot; # 需要加载的目录，可能有lisp site-lisp 等 DS = core etc lang # 自定义编译模板的函数 tangle_template 用于将 *.org 转为 *.el define tangle_template # 检查目录是否存在，不存在就创建 check_dir.$(1): @mkdir -p lisp/$(1) # 目录作为目标，指示新的编译目标 $(1): $(patsubst config/$(1)/%.org, lisp/$(1)/%.el,$(wildcard config/$(1)/*.org)) clean-$(1): rm -rf lisp/$(1) .PHONY: clean-$(1) # 目标的编译方法 lisp/$(1)/%.el: config/$(1)/%.org $(EE) --eval '(org-babel-tangle-publish t \u0026quot;$$\u0026lt;\u0026quot; \u0026quot;$$(@D)/\u0026quot;)' endef early-init.el: config/early-init.org $(EE) --eval '(org-babel-tangle-publish t \u0026quot;$\u0026lt;\u0026quot; \u0026quot;$(@D)/\u0026quot;)' init.el: config/init.org $(EE) --eval '(org-babel-tangle-publish t \u0026quot;$\u0026lt;\u0026quot; \u0026quot;$(@D)/\u0026quot;)' dump.el: config/dump.org $(EE) --eval '(org-babel-tangle-publish t \u0026quot;$\u0026lt;\u0026quot; \u0026quot;$(@D)/\u0026quot;)' # (foreach var, list, template) var 是临时变量，list是需要遍历的列表，template是一个模板字符串 # foreach 遍历 DS 中的每个元素，作为dir传给后面的eval函数求值，所需求值的表达式为call调用模板方法生成编译命令 # 遍历 DS 目录，生成 tangle_template规则 $(foreach dir,$(DS),$(eval $(call tangle_template,$(dir)))) el: $(DS) early-init.el init.el dump.el elc: $(EM) --batch -l ./init.el -L \u0026quot;lisp\u0026quot; --eval '(byte-recompile-directory \u0026quot;lisp/etc\u0026quot; 0)' $(EM) --batch -l ./init.el -L \u0026quot;lisp\u0026quot; --eval '(byte-recompile-directory \u0026quot;lisp/lang\u0026quot; 0)' generate: el generate-elc: el elc clean: rm early-init.el init.el rm -rf lisp ","permalink":"https://endlesspeak.github.io/docs/build/editorconfiguration/4-manage-by-orgmode/","tags":[],"title":"Manage By Org Mode"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Variable Basic Varibale 变量拥有以下特性：\n默认情况下变量是不可变的(immutable) 它是 Rust 众多精妙特性的其中一个 它令用户充分利用 Rust 提供的安全性和简单并发性的方式来编写代码 在此情况下，一旦将值绑定到变量将不能再更改 添加 mut 关键字让变量可变(mutable) Constant 常量是绑定到一个常量名且不允许更改的值，它与不可变变量的差异如下：\n常量使用 const 关键字，并且 必须注明类型 常量只能设置成常量表达式，这代表： 编译期计算完成，不能在运行时计算 不能是函数调用的结果 常量命名约定是全部字母大写，且下划线分隔单词 const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; Shadow 遮蔽使用户可以声明和前面变量具有相同名称的新变量，它和可变变量差异如下：\n如果不小心尝试重新赋值给变量，将得到编译错误 遮蔽允许对值进行转换，也允许对类型进行转换 let spaces = \u0026quot; \u0026quot;; let spaces = spaces.len(); ","permalink":"https://endlesspeak.github.io/docs/docs/rust-programming-basic-doc/4-variable/","tags":[],"title":"Variable"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"原理 简要描述一下前馈神经网络算法的实现原理\n确定每层隐藏层的层数、激活函数，根据净输入计算输出和活性值，然后传递给下一层，直到最终的输出层； 通过输出层的内容与分类结果比对，记录误差； 通过后一层的误差计算前一层的误差；计算该层的权重梯度和偏置梯度，然后更新参数，直到最前一层隐藏层。 什么是激活函数？为什么需要激活函数？有哪些激活函数？\n神经网络中每个神经节点接受上一层的输出作为本层的输入，并将输出传给下一层。上层节点的输出和下层节点的输入之间具有一个函数关系，这个函数称为激活函数（又称激励函数）。\n激活函数的性质：连续并可导或少数点不可导的非线性函数，激活函数及其导数要尽可能简单；激活函数的导函数的值域要在一个合适的区间内；\n激活函数的作用相当于支持向量机中的核技巧，使用非线性函数激活函数可以令神经网络具有逼近任意函数的能力，而不仅仅只是输入的线性组合。\n激活函数例如Sigmoid型（包括Logistic函数和Tanh函数）又如ReLU型。\n\\[ \\begin{align} \u0026amp;sigmoid(x)=\\frac{1}{1+e^{-x}}\\\\ \u0026amp;tanh(x)=\\frac{e^x-e^{-x}}{e^x+e^{-x}}\\\\ \u0026amp;tanh(x)=2\\sigma(2x)-1\\\\ \u0026amp;ReLU(x)=max(0,x)= \\begin{cases} \\ x,x\u0026gt;0\\\\ \\ 0,x\u0026lt;0 \\end{cases} \\end{align} \\]\n激活函数的性质\nLogistic 函数是“挤压”函数，值域\\((0,1)\\)\n对一些输入产生兴奋，对另一些输入产生抑制\nTanh 函数，值域\\((-1,1)\\)\n零中心化（关于原点对称）。\n特别地，非零中心化会使后一层神经元的输入发生偏置偏移，并使梯度下降收敛速度变慢。\nReLU 函数，值域\\((0,+\\infty)\\)\n非零中心化。另外在训练时比较容易“死亡“，即某一次更新后ReLU神经元对所有数据都是0，且在以后的训练过程中永远不能被激活。\n什么是通用近似定理？\n神经网络的隐藏层在满足一定条件时，可以以任意精度近似任何一个在实数空间内的有界闭集函数。\n条件如下：\n具有线性输出层和至少一个使用“挤压”性质（把无穷区间映射到有穷区间）的激活函数； 隐藏层内神经元数量足够多； 神经网络的前馈传播如何进行？\n设输入\\(\\alpha_i=[\\alpha_{i1},...,\\alpha_{im}]^T\\)，第l层第i个神经元的输入是\\(m\\times 1\\)的向量。\n设第l层权重矩阵的行向量\\(W_i^{(l)}=[W_{i1}^{(l)},...,W_{im}^{(l)}]\\)，第l层的第i个神经元的权重向量是\\(1\\times m\\)向量。\n设第i层有n个神经元（n的数量可以自由设置）。\n第l层的净输入\\(z^l\\)： \\[ z^{(l)}=W^{(l)}\\alpha^{(l-1)}+b^{(l)} \\] 其中\\(W^{(l)}\\)是\\(n\\times m\\)矩阵，\\(\\alpha^{(l-1)}\\)是\\(m\\times 1\\)向量。\n第l层的净输出\\(\\alpha^l\\)： \\[ \\alpha^{(l)}=f_l(z^{(l)}) \\] 其中\\(\\alpha^{(l)}\\)是\\(n\\times 1\\)向量。\n特别地，样本向量x作为第0层的净输出；最后一层的净输出作为整个函数的输出。\n神经网络中的参数的学习方式是什么？\n损失函数为交叉熵损失函数，样本的损失函数为： \\[ \\mathcal{L}(y,\\hat{y})=-ylog\\hat{y} \\] 训练集在数据集上的结构化风险函数为： \\[ R(W,b)=\\frac{1}{N}\\sum\\limits_{n=1}^{N}\\mathcal{L}(y^{(n)},\\hat{y}^{(n)})+\\frac{1}{2}\\lambda\\Vert W\\Vert_F^2 \\] 正则化项是Frobenius范数的平方，也就是所有参数平方的和。\n参数更新采用梯度下降法。具体过程如下：\n新参数等于旧参数减去学习率乘以偏导数（偏置参数）或偏导数加上\\(\\lambda W^{l}\\)（权重参数）； \\[ W^l_{new}=W^l_{old}-\\alpha(\\frac{\\partial \\mathcal{L}(y^{(n)},\\hat{y}^{(n)})}{\\partial W^{l}}+\\lambda W^{l}) \\]\n\\[ b^l_{new}=b^l_{old}-\\alpha(\\frac{\\partial \\mathcal{L}(y^{(n)},\\hat{y}^{(n)})}{\\partial b^{l}}) \\]\n反向传播算法\n先计算损失函数对每个元素的偏导数，然后合并到矩阵；根据链式法则： \\[ \\frac{\\partial\\mathcal{L}(y,\\hat{y})}{\\partial\\omega_{ij}^{(l)}}=\\frac{\\partial\\mathcal{L}(y,\\hat{y})}{\\partial z^{(l)}}\\cdot\\frac{\\partial z^{(l)}}{\\partial\\omega_{ij}^{(l)}} \\]\n\\[ \\frac{\\partial\\mathcal{L}(y,\\hat{y})}{\\partial b^{(l)}}=\\frac{\\partial\\mathcal{L}(y,\\hat{y})}{\\partial z^{(l)}}\\cdot\\frac{\\partial z^{(l)}}{\\partial b^{(l)} } \\]\n由上式知需要计算三个偏导数：\n第l层的损失函数对第l层的净输入的偏导\n表示第l层神经元对最终损失函数的影响，也称其为误差项；\n\\[ \\begin{aligned} \\delta^{(l)}\u0026amp;=\\frac{\\partial\\mathcal{L}(y,\\hat{y})}{\\partial z^{(l)}}\\\\ \u0026amp;=\\frac{\\partial\\alpha^{(l)}}{\\partial z^{(l)}}\\frac{\\partial z^{(l+1)}}{\\partial \\alpha^{(l)}}\\frac{\\partial\\mathcal{L}(y,\\hat{y})}{\\partial z^{(l+1)}}\\\\ \u0026amp;=f\u0026#39;_l(z^{(l)})\\odot\\left((W^{(l+1)})\\delta^{(l+1)})\\right)\\\\ \\end{aligned} \\]\n第l层的神经元误差项：是所有与该神经元相连的第l+1层的神经元的误差项的权重和再乘以该神经元激活函数的梯度。\n第l层的净输入对第l层的权重向量的偏导\n矩阵微分采用分母布局，一个列向量关于标量的偏导数为行向量。\n\\[ \\begin{aligned} \\frac{\\partial z^{(l)}}{\\partial\\omega_{ij}^{(l)}}\u0026amp;=\\left[ \\frac{\\partial z_1^{(l)}}{\\partial\\omega_{ij}^{(l)}},...,\\frac{\\partial z_i^{(l)}}{\\partial\\omega_{ij}^{(l)}},...,\\frac{\\partial z_{M_l}^{(l)}}{\\partial\\omega_{ij}^{(l)}}, \\right]\\\\ \u0026amp;=\\left[ 0,...,\\frac{\\partial (W_i^{(l)}\\alpha^{(l-1)}+b_i^{(l)})}{\\partial\\omega_{ij}^{(l)}},...,0 \\right] \\end{aligned} \\]\n设结果为第i个元素为\\(a_j^{(l-1)}\\)，其余为0的行向量； \\(W_i^{(l)}\\)为权重矩阵\\(W^{(l)}\\)的第i行，即第i个神经元的权重向量。\n第l层的净输入对第l层的偏置的偏导（单位矩阵）；最终得到下面的公式：\n\\[ \\begin{align} \u0026amp; \\frac{\\partial \\mathcal{L}(y^{(n)},\\hat{y}^{(n)})}{\\partial W^{l}}=\\delta^{(l)}(\\alpha^{(l-1)})^T\\\\ \u0026amp; \\frac{\\partial \\mathcal{L}(y^{(n)},\\hat{y}^{(n)})}{\\partial b^{l}}=\\delta^{(l)} \\end{align} \\]\n层与层之间参数更新的方式是矩阵乘法。 softmax函数\n假设我们有一个数组V，Vi表示V中的第i个元素，那么这个元素的Softmax值为 \\[ S_i=\\frac{e^{V_i}}{\\sum\\limits_je^{V_j}} \\] 该元素的softmax值就是该元素的指数与所有元素指数和的比值。\n定义交叉熵损失函数： \\[ Loss=-\\sum\\limits_i t_ilny_i \\] 其中\\(t_i\\)表示真实值，\\(y_i\\)​表示求出的softmax值。其中目标类的\\(t_i=1\\)，其他均为0。\n当预测到第i个时，可以认为\\(t_i=1\\)，损失函数变成： \\[ Loss_i=-lny_i \\] 定义选到\\(y_i\\)的概率为 \\[ P_{f_{y_i}}=\\frac{e^{f_{y_i}}}{\\sum\\limits_je^{f_{y_i}}} \\] 把数值映射到0-1之间，和为1，则有 \\[ f_{y_i}=\\frac{e^{f_{y_i}}}{\\sum\\limits_je^{f_{y_j}}}=1-\\frac{\\sum\\limits_{j \\neq i}e^{f_{y_j}}}{\\sum\\limits_je^{f_{y_j}}} \\] 对损失函数求导 \\[ \\begin{aligned} \\frac{\\partial Loss_i}{\\partial f_{y_j}}\u0026amp;=\\frac{\\partial (-lny_i)}{\\partial f_{y_j}}\\\\ \u0026amp;=\\frac{\\partial (-ln\\frac{e^{f_{y_i}}}{\\sum\\limits_je^{f_{y_j}}})}{\\partial f_{y_j}}\\\\ \u0026amp;=-\\frac{1}{\\frac{e^{f_{y_i}}}{\\sum\\limits_je^{f_{y_j}}}}\\cdot \\frac{\\partial \\frac{e^{f_{y_i}}}{\\sum\\limits_je^{f_{y_j}}}}{\\partial f_{y_i}}\\\\ \u0026amp;=-\\frac{\\sum\\limits_je^{f_{y_j}}}{e^{y_i}}\\cdot \\frac{\\partial(1-\\frac{\\sum\\limits_{j \\neq i}e^{f_{y_j}}}{\\sum\\limits_je^{f_{y_j}}})}{\\partial f_{y_i}}\\\\ \u0026amp;=-\\frac{\\sum\\limits_je^{f_{y_j}}}{e^{y_i}}\\cdot (-\\sum\\limits_{j \\neq i}e^{y_j})\\cdot \\frac{\\partial(\\frac{1}{\\sum\\limits_j e^{y_j}})}{\\partial f_{y_i}}\\\\ \u0026amp;=\\frac{\\sum\\limits_j e^{f_{y_j}}\\cdot \\sum\\limits_{j \\neq i}e^{y_j}}{e^{y_i}}\\cdot \\frac{-e^{y_i}}{(\\sum\\limits_{j}e^{y_j})^2}\\\\ \u0026amp;=-\\frac{\\sum\\limits_{j \\neq i}e^{f_{y_j}}}{\\sum\\limits_je^{f_{y_j}}}\\\\ \u0026amp;=-(1-\\frac{e^{f_{y_i}}}{\\sum\\limits_je^{f_{y_j}}})\\\\ \u0026amp;=P_{f_{y_i}}-1 \\end{aligned} \\]\n什么是随机梯度下降？为什么要随机梯度下降？\n为了使结构化风险函数最小，需要优化其中的参数。\n每次采集一个样本，计算这个样本的结构化风险函数的梯度并沿负方向更新参数。\n沿负方向的目的是使结构化风险函数最小化。\n其中结构化风险是经验风险加上一个参数的正则化项；\n经验风险是对所有训练样本的损失函数的平均值。\n批量梯度下降的开销太大，每次只计算一个样本可以简化计算，通过梯度下降找到局部最优或鞍点，通过随机噪声跳出局部最优。降低开销，提高收敛速度。\n随机梯度下降的反向传播算法实现\n随机初始化权重矩阵、偏置 当模型的错误率还在下降时，循环 对训练样本集中的样本随机重排序 对每个样本，循环 选取样本 前馈计算 反向传播 实现思路 sigmoid函数实现\n计算公式为： \\[ sigmoid(x)=\\frac{1}{2}tanh(\\frac{x}{2}) \\] 实现代码为：\ndef sigmoid(x): return 0.5*(1+np.tanh(0.5*x)) 该函数实际未用，实际使用的是numpy.tanh(x)，因为它能传入矩阵。\nnumpy拆分数组和合并数组\n合并数组dataSet=np.concatenate((x_train, y_train), axis=1) 拆分数组x_train,y_train=np.split(dataSet,(76,),axis=1) numpy排序\nnumpy.sort(a,axis,kind,order)\nnumpy产生随机权重矩阵\nnumpy.random.rand(76,50) numpy.random.randn(76,50)/np.sqrt(76) 正向传播\nz1 = a0.dot(W1) + b1 a1 = np.tanh(z1) z2 = a1.dot(W2) + b2 a2 = np.tanh(z2) z3 = a2.dot(W3) + b3 a3 = np.tanh(z3) z4 = a3.dot(W4) + b4 # 最后一层使用softmax函数作为输出层激活函数 exp_scores=np.exp(z4) # 归一化概率 probs=exp_scores/np.sum(exp_scores,axis=1,keepdims=True) 反向传播\n\\(\\delta^{(l)}\\)的更新公式见上。输出层为softmax函数。 \\[ \\delta^{(l)}_k=p_k-1 \\] （该公式推导见上面。）\ndelta4 = probs delta4[range(num_examples), y] -= 1 dW4 = (a3.T).dot(delta4) db4 = np.sum(delta4, axis=0, keepdims=True) delta3 = delta4.dot(W4.T) * (1 - np.power(a3, 2)) # tanh(x)的导数是1-tanh^2(x) dW3 = (a2.T).dot(delta3) db3 = np.sum(delta3, axis=0, keepdims=True) delta2 = delta3.dot(W3.T) * (1 - np.power(a2, 2)) dW2 = (a1.T).dot(delta2) db2 = np.sum(delta2, axis=0, keepdims=True) delta1 = delta2.dot(W2.T) * (1 - np.power(a1, 2)) dW1 = np.dot(a0.T, delta1) db1 = np.sum(delta1, axis=0) 预测\n正向传播一次，用softmax激活函数作输出层的激活函数，并归一化。\n使用numpy.argmax输出最大值索引（分类正确结果是0或1，两个概率哪个高选择哪个）\n","permalink":"https://endlesspeak.github.io/docs/docs/machinelearning-doc/traddional-machine-learning/4-nerualnetwork/","tags":[],"title":"前馈神经网络问题"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"概述 21世纪的三大特征？三类网络是哪三类？\n数字化、信息化、网络化；电信网络、有线电视网络、计算机网络\n计算机网络经历了哪些发展阶段？\n一共有三大阶段，分别是：\n单个网络向互联网发展； 建成三级结构的互联网； 形成多层次ISP结构的互联网； 互联网最重要的两个特点？\n连通性和共享。连通性是交换信息，共享是资源共享。\n硬件资源共享 软件资源共享 用户间信息交换 分布式处理 互联网的组成？\n分为边缘部分和核心部分。\n边缘部分由连接在互联网上的主机构成，由用户直接使用，功能是通信和资源共享； 核心部分由网络和路由器构成，为边缘部分提供服务，功能是连通性和交换。 网络边缘部分通信方式有哪些？\n客户-服务器 C/S 方式和对等 P2P 方式。\nB/S\n本质上是 C/S 架构，对用户来说，可以通过固定的客户端（浏览器）接入互联网\n优点：接入方式统一，具有一定的安全性； 缺点：浏览器在部分系统上的特定操作无法执行； 应用：搜索引擎； C/S\n客户端和服务端的模式；客户端向服务器发送请求，服务端根据请求向客户端返回数据；\n优点：可以根据需要定制客户端 缺点：需要安装客户端才能启动 应用：QQ、微信 P2P\n网络之间结点采取对等方式进行通讯，无服务器端或服务端的概念。\n优点：通讯过程不经过服务器，而是直接与其他主机相连； 缺点：安全性受到影响；消耗更多的用户机器资源； 应用：P2P下载 网络核心部分通信方式是什么？\n分组交换。（路由器是实现分组交换的关键构件，任务是转发收到的分组）\n实体、协议、服务、接口分别是什么？\n实体表示任何可发送或接收信息的硬件或软件进程。\n协议是控制两个对等实体或多个实体进行通信的规则的集合。\n在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。\n接口是同一结点相邻两层之间交换信息的连接点。\n协议是水平的，服务是垂直的。\n计算机网络提供的服务类型\n面向连接服务与无连接服务\nTCP是面向连接的，IP和UDP是无连接的；\n可靠服务与不可靠服务\n可靠指的是网络具有纠错、检错、应答机制；\n不可靠指的是尽最大努力交付；\n有应答服务与无应答服务\n接收方收到数据后给出应答，包括接收应答与否定应答，例如TCP协议；\n无应答服务则在接收数据后不给出应答。例如WWW服务。\n网络协议是什么？具有哪些核心要素？各起到什么作用？\n网络中进行数据交换而建立的规则称为协议。\n语法。数据和控制信息的结构与格式。 语义。发出何种控制信息、完成何种动作以及如何响应。 同步。事件发生顺序的详细说明。 信息数据交换方式有哪些？\n电路交换和分组交换（包括报文交换）。\n电路交换是面向连接的\n通信前建立一条双方专用的物理通信路径，通信结束后释放。\n分组交换是无连接的\n可靠性高，利用率高，无连接（无建立时延），多目标服务\n报文交换使用存储转发方式\n分组交换在报文交换的方式上限制了每次传送的数据块大小的上限\n额外具有简化了存储管理，减少了出错概率和重发数据量\n东西蓝军和白军问题\n东边先发送计划，及要求确认。西边收到电文并回发同意。但是西边现在还要等待东边蓝军发送对确认的确认，而东边蓝军发送后还需要等待对这个确认的确认的确认，如此反复，两边都无法确定对方是否一定收到了电文，因此无法百分之百保证双方会共同进攻。\n点到点通信与端到端通信的区别（见运输层/传输层题2）\n从本质上说,由物理层、数据链路层和网络层组成的通信子网为网络环境中的主机提供点到点的服务, 而传输层为网络中的主机提供端到端的通信。\n点到点通信\n直接相连的结点之间的通信称为点到点通信,\n它只提供一台机器到另一台机器之间的通信，不涉及程序或进程的概念。\n点到点通信并不能保证数据传输的可靠性,也不能说明源主机与目的主机之间是哪两个进程在通信,这些工作都是由传输层来完成的。\n端到端通信\n建立在点到点通信的基础上,它是由一段段的点到点通信信道构成的,是比点到点通信更高一级的通信方式，以完成应用程序(进程) 之间的通信。\n”端” 是指用户程序的端口，端口号标识了应用层中不同的进程。\n物理层 物理层特性\n机械特性 主要定义物理连接的边界点 电气特性 传输二进制位时线路上信号的电压、传输速率、距离等限制 功能特性 指明某一电平具体表示的意义 过程特性 主要与事件时序等相关 基带和频带的区别\n基带信号\n基带信号即基本频带信号（低频），是来自信源的信号，既包括数字信号也包括模拟信号；\n基带传输\n将基带信号送到数字信道上传输称为基带传输；距离近，速率快；\n带通信号\n将基带信号进行载波调制后（可能是频分复用模拟信号），信号的频率范围被搬移到较高的频段；\n带通传输/宽带传输\n将带通信号/宽带信号放到模拟信道传输称为带通传输（或宽带传输）；距离远，速率慢；\n比特和波特的区别？\n波特是设备每秒钟发生信号变化的度量，它代表的是信号的变化。1波特表示数字通信系统每秒传输1个码元。码元是指用一个固定时长的信号波形表示的k进制数字。\n比特是信息量的单位。\n换算关系为$1\\ Baud=log_2k\\ bit$\n奈奎斯特定理（解决码间串扰）\n理想低通，没有噪声，带宽有限的信道中，\n极限码元传输率为$2W\\ Baud$； 极限数据传输速率为$2Wlog_2k\\ bit$ 其中W是带宽，k代表码元离散电平的数目，或不同码元的个数，或码元代表k进制数\n香农定理（解决噪声影响）\n信道的极限数据传输率为$Wlog_2(1+S/N)$\n式中W为信道的带宽，S为信道所输信号的平均功率，N为高斯噪声功率。\n采样定理\n采样频率至少需要大于等于信号最高频率的2倍，才能保证完整保留原始模拟信号的信息。\n信道复用技术\n频分复用\n多路基带信号调制到不同频率载波上，叠加形成一个复合信号；\n时分复用\n物理信道分为N个时间片，轮流分配给各个信号使用；\n波分复用\n光的频分复用，在光纤中传输多种不同波长（频率）的光信号\n码分复用\n既共享信道的频率，又共享信道的时间。\n数据链路层 数据链路层的三个基本问题？（待完善）\n封装成帧，透明传输和差错检测。\n什么是可靠传输？（待完善）\n点对点和端到端工作在哪层？是什么工作机制？\n传输层用来提供端到端的服务，两个主机上的进程进行通信，不需要关心报文的中间的转发，看上去就像两端进程直接在通信。\n数据链路层和网络层则提供点到点的通信；其中数据链路层使用点对点协议PPP，而网络层则考虑的是报文的存储转发，具体来说是从一台主机到另外一台主机。\n局域网有哪些？\n以太网是最普遍的有线局域网。逻辑拓扑是总线型，物理拓扑是星型。\n局域网的介质访问控制方式是？\nCSMA/CD协议 令牌总线 令牌环 其中前两种用于总线型局域网，如以太网的介质访问控制方式是CSMA/CD协议。\n网络层 互联网网络层的设计思路和传统的电信网络有何不同？\n电信网是面向连接的，而网络层向上只提供简单灵活、无连接、尽最大努力交付的数据报服务。\n优点：使网络中路由器简单，价格低廉。\n如果需要可靠通信，由网络的主机中的运输层负责。\n什么是虚拟互连网络？\n使用相同的网际协议（IP协议）参与互连的网络，屏蔽各种物理网络的异构性使这些性能各异的网络看起来好像是一个统一的网络，称之为虚拟互连网络。\n网络互连的中间设备/中继系统有哪些？\n物理层使用转发器；\n数据链路层使用网桥或桥接器；\n网络层使用路由器；\n网络层以上使用网关；\nIP地址编址的阶段？\n分类的IP地址； 子网的划分； 构成超网； 分类的IP地址具有哪些特点？\nIP地址管理时只分配网络号，路由器仅根据网络号转发分组； 当主机连接到两个不同的网络中时，必须具有两个相应的IP地址，因此一个路由器至少应该有两个以上不同的IP地址。 用转发器或网桥连接起来的若干局域网仍然为一个网络； 所有分配到网络号的网络都是平等的。 请简述子网划分？\n子网划分的原理是从主机号借用若干比特作为子网号；\n请简述子网掩码？\n子网掩码的原理是使用一个与IP地址相对应的、长32bit的二进制串。\n通过子网掩码和IP地址进行按位与运算，可以得到子网地址。\n请简述无分类域间路由选择（CIDR）？\nCIDR是使用网络前缀来消除传统ABC类网络划分及实现超网构造的方法。\n子网掩码与CIDR的区别就是子网掩码在使用传统的ABC类地址而CIDR消除了这种传统的网络划分。\n路由选择时，使用最长前缀匹配方法。\n如果某些线路上未分配IP地址，是否属于网络？\n可能属于，如两个路由器直接相连时，可以不分配IP地址，这种特殊网络称之为无名网络/无编号网络。\nIP地址与硬件地址的区别？\n在网络层及以上各层使用IP地址（逻辑地址）；\n在物理层和数据链路层使用硬件地址（物理地址）；\n1. 在网络层看到的是IP数据报，源IP地址和目的IP地址不变；\r2. 路由器转发时根据目的IP进行路由选择，不改变目的IP地址；\r3. IP数据报交给数据链路层封装成MAC帧，MAC帧在传送时使用硬件地址，上层不可见；\r4. IP层忽略下层的实现细节，使用统一的、抽象的IP地址研究主机之间或与路由器的通信。\r请简述ARP协议？\nARP协议用于将IP地址转化为硬件地址。\n使用ARP高速缓存（特别地，高速缓存有生存时间）； ARP进行在局域网上广播ARP请求分组（广播）； 主机B的IP地址与ARP查询的一致，收下ARP请求分组，并回发ARP响应分组（单播）； 主机A收到响应分组后在其高速缓存中写入； 为什么不直接使用硬件地址？\n存在很多异构网络，它们使用不同的硬件地址；若要使得它们能够互相通信就必须进行非常复杂的硬件地址转换工作，由用户主机来完成这项工作几乎不可能。\n解决IP地址耗尽的问题的方法\n使用无分类域间路由选择 CIDR 方法 使用网络地址转化 NAT 方法 使用IPv6地址 IPv6地址\n单播（点对点通信） 多播（类似广播通信） 任播（目的站是一组计算机，交付时只交最近的一台） 请简述ICMP协议？\nICMP是网际控制报文协议，目的是更有效的转发IP数据报，提高交付成功的机会，使用ICMP协议来让主机或路由器报告差错和异常等情况。\n应用：分组网间探测ping命令是用来探测主机到主机之间是否可通信。ping命令是使用 IP 和网络控制信息协议 (ICMP)，它发送icmp回送请求，收到回答报文。\nICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。\n请简述DHCP协议？\n动态主机配置协议常用于给主机动态地分配IP地址，它是应用层协议，基于UDP。\nDHCP使用客户/服务器方式，分为以下几步：\n主机向DHCP服务器广播DHCP发现报文； DHCP服务器向主机广播DHCP提供报文； 如果接收DHCP服务器提供的相关参数，广播DHCP请求报文； DHCP服务器广播DHCP确认消息，分配IP地址给主机； 路由选择协议\n分为静态路由选择策略（非自适应路由选择）和动态路由选择策略（自适应路由选择）。\n路由选择协议划分为：内部网关协议 IGP 和外部网关协议 EGP 。其中自治系统间的路由选择叫域间路由选择，自治系统内部的路由选择叫域内路由选择。\nIGP\nRIP OSPF EGP\n运输层/传输层 运输层的作用是什么？\n运输层向它上面的应用层提供通信服务，对上层来说，运输层提供应用进程间的逻辑通信。\n运输层和网络层的区别？\n由物理层、数据链路层和网络层组成的通信子网为主机之间提供点对点的逻辑通信，运输层/传输层为应用进程之间提供端到端的逻辑通信；\n网络层提供简单灵活、无连接、尽最大努力交付的服务；而运输层提供面向连接 TCP 或无连接 UDP 的运输协议，并对收到的报文进行差错检测。\nTCP和UDP的全称是什么？TCP/IP协议是什么？\nTCP Transmission Control Protocol；UDP User Datagram Protocol\nTCP/IP协议叫做传输控制/网际协议族。\n协议分成4层，自上而下分别是应用层、运输层、网络层和网络接口层。\n应用层：HTTP，Telnet，FTP，DNS\n运输层：UDP，TCP\n网络层：IP，ICMP，IGMP\n网络接口层：ARP\n比较TCP与UDP的区别和联系？\n联系：\nTCP与UDP都是传输层的协议，且都用端口号标识数据所达的进程。\n区别：\nTCP提供的是面向连接服务，UDP提供的是无连接服务；\nTCP提供可靠交付，UDP提供不可靠交付，且无确认机制；\nTCP保证数据顺序，UDP不保证；\nTCP占用资源较多，具有流量控制和拥塞控制，可用于可靠要求高的场合；UDP占用资源较少，主要用于即时强的场合；\nTCP是基于字节流模式，UDP是基于数据报（报文）模式；\nTCP是点对点的，UDP则提供一对一，一对多，多对一和多对多的交互通信；\nTCP运输连接包括哪些步骤？\n**连接建立、数据传送、连接释放。**其中建立连接又称为TCP三报文握手，断开连接称为TCP四报文挥手。\nTCP三次握手的过程\n具体步骤如下\n假设A是客户，B是服务器，A主动打开连接，B被动打开连接；\n第一次握手：\nA向B发出连接请求报文段，SYN=1，初始序号seq=x；\nA进入SYN_SENT状态（同步已发送）；\n第二次握手：\nB收到A的连接请求报文段，同意建立连接，向A发送确认报文段；\n确认报文段中SYN=1，ACK=1，初始序号seq=y，确认号ack=x+1；\nB进入SYN-RCVD状态（同步已收到）；\n第三次握手：\nA收到B的确认后，检查ACK是否为1，ack是否正确，向B发送确认报文段；\n确认报文段中ACK=1，seq=x+1，ack=y+1；\n特别地，ACK报文段若不携带数据则不消耗序号，下一数据报文段序号仍为seq=x+1；\nA进入ESTABLISHED状态（已建立连接）；\nB收到A的确认后也进入ESTABLISHED状态。\n为什么需要A最后再发送一次确认？\n为了防止已失效的连接请求报文段突然传到了B，从而产生错误。\n比如A想向B建立连接，发送了一次连接请求，未收到确认，于是重传了请求，并建立了连接，数据传输完毕后释放了连接。然而第一个连接请求并没有丢失，而是长时间滞留在网络结点中，并在稍后连接释放后到达了B。B误以为是重新要求连接，因而回发确认。此时如果A并没有发出请求，就不会理睬B的确认。B以为连接已经建立，造成资源浪费。\n你觉得TCP三次握手是否有缺陷？\n当A向B发送请求报文段成功，B向A发送确认报文段成功，A向B发送确认报文段而B并未收到时，A会进入ESTABLISHED状态，而B由于收不到A的确认，只会恢复到LISTEN状态。\n数据传送（待完善）\n超时重传 快速重传 流量控制 拥塞控制 TCP如何进行连接释放？TCP四次挥手的过程？\nHTTPS和HTTP\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/computernetwork/","tags":[],"title":"计算机网络"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　眼见燕书磐疾速奔来，张慎峰面色凝重，刚刚记诵的紫霞功心法马上在脑海中逐字浮现出来：“紫霞功，起于灵台，收于识海，韧如精丝，绵如云霞，至阴至柔，至阳至刚，功启《易》理，源于无极。灌注周身，可震外敌……”\n张慎峰口中念念，感受着经脉中力量的攀升，逐渐心神沉静，神识外放，然而就在他运转到最关键的部分的时候，后面记诵的口诀突然想不起来了！这一下可把张慎峰吓的不轻，霎那间心法断层，心神震荡，紫霞功带来的增益瞬间如潮水般退去，同时震荡带来的后劲使得张慎峰一阵气血翻涌，不能自抑。\n看到张慎峰如同木桩一般杵在原地，燕书磐以为他被自己的气势所摄，完完全全地吓傻了，心中大定，手中的木剑也连忙加重了几分力道。\n“还以为这位小师弟口出狂言，是有什么依仗，现在看来，不过是个不知天高地厚的家伙。我律令阁历来都是真武山最优秀弟子的出师之地，你一个普普通通尚未拜师的三代弟子，怎么可能是我的对手！哼，趁你病，要你命，结结实实地受我这一剑，保证你十天半个月都下不来床！”燕书磐心中想道，脸色也带上了几分狰狞。\n木剑距离张慎峰越来越近，马上就要到达身前了。此时再想重新调动紫霞功是决计不可能了，张慎峰只能强提真气，用拂尘架开木剑，身体则向一旁闪避。\n然而，因为之前受紫霞功断招带来的震荡的缘故，张慎峰身形移动并不迅速，木剑几乎是擦着他的左边身子飞了过去，而后燕书磐壮硕的身躯紧跟而来，张慎峰暗道不好，连忙再度侧身，让过了燕书磐壮硕的身躯，不过好景不长，拂尘刚刚架上木剑，一阵大力便通过桃木剑传来，震的张慎峰手臂发麻，几乎把拂尘丢出去。一招走过，张慎峰蹲在地上大口喘气，非常狼狈。\n“哈哈哈哈……”燕书磐大笑，而后道：“小师弟，你不是我的对手，今日你不仅要把这太极道场的位置让给我，而且还得给我道歉，否则，你就等着在榻上养伤吧！”说罢，抽剑再度欺身而来。\n见燕书磐再次冲来，张慎峰深深吸气，又一次使出他应对师尊和光同尘的那一式观水。片刻间，张慎峰拳掌相出，摆出太极单鞭之势，眉心发胀，精神力倾泻而出。燕书磐狂笑着用木剑狠狠对着张慎峰的腹部穿刺，在他看来，无论如何师弟是不可能挡住自己这雷霆万钧一击的。自己的招式看似是江湖中人寻常的直刺，实为真武派剑法：道生一剑。\n举凡真武弟子，皆须修习两种门派基本心法：载营守魄和驱影逐形。顾名思义，载营守魄是稳固自身心神，强化自身防御的心法，所谓“未学打人，先学挨打。”讲的便是这种道理。而驱影逐形的心法对应的招式则皆可追加释放 “影”。“影”由真武独门真力修成，来无踪，去无痕，看的见却摸不着，是真武派在江湖中赖以成名的绝学，驱“影”可以对人进行击打，而不必担心受到反击，因为“影”本来就不是存在的实体；驱“影”也可以形成防护，替代自身脱离危险。\n刚才，燕书磐使用的便是真武基本心法驱影逐形下的道生一剑，只要刺中目标，便可在原地形成一道凝炼的“影”，追加一次打击。虽然驱使的 “影”只追加一次打击，但是它的出现的时机和力度难以估计和判断，所以对同功力的师兄弟来说，中者基本不可能形成有效防御，而对于张慎峰甚至没有拜师的人来说，绝不可能会有任何应对之策，故而这一剑，燕书磐是势在必得。\n燕书磐对张慎峰的整体估计其实并不低，从他第二招便使用真武心法能够看出他是战略上藐视，而战术上还是很重视张慎峰的。然而，他认为张慎峰没有拜师这一错误的观点，导致他对这一剑的结局判断存有很大的问题。对张慎峰来说，其所运观水之式早已尽得潇湘子的真传，此式蕴有包罗万象的太极守势，又含有勘破敌招进而反击的要义，应对燕书磐的道生一剑，可谓绰绰有余。\n此刻，燕书磐的剑已经刺到张慎峰身前，说时迟，那时快，张慎峰右手生出阴影，急速收成漩涡，化作一道太极图案，猛然点在木剑之上，与此同时左手拂尘削过剑身，将其向自己身侧送过。如此一点一划，燕书磐的剑气势荡然无存，旋即，张慎峰左手拂尘向前狠狠一戳，要给燕书磐也来个前后通透。\n燕书磐眼见不对，急速抽剑挡于胸前，架开了张慎峰的这一击蜻蜓点水，而后驱影逐形心法运转，一道手持木剑的“影”猛然出现在燕书磐与张慎峰之间，剑锋上指张慎峰见状暗道不好，连忙向侧边翻滚，就在他翻到旁边的一刹那，“影”所持的“剑”狠狠撕裂了之前张慎峰所立之处，速度之快，擦的周围空气甚至发出了巨响。\n寄托了燕书磐莫大希望的道生一剑甚至没有擦破张慎峰的皮，实在出燕书磐的意料，将他气的鼻子都歪了。为了出心中的这口恶气，燕书磐连喘气也顾不上了，迅速拔剑，再度出击。如此高强度的进攻令燕书磐气血翻涌，不过张慎峰也没好到哪去——刚从地上爬起，也没来得及喘气，燕书磐的反身劈剑式便已到达。燕书磐此招乃驱影逐形心法下的厉招，唤作微明生灭。“万物无以生，将恐灭，万物无以继，将恐竭。”此招一共五式，皆糅合了以柔克刚的精髓。虽然连续释放两招对内力消耗极大，但燕书磐为保住脸面而求速胜，此时根本顾不得内力消耗多少。\n张慎峰见燕书磐剑法来的犀利，只能再度闪避。燕书磐的剑反身劈后迅速斜向左上挑，压迫着张慎峰的躲避空间，而后直接蓄势向右横扫千军，张慎峰连忙吸气下蹲，正要翻滚从右脱离，燕书磐的斜左下竖劈早已先至，张慎峰见状，只得强压真气，生生改变方向从左边翻滚出去，他身形从原地脱离片刻不久，燕书磐所使微明生灭的最后一击便狠狠地刺穿了张慎峰之前的位置。这一套连招打下来，张慎峰如同暴风雨中的一叶小舟，看起来随时都会被风暴淹没，一招不慎，便是满盘皆输。不过，小舟在大浪中虽然风雨飘摇，最后还是化险为夷，没有舟毁人亡。\n从武道上讲，燕书磐释放的微明生灭未曾释放出最大威力，原因很简单：其一是此式驱“影”对心神要求极高，而他此际还不能做到释放微明生灭后驱“影”代替自身完成打击，否则，被道生一剑所驱之“影”逼得闪躲的张慎峰即使躲开了这次“影”的攻击，也会被后面以逸待劳的燕书磐的微明生灭所斩中；其二，燕书磐的微明生灭目前尚不熟练，根本不能做到气机锁定，不然此招一旦使出，被锁定的张慎峰根本无处可躲，岂是简简单单的翻滚就能避开锋芒的。\n不过，张慎峰毕竟没有中招，这样，待燕书磐此招走完，他就有了充足的缓气的时间，而就在这一连串虽然繁杂，却快如电光火石、白驹过隙一般的战斗中，在避免中剑的潜能激发下，张慎峰终于想起了之前自己紫霞功记诵卡壳的那一句功法口诀。\n“忍性忍恶，布道布善。”结合他自己之前的凶险处境，张慎峰恍然大悟：在危机关头，必须克制自己的性情，克制自己的脾气，保持清醒的头脑，对情形有准确的判断，方能够化险为夷，枯木逢春。\n紫霞功功诀既忆，张慎峰连忙再次开始运转这门上古心法，这次他闭上了双眼，置面前的燕书磐于不顾，将整个心神都沉入了紫霞功之中。感受着经脉中力量的攀升，张慎峰觉得整个人都像沐浴在朝霞之中，逐渐升华起来。\n再说燕书磐，他见张慎峰翻滚闪避，虽然因为自己的木剑未斩中他而有所不喜，但看到张慎峰狼狈躲避的样子，还是有些舒坦的。原因无他，如果这位白脸师弟能够反击，岂不是早就动手了，何必一直闪躲自己的招式而毫无进攻之意？燕书磐自信，只要自己稳扎稳打，逐步扩张，再过一炷香的时间，师弟必然无以为继，被自己的木剑刺中。到那时，这位不知天高地厚的师弟就得为刚才自己不友善的言论付出点代价了。\n然而燕书磐尚未想完，就惊骇地发现眼前的师弟气势和力量都在恐怖的攀升，仿佛一个大漩涡，而天空中无边无际的灵气则旋转着倒灌进他的身体。“难道，师弟用的是激发潜能的秘法？”燕书磐越想越觉得有理，这位师弟必然是被自己凌厉的剑法压制的不知所措，只知道翻滚闪避，心中咽不下怒气，这才激发自己的潜能。\n可惜，江湖中流传的所有激发潜能的秘法燕书磐均有所耳闻，而且知道它们一般都有一个致命的弱点，那就是需要蓄势，在蓄势期间，蓄势者本人就像是一个充气的气球，若是此时有人将其狠命一剑戳个窟窿，呵呵……燕书磐脸上再度浮现出狰狞的面容，“小师弟，你自寻死路，与我无尤。我若是此刻退却，面对激发了潜能的你，肯定不会好受，索性就让我给你放放气，让你感受感受在放气中爆炸是什么滋味！”\n想到这里，燕书磐持剑再度上前，招式仍然是之前的那一式道生一剑！剑法朴实，剑招却极其凌厉，刺出一阵劲风,此剑比先前更加凶狠，可以说是不成功便成仁。然而，这倾注了燕书磐全部希望的一剑，距离张慎峰还有一段距离的时候，异变突起！\n只见张慎峰猛地睁开双眼，从中射出两道夺目精光，光如利剑，直直地迎着燕书磐的眼睛扎进了他的脑海中，随即燕书磐一声惨叫传来，左手死死地捂住自己的双眼，像是受到了很大的伤害一般，而他的右手，由于先前出剑的惯性，还是处于持剑向张慎峰刺来的状态。\n眼见燕书磐的剑马上就要刺中自己，张慎峰准备全力运转紫霞功反击。之前张慎峰已经成功地运转过紫霞功，他能感觉到自己身体的各个方面都被这华山上古功法增强了，或者说，是洗炼了一遍。紫霞功作为道家至高无上的内功心法，蕴含着太极守势的最高奥义，这一点，甚至连潇湘子所教授的观水也难以企及。以紫霞功的内功心法使出外功招式，哪怕是不加持精神力的观水，挡住燕书磐的这一剑也绰绰有余，更别说紫霞功附带有乘霞和冥思两种效果，使得张慎峰即使是硬吃这一剑也不会有太大问题。\n然而张慎峰还未使出任何招式，就听到太极道场外突然传来一声嘹亮的喝声：“住手！”，话音刚落，一道极快的光影便掠至此地，而后如虎钳一般牢牢地抓住了燕书磐向前直刺的剑，使其不能移动分毫。\n及至此时，张慎峰才看清来人，连忙作揖道：“一云子师叔。”同时收功肃立，静候一云子说话。\n一云子是真武武道院的修行大家，和张慎峰的师尊潇湘子性格相仿，平素喜闲云野鹤。刚才，他在太极道场外的山海楼上远眺清晨的云海，想感受一下“道过深山雾气迢，巧唱清鸣隐林荆”的乐趣，然而虫鸣鸟叫没听到，反而听到的是太极道场斗殴的动静，一回头，正好把燕书磐要将剑刺入张慎峰身上的景象尽收眼底。这要是放在寻常真武弟子身上，硬吃这一剑恐怕甚至要落下终身残疾。一云子既惊讶，又疑惑，于是连忙掠步赶来，牢牢地钳住了燕书磐向前直刺的剑，这才有了刚才那一幕。\n看到张慎峰肃立而燕书磐则是捂着眼睛拿着剑，又是跳又是叫的，一云子就感觉有点奇怪，怎么被刺的人镇定自若没有什么反应，反而是出剑刺人的家伙难受无比呢？不过，再怎么疑惑，还是得先处理两人打斗的事情，真武虽提倡相互切磋，但好勇斗狠，搏杀分生死的事情还是严令禁止的，于是，一云子严肃道：“太极道场乃我真武弟子修行之处，你二人为何在此打架，难道不知道真武门规森严吗？”\n“师叔容禀，”张慎峰不急不缓道，“弟子张慎峰，是武道院三代弟子，今日，弟子寅末时分来到太极道场中央，开始修行。卯初时分，这位燕师兄来到太极道场，告诉弟子说太极道场中央的位置是他的，让弟子即刻离开。我想太极道场是供真武弟子修行之地，至今还未有划地为限一说，再者公共修行场所讲求先来后到，从未有后来居上的道理。可这位燕师兄却偏偏强抢，还恐吓弟子。弟子无奈，正欲离开，燕师兄竟还要弟子道歉，弟子觉得过分，这才与他打斗起来，望乞师叔恕罪。”\n一云子捋了捋须，微微颌首。燕书磐是真武律令阁的弟子，平日嚣张跋扈，欺负其他弟子的事情，一云子也有所耳闻。平常时节，没有弟子会和燕书磐争这个太极道场中央位置。今日倒好，这个张慎峰不但占了位置，敢于与燕书磐争执，还动了一番手，果然是胆识不俗。一云子欣赏这种不畏强权的性格，于是有心帮他一把，便对燕书磐道：“方才这位张师弟所言，你可有异议？”\n“划地为限又如何？我向来在道场中央修行，今日不过是来晚了些，根本没有让地方给他的道理！”燕书磐哼道。\n一云子心道这燕书磐可真是烂泥扶不上墙，人家张慎峰面对师叔，不仅恭谨肃立，答话也是礼貌有加，处处表明弟子身份，摆事实讲道理；而这个燕书磐，虽然一身白衣，看起来有些风度，但说起话来竟如此的蛮横，反差之下，实在令人不适。再者，自己怎么也是燕书磐的师叔，他竟半点礼谓没有，真是托大以极！\n想到这里，一云子重重地哼了一声：“燕书磐，太极道场乃是公共修行场所，先来后到的规矩，难道你师傅没教你吗？”这番话看似是在教训燕书磐，实际上则是讽刺燕书磐的师尊。不过，是他燕书磐先目中无人，倨傲回话，折了一云子的面子，故此，一云子对燕书磐的师尊寒湘子便也没什么可客气可言。\n不过一云子这番话，到了燕书磐耳朵里，便不是那么回事了。真武山掌管一切门规的，是他燕书磐的师尊寒湘子，太极道场什么规矩，那都得自己师尊说了算。而自己作为寒湘子的亲传弟子，在修炼地点上难道不该有所优待？今日在武道院一名普普通通名不见经传的三代弟子面前没讨到好，这已经是自己天大的耻辱了，然而这个叫一云子的师叔，钳住了自己那最为关键的一剑，还向着张慎峰说话，实在可恨！要不是他死死钳住自己的剑，估计自己那一剑早就把这个不知天高地厚的师弟来了个心脏对穿了！\n燕书磐越想越气，直接就爆起了粗口：“一云子，你个闲游老匹夫！我告诉你，平日看你和我师尊同辈，我尊你一声师叔。我占太极道场居中的位置修行的时间亦是由来已久，可谓是“自古以来”。你闲云野鹤，不问真武世事，我俩正是井水不犯河水。你有什么资格指手画脚？你既然能教训我，我还不能教训这位师弟不成？你可别惹急了我，否则，待我回去找师尊告状，顷刻之间，就让你知道厉害！”\n“厉害？”张慎峰硬生生憋住自己的笑，心想燕书磐恐怕今天是装逼过头了。一云子虽然一直在野外修行，门派里的事务他很少操心，但是涉及到门派的根本原则和核心利益的时候，他可是连真武祖师张梦白的桌子都敢拍；论辈分，他和燕书磐的师尊、真武律令阁执掌寒湘子，还有自己的师尊潇湘子都属同一辈。燕书磐嚣张跋扈惯了，今天遇到一云子师叔，居然还大放厥词，一会可有好戏看了。\n想到这里，张慎峰连忙对一云子郑重道：“师叔，这位燕师兄的师尊寒湘子，是律令阁的律令执掌，今日弟子吃些亏不打紧的；师叔你大人有大量，千万别申斥于他，不然，弟子恐怕连累了师叔你啊。”\n张慎峰这么一讲，一云子的脸彻底黑了:怎么个意思？寒湘子是真武门派的长老，难道自己就是空架子么？自己在门派里太久没活动筋骨了，现在说话已经没有威信了？看来，很有必要从某人身上开开刀，杀鸡儆猴！\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch3/","tags":[],"title":"第三章 交锋"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"生产者与消费者问题 一组生产者和一组消费者交替使用缓冲区。\n设缓冲区是临界资源，它只允许一个生产者放入内容或一个消费者取出内容。\n代码描述如下：\nsemaphore mutex=1; semaphore empty=n; semaphore full=0; producer(){ while(1){ produce items; P(empty); P(mutex); add items to buffer; V(mutex); V(full); } } consumer(){ while(1){ P(full); P(mutex); remove items from buffer; V(mutex); V(empty); consume the items; } } 考虑下面较为复杂的生产消费问题：\n设桌上有一个盘子，每次只能放入一个水果，爸爸专放苹果，妈妈专放橘子，女儿专吃苹果，儿子专吃橘子。\n仅当盘子为空时爸爸或妈妈才可放入，仅当盘子为满时女儿或儿子才能吃。\n代码描述如下：\nsemaphore orange=0; semaphore apple=0; semaphore plate=1; dad(){ while(1){ P(plate); produce apple; V(apple); } } mom(){ while(1){ P(plate); produce orange; V(orange); } } daughter(){ while(1){ P(apple); eat apple; V(plate); } } son(){ while(1){ P(orange); eat orange; V(plate); } } 注：为什么可以不设置mutex？因为缓冲区大小为1，任意时刻apple，orange，plate三个同步信号量中最多只有一个是1，因此任何时刻最多只有一个进程进行P操作，而不会被阻塞。若缓冲区大小为2，则需要设置mutex, 且必须在同步信号量的P操作之后，以防死锁。\n读者与写者问题 读写公平算法：\n当读进程访问时，写进程到达，则禁止后续到达的读进程的请求；\n当写进程访问时，读进程和写进程先后到达，则按到达的先后次序进行访问。\n哲学家进餐问题 暂未更新。\n吸烟者问题 暂未更新。\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/operating-system/synchronization-exclusion/","tags":[],"title":"经典同步问题"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"线性表的基本操作如下：\nvoid InitList(\u0026amp;L);//初始化表，构造一个空的线性表 int Length(L);//求表长 ElemType LocateElem(L,e);//按值查找 ElemType GetElem(L,e);//按位查找 bool ListInsert(\u0026amp;L,i,e);//插入操作 bool ListDelete(\u0026amp;L,i,\u0026amp;e);//删除操作 void PrintList(L);//输出操作 bool Empty(L);//判空操作 bool DestroyList(\u0026amp;L);//销毁操作 顺序表 定义 静态分配 static const int MaxSize=50; typedef int ElemType; typedef struct{ ElemType data[MaxSize];//定义即开辟了存储空间 int length; }SqList; 动态分配 static const int MaxSize=50; typedef int ElemType; typedef struct{ ElemType *data; int MaxSize,length;//此处需要声明最大存储空间 }SqList; 初始化 静态分配 void InitList(SqList \u0026amp;L){ for(int i=0;i\u0026lt;MaxSize;i++) L.data[i]=0; L.length=0; } 动态分配 void InitList(SqList \u0026amp;L){ //以下两种初始化内存空间方式分别对应C与C++ L.data=(ElemType*)malloc(sizeof(ElemType)*MaxSize); L.data=new ElemType[InitSize]; for(int i=0;i\u0026lt;MaxSize;i++) L.data[i]=0; L.length=0; } 插入 其中i是位序。\nbool ListInsert(SqList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1||i\u0026gt;L.length+1)\treturn false; if(L.length==MaxSize){//可以直接返回错误，理由是存储空间已满；或分配内存空间 MaxSize++; ElemType *new; new=(ElemType*)realloc(L.data,sizeof(ElemType)*(MaxSize+1)); if(!new) return false;//申请空间失败 L.data=new; } if(L.length\u0026gt;MaxSize)\treturn false; for(int j=L.length;j\u0026gt;=i;j--) //位序从最后1位一直到第i个，插入向右移，因此最后需要额外的j=L.length，共L.length-i+1位 L.data[j]=L.data[j-1]; L.data[i-1]=e; L.length++; return true; } 删除 bool ListDelete(SqList \u0026amp;L,int i,ElemType e){ if(i\u0026lt;1||i\u0026gt;L.length+1) return false; e=L.data[i-1]; for(int j=i;j\u0026lt;L.length;j++) //位序从第i+1个到最后1位，删除向左移，因此不需要最后一个j=L.length，共L.length-i个 L.data[j-1]=L.data[j]; L.length--; return true; } 查找 按值查找 ElemType LocateElem(SqList L,ElemType e){ int i; for(i=0;i\u0026lt;L.length;i++) if(L.data[i]==e) return i+1; return 0; } 按位查找 ElemType LocateElem(SqList L,int i){ if(i\u0026lt;1||i\u0026gt;L.length) return NULL; return L.data[i-1]; } 单链表 如无特殊说明，均指带头结点的单链表。\n定义 typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 初始化 不带头结点 bool InitList(LinkList \u0026amp;L){ L=NULL;//防止内存中的脏数据进入单链表 return true; } 带头结点 bool InitList(LinkList \u0026amp;L){ L=(LNode*)malloc(sizeof(LNode)); if(L==NULL)\treturn false; L-\u0026gt;next=NULL; return true; } 判空 bool Empty(LinkList L){ return (L==NULL);//不带头结点 return (L-\u0026gt;next==NULL);//带头结点 } 查找 按位查找 带头结点的按位查找如下\nLNode *GetElem(LinkList L,int i){ int j=0;//从0开始查找 LNode *p=L; /*或改写成 int j=1; LNode *p=L-\u0026gt;next; */ if(i==0)\treturn L; if(i\u0026lt;1)\treturn NULL; while(p\u0026amp;\u0026amp;j\u0026lt;i){ p=p-\u0026gt;next; j++; } return p;//返回第i个结点的指针，若大于表长，返回的则是NULL } 按值查找 LNode *LocateElem(LinkList L,ElemType e){ LNode *p=L-\u0026gt;next; while(p!=NULL\u0026amp;\u0026amp;p-\u0026gt;data!=e) p=p-\u0026gt;next; return p;//要么返回指针，要么返回NULL } 插入 给定结点插入 对于给定的结点，向其前后插入。\n向后插入 bool ListInsertNextNode(LNode *p,ElemType e){ if(p==NULL)\treturn false;//待插入结点不合法 LNode *s=(LNode*)malloc(sizeof(LNode)); if(s==NULL)\treturn false;//无法新插入结点 s-\u0026gt;data=e; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s;//注意上述三语句的顺序，此句和前句顺序不能颠倒 return true; } 向前插入 方法有两种，一是传入头指针，找到第i-1个结点；二是转换为后插操作，即向后插入操作后将前驱结点p与插入结点s交换数据域。\n如果给定的是待插入的值，则\nbool ListInsertPriorNode(LNode *p,ElemType e){ if(p==NULL)\treturn false;//待插入结点不合法 LNode *s=(LNode*)malloc(sizeof(LNode)); if(s==NULL)\treturn false;//无法新插入结点 s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; s-\u0026gt;data=p-\u0026gt;data; p-\u0026gt;data=e; return true; } 如果给定的是待插入的结点，则\nbool ListInsertPriorNode(LNode *p,LNode *s){ if(p==NULL)\treturn false;//待插入结点不合法 LNode *s=(LNode*)malloc(sizeof(LNode)); if(s==NULL)\treturn false;//无法新插入结点 s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; ElemType temp; temp=p-\u0026gt;data; p-\u0026gt;data=s-\u0026gt;data; s-\u0026gt;data=temp; return true; } 给定位序插入 对于给定的位序，向其前后插入如下。\n向后按位序插入 带头结点\nbool ListInsertNext(LinkList \u0026amp;L,int i,ElemType e){ p=GetElem(L,i); return ListInsertNextNode(p,e); } 不带头结点\nbool ListInsertNext(LinkList \u0026amp;L,int i,ElemType e){ p=GetElem(L,i); if(i!=1)\treturn ListInsertNextNode(p,e); if(i==1){ LNode *s=(LNode*)malloc(sizeof(LNode)); s-\u0026gt;data=e; s-\u0026gt;next=L; L=s;//注意体会此处的书写 return true; } } 向前按位序插入 bool ListInsertPrior(LinkList \u0026amp;L,int i,ElemType e){ p=GetElem(L,i); return ListInsertPriorNode(p,e); } 建表 尾插法 LinkList List_TailInsert(LinkList \u0026amp;L){ int x; L=(LinkList)malloc(sizeof(LNode)); LNode *s,*r=L;//r是表尾指针 scanf(\u0026quot;%d\u0026quot;,\u0026amp;x); while(x!=9999){//输入9999表示结束 s=(LNode*)malloc(sizeof(LNode)); s-\u0026gt;data=x; r-\u0026gt;next=s; r=s; scanf(\u0026quot;%d\u0026quot;,\u0026amp;x); } r-\u0026gt;next=NULL; return L; } 头插法 带头结点\nLinkList List_HeadInsert(LinkList \u0026amp;L){ int x; L=(LinkList)malloc(sizeof(LNode)); LNode *s; L-\u0026gt;next=NULL;//不带头结点则 L=NULL; scanf(\u0026quot;%d\u0026quot;,\u0026amp;x); while(x!=9999){//输入9999表示结束 s=(LNode*)malloc(sizeof(LNode)); s-\u0026gt;data=x; s-\u0026gt;next=L-\u0026gt;next;//不带头结点则 s-\u0026gt;next=L; L-\u0026gt;next=s;//不带头结点则 L=s; scanf(\u0026quot;%d\u0026quot;,\u0026amp;x); } return L; } 删除 按位序删除 bool ListDelete(LinkList \u0026amp;L,int i,ElemType \u0026amp;e){ LNode *p=GetElem(L,i-1);//寻找被删除结点的前驱结点 LNode *q=p-\u0026gt;next;//q指向被删除的结点 p-\u0026gt;next=q-\u0026gt;next; free(q); } 按结点删除 删除某结点，方法有两种，一是传入头指针，找到第i-1个结点；二是该结点与其后继结点交换数据域。该方法不能删除最后一个结点。\nbool ListDeleteNode(LNode *p){ if(p==NULL)\treturn false; LNode *q=p-\u0026gt;next; if(q==NULL) return false;//不能删除最后一个结点 p-\u0026gt;data=p-\u0026gt;next-\u0026gt;data;//被删除结点和后继结点交换数据域 p-\u0026gt;next=q-\u0026gt;next;//断链 free(q); return true; } 求表长 求表长的思想类似于按位序查找结点。\nint Length(LinkList L){ int len=0; LNode *p=L; /*不带头结点 if(L==NULL)\treturn len; */ while(p-\u0026gt;next!=NULL){ p=p-\u0026gt;next; len++; } return len; } 双链表 定义 tyepdef struct DNode{ ElemType data; struct DNode *next,*prior; }DNode,*LinkList; 初始化 bool InitDLinkList(DLinkList \u0026amp;L){ L=(DNode *)malloc(sizeof(DNode));//分配头结点 if(L==NULL) return false;//内存不足 L-\u0026gt;prior=NULL; L-\u0026gt;next=NULL; return true; 判空 bool Empty(DLinkList \u0026amp;L){ if(L-\u0026gt;next==NULL) return true;//头结点 else return false; } 插入 向后插入 bool InsertNextDNode(DNode *p,DNode *s){ if(p==NULL||s==NULL) return false; s-\u0026gt;next=p-\u0026gt;next; if(p-\u0026gt;next!=NULL)//如果p结点有后继结点 p-\u0026gt;next-\u0026gt;prior=s; s-\u0026gt;prior=p; p-\u0026gt;next=s; return true; } 向前插入 bool InsertPriorDNode(DNode *p,DNode *s){ if(p==NULL||s==NULL) return false; if(p-\u0026gt;prior==NULL){ s-\u0026gt;next=p; p-\u0026gt;prior=s; } p=p-\u0026gt;prior;//找到p的前驱结点，然后向后插入 s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next-\u0026gt;prior=s; s-\u0026gt;prior=p; p-\u0026gt;next=s; return true; } 删除 删除p结点的后继结点\nbool DeleteNextNode(DNode *p){ if(p==NULL) return false; DNode *q=p-\u0026gt;next; if(q==NULL) return false;//p没有后继结点 p-\u0026gt;next=q-\u0026gt;next; q-\u0026gt;next-\u0026gt;prior=p; free(q); return true; } 销毁 void DestroyList(DLinkList \u0026amp;L){ while(L-\u0026gt;next!=NULL) DeleteNextNode(L); free(L); L=NULL;//头指针指向NULL } 遍历 正向遍历\nvoid Travere(DNode *p){ while(p!=NULL) p=p-\u0026gt;next; } 反向遍历\nvoid TravereBack(DNode *p){ while(p-\u0026gt;prior!=NULL)//略过头结点，仅处理数据结点 p=p-\u0026gt;prior; } 循环链表 循环单链表 循环单链表和单链表的区别在于表中最后一个结点的指针指向头结点L。\n定义 循环单链表的定义与单链表的定义完全相同。\n初始化 bool InitList(LinkList \u0026amp;L){ L=(LNode*)malloc(sizeof(LNode)); if(L==NULL) return false; L-\u0026gt;next=L;//头结点next指向头结点 return true; } 判空与判尾 思想：判断当前结点是否指向头结点L。\n//判空 bool Empty(LinkList L){ if(L-\u0026gt;next==L)\treturn true; else return false; } //判尾 bool isTail(LinkList L,LNode *p){ if(p-\u0026gt;next==L)\treturn true; else return false; } 循环双链表 循环双链表与循环单链表的区别在于其头结点的prior指针指向表尾结点。\n定义 循环双链表的定义与双链表的定义完全相同。\n初始化 bool InitDLinkList(DLinkList \u0026amp;L){ L=(DNode*)malloc(sizeof(DNode)); if(L==NULL)\treturn false; L-\u0026gt;next=L; L-\u0026gt;prior=L; return true; } 判空与判尾 思想：判断当前结点是否指向头结点L，与循环单链表完全相同。\n//判空 bool Empty(DLinkList L){ if(L-\u0026gt;next==L)\treturn true; else return false; } //判尾 bool isTail(LinkList L,LNode *p){ if(p-\u0026gt;next==L)\treturn true; else return false; } 插入 插入部分基本同双链表，区别在于后继结点是否存在不需要额外判断。\n向后插入 bool InsertNextDNode(DNode *p,DNode *s){ if(p==NULL||s==NULL) return false; s-\u0026gt;next=p-\u0026gt;next; //if(p-\u0026gt;next!=NULL)//普通双链表需要判断p结点后是否有后继结点 p-\u0026gt;next-\u0026gt;prior=s; s-\u0026gt;prior=p; p-\u0026gt;next=s; return true; } 向前插入 bool InsertPriorDNode(DNode *p,DNode *s){ if(p==NULL||s==NULL) return false; if(p==L)//不能在头结点之前插入 return false; p=p-\u0026gt;prior;//找到p的前驱结点，然后向后插入 s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next-\u0026gt;prior=s; s-\u0026gt;prior=p; p-\u0026gt;next=s; return true; } 删除 删除p结点的后继结点，基本同双链表，区别在于后继结点是否存在不需要额外判断。\nbool DeleteNextNode(DNode *p){ if(p==NULL) return false; DNode *q=p-\u0026gt;next; //if(q==NULL) return false;//p一定有后继结点 p-\u0026gt;next=q-\u0026gt;next; q-\u0026gt;next-\u0026gt;prior=p; free(q); return true; } 静态链表 借助数组描述线性表的链式存储结构。\ntypedef struct{ ElemType data; int next;//下一个元素的数组下标 }SLinkList[MaxSize],SNode; SLinkList a;//等价于 struct SNode a[MaxSize]; 游标next=-1表示到链表尾，next=-2表示该结点暂未使用。\n顺序表和链表的比较 存取方式 存取方式又叫读写方式，顺序表可以顺序存取，也可以随机存取；链表只能顺序存取，因此有下面的结论：\n线性表的顺序存储结构是一种随机存取的存储结构，线性表的链接存储结构是一种顺序存取的存储结构。\n逻辑与物理结构 顺序存储：逻辑上相邻的元素物理上也相邻。\n链式存储：逻辑上相邻的元素物理上不一定相邻。\n增删改查操作 查改 按值查找，顺序表无序时，顺序表与链表时间复杂度均为O(n)，顺序表有序时顺序表时间复杂度为O(logn)；\n按位序查找，顺序表时间复杂度为O(1)，链表时间复杂度为O(n)；\n增删 顺序表的插入、删除操作时间复杂度O(n)，主要来自于移动元素；\n链表的插入、删除操作时间复杂度O(n)，主要来自于查找元素。\n选择 如果存储结构需要具有弹性、可扩容，选择链表；\n如果存储结构需要具有频繁的增删操作，选择链表；\n如果存储结构需要具有频繁的查找操作，选择顺序表；\n如果存储结构需要易于实现，选择顺序表。\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/linear-list-operation/","tags":[],"title":"线性表基本操作"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Data Type Rust 是一种静态类型（statically typed）的语言，它必须在编译期知道所有变量的类型。\n常见的静态类型语言有 C/C++/Java/C#/Rust/Go/Swift/TypeScript/Kotlin/Haskell 常见的动态类型语言有 JavaScript/Python/Ruby/PHP/Perl/Lua/Shell/R/Matlab/Lisp Scalar 标量类型表示单个值，Rust 基本的标量类型有整型、浮点型、布尔型、字符\nInteger Type Rust 整型如表所示：\n长度 有符号类型 无符号类型 字节 8 位 i8 u8 1 16 位 i16 u16 2 32 位 i32 u32 4 64 位 i64 u64 8 128 位 i128 u128 16 arch iszie usize - 注：\n有符号和无符号表示数字能否取负数，有符号数字以二进制补码形式存储。 存储范围 每个有符号类型存储范围是 \\(-(2^{n-1})\\) ~ \\(2^{n-1}-1\\) 每个无符号类型存储范围是 0 ~ \\(2^{n}-1\\) 默认整型是 i32 isize 和 usize 主要用于某些集合的索引 对于数学计算：\nRust 所有数字类型都支持基本数学运算 整数除法会向下取整 Literal Rust 整型字面量格式如表所示：\n数字字面量 示例 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节 b\u0026rsquo;A' 注：字节字面量仅限于 u8 类型。\nOverflow 整型溢出分为两种：\n当在调试（debug）模式编译时，Rust 会检查整型溢出，若存在这些问题则使程序在编译时 panic。 在当使用 --release 参数进行发布（release）模式构建时 Rust 不检测会导致 panic 的整型溢出 当运行到整型溢出时，Rust 会进行一种被称为二进制补码包裹（two’s complement wrapping）的操作 简而言之类似环绕，从最大值变为最小值 要显式处理溢出的可能性，可以使用标准库针对原始数字类型提供的以下一系列方法：\n使用 wrapping_* 方法在所有模式下进行包裹 使用 checked_* 方法，发生溢出则返回 None 值 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值 使用 saturating_* 方法使该值达到最小值或最大值 Floating Rust 的浮点类型有两种类型：\nf32 大小为 32 位 f64 大小为 64 位 它是默认浮点类型 在现代的 CPU 中它的速度与 f32 的几乎相同，但精度更高 注：所有浮点型都是有符号的。\nBoolean \u0026amp; Char 布尔类型可用 bool 声明，布尔值的大小为 1 个字节。 字符类型可用 char 声明，字符类型大小为 4 个字节。 注：\n字符 char 字面量采用 单引号 括起来 字符串 String 字面量采用 双引号 括起来 字符表示的是一个 Unicode 标量值，这意味着它可以表示的远远不止 ASCII Compound Tuple 元组是将多种类型的多个值组合到一个复合类型中的一种基本方式 元组的长度是固定的，声明后就无法修改 元组的绑定与通过模式匹配进行解构的过程如下所示：\nfn main() { let tup = (500, 6.4, 1); let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; println!(\u0026quot;The value of x is: {}\u0026quot;, x); println!(\u0026quot;The value of y is: {}\u0026quot;, y); println!(\u0026quot;The value of z is: {}\u0026quot;, z); } 元组的元素访问如下所示：\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundered = x.0; let six_point_four = x.1; let one = x.2; } Rust 元组与 C 语言结构体的相似之处：\n都可以用于组合多个值，以作为整体进行处理 元组和结构体都可以包含不同类型的数据成员 元组和结构体都可以通过索引访问成员 Rust 元组与 C 语言结构体的不同之处\n成员构成 元组的成员仅有值，只能通过索引访问，索引用 点号 结构体的成员是键值对，即可以通过索引或字段名访问 应用场景 元组主要为临时存储、函数返回值等简单场景 结构体主要用于自定义数据结构 特别注意，Rust 中存在空元组的概念：\n没有任何值的元组 () 是一种特殊的类型，它只有一个值 () 该类型被称为单元类型(unit type)，该值被称为单元值(unit value) 如果表达式不返回任何其他值，就隐式地返回单元值 由于它没有元素，因此无法解构或访问其中的内容 Array 数组的每个元素都具有相同类型，Rust 中数组具有固定长度。 当希望数据分配到栈上而非堆上时，或希望确保始终具有固定数量元素，选择数组 如果希望使用动态数组，选择 vector fn main() { let weekdays = [\u0026quot;Monday\u0026quot;, \u0026quot;Tuesday\u0026quot;, \u0026quot;Wednesday\u0026quot;, \u0026quot;Thursday\u0026quot;, \u0026quot;Friday\u0026quot;]; let a: [i32; 5] = [1, 2, 3, 4, 5]; let a = [3; 5]; let first = a[0]; } 如果产生了无效的数组元素访问，则会导致运行时错误，Rust 程序会 panic 并退出。\nuse std::io; fn main() { let a = [1, 2, 3, 4, 5]; println!(\u0026quot;Please enter an array index.\u0026quot;); let mut index = String::new(); //这里用直接expect的写法 io::stdin() .readline(\u0026amp;mut index) .expect(\u0026quot;Failed to read line.\u0026quot;); //这里用match的方法 let index: usize = match index.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; expect(\u0026quot;Failed to parse number\u0026quot;), }; let element = a[index]; println!( \u0026quot;The value of the element at index {} is {}\u0026quot;, index, element ); } ","permalink":"https://endlesspeak.github.io/docs/docs/rust-programming-basic-doc/5-data-type/","tags":[],"title":"Data Type"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Plasma Configuration 如果 KDE 的外观设置下载缓慢，可以在 KDE 商店 中下载。\nGlobal Theme 全局主题安装在 ~/.local/share/plasma/look-and-feel 下，其包括 layouts 和 splash 等部分 一般地，安装全局主题后会自动配置 Plasma 主题和 Colors 等部分 Plasma Theme Plasma 主题安装在 ~/.local/share/plasma/desktoptheme 下\nColors Colors 安装在 ~/.local/share/color-schemes 下\nSplash Screen 开机加载画面安装在 ~/.local/share/plasma/look-and-feel 的全局主题包中 splash 下 其中 background.png 是加载画面的背景图，=logo.svg= 是图片中心的图标 Icon NixOS 的主题图标在 /nix/store/\u0026lt;sha256\u0026gt;-nixos-icons-\u0026lt;date\u0026gt;/share/icons 下，可以用 fuzzy file finder 寻找 plasma 的图标在 ~/.local/share/icons 下 Backgrounds 记录壁纸的配置文件在 ~/.config/plasmarc 中 背景可在 FreePik 中下载。 Dolphin Mode 按空格可以进入多选模式，再按依次推出该模式\nPanel Dolphin 左侧视图为 panel，通过 \u0026quot;View\u0026quot;-\u0026quot;Show panels\u0026quot; 可以查看所有的 panel. places 提供常用的导航路径； folder 提供当前位置的视图； information 显示当前 folder 的信息； places 提供 XDG user directories 导航； 提供远程位置、最近文件、按类别查找和设备的导航； 通过右键点击 places 空白处可以新增 Entry，新增导航到指定位置的条目； Dolphin 关于 places 的配置文件位于 /.local/share/user-places.xbel Dolphin 关于 recent files 的配置文件位于 /.local/share/recently-used.xbel Context menu Dolphin 右键菜单的提供的内容称为 Context Menu ，通常用户设置的内容归到 Actions 中。 Context Menu 配置： Dolphin 关于 Context Menu 的配置文件位于 /usr/share/kservices5/ 中，用户自定义的配置位于 ~/.local/share/kservices5 中（如不存在可以新建）；\n假如需要新增一项为“在此处打开 Alacritty ”，可以新建 alacrittyhere.desktop 文件，并编辑以下内容：\n[Desktop Entry] Type=Service X-KDE-ServiceTypes=KonqPopupMenu/Plugin,inode/directory Actions=openAlacrittyHere; X-KDE-AuthorizeAction=shell_access [Desktop Action openQTerminalHere] Name=Open alacritty here Icon=Alacritty Exec=alacritty --working-directory %f 特别地，\n在 NixOS 中，alacritty 位于 /etc/profiles/per-user/\u0026lt;username\u0026gt;/bin 或 /run/current-system/sw/bin 中\nalacritty 需要指定的工作目录参数为 --working-directory ，而一般的 terminal 则需要指定 --workdir 。\nDolphin 对 Context Menu 中的内容修改的方式为 \u0026quot;Settings\u0026quot;-\u0026quot;Context Menu\u0026quot; 进行增删。 ","permalink":"https://endlesspeak.github.io/docs/build/operating-system-configuration/linux-technology-5-5-kde-usage/","tags":[],"title":"Linux KDE 桌面使用指南"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"SDRAM SDRAM 概念 STM32 控制器芯片内部有一定大小的 SRAM 及 FLASH 作为内存和程序存储空间，例如 STM32F767 的 RAM=512K，FLASH=1024K； 当程序较大，内存和程序空间不足时，就需要在 STM32 芯片的外部扩展存储器； PC 机上的内存条实质是多个内存颗粒(SDRAM)芯片组成的通用标准模块，而 STM32 则直接与 SDRAM 芯片连接； STM32F7 采用的 SDRAM 芯片型号为 W9825G6KH（有些采用 W9825G6JH）。 SDRAM 信号线 SDRAM 芯片控制引脚说明如表。\n信号线 类型 说明 CLK I 同步时钟信号，所有输入信号都在 CLK 为上升沿的时候被采集 CKE I 时钟使能信号，禁止时钟信号时 SDRAM 会启动自刷新操作 CS# I 片选信号 CAS# I 列地址选通，为低电平时地址线表示的是列地址 RAS# I 行地址选通，为低电平时地址线表示的是行地址 WE# I 写入使能，低电平有效 DQM[0:1] I 数据输入/输出掩码信号，表示 DQ 信号线的有效部分 BA[0:1] I Bank 地址输入，选择要控制的 Bank A[0:12] I 地址输入 DQ[0:15] I/O 数据输入输出信号 FMC 外设概述 FMC 概念 STM32F7xx 使用 FMC 外设来管理扩展的存储器，FMC 是 Flexible Memory Controller 的缩写，译为可变存储控制器，可变存储控制器是一种接口，可以连接同步或异步存储器，16 位 PC 存储卡和 LCD 模块。其主要作用是： 负责向外部扩展的存储类设备提供控制信号 ； FMC 可以用于驱动下列类型的存储器 SRAM SDRAM NOR FLASH NAND FLSAH 特别地： 在 STM32F1、F3、F4 系列微控制器中，只有 FSMC 控制器 (Flexible Static Memory Controller)，译为可变静态存储控制器； 它们不能驱动 SDRAM 这样的动态存储器，因为驱动 SDRAM 时需要定时刷新； 仅 STM32F7xx 的 FMC 外设支持该功能，且只支持普通的 SDRAM，不支持 DDR 类型的 SDRAM； FMC 外设结构 有关 FMC 的外设结构框图可以参考《野火 STM32 HAL 库开发实践指南》\nFMC 接口的时钟信号来自 HCLK，连接 FMC 外设配置寄存器 FMC 包含 NOR/PSRAM 存储器控制器、NAND/PC 卡存储器控制器、SDRAM 控制器等。 FMC 中与 SRAM 引脚对照表如下 FMC 引脚名 对应 SDRAM 引脚名 说明 FMC_NBL[3:0] DQM[3:0] 数据掩码信号 FMC_A[12:0] A[12:0] 行或列地址线 FMC_A[15:14] BA[1:0] Bank 地址线 FMC_D[31:0] DQ[31:0] 数据线 FMC_SDCLK CLK 同步时钟信号 FMC_SDNWE WE# 写入使能 FMC_SDCKE[1:0] CKE SDCKE0:SDRAM 存储区域 1 时钟使能 SDCKE1:SDRAM 存储区域 2 时钟使能 FMC_SDNE[1:0] \u0026ndash; SDNE0:SDRAM 存储区域 1 芯片使能 SDNE1:SDRAM 存储区域 2 芯片使能 FMC_NRAS RAS# 行地址选通信号 FMC_NCAS CAS# 列地址选通信号 其中需要注意的，比较特殊的部分是：\nFMC_A[15:14] 引脚用作 Bank 的寻址线；FMC_SDCKE 线和 FMC_SDNE 都各有 2 条，FMC_SDCKE 用于控制 SDRAM 的时钟使能，FMC_SDNE 用于控制 SDRAM 芯片的片选使能； 它们用于控制 STM32 使用不同的存储区域驱动 SDRAM，使用编号为 0 的信号线组会使用 STM32 的存储器区域 1，使用编号为 1 的信号线组会使用存储器区域 2。使用不同存储区域时，STM32 访问 SDRAM 的地址不一样 ","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/5-stm32-fmc/","tags":[],"title":"STM32 FMC"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Question Implement int sqrt(int x).\nCompute and return the square root of x.\nAnswer 二分查找 对于一个非负数n，它的平方根不会大于$\\frac{n}{2}+1$。在$[0, \\frac{n}{2}+1]$这个范围内进行二分查找，求出n的平方根。\n所谓二分查找，又称为折半查找。要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。\nint sqrt(int x) { int i = 0; int j = x / 2 + 1; while (i \u0026lt;= j) { int mid = (i + j) / 2; int sq = mid * mid; if (sq == x) return mid; else if (sq \u0026lt; x) i = mid + 1; else j = mid - 1; } return j; } 牛顿迭代法 （待补充牛顿迭代法的完整内容）\n为计算$x^2=n$的解，令$f(x)=x^2-n$，即相当于求$f(x)=0$的解。\n任取$x_0$，如果$x_0$不是解，作过$(x_0,f(x_0))$的切线，与x轴交点为$x_1$；\n同样地，如果$x_1$不是解，作过$(x_1,f(x_1))$的切线，与x轴交点为$x_2$；\n以此类推，最终得到$f(x)=0$的解。\n其中，经过$(x_i,f(x_i))$点的切线方程为$y-f(x_i)=f\u0026rsquo;(x_i)(x-x_i)$，其中$f\u0026rsquo;(x)$是$f(x)$的导数。\n令切线方程等于0，则\n$$ x_{i+1}=x_i-\\frac{f(x_i)}{f'(x_i)} $$ 化简可得 $$ x_{i+1}=x_i-\\frac{x_i^2-n}{2x_i}=x_i-\\frac{x_i}{2}+\\frac{n}{2x_i}=\\frac{x_i+\\frac{n}{x_i}}{2} $$ 程序如下：\ndouble sqrt(double x){ if(x==0)\treturn 0; double last=0;//即xi double res=1;//即xi+1 while(res!=last){//可以改为res-last\u0026lt;=epsilon,其中epsilon是误差 last=res; res=(res+x/res)/2; } return res; } ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/algorithms-doc/sqrtx/","tags":[],"title":"Sqrt(x)"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Question 1 给定两个字符串，找出他们的相同元素。\n注：可以把字符串换成数组。\nAnswer 1 双循环遍历法 算法思想：\n遍历字符串A； 对A的每个元素，遍历字符串B； 遇到相同元素就加入结果数组。 排序遍历法 算法思想：\n对字符串A与B按字母顺序排序； 设双指针分别指向字符串A的首位和字符串B的首位； 比较两个指针指向的值的字母位序大小： 若A大于B，则B指针后移； 若A小于B，则A指针后移； 若A等于B，则加入结果数组，双指针同时后移。 哈希查找法 算法思想：\n将字符串A、B的所有元素分别加入哈希表a和b； 对哈希表a的每个元素，在哈希表b中查找； 若查找到，则加入结果数组，直到哈希表a的元素遍历结束为止。 Question 2 有两个长度相同的字符串s1和s2，且它们其中只含有字符”x” 和”y”，你需要通过“交换字符“的方式使这两个字符串相同。\n每次“交换字符“的时候，你都可以在两个字符串中各选一个字符进行交换。\n交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换s1[i] 和s2[j]，但不能交换s1[i]和s1[j]。\n最后，请你返回使s1和s2相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回-1。\nAnswer 2 由于字符串里只有两种字母 x 和 y，因此统计位置的匹配情况，一共只有 4 种可能，即 x - x，x - y，y - x，y - y。\n其中 x - x 和 y - y 都是已经能匹配的情况，不需要额外操作。剩余的是：\nx - y，假设有 a 对。 y - x，假设有 b 对。 对于两对 x - y 或者 y - x，我们都是可以通过一次交换使得他们变为 x - x，y - y 的；\n对于一对 x - y 或一对 y- x 的情况，我们需要通过“两次“操作使他们变为 x - x，y - y；\n综上，优先使两对一样的进行交换操作；操作结束后，剩余的情况有以下几种：\na,b 都是偶数，那么最后无剩余，不需要额外操作。 a,b 一奇一偶，最后只会剩下一对不匹配字符，无解返回-1。 a,b 都是奇数，那么最后会剩下一对 x - y 和一对 y - x，需要额外 2 次操作。 我们的主要计算代价是开头统计的时候会遍历字符串，所以时间复杂度为 O(n)。\nint minimumSwap(string str1,string str2) { int count = 0; //交换次数 int xy = 0, yx = 0 ,len = str1.size(); for(int i=0; i\u0026lt;len; i++) { if(str1[i] != str2[i]) if(str1[i] == 'x') xy++; else yx++; } //两个都是偶数不需要额外操作 if((xy+yx) % 2 == 1)//两者一奇一偶 return -1; count = xy/2 +yx/2; if(xy%2 == 1 \u0026amp;\u0026amp; yx%2 == 1)//两个都是奇数 count += 2; return count; } ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/algorithms-doc/string-common-element/","tags":[],"title":"字符串公共元素问题"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　燕书磐正要继续给一云子摆脸色，可是他还没来得及实施，就被狂怒的一云子拎小鸡一般拎起来。身形一闪，一云子带着燕书磐掠上太极道场前的一道崖壁，两人的身影才消失在崖壁顶端，一声声惨叫随即传了出来，“余音绕梁，三日不绝”，张慎峰尽力忍住笑，准备收拾东西离开太极道场，找个僻静地方继续研究自己的功法。\n此时，天已大亮，真武殿后的弟子居中整整齐齐排出三十名二代弟子组成的队列，有序地分三圈绕太极道场站定，而其他三代弟子紧随其后，从弟子居中鱼贯而出。很快，领头的真武弟子笑道人发现了太极道场的异常，连忙朝正往太极道场外走的张慎峰问道：“师弟，你方才在此地可曾见到一位穿白袍的真武弟子？他每日都会到太极道场中央行功。”\n“白袍弟子？不清楚，不知道，不了解。”张慎峰一脸的严肃，脸上的肌肉都快绷散架了，才把自己的这股笑意憋下去，然后尽可能沉声道，“我也是刚刚到，路过太极道场而已。”\n话音刚落，太极道场前的山林后又传出一声惨叫，响彻云霄，在场的真武弟子悉数闻声抬眼，向峭壁上看去，然而声音从峭壁后传来，完全看不到具体情况。只是这惨叫众人都非常熟悉，一听就知道是燕书磐的，随即笑道人和其他几名领队神色一变，同时说声：“不好！”而后飞鹤冲天，腾空而起，一边朝着峭壁上飞掠一边喊道：“是哪个家伙，端的行踪诡秘，神龙见首不见尾，竟然殴打我真武弟子！”\n“我！一云子！”一云子满脸怒容，眼神像是能活剥人一般，从峭壁顶端露出头来，两道目光凝聚着向下看来，空气几乎都实质化了。这一下可把几个正在飞掠的真武弟子吓得不轻，道行不高的差点直接从峭壁上摔下去，还是笑道人反应快，沉声道：“稳住心神，屏息聚气！”众弟子闻声连忙提神聚气，堪堪从峭壁上滑下，一个个重重地砸在地上，只有笑道人稳稳地落地，而后众弟子仰视一阵，纷纷躬身行礼道：“弟子等参见师叔。”\n“不必多礼！”一云子黑着脸压着怒气说道，“我只说一句！以后再有以下犯上，对师门长辈不敬的，燕书磐就是你们的榜样！”说罢，袖袍一挥，返身消失在崖壁上，紧跟着惨叫声再度响起，逐渐趋于高昂。\n“弟子等领师叔教诲！”听着崖壁上的一声声惨叫，众弟子面面相觑，连练功也顾不得了，都在议论这位燕书磐师兄是怎么了，竟然让一云子师叔如此愤怒，平素里一云子只有在太极道场时巡视时非常严肃，若是在其他地方遇到这位师叔，就像遇到个面善和蔼的普通中年道士一般。可今日一云子师叔怎么如此生气，难道燕书磐……\n想到这里，众弟子连忙肃容，眼观鼻鼻观心，事不关己高高挂起。燕书磐在太极道场占着不走本就有碍观瞻，方才大家慌张是因为以为燕书磐是被混入真武山中的江湖人士掳去，这才上前询问。毕竟掳燕书磐事小，掳真武律令阁寒湘子的亲传弟子事大啊，是以众弟子不得不问问情况，然而既然是一云子在对真武弟子进行“教育”，那就没必要凑热闹了。最好是将这厮打的十天半个月下不来床，某些曾被受欺的真武弟子心中甚至想道。\n笑道人目送一云子消失，这才想起来得赶紧派人去律令阁通知寒湘子师叔，于是连忙四处张望张慎峰的踪迹，想要让张慎峰去给寒湘子带信。然而四下望去，张慎峰早已连影子都不见了。笑道人连声叹气，回过头对其他弟子道：“各位，一云子师叔大发雷霆，教训燕书磐，我怕会发生什么意外。当务之急是要赶紧去律令阁，将这里发生的事情告知寒湘子师叔，请他老人家定夺。哪位弟子辛苦一趟？”\n众弟子面面相觑，谁也没吱声。俗话说，报喜不报忧，这等晦气事情，告知寒湘子完全是吃力不讨好，寒湘子知道此事后定然会勃然大怒，那时他压根不会记得是哪位弟子好心前来报信的，只知道赶紧出面将他的徒弟保下，至于他和一云子之间会发生什么不友善的事情，更是殊难预料。去律令阁完全是一举三失：既无法给师叔留下好印象，还有可能要承担一小部分师叔的怒火，再者还会耽误练功，谁爱去谁去。\n在短暂的冷场后，众弟子赶紧出声打太极，这个说：“师兄，此等大事我以为还是要选腿脚得力之人，只恨我刚才飞掠岩壁的时候把脚扭伤了，律令阁路远，跋涉艰难，恕我无法过去。”那个说：“师兄，这等重要的事情，我就不掺和了，今天出门我没洗脸，贸然前去有损武道院的形象。”\n笑道人听着众弟子的言论，额头上的黑线一根一根地浮现出来，众弟子入武道院修习武功，不说五年十载的，三年五载总有了吧？这么长时间的修行，腿脚上的关节应该柔韧无比才对，怎么可能施展轻功攀个岩壁还把脚扭了？再说律令阁不还是我真武本派建筑吗，从真武殿走，就算是施展最慢的轻功，小半个时辰也该到了，至于说跋涉艰难嘛？出门没洗脸——亏他想得出这理由，洗不洗脸的有什么关系？此时，笑道人的一张脸完全变黑，黑的像长生楼里炼丹时投入的煤炭一般。\n笑道人在太极道场焦头烂额，犹豫着是否自己亲自跑一趟律令阁；而张慎峰此时已经悠哉游哉地到了律令阁所在地，不过，他并不是好心来给寒湘子报告太极道场发生的事情，而是来观摩学习寒湘子讲经论道的。\n其实，真武门派并无严密门规，只有一般赏罚。门规规定，凡有大过者入律令阁静修。不过来到律令阁的弟子却并非人人均是反思静修，与此相反，大部分自由弟子来到律令阁，都是来听寒湘子这位律令执掌讲经论道的。真武祖师张梦白张真人曾有云：“先入世，方可出世；先得道，方可忘道。”循此武训，真武门人一直将入世和得道作为修行标准。故此，律令阁时时都有弟子聆听寒湘子讲经论道也就无可厚非了。\n律令阁坐落在真武山九室岩的北部，朝向正南，这种布局其一是象征着律令阁在真武派中的地位：全派的律令执掌。虽然不是绝对的至高无上，但也足可谓是一殿之下，万户之上；其二则是因为真武山九室岩乃是一个不规则的扁圆环，真武山中三大标志性建筑：律令阁、三清殿、长生楼错落分布在这个圆环上，面朝最中间的真武殿。律令阁处在真武山北，面朝南边的真武殿正属该然。\n真武律令阁建在真武山北山接近顶峰的位置上，七八十间房舍，排成五排建筑，随山势逐渐拔高，最后一层建筑后，两面巨大的峰壁呈半圆状排列，将整个律令阁笼上一层光影，在阳光照射下，有几分审视真武的森然气象，又有几分纳春秋入芥子的广阔胸怀。\n张慎峰从峰壁下沿山脊而上，一个灵巧的翻跃，轻轻落到了律令阁五排建筑的最后一排上。然而令他惊讶的是，此际本该庄严肃穆的律令阁，竟传来一阵阵欢快跳动的琴声！\n琴声？张慎峰觉得脑子有点不够用了？这里不是律令阁么？律令阁历来以庄肃著称，寒湘子这位律令执掌更是不苟言笑之人，怎么会有琴声呢？退一步讲，即使有真武弟子抚琴，也不该在这传授经文，讲授道理的律令阁中弹奏啊？如此散漫做法，以寒湘子的性格，必然是雷霆震怒。再退一步讲，真武山中门人皆修习的是沉着稳重的道法，即便弹奏琴曲，也该以重音为多，怎么会显得欢快呢？\n难道抚琴的竟不是真武门人？那会是谁？寒湘子师叔又在哪里？\n张慎峰脑海中泛起的第一个念头就是寒湘子师叔被歹人偷袭，不过这个念头很快就被他抛之脑后了。试想，哪会有贼人偷偷上真武山，只为了打晕律令执掌然后在此弹琴？那不是脑子有问题嘛。既然不是歹人偷袭，那应该就只能是哪位寒湘子的友人或者是江湖中的大能前来真武拜访了。\n张慎峰刚想下去一探究竟，身后两边却变故骤起。张慎峰还没来得及动作，两道指诀便已然如风似雷般迅速点在张慎峰的身上，然后数十个身着各色服饰的人从他的身后出现。其中一个身着真武服饰的人走上前来悄声说道：“若你能保证不大喊大叫，我等便解除你身上的束缚，懂了吗？”\n事起突然，张慎峰从这些人的出手一瞬间就明白，他们决不是一般的习武之人，即使是那名身着真武服饰的弟子，也绝不在真武三代弟子之列。既然来路不明，张慎峰并不打算轻举妄动，而是装作很慌乱的样子，忙不迭地点头，不停地说道：“好，好……”\n那名身着真武灰白道袍的弟子见张慎峰表情讪讪，口中讷讷，戒备的神情便消散了几分。另一名身着白袍的人过来，伸手解了张慎峰的穴位，而后灰白道袍盘问道：“你是何人？在此作甚？”\n何人？饶是张慎峰的城府，此刻内心中也有些啼笑皆非。此山乃真武山九室岩，此地乃我真武派下的律令阁，我张慎峰乃是真武弟子，在我自己门派之中行走，难道还得向你们这些来历不明的江湖人交代行迹？真真是滑天下之大稽。不过此际敌众我寡，这些人的武力又远在张慎峰之上，情形不明，张慎峰只得继续假装结结巴巴地虚与委蛇，道：“我，我乃是真武律令阁中的杂役弟子，每，每日在此以清水洒地，扫除灰尘。你，你，你等是何人，为何突然出现在此，威吓于我？”\n灰白道袍闻听此言，挥挥手，扭头对其他几个人说道：“我观此人道袍已旧，应是杂役弟子无误。既是我同门，各位不要为难与他。”说罢，再度面向张慎峰，以不容置疑的口气说道：“我等欲往律令阁中聆曲，你随我们一道前往。”\n“聆……聆曲？”张慎峰竭力表现出一个普通杂役弟子骤然经历变故而魂不守舍的样子，嗫嚅道，“我，我的轻功不好，可……可能……”\n“无妨。”灰白道袍摆摆手，道，“由我带你飞掠，你不必担忧轻功。”\n“你，你们是谁？”张慎峰再度问到。不过灰白道袍却没有再回应。\n言语间，数十个各色服饰的神秘人皆腾空而起，张慎峰也被那灰白道袍带离了地面。这些人端的轻功了得，在律令阁五排建筑中轻巧地向前低空横掠，借助光影将自己的身躯隐藏在暗处，既改换了行迹又不会被他人发现。张慎峰一面观摩着这些人的身法；另一面脑海中飞速运转起来：一，据他所知，真武山明面上有价值的物事如经书，丹药等尽皆存于山海楼和长生楼，而断然不在律令阁；二，若是这些人乃是真武弟子与外勾结，欲盗真武镇派之宝，则事成之后为了不暴露行踪，必定会将自己灭口。当务之急，一是要弄清楚这些人的来意，提前预警，不让门派遭受损失；二则是要抓住机会，及时逃离，免得自己难逃灭口命运。\n不过，想要从数十个轻功高强的人手中逃离，实在是难于登天；更何况这其中还有一名真武弟子，自己唯一的地利优势也是荡然无存。难道此际绝路竟是天意吗？\n终于，所有神秘人尽皆轻轻下坠，稳稳落在律令阁最前面的一排建筑上。此处的琴声已然非常近，张慎峰微微探头，从房顶的翼角下伸出脑袋，观察着外面的情形。\n外面乃是一进非常大的院落，周围四间房子将其围住，如果说这进院落宛若一个巨大的四合院的话，那么张慎峰等人便在这进四合院的院门房顶上。他们正对的院落中，二十几名姑娘均身着粉锦，围坐在院内的香炉前。居中一名女子斜坐中央，正在抚琴；而寒湘子师叔和十名真武女知客弟子在正对的房舍中，与三名姑娘客气地交谈着。\n周边的所有人就位后，尽皆使出了江湖上流传甚广、简单易学的隐匿身形的功夫——狸翻之术，让自身与日光还有房顶完美地融合在一起。\n“淦！”张慎峰一拍大腿。如果这时候他还不知道这些神秘人是要做什么的话，那他就算白在真武山待了。眼前情形，宛若一个大型的歌舞会表演现场；而这些神秘人，自然是来观赏歌舞的。\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch4/","tags":[],"title":"第四章 律令"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"请求分页管理方式 设计算机中各项操作时间如下所示：\n访问快表命中率$P_1$ 访问内存页表命中率$P_2$ 访问快表耗时$a$ 访问内存耗时$b$ 更新快表耗时$c$ 更新内存耗时$d$ 磁盘I/O耗时e（磁盘I/O包括读磁盘和写磁盘，一般会用到读磁盘，但不一定需要写磁盘，因此这里的e不是定值，需要特别注意） 则平均访问时间： $$\rP_{1}(a+b)+(1-P_{1})[P_{2}(a+b+b+c)+(1-P_{2})(a+b+e+d+c+a)]\r$$ 第一部分是访问快表，得到物理地址后直接在内存中寻址；\n第二部分是快表未查找到，因此在内存中查找页表，然后得到物理地址并在内存中寻址，最后更新快表；\n第三部分是快表和内存都未查找到，因此发生缺页中断，需要调页。中断后首先读磁盘，接下来分为两种情况：\n内存页表已满，需要换出一页，因此选中需要调出的页，判断是否修改，进而判断是否需要写磁盘（与此同时需要删去快表中被调出的页表项，但通常并行因而忽略），然后更新内存（包括换入页及更新页表两方面），最后更新快表并查快表； 内存页表未满，因此不需要写磁盘，直接更新内存，更新快表，查快表。 特别地，需要注意访问内存和查快表、更新内存和更新快表是否能够同时执行。若能同时执行，则忽略掉快表所需时间。因为快表是高速缓存硬件，速度比内存快得多。更新快表一般包括删去被调出的页表项及增加新页表项两方面，但前者通常与磁盘I/O并行，因而忽略）\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/operating-system/memory-manage/","tags":[],"title":"进程管理"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"本节尝试对具有代表性的线性表编程题及经典算法进行实现。\n题1 删除单链表中的指定结点 递归算法实现删除不带头结点的单链表L中所有值为x的结点。\nvoid RecurseDel(LinkList \u0026amp;L,ElemType x){ if(L==NULL)\treturn; if(L-\u0026gt;data!=x) RecurseDel(L-\u0026gt;next,x); LNode *p; p=L; L=L-\u0026gt;next; free(p); RecurseDel(L,x); } 本算法的难点在于有观点认为该实现过程会造成线性表断链，分析如下。\n每次调用算法均只会对当前链的首结点进行删除或不删除操作；而断链仅在前一个结点未被删除，中间结点被删除，后一个结点未被删除时可能发生；因此仅在上一层函数不删除当前链首结点并递归调用，本层函数删除当前链首结点的时候可能出现断链。注意到函数参数表使用的是引用调用，设上层线性表为L(up)，它进入函数后调用RecurseDel(L-\u0026gt;next,x)，因此对本层来说，本层的单链表L(current)=\u0026amp;(L(up)-\u0026gt;next)，而后本层函数赋值L(current)=L(current)-\u0026gt;next，即最终有下式成立：\u0026amp;(L(up)-\u0026gt;next)=L(current)-\u0026gt;next，即上层的next指针最终指向了本层被删除结点的下一个结点。因此不会断链。\n当调用函数时，有三种向函数传递参数的方式，分别是传值调用，指针调用和引用调用。其中后两种调用时修改形式参数会影响实际参数。\n题2 反向输出单链表结点的值 对带头结点L的单链表，从尾到头反向输出结点的值。\n思想1：采用递归，每次返回后一个结点的反向输出值，再返回当前结点的值。\nvoid RecursePrint(LinkList L){ if(L-\u0026gt;next!=NULL) RecursePrint(L-\u0026gt;next); if(L!=NULL) printf(\u0026quot;%d\u0026quot;,L-\u0026gt;data); } 思想2：采用头插法对原单链表进行逆置\n实现法1：生成新单链表，然后遍历输出新单链表。\nvoid HeadInsertPrint(LinkList L){ LinkList L1=(LinkList)malloc(sizeof(LNode)); L1-\u0026gt;next=NULL; LNode *p=L-\u0026gt;next,*q;//p是工作指针，指向当前需要进行头插的结点；不断新生成q插入新链表 while(p!=NULL){ q=(LNode*)malloc(sizeof(LNode)); q-\u0026gt;data=p-\u0026gt;data; q-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=q; p=p-\u0026gt;next; }//头插法结束 p=L1;//将逆置链表头结点赋给p while(p-\u0026gt;next!=NULL){ p=p-\u0026gt;next; printf(\u0026quot;%d\u0026quot;,p-\u0026gt;data); } } 实现法2：就地逆置，遍历输出（见题3）\n题3 单链表的就地逆置 就地逆置单链表，最后打印单链表的内容。\n思想1: 将头结点摘下，然后从第一个结点开始依次头插法建立单链表。\nvoid LinkListReversePrint(LinkList L){ LNode *p,*q; p=L-\u0026gt;next; L-\u0026gt;next=NULL; while(p!=NULL){ q=p-\u0026gt;next;//暂存工作指针的后继，防止断链 p-\u0026gt;next=L-\u0026gt;next; L-\u0026gt;next=p; p=q; }//头插法结束 p=L;//将逆置链表头结点赋给p while(p-\u0026gt;next!=NULL){ p=p-\u0026gt;next; printf(\u0026quot;%d\u0026quot;,p-\u0026gt;data); } } 思想2: 使用三个工作结点 pre,p,r 依次遍历单链表，pre指示前一个结点，p指示当前结点，r指示后一个结点。每次翻转两个结点，最终得到就地逆置的单链表。\nvoid LinkListReversePrint(LinkList L){ LinkList pre,p,r; p=L-\u0026gt;next; r=p-\u0026gt;next; p-\u0026gt;next=NULL;//p即是逆置后的最后一个结点，将其尾部置空 while(r!=NULL){ pre=p; p=r; r=r-\u0026gt;next; p-\u0026gt;next=pre;//指针反转 } L-\u0026gt;next=p;//头结点的下一结点指向逆置前的最后一个结点 p=L; while(p-\u0026gt;next!=NULL){ p=p-\u0026gt;next; printf(\u0026quot;%d\u0026quot;,p-\u0026gt;data); } } ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/linear-list-algorithms/","tags":[],"title":"线性表算法题解"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Guass Newton 考虑曲线拟合问题，使用加权非线性最小二乘法\n代码如下：\n#include \u0026lt;Eigen/Core\u0026gt; #include \u0026lt;Eigen/Dense\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;opencv2/opencv.hpp\u0026gt; using namespace std; using namespace Eigen; int main(int argc, char **argv){ double ar = 1.0, br = 2.0, cr = 1.0; // 真实参数值 double ae = 2.0, be = -1.0, ce = 5.0; // 估计参数值 int N = 100; // 数据点 double w_sigma = 1.0; // 噪声标准差 double inv_sigma = 1.0 / w_sigma; // 噪声标准差的倒数 cv::RNG rng; // 随机数产生器 vector\u0026lt;double\u0026gt; x_data, y_data; // 拟合数据 for (int i = 0; i \u0026lt; N; i++){ double x = i / 100.0; x_data.push_back(x); // 生成带噪声的数据 y_data.push_back(exp(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma)); } // 开始Gauss-Newton迭代 int iterations = 100; // 迭代次数 double cost = 0, lastCost = 0; // 本次迭代的代价和上一次迭代的代价 chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); for (int iter = 0; iter \u0026lt; iterations; iter++){ Matrix3d H = Matrix3d::Zero(); // Hessian = J^T W^{-1} J in Gauss-Newton Vector3d b = Vector3d::Zero(); // 偏置向量 bias cost = 0; for (int i = 0; i \u0026lt; N; i++){ double xi = x_data[i], yi = y_data[i]; // 第i个数据点 double error = yi - exp(ae * xi * xi + be * xi + ce); Vector3d J; // 雅可比矩阵 J(0) = -xi * xi * exp(ae * xi * xi + be * xi + ce); // de/da J(1) = -xi * exp(ae * xi * xi + be * xi + ce); // de/db J(2) = -exp(ae * xi * xi + be * xi + ce); // de/dc // 构建 Hessian 矩阵和偏置向量 b // 这里 W^{-1} 是标量，因此可以约去 H += inv_sigma * inv_sigma * J * J.transpose(); b += -inv_sigma * inv_sigma * error * J; cost += error * error; // 累加当前的误差平方和 } // 求解线性方程 Hx=b // 对于正定矩阵，使用LDL^T分解（cholesky 分解法的一种） Vector3d dx = H.ldlt().solve(b); if (isnan(dx[0])){ cout \u0026lt;\u0026lt; \u0026quot;result is nan!\u0026quot; \u0026lt;\u0026lt; endl; break; } // 如果当前迭代的代价大于等于上一次迭代的代价，则终止迭代 if (iter \u0026gt; 0 \u0026amp;\u0026amp; cost \u0026gt;= lastCost){ cout \u0026lt;\u0026lt; \u0026quot;cost: \u0026quot; \u0026lt;\u0026lt; cost \u0026lt;\u0026lt; \u0026quot;\u0026gt;= last cost: \u0026quot; \u0026lt;\u0026lt; lastCost \u0026lt;\u0026lt; \u0026quot;, break.\u0026quot; \u0026lt;\u0026lt; endl; break; } // 更新估计后的参数值 ae += dx[0]; be += dx[1]; ce += dx[2]; // 更新上一次迭代的代价 lastCost = cost; // 输出当前迭代的总代价和更新后的参数 cout \u0026lt;\u0026lt; \u0026quot;total cost: \u0026quot; \u0026lt;\u0026lt; cost \u0026lt;\u0026lt; \u0026quot;, \\t\\tupdate: \u0026quot; \u0026lt;\u0026lt; dx.transpose() \u0026lt;\u0026lt; \u0026quot;\\t\\testimated params: \u0026quot; \u0026lt;\u0026lt; ae \u0026lt;\u0026lt; \u0026quot;,\u0026quot; \u0026lt;\u0026lt; be \u0026lt;\u0026lt; \u0026quot;,\u0026quot; \u0026lt;\u0026lt; ce \u0026lt;\u0026lt; endl; } chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); // 记录结束时间 chrono::duration\u0026lt;double\u0026gt; time_used = chrono::duration_cast\u0026lt;chrono::duration\u0026lt;double\u0026gt;\u0026gt;(t2 - t1); cout \u0026lt;\u0026lt; \u0026quot;solve time cost = \u0026quot; \u0026lt;\u0026lt; time_used.count() \u0026lt;\u0026lt; \u0026quot; seconds. \u0026quot; \u0026lt;\u0026lt; endl; // 输出最终估计的参数值 cout \u0026lt;\u0026lt; \u0026quot;estimated abc = \u0026quot; \u0026lt;\u0026lt; ae \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; be \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; ce \u0026lt;\u0026lt; endl; return 0; } Ceres Solver 步骤如下：\n构建最小二乘问题 ceres::Problem problem 创建代价函数的计算模型，可以是 struct 或 class 向问题中添加误差项 problem.AddResidualBlock 描述代价函数的微分，指定代价函数的类型、残差维度、参数维度等 构建求解器 ceres::Solver 配置求解器的选项 ceres::Solver::Options options 声明求解器的摘要 ceres::Solver::Summary summary 执行优化 ceres::solve(options,\u0026amp;problem,\u0026amp;summary) 代码如下： #include \u0026lt;ceres/ceres.h\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;opencv2/core/core.hpp\u0026gt; using namespace std; // 代价函数的计算模型 struct CURVE_FITTING_COST { CURVE_FITTING_COST(double x, double y) : _x(x), _y(y) {} // 残差的计算 // 声明模板；abc是指向待估计参数的预测值的指针，residual是指向残差的指针 // 该 operator 将在 ceres 库的内部被调用 template \u0026lt;typename T\u0026gt; bool operator()(const T * const abc, T * residual) const{ // 使用 ceres 提供的模板化指数函数，否则无法用 ceres 优化 // 使用强制类型转换 residual[0] = T(_y) - ceres::exp(abc[0] * T(_x) * T(_x) + abc[1] * T(_x) + abc[2]); // y - exp(ax^2 + bx + c) // Ceres 要求 operator() 返回一个 bool 值，以指示计算是否成功。 return true; } // 类的属性包括 x, y 数据 const double _x, _y; }; int main(int argc, char **argv) { double ar = 1.0, br = 2.0, cr = 1.0; // 真实参数值 double ae = 2.0, be = -1.0, ce = 5.0; // 估计参数值 int N = 100; // 数据点数量 double w_sigma = 1.0; // 噪声的标准差 double inv_sigma = 1.0 / w_sigma; cv::RNG rng; // OpenCV随机数产生器 vector\u0026lt;double\u0026gt; x_data, y_data; // 数据 for (int i = 0; i \u0026lt; N; i++) { double x = i / 100.0; x_data.push_back(x); // 生成带有噪声的y数据 y_data.push_back(exp(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma)); } double abc[3] = {ae, be, ce}; // 待估计的参数 // 也可以用 Eigen 的 Vector3d 作为参数 // Vector3d abc; // abc \u0026lt;\u0026lt; ae, be, ce; // 构建最小二乘问题 ceres::Problem problem; for (int i = 0; i \u0026lt; N; i++){ // 向问题中添加误差项 problem.AddResidualBlock( // 使用自动微分代价函数进行自动求导，或者也可以使用其他方法 // 模板参数：误差类型，输出维度，输入维度，维数要与前面struct中一致 // 1. 自动求导 Auto Diff // 2. 数值求导 Numeric Diff // 3. 自行推导解析的导数形式 new ceres::AutoDiffCostFunction\u0026lt;CURVE_FITTING_COST, 1, 3\u0026gt;(new CURVE_FITTING_COST(x_data[i], y_data[i])), nullptr,// 核函数，这里不使用，为空 abc // 待估计参数 // abc.data() // 使用 Eigen 的 data() 方法获取指向数据的指针 ); } // 配置求解器 ceres::Solver::Options options; // 这里有很多配置项可以填 options.linear_solver_type = ceres::DENSE_NORMAL_CHOLESKY; // 增量方程使用 cholesky 分解 // 1. DENSE_QR // 2. DENSE_NORMAL_CHOLESKY options.minimizer_progress_to_stdout = true; // 输出到 cout ceres::Solver::Summary summary; // 优化信息 chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); // 记录起始时间 ceres::Solve(options, \u0026amp;problem, \u0026amp;summary); // 开始优化 chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); // 记录结束时间 chrono::duration\u0026lt;double\u0026gt; time_used = chrono::duration_cast\u0026lt;chrono::duration\u0026lt;double\u0026gt;\u0026gt;(t2 - t1); // 计算总耗时 cout \u0026lt;\u0026lt; \u0026quot;solve time cost = \u0026quot; \u0026lt;\u0026lt; time_used.count() \u0026lt;\u0026lt; \u0026quot; seconds. \u0026quot; \u0026lt;\u0026lt; endl; // 输出结果 cout \u0026lt;\u0026lt; summary.BriefReport() \u0026lt;\u0026lt; endl; // 输出优化摘要 cout \u0026lt;\u0026lt; \u0026quot;estimated a,b,c = \u0026quot;; for (auto a : abc) cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; // 使用 Eigen 时 // cout \u0026lt;\u0026lt; \u0026quot;estimated a,b,c = \u0026quot; \u0026lt;\u0026lt; abc.transpose() \u0026lt;\u0026lt; endl; return 0; } G2O G2O 是通用的图优化库，图优化是将非线性优化与图论结合起来的理论。\n图是图论意义上的图，由若干个顶点和边组成，顶点表示的是优化变量，边表示的是误差项，因此对于非线性最小二乘问题，都可以构建与之对应的图，或称贝叶斯图、因子图。\nG2O 可选依赖于 suitesparse 和 cxsparse 。\n步骤如下：\n定义顶点类，表示优化问题中的参数，继承自 g2o::BaseVertex，重写其虚函数 重置顶点的估计值 void setToOriginImpl() 更新顶点的估计值 void oplusImpl(const double *update) 定义边类，表示误差项，它可以连接一个或多个顶点，继承自一元边 g2o::BaseUnaryEdge 或二元边 g2o::BaseBinaryEdge 或多元边 BaseMultiEdge 计算误差 void computeError() 计算雅可比矩阵 void linearizeOplus() 构建优化问题 创建g2o图模型，设置求解器 向图中添加顶点和边 执行优化 代码如下：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;opencv2/core/core.hpp\u0026gt; #include \u0026lt;chrono\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;Eigen/Core\u0026gt; #include \u0026lt;g2o/core/base_unary_edge.h\u0026gt; #include \u0026lt;g2o/core/base_vertex.h\u0026gt; #include \u0026lt;g2o/core/block_solver.h\u0026gt; #include \u0026lt;g2o/core/g2o_core_api.h\u0026gt; #include \u0026lt;g2o/core/optimization_algorithm_dogleg.h\u0026gt; #include \u0026lt;g2o/core/optimization_algorithm_gauss_newton.h\u0026gt; #include \u0026lt;g2o/core/optimization_algorithm_levenberg.h\u0026gt; #include \u0026lt;g2o/solvers/dense/linear_solver_dense.h\u0026gt; using namespace std; // 曲线模型的顶点类，优化变量 // 模板参数：优化变量维度和数据类型 class CurveFittingVertex : public g2o::BaseVertex\u0026lt;3, Eigen::Vector3d\u0026gt;{ public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW // 重置顶点的估计值 // `virtual` 关键字可以省略，因为这是在派生类中重写基类的函数，但是加上则有助于可读和维护； virtual void setToOriginImpl() override { _estimate \u0026lt;\u0026lt; 0, 0, 0; } // 更新顶点的估计值 virtual void oplusImpl(const double *update) override { _estimate += Eigen::Vector3d(update); } // 存盘和读盘：留空 virtual bool read(istream \u0026amp;in) {} virtual bool write(ostream \u0026amp;out) const {} }; // 曲线模型的边类，误差模型 // 模板参数：观测值维度，类型，连接顶点类型 class CurveFittingEdge : public g2o::BaseUnaryEdge\u0026lt;1, double, CurveFittingVertex\u0026gt;{ public: EIGEN_MAKE_ALIGNED_OPERATOR_NEW CurveFittingEdge(double x) : BaseUnaryEdge(), _x(x) {} // 计算曲线模型误差 virtual void computeError() override{ const CurveFittingVertex *v = static_cast\u0026lt;const CurveFittingVertex *\u0026gt;(_vertices[0]); const Eigen::Vector3d abc = v-\u0026gt;estimate(); _error(0, 0) = _measurement - std::exp(abc(0, 0) * _x * _x + abc(1, 0) * _x + abc(2, 0)); } // 计算雅可比矩阵，微分部分 virtual void linearizeOplus() override { const CurveFittingVertex *v = static_cast\u0026lt;const CurveFittingVertex *\u0026gt;(_vertices[0]); const Eigen::Vector3d abc = v-\u0026gt;estimate(); double y = exp(abc[0] * _x * _x + abc[1] * _x + abc[2]); _jacobianOplusXi[0] = -_x * _x * y; _jacobianOplusXi[1] = -_x * y; _jacobianOplusXi[2] = -y; } virtual bool read(istream \u0026amp;in) {} virtual bool write(ostream \u0026amp;out) const {} public: double _x; // x 值， y 值为 _measurement }; int main(int argc, char **argv) { double ar = 1.0, br = 2.0, cr = 1.0; // 真实参数值 double ae = 2.0, be = -1.0, ce = 5.0; // 估计参数值 int N = 100; // 数据点 double w_sigma = 1.0; // 噪声的标准差 double inv_sigma = 1.0 / w_sigma; // 噪声的标准差的倒数 cv::RNG rng; // OpenCV随机数产生器 vector\u0026lt;double\u0026gt; x_data, y_data; // 数据 for (int i = 0; i \u0026lt; N; i++){ double x = i / 100.0; x_data.push_back(x); y_data.push_back(exp(ar * x * x + br * x + cr) + rng.gaussian(w_sigma * w_sigma)); } // 构建图优化 // 先设定g2o // 每个误差项优化变量维度为3，误差值维度为1 typedef g2o::BlockSolver\u0026lt;g2o::BlockSolverTraits\u0026lt;3, 1\u0026gt;\u0026gt; BlockSolverType; // 线性求解器类型 typedef g2o::LinearSolverDense\u0026lt;BlockSolverType::PoseMatrixType\u0026gt; LinearSolverType; // 梯度下降方法，可以从GN, LM, DogLeg 中选 // solver 可选 // 1. OptimizationAlgorithmGaussNewton // 2. OptimizationAlgorithmLevenberg // 3. OptimizationAlgorithmDogleg auto solver = new g2o::OptimizationAlgorithmGaussNewton( g2o::make_unique\u0026lt;BlockSolverType\u0026gt;(g2o::make_unique\u0026lt;LinearSolverType\u0026gt;())); g2o::SparseOptimizer optimizer; // 图模型 optimizer.setAlgorithm(solver); // 设置求解器 optimizer.setVerbose(true); // 打开调试输出 // 往图中增加顶点 CurveFittingVertex *v = new CurveFittingVertex(); v-\u0026gt;setEstimate(Eigen::Vector3d(ae, be, ce)); v-\u0026gt;setId(0); optimizer.addVertex(v); // 往图中增加边 for (int i = 0; i \u0026lt; N; i++){ CurveFittingEdge *edge = new CurveFittingEdge(x_data[i]); edge-\u0026gt;setId(i); // 顶点索引，顶点指针 edge-\u0026gt;setVertex(0, v); // 设置连接的顶点 edge-\u0026gt;setMeasurement(y_data[i]); // 观测数值 edge-\u0026gt;setInformation(Eigen::Matrix\u0026lt;double, 1, 1\u0026gt;::Identity() * 1 / (w_sigma * w_sigma)); // 信息矩阵：协方差矩阵之逆 optimizer.addEdge(edge); } // 执行优化 cout \u0026lt;\u0026lt; \u0026quot;start optimization\u0026quot; \u0026lt;\u0026lt; endl; chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); optimizer.initializeOptimization(); optimizer.optimize(10); chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); chrono::duration\u0026lt;double\u0026gt; time_used = chrono::duration_cast\u0026lt;chrono::duration\u0026lt;double\u0026gt;\u0026gt;(t2 - t1); cout \u0026lt;\u0026lt; \u0026quot;solve time cost = \u0026quot; \u0026lt;\u0026lt; time_used.count() \u0026lt;\u0026lt; \u0026quot; seconds. \u0026quot; \u0026lt;\u0026lt; endl; // 输出优化值 Eigen::Vector3d abc_estimate = v-\u0026gt;estimate(); cout \u0026lt;\u0026lt; \u0026quot;estimated model: \u0026quot; \u0026lt;\u0026lt; abc_estimate.transpose() \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/7-gauss-newton/","tags":[],"title":"Guass Newton Algorithm"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Function （待完成）\n","permalink":"https://endlesspeak.github.io/docs/docs/rust-programming-basic-doc/6-function/","tags":[],"title":"Function"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"开发环境 开发板： STM32F767IGT6 核心板加正点原子阿波罗底板 屏幕：正点原子 ALIENTEK 7 RGB LCD 屏幕 开发软件：STM32CubeIDE LTDC 外设概述 LTDC 概念 LTDC 全称 LCD-TFT Display Controller，LCD 显示控制器，提供了 RGB 信号和控制信号来直接控制外部 LCD 显示屏。\nTFT-LCD 屏幕 一般 TFT-LCD 屏幕中带有驱动 IC，并集成有显存，其内部就在不断的将显存内容显示到 LCD 面板上； 驱动屏幕时往往是直接去操作驱动 IC，通过发送操作命令来设置显示模式，通过发送显示数据来修改显存内容。 数据通信 GPIO 传送 LCD_RS 命令/数据到 IC； FMC 传送 LCD_CS 片选信号到 IC； FMC 传送 LCD_WR 写使能信号到 IC； FMC 传送 LCD_RD 读使能信号到 IC； IC 传送 D0-D15 16 位数据总线到 FMC； RGB 屏幕 RGB 类型的屏幕中内部没有驱动 IC，操作这种屏幕时往往使用 MCU 内部集成的 LCD 控制器直接去控制 LCD 显示； 显存空间当然也是在 MCU 内部，按照空间大小可以选择放在内部 SRAM 或者外部 SDRAM 中。 数据通信 LTDC 传送 LCD_HSYNC 水平同步信号； LTDC 传送 LCD_VSYNC 垂直同步信号； LTDC 传送 LCD_DE 数据使能信号； LTDC 传送 LCD_CLK 像素时钟； LTDC 传送 R0-R7 8 位数据总线； LTDC 传送 G0-G7 8 位数据总线； LTDC 传送 B0-B7 8 位数据总线； 颜色格式 LCD 可以理解为像素阵，其常见的参数是：\n屏幕尺寸 表示对角线的长度，单位是英寸 屏幕分辨率 像素点的数量，1024*600 表示一行有 1024 个像素点，共 600 行 色彩格式 用于控制每个像素点的颜色 单色屏每个像素点只需要 1 bit 表示（非黑即白） 彩色屏每个像素点由 RGB 三原色的值混合 RGB888(3B)：R值 8 位、G值 8 位、B值 8 位 RGB565(2B)：R值 5 位、G值 6 位、B值 5 位 ARGB8888(4B)：在 RGB888 基础上增加 8 位 Alpha 值表示透明度，0x00 表示完全透明，0xFF 表示完全不透明 ARGB1555(2B)：在 RGB565 基础上砍掉 1 位用于 Alpha，0 表示完全透明，1表示完全不透明 可以看到，RGB888 比 RGB565 表示的颜色更多，LTDC 对上述格式均支持；但是 RGB888 每个像素点需要 24bit（3 个字节）的显存空间来存储。\n在资源紧张的嵌入式系统中，在一般屏幕显示需求中 RGB888 格式过于浪费珍贵的 SRAM 空间；因此在不影响显示的情况下，建议使用 RGB565 格式，每个像素点只需要 16bit（两个字节）的显存空间就够了。\n液晶面板的控制信号 RGB 信号线 RGB 信号线各有 8 根，分别用于表示液晶屏一个像素点的红、绿、蓝颜色分量。 同步时钟信号 CLK 液晶屏与外部使用同步通讯方式，以 CLK 信号作为同步时钟，在同步时钟的驱动下,每个时钟传输一个像素点数据。 水平同步信号 HSYNC 水平同步信号 HSYNC(Horizontal Sync) 用于表示液晶屏一行像素数据的传输结束 每传输完成液晶屏的一行像素数据时，HSYNC 会发生电平跳变 如分辨率为 800x480 的显示屏(800 列,480 行)，传输一帧的图像 HSYNC 的电平会跳变 480 次。 垂直同步信号 VSYNC 垂直同步信号 VSYNC(Vertical Sync) 用于表示液晶屏一帧像素数据的传输结束 每传输完成一帧像素数据时,VSYNC 会发生电平跳变。 “帧”是图像的单位，一幅图像称为一帧。在液晶屏中，一帧指一个完整屏液晶像素点 人们常常用“帧每秒”来表示液晶屏的刷新特性，即液晶屏每秒可以显示多少帧图像。如液晶屏以 60 帧每秒的速率运行时，VSYNC 每秒钟电平会跳变 60 次。 数据使能信号 DE 数据使能信号 DE(Data Enable) 用于表示数据的有效性,当 DE 信号线为高电平时,RGB 信号线表示的数据有效。 液晶通讯的时间参数和传输时序 建议参考《野火 STM32 HAL 库开发指南》书中 LTDC 部分。\n液晶屏显示的图像可看作一个矩形。液晶屏有一个显示指针，它指向将要显示的像素。 显示指针的扫描方向方向从左到右、从上到下，一个像素点一个像素点地描绘图形。这些像素点的数据通过 RGB 数据线传输至液晶屏，它们在同步时钟 CLK 的驱动下依次传输到液晶屏中交给显示指针。 当传输完成一行时，水平同步信号 HSYNC 电平跳变一次，当完成传输一帧时，垂直同步信号 VSYNC 电平跳变一次。 Active width 和 Active height 是可见的 LCD 显示面板分辨率，称为有效宽度和有效高度。 传送数据行过程： 传输 HSYNC 信号数据，用 HSW 表示其宽度，单位为 CLK 个数； 等待 HBP ，即从该水平同步信号开始到有效数据开始间的 CLK 个数； 传送有效数据； 等待 HFP ，即从有效数据结束到下一个水平同步信号开始间的 CLK 个数； 传送数据帧过程： 传输 VSYNC 信号数据，用 VSW 表示其宽度，单位为行； 等待 VBP ，它表示在一帧图像开始时，垂直同步信号以后的无效的行数； 传送有效高度的数据行； 等待 VFP ，表示在一帧图像结束后，垂直同步信号以前的无效的行数； 在时间参数控制区域，数据使能信号线 DE 均为低电平；仅在传送有效数据时 DE 为高电平； 图像数据混合 LTDC 有三个层：背景层（BG）、图层 1（Layer1）、图层 2（Layer2）。\n背景层只能是 RGB888 格式，并且是一个常量值，在 LTDC 初始化结构体中由 Backcolor 成员指定； 图层用来显示内容； 大小是设置的 Active width 和 Active height，称为有效区域； 在这个图层的有效区域中，用户可以设置一个任意大小的窗口用于显示，称为 Window； 当窗口小于图层有效区域时，窗口之外的区域会显示该图层背景色； 图层混合 首先，背景和图层的大小都是 Active width 和 Active height； 背景层在最下面，如果开了单个图层，则显示结果为背景层和单个图层混合结果；如果两个图层都开，则显示结果为背景层先和图层 1 混合，混合结果再与图层 2 混合的结果； 图层混合在 LTDC 硬件上是一直开启的，可以直接配置该图层用于混合的 Alapha 常量来调节整层透明度，范围为 0-255，0 为完全透明、255 为不透明、127 为半透明； ","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/6-stm32-rgblcd/","tags":[],"title":"STM32 RGBLCD"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":" 请解释数据库的四个基本概念\n数据\n数据(Data)是描述事物的符号记录，是数据库中存储的基本对象。\n数据库\n数据库(Data Base DB)是长期存储在计算机内，有组织的，可共享的大量数据的集合。\n数据库管理系统\n数据库管理系统(Data Base Management System DBMS)位于用户和操作系统之间的一层数据管理软件；是基础软件，是一个大型复杂的软件系统。\n数据库系统\n数据库系统(Data Base System)是指在计算机系统中引入数据库后的系统构成。\n包括：DB 数据库、DBMS 数据库管理系统、APP 应用程序、DBA 数据库管理员、用户\n数据模型是什么？分为哪些？\n数据模型是对现实世界数据特征的抽象。\n概念模型\n信息世界的建模，是现实世界到信息世界的第一层抽象；\n逻辑模型\n数据的逻辑结构。它包括层次模型、网状模型、关系模型和其他模型；\n其他模型包括面向对象模型、对象关系数据模型和半结构化数据模型；\n物理模型\n描述数据是如何在计算机中存储和组织的。\n请描述数据库三级模式的结构\n模式与实例\n模式：对数据库逻辑结构和特征的描述，是型的描述（模式是相对稳定的） 实例：数据库某一时刻的状态，模式的具体值，同一个模式可以有很多实例 三级模式结构\n外模式（用户模式、子模式）\n与某一应用有关的数据的逻辑表示，如视图\n模式（逻辑模式）\n是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图\n内模式（存储模式）\n是数据物理结构和存储方式的描述，如聚簇和索引\n二级映像\n外模式-模式映像：保证数据与程序的逻辑独立性 模式-内模式映像：保证数据与程序的物理独立性 数据与程序的逻辑独立性与物理独立性\n逻辑独立性：模式改变，外模式和应用程序不变 物理独立性：数据存储结构改变，模式、外模式、应用程序不变 数据模型的组成要素\n数据结构（静态）\n描述系统的静态特性，它是刻画数据模型性质的重要方面\n数据操作（增删改查）\n数据完整性约束条件\n是一组完整性规则，描述数据及其联系所具有的制约和依存关系\n关系完整性约束分为哪些\n实体完整性：主属性不可以取空值； 参照完整性：外码要么取空值要么取参照关系中某个元组定义的主码值 用户自定义的完整性 视图和基本表的区别\n视图是从一个或多个基本表中导出的表，是已经编译好的SQL语句； 视图没有实际的物理记录，不占用物理空间，而基本表相反； 视图是查看表内容的窗口，查看数据表的一种方法，视图可以不给用户接触表，使用户不知道表结构，安全性更高； 视图是逻辑概念，视图的建立删除只影响它本身，而不影响对应的基本表；基本表是物理概念，对基本表的操作就是数据库的实际读写； 数据库范式\n1NF 是指数据库表的每一列都是不可分割的基本数据项；（队伍中是由人组成的）\n2NF 是指实体的非主属性对码完全依赖，不是部分依赖；（对一把手的绝对服从）\n3NF 是指非主属性属性之间不互相依赖；（队伍内部不拉帮结派）\n例如存在部门信息表，每个部门除了部门号还有部门名称等；员工信息表中列出部门编号后不能再列出部门名称等，防止信息冗余。\nBCNF 是指在3NF基础上，消除主属性对码/键的部分依赖、传递依赖，则称它符合BCNF；（一把手之间互不影响）\n即每一个决定因素都包含码。\n数据库设计基本步骤\nODBC、JDBC是什么？\nODBC是微软公司开发的开放数据库互连系统。不依赖任何DBMS。 JDBC是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。 加载jdbc驱动程序； 创建数据库的连接； 创建preparedStatement； 执行SQL语句； 遍历结果集； 处理异常及关闭JDBC对象资源。 事务的四大特性是？\n原子性\n全部成功或全部失败；\n一致性\n事务的执行不能破坏数据库的完整性和一致性；\n隔离性\n在并发环境中，并发的事务是相互隔离的，一个事务的执行不能不被其他事务干扰。\n持久性\n一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。\n数据库故障的种类有哪些\n事务内部故障 系统故障 存储介质故障（硬件故障） 计算机病毒 数据并发操作所造成的数据库不一致性\n丢失修改 不可重复读 读“脏”数据 什么是封锁？什么是两段锁协议？有哪些封锁类型？\n封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁。 两段锁协议指的是事务执行分为两个阶段：加锁阶段和解锁阶段。 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议； 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。 基本锁的类型 排它锁X锁，也称为写锁，表示对数据进行写操作。 共享锁S锁，也称为读锁，用于所有的只读数据操作。 一级、二级和三级封锁协议\n一级封锁协议 事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。 在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。 二级封锁协议 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后释放S锁。 二级封锁协议防止了丢失修改和读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。 三级封锁协议 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。 三级封锁协议防止了丢失修改和读“脏”数据，还进一步防止了不可重复读。 饥饿、活锁、死锁的区别？\n饥饿：任务一直等待得不到处理； 活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 死锁：两个或多个事务都已封锁了一些数据对象，然后又都请求对已为其他事务封锁的数据对象加锁，从而出现死等待 可串行化调度的充分条件有哪些？\n事务遵守两段锁协议是可串行化调度的充分条件 冲突可串行化调度是可串行化调度的充分条件 自主存取控制和强制存取控制的区别\n自主存取控制 通过 SQL 的GRANT 语句和REVOKE语句实现 用户对不同的数据对象有不同的存取权限。 不同的用户对同一对象也有不同的权限。 用户还可以将其拥有的存取权限转授给其他用户。 强制存取控制 每个数据对象被标注为一个特定的等级 每个用户被授予一个特定等级的许可证 对于任意一个对象，只有具备合法许可证的用户才可以存取。 为什么强制存取控制规定仅当主体许可证级别小于等于客体密级才能写入相应客体，而非大于等于？\n自主存取控制的缺点？\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/databaseprinciples-2/","tags":[],"title":"数据库原理"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"绪论 graph LR\rA[现实世界]--\u003e|抽象|B[信息世界 E-R图]\rB--\u003e|设计|C[计算机世界 关系模式]\r请解释数据库的四个基本概念\n数据\n数据(Data)是描述事物的符号记录，是数据库中存储的基本对象。\n数据库\n数据库(Data Base DB)是长期存储在计算机内，有组织的，可共享的大量数据的集合。\n数据库管理系统\n数据库管理系统(Data Base Management System DBMS)位于用户和操作系统之间的一层数据管理软件；是基础软件，是一个大型复杂的软件系统。\n数据库系统\n数据库系统(Data Base System)是指在计算机系统中引入数据库后的系统构成。\n包括：DB 数据库、DBMS 数据库管理系统、APP 应用程序、DBA 数据库管理员、用户\n数据管理发展阶段有哪些？\n人工发展阶段 文件系统阶段 数据库系统阶段 数据库系统阶段的优点\n数据高度化集成，数据共享性好，数据冗余少、易扩充，数据和程序独立性高\n独立性包括：\n物理独立性 逻辑独立性 数据模型是什么？分为哪些？\n数据模型是对现实世界数据特征的抽象。\n概念模型 逻辑模型和物理模型 信息世界中的基本概念有哪些？\n实体：客观存在并可相互区别的事物，如学生 属性：实体具有的属性，用于区分实体，如学号，姓名，性别等 码：唯一标识实体的属性集合，用于更好的区分实体，如学号是学生的码 实体型：用实体名和属性名集合来抽象、刻画。如学生（学号，姓名，性别，……） 实体集：同型实体叫实体集，如全体学生 实体联系：有一对一，一对多，多对多等 概念模型的表示方法：实体-联系方法 数据模型的组成要素是什么？\n数据结构（静态）\n描述系统的静态特性，它是刻画数据模型性质的重要方面\n数据操作（增删改查）\n数据完整性约束条件\n是一组完整性规则，描述数据及其联系所具有的制约和依存关系\n常用的逻辑数据模型有哪些？\n层次模型（树形）\n网状模型（网状）\n关系模型\n其他模型\n包括面向对象模型、对象关系数据模型、半结构化数据模型\n关系模型的数据结构是怎样的？\n关系：表 元组：表中的一行为一个元组 属性：表张的一列为一个属性 码：唯一确定一个元组 域：一组具有相同数据类型的值的集合，如年龄在0-120岁之间、性别在男女之间 分量：元组中的一个属性值（单元格） 关系模式：关系名（属性1，属性2，……） 试描述数据库的三级模式结构\n模式与实例\n模式：对数据库逻辑结构和特征的描述，是型的描述（模式是相对稳定的） 实例：数据库某一时刻的状态，模式的具体值，同一个模式可以有很多实例 三级模式结构\n外模式（用户模式、子模式）\n与某一应用有关的数据的逻辑表示，如视图\n模式（逻辑模式）\n是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图\n内模式（存储模式）\n是数据物理结构和存储方式的描述，如聚簇和索引\n二级映像\n外模式-模式映像：保证数据与程序的逻辑独立性 模式-内模式映像：保证数据与程序的物理独立性 数据与程序的逻辑独立性与物理独立性\n逻辑独立性：模式改变，外模式和应用程序不变 物理独立性：数据存储结构改变，模式、外模式、应用程序不变 数据库系统的组成\n包括硬件平台及数据库、软件、人员\n数据库管理员的职责\n决定数据库中的信息内容与结构（决定存什么） 决定数据库的存储结构、存取策略（决定怎么存） 定义数据的安全性要求、完整性约束条件（保证数据的安全与完整） 监控数据库的使用和运行（管理） 数据库的改进、重组和重构（维护） 关系数据库 关系模型的三个组成部分？\n关系数据结构 关系操作集合 关系完整性约束 关系数据结构 域：一组具有相同数据类型的值的集合（可能取多个列）；\n域的基数：一个域中允许的不同取值的个数称为这个域的基数；\n笛卡尔积：给定一组域$D_1,D_2,\u0026hellip;,D_n$，允许其中某些域相同，它们的笛卡尔积为：\n$$D_1×D_2×...×D_n=\\\\{ (d_1,d_2,...,d_n)|d_i\\in D_i,i=1,2,...,n \\\\}$$ 简而言之，笛卡尔积是各域中元素的全部排列组合。\n把笛卡尔积看作域，则它的基数是各子域的基数的积，即$D_1×D_2×\u0026hellip;×D_n$的基数\n$$ M=\\prod_{i=0}^{m}m_i$$ 其中每个元素$(d_1,\u0026hellip;,d_n)$叫一个n元组，简称元组（对应行），其中的每个值称为分量（对应单元格）。\n关系：$D_1×D_2×\u0026hellip;×D_n$的子集叫做在域$D_1,D_2,\u0026hellip;,D_n$上的关系，表示为$R(D_1,D_2,\u0026hellip;,D_n)$，其中R是关系的名字，n是关系的目或度。\n关系是笛卡尔积的有限子集。\n候选码：关系中的某一属性值能唯一的标识一个元组，而其子集不能，则称该属性组位候选码。\n主码：从候选码中选定一个作为主码。\n非主属性/非码属性：不包含在任何候选码中的属性。\n全码：关系模式的所有属性都是这个关系模式的候选码。\n关系的三种类型\n基本表/基本关系\n是实际存在的表，实际存储数据的逻辑表示\n查询表\n查询结果对应的表\n视图表\n由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据\n基本关系的6条性质\n列同质（每一列中的分量都是同一类型的数据，来自同一个域）；\n不同的列可以出自同一个域，每一个列称为一个属性，不同的属性要给予不同的属性名。\n例如域名为：人名，那么选课表中至少需要定义导师属性名、学生属性名两种属性名。\n列的顺序无所谓；\n候选码是区分元组（行）的，因此不能相同；\n行的顺序无所谓；\n分量（单元格）必须取原子值，是不可再分的数据项。\n关系模式是四元组$R(U,D,DOM,F)$，其中：\nR是关系名； U为组成该关系的属性名集合（各个列）； D为U中属性所来自的域（取值范围）； DOM为属性向域的映像集合（某些属性属于同一个域）； F为属性间数据的依赖关系集合（属性间的关系）； 关系数据库的型与值\n型：关系数据库模式，是对关系数据库的描述，是静态的，稳定的； 值：关系模式在某一时刻对应的关系的集合，是动态的，随时间变化的； 关系操作集合 关系模型中常有的查询操作有哪些？\n选择：筛选满足条件的元组（行） 投影：筛选去除不需要的属性（列） 连接：根据查询需要，将多个表连接到一起 除：同时从行和列的角度进行运算 并：求合并的元组 差：求在A表而不在B表中的元组 交：求共同的元组 笛卡尔积：略 其中基本操作是选择、投影、并、差、笛卡尔积。\n关系运算记号\n设关系模式$R(A_1,A_2,\u0026hellip;,A_n)$，它的某关系设为$R$，$t\\in R$表示$t$是$R$的一个元组，$t[A_i]$表示元组$t$中相应于属性$A_i$的一个分量。 $A=\\{ A_{i1},A_{i2},\u0026hellip;,A_{ik} \\}$，其中$\\{A_{i1},A_{i2},\u0026hellip;,A_{ik}\\}$是$\\{A_{1},A_{2},\u0026hellip;,A_{n}\\}$中的一部分，则$A$称为属性列或属性组。$t[A]=(t[A_{i1}],t[A_{i2}],\u0026hellip;,t[A_{ik}])$表示元组$t$中属性列$A$上诸分量的集合，$\\bar{A}$表示$\\{A_{1},A_{2},\u0026hellip;,A_{n}\\}$去掉$\\{A_{i1},A_{i2},\u0026hellip;,A_{ik}\\}$后剩余的属性组。 $R$是n目关系，$S$是m目关系，$t_r\\in R,t_s\\in S$，$\\mathop{t_rt_s}\\limits^{\\frown}$称为元组的连接或串接。 给定一个关系$R(X,Z)$，$X,Z$为属性组，当$t\\left [X \\right]=x$时，$x$在$R$中的象集定义为$Z_x={t\\left [Z\\right ]|t\\in R,t\\left [X\\right ]=x}$ 除运算\n设关系R除以关系S的结果为关系T，则T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。\n给定关系$R(X,Y)$和$S(Y,Z)$，其中$X,Y,Z$为属性组，$R.Y$和$S.Y$可以有不同的属性名，但必须出自相同的域集。\n则$R\\div S={t_r[X]|t_r\\in R\\wedge\\sqcap_Y(S)\\subseteq Y_x}$\n即结果P是R中满足条件的元组在X属性列上的投影，条件是：元组在X上的分量值x的象集包含S在Y上投影的集合。\n关系完整性约束 关系完整性约束包括了实体完整性，参照完整性，用户自定义完整性。\n实体完整性：主属性不可以取空值； 参照完整性：外码要么取空值要么取参照关系中某个元组定义的主码值 用户自定义的完整性 关系数据库标准语言 SQL概述 SQL是什么？主要特点是什么？\nSQL for Structured Query Language，是结构化查询语言；\nSQL的主要特点如下：\n综合统一\nSQL集数据定义、数据操纵、数据查询、数据控制于一体；\n高度非过程化\n提出做什么而不必关心怎么做\n面向集合\n以同一种语法提供多种操作方式\n独立用于联机交互或嵌入到高级语言之中；\n简洁\n使用9个动词完成SQL的全部操作\nSQL功能 动词 数据查询 SELECT 数据定义 CREATE，DROP，ALTER 数据操纵 INSERT，UPDATE，DELETE 数据控制 GRANT，REVOKE 数据定义 数据库对象的层次结构\ngraph LR\rA[数据库管理系统]--\u003e|多个|B[数据库]\rB--\u003e|多个|C[模式]\rC--\u003e|多个|D[表]\rC--\u003e|多个|E[视图]\rC--\u003e|多个|F[索引]\r模式实质上是命名空间。\n模式定义\n模式删除\n基本表定义\n基本表数据类型\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/databaseprinciples-1/","tags":[],"title":"数据库原理"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　张真人曾说：“先入世，方可出世；先得道，方可忘道。” 那么何谓入世？入世便是真武门下弟子同江湖中其他各派打交道。\n虽然真武门下弟子终年在真武山上修行，观想云海以和自身武学驱影相验证，真武却并非闭门造车之派，而是积极的和外界相沟通联系。即使是俗世中的民众，真武弟子也未曾有丝毫倨傲表现，同时，真武频繁和江湖中的其他门派参与论剑，交流武学，以道德经的说法，正是“致虚极，守静笃，万物并作，吾以观复。夫物芸芸，各复归其根。归根曰静，静曰复命。复命曰常，知常曰明……”\n如今六月下旬，再过几天便到了七月初，正是一年一度的江湖武学交流集会，由于真武地处平原中部，更兼以修道为主，故深得世人信任，每年的武学切磋交流，若无意外，一般都设在真武山上。而眼前这些姑娘们，便是前来交流武学、论剑切磋的八荒之一——江湖中声名远扬的天香。\n天香门派是八荒门派中的特例，因为它是八荒中唯一只招收女子的门派，清丽脱俗之中自有冰心玉骨，只可恋慕，不容轻侮。天香谷位于东越幽谷万顷花海之中，以医入武，医武合一，凭借将自然、音律、医道和武功结合在一起创造独特武学而自成一派，于花语、剑伞、长裙、金铃中处处体现其“清丽脱俗之优雅”。有诗云：竞夸天下双无绝，独立人间第一香。\n天香没有太白的飘逸，没有神威的刚猛，没有五毒的莫测，也没有唐门的机关之术，但天香超强的生存能力，集治疗，控制，攻击于一体，成为八荒中不可缺少的强大力量。今次来真武山切磋论剑的天香弟子都是十七八岁的女子，个个都生得国色天香，娇艳欲滴。此刻辰末巳初（早上九点），阳光透过律令阁后的两面峰壁，斜斜射在天香姑娘们身上，别有一番风景。\n想明白了院子里的姑娘们的身份，张慎峰要推测出这数十名各色服饰的神秘人的身份也就不难了。这些人应该都是江湖各派前来真武交流武学、切磋论剑的弟子，目前刚到真武不久。而其中那灰白道袍既是真武门人，肯定不是知客弟子，否则其定然是在下面道貌岸然地与姑娘交谈，而不会在房顶上做“梁上君子”。目前真武山中所有三代弟子对此次切磋尽皆毫不知情，而一代弟子又大多迈入而立之年，自重身份，不可能鬼鬼祟祟来此，如此来看，这些神秘人必然尽是所属门派之中的二代弟子。而他们的来意，也很简单，就是窥伺。\n为什么要窥伺这些天香姑娘呢？眼前的情景给出了答案：只见立在院门口的十数名天香谷的素问轩弟子，穿着深紫色短裙，整个身体绷地笔直，又长又直的双腿直插入地，有些凛然的意味；然而其如月牙一般的眉毛却破坏了这种凛然，既显得冷艳，又有种说不出的娇弱。在院子中央的几拨姑娘，则是天香谷的星罗居弟子。尖下颌，红脸颊，粉色连衣长裙，手中的花伞在太阳下撑开，人倚着花伞，就如花瓣在阳光的照耀下绽放一般，让人觉得柔和而美好。\n下面的情景可谓是美不胜收，循着莺莺燕燕声音，可以看到，居中的几名女子嗓音甜美，如幽谷清泉，涓涓细流，让人在炎炎夏日里直生出一股甘冽的感觉；周边的十几名姑娘互相嬉戏打闹，莺声燕语，如翠鸟弹水，如黄莺吟鸣；另外还有几名姑娘在小声交谈：绵言细语，温婉柔和，娇中带柔，柔中带媚，时如浸蜜，时如濯水，俄而一声轻笑，听起来就像是红唇上细细的绒毛在慢慢地勾勒自己的耳朵，然后突然向前猛地一抵，轻轻吹入一口气一般，熨帖着、涤荡着房顶上所有人的心神。\n见大美而自视兮，自渐而形秽。房顶上的众人看到如斯美景，几乎同时咽下口水，然后又同时叹了口气，就连张慎峰也忍不住小声地赞美了一句：“真好看。”。一股几欲凝成实质的怅然若失的感受堵在了“在趴”的所有人的心口上。正所谓，窈窕淑女，君子好逑。求之不得，寤寐思服……\n就在张慎峰一干人等沉浸在欣赏此等美轮美奂的景色之际，眼前的院落正堂中，突然三名真武知客弟子和六名天香弟子簇拥着一名妙龄女子出来，在院子的正中心站定。见此情形，之前还三五成群的天香姑娘们纷纷再度聚拢过来，围着古琴整整齐齐地坐了两个半圈。\n张慎峰定睛一看，几乎当场愣住。只见院落中那名妙人儿：衣着锻锦，长发飘扬；姿容秀美，仪态飘逸；黛眉横扫，星目流光；云雪为鬓，皓发如霜；皎若朝霞，润似渌波；柔颈颀长，酥软飘香……似这等脸庞争若人间绝色，似这等娇嫩直如吹弹可破，似这等酥软好似柔枝弱骨，实在是美艳不可方物。妙龄女子俏脸微红，羞涩万分，面对古琴犹豫而又迟疑，几般扭捏，不肯坐到古琴前；直到院子的正堂中另一名女子开口，才终于在古琴前站定，螓首低垂，冰肌通红，如同成熟而又水灵的苹果；一只手拢过一侧的青丝发，如同春天的清风吹醒了冬眠的生机；只听一声：“献丑了。”声若蚊呐，直拨弄地心弦也不安分起来。终于，她斜斜地坐到地上早已铺好的软席上。如此一红，一羞，一迟，一低，一声，吸引了“在趴”的和“在坐的”所有人的目光，同时所有人也都迫切地想听一听，这位女子的琴曲。\n琴弦拨弄几下，弹奏旋即开始。音调忽扬忽挫，舒缓，深沉，婉转。柔美的琴声仿佛遮住了太阳，在院落中创造出了一片星空。这一刻，不论是房梁上的众人，还是院子里的姑娘们，都感到世间万物仿佛消散了一般，万籁俱寂，惟余琴声在空中如嫩芽般，开枝散叶，逐渐绽放；如沉睡的小草，在清泉的滋润下，伸长脖子，昂首挺胸；如坚实的大树，在春风的吹拂下，舒展枝叶。换言之，此刻这片天地间，没有喧嚣，吵闹和烦躁，唯有月光、琴声和女子。\n遥遥地，琴声似乎远在天边，缓缓地，琴声如流水潺潺；亲切的琴声缭绕耳际；温和的琴声划过心尖。音乐由远及近，低回委婉似窃窃私语，轻松柔和如徐徐晚风，虽然此刻阳光依旧，但听着琴声，众人就像都跟着音符进入了夜色，就像都在群星璀璨的天空中极目。众人随琴曲自由自在，无忧无虑，快快乐乐的飞翔着；清澈明净的琴声潺潺流动。如同来自幽谷深山。琴声如潮，四溢不止；琴声如人，随风而舞；琴声如花，次第开放；琴声如酒，山海苍茫。\n不多时，琴声变幻为渐渐强烈的颤音，低沉逐渐升调，如展翅欲飞的蝴蝶，扑闪着灵动的翅膀，清亮亮的飞舞着；像塞外悠远的天空，闪着清澄的光。随着妙龄女子手迅速的变化，琴声逐渐形成了水流：由静静地，慢慢地流动的水变为富有起伏性的、跳跃性的流淌，淌过人生的皱折，淌过岁月的颠沛，淌过洞悉尘世的盲眼……\n起伏越来越大，越来越显激昂，音符敲打着院子里所有人的心叶，像涨潮时的海水拍打着海岸，强有力的节奏感使众人仿佛都要跳起舞来似的。随着琴声逐渐急促，渐次高潮，仿佛渐渐穿过了院门外洒满铜绿的门环，拂过满是灯火的青山，飘过布满萤光的芦苇群，绕进山间客栈里的巷弄，徘徊在凉爽晚风吹过的院子里，在清幽的夜色中，悠悠荡荡，似在低语，似在控诉，似在流泪……然而就在众人都已经全身心地沉浸在这动人心弦的琴声中时，变故骤生:不知道哪个不小心的家伙，突然全身一激灵，猛地踩塌了一块瓦片!\n琴声戛然而止，在房顶上的众弟子一瞬间心都提到了嗓子眼，然后纷纷低声暗暗问候那个不小心的家伙。如此清雅的琴曲，如此漂亮的姑娘，如此难得一遇的境界，全然被这个不小心的家伙破坏了！是美妙的琴声不好听还是如花般的漂亮姑娘不好看？你就非得踩踏一两块瓦片找找存在感?没素质的家伙，不仅打断了宛如天籁的琴声，打断了姑娘弹琴的思绪，还会让我们濒临暴露的边缘！\n现在，在房顶上的众人一个个都像是四五岁的乖宝宝，连口大气都不敢出，一动不动，全身心收敛自身气息，仿佛要与这夜色，哦不，琴声结束，夜色已经荡然无存，只有太阳照耀这大地；仿佛要与这日光融为一体，生怕会被下面的姑娘发现。\n琴声没有再响起，这让房顶上的众弟子更是如“趴”针毡，趁着姑娘们还沉浸在刚才的意境中没有回神的功夫，所有在房顶上窥伺的弟子纷纷摸向房顶边缘，而后如同一片浮云般向后飘去。灰白道袍这次没有带上张慎峰，而是径自飘然而去，及自落地后，众人脚底抹油般地向远处飞奔，就像后面有什么洪水猛兽在追逐一般，飞速离去。\n张慎峰叹了口气，他现在已经全然明白那些弟子为何要不由分说地将自己带到此地了。寒湘子身为律令执掌，神识灵觉远非寻常弟子可比，而天香此番来真武切磋论剑的姑娘们也必然由强者带队，他们一行数十人，尽皆是二代弟子，虽然轻功了得，但却目标过大，难保在窥伺中不会发生什么意外。带上自己这名“杂役”，一有风吹草动发生，他们便即刻撤退，顺便将自己丢在这里。到时候寒湘子只会认为是杂役难抵诱惑前来窥伺，却不会想到其实前来窥伺的足有四五十人之多，更不会想到是本派真武弟子“内奸”引其前来。\n然而明白归明白，这些解释在寒湘子面前是完全绵软无力的。既然你是一名“杂役”，前来此地绝非自愿，为何刚才到达房顶之时并不高声示警，而是一直潜伏？这其中若说你没有任何私心作祟，那是绝对不会不可能的。而事实上，张慎峰也确实是被这绝美的容颜和引人入胜的琴曲所吸引，如果让他示警破坏这番近乎完美的意境，他的内心也并不是十分愿意的。\n另外张慎峰心中还有存有一层顾虑：江湖中各大派系看似和睦，实则遇到争端时尽皆护短。今日若是一干江湖各派弟子窥伺天香姑娘被寒湘子抓到现形，作为律令执掌，寒湘子绝对是要惩戒“在趴”的所有人的。而各位带队前来交流切磋的并非易于之辈，若是因此生出争端，甚至冲突，天香远来是客，作为被窥伺的一方，是受害者，即使惩戒这些弟子，那也在情理之中，其他江湖派系可能不会对其有所迁怒。然而对惩戒自己派下弟子，污蔑本派弟子是好色之徒，甚至破坏本派的江湖名誉的罪魁祸首——寒湘子，以及寒湘子所在的真武山，则很可能被各大江湖派系当做出气口，甚至引发门派之争。既伤和气，又会使真武成为众矢之的，反为不美。\n张慎峰再度叹气，目前他还不曾习得飘雪穿云的轻功，更做不到在低空飞掠，甚至不会其他窥伺弟子们的狸翻之术。遭遇如此尴尬境地，绝非他之本意。虽说有幸聆听一首乐曲，然而始终是不速之客不请自来，若是被抓住当场，更是百口莫辩。此际房顶已属于是非之地，绝不可久留。但若是随众人一起离去，不仅很有可能被众人当做掩人耳目的炮灰，况且以他目前的轻功水平，必然会发出响动吸引下面的姑娘们。为了保证万无一失，张慎峰决定不从房顶向远处飘身飞掠，而是采取最简单粗暴的办法，从房顶的翼角沿着侧脊向下转移，而后从门前的柱子上慢慢滑到地上，再沿着墙檐到达尽头，最后狂奔离去。\n“云梦，怎么了？”从琴曲中回过神来的姑娘们纷纷向抚琴的妙龄女子发出疑惑的询问。而那位叫做江云梦的女子则是若有所思地看向张慎峰藏身所在的屋顶，轻轻说道：“有人。”\n“有人？”姑娘们沿着江云梦的目光看去，烫金的院落大门的房顶在阳光下显得更加耀目，仿佛要照亮世间一切黑暗似的，让邪恶无所遁形。众女目光到处，什么都没有。几位天香素问轩的弟子随即施展飞鹤冲天，一跃五丈，居高临下审视着整进院子，观察着有什么异常。\n此时，张慎峰已经沿着院门前的柱子下滑到了地上，而后迅速贴到了院门旁的墙下，缓缓向院落的夹角，亦即墙的尽头挪动。墙的顶端窄窄的檐瓦，此刻竟成了躲避搜寻的温暖的港湾。短短的五十丈距离，放在平常，数十个掠步便可到达。然而在此时，却变成了遥不可及的天堑。一炷香的挪动功夫，在张慎峰看来就像过了一个世纪那么长。巳正时分的太阳并不似正午那般毒辣，然而张慎峰却早已汗流浃背。\n天香素问轩弟子在空中足足停留了二十息的功夫，来回巡视，都没有发现异常，这才缓缓下落，然后向在地上沉思的江云梦摇摇头，表示没人。而就在此时，某位“贴墙使者”也成功到达了墙角处，低声感慨一句：“最危险的时刻总算过去了。”随即深吸一口气，低下身，整个人如同一支利箭，向律令阁外通向真武殿的山路迅猛地射去。\n张慎峰想不到的是，就在他拔腿狂奔的一刹那，先前在院落正堂坐着的两名女子、律令执掌寒湘子和院落中先前抚琴的江云梦几乎同时睁开了双眼，锁定着张慎峰离去的方向，八道夺目精光向围墙射去，仿佛要穿透墙壁看到墙外。随即江云梦飞身而起，斜斜地飞向天空中，顷刻便已不见。\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch5/","tags":[],"title":"第五章 天籁"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"文件分配方式 简述连续分配、链接分配、索引分配方式的原理、主要优缺点。\n连续分配：\n优点：由于线性地占用磁盘上一组连续的物理块，因此寻道数和寻道时间最小。支持顺序访问和随机访问（特别地，连续分配的文件在顺序存储时读写时速度最快），实现简单； 缺点：文件长度不能动态增加，否则需要大量移动盘块；需要分配连续的存储空间，容易产生外部碎片，降低磁盘空间利用率。 链接分配（默认指的是隐式链接）：\n优点：不要求连续的存储空间，能更有效地利用磁盘空间，利于扩充文件；消除了外部碎片； 缺点：只适合顺序访问，访问时需要多次读磁盘，不适合随机访问，读取和存储效率低；链接指针占用了一定的空间；可靠性差（隐式链接可能存在断链问题）。 索引分配：\n优点：既支持顺序访问又支持随机访问，查找效率高；无外部碎片问题； 缺点：索引表会占用一部分存储空间。 ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/operating-system/file-manage/","tags":[],"title":"文件管理"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Reference [1] The linker’s warnings about executable stacks and segments\n[2] Hardened/GNU stack quickstart\n[3] Executable Stack\n[4] Nested Functions\n[5] Arm Gcc warning: Load segment with RWX permissions\n[6] Solution to LOAD segment with RWX permissions warning with CMSIS\nSummary 本文讨论 BFD 链接器中添加的一些新警告消息：它们的含义、重要性以及可以采取哪些措施来预防或压制它们。\n注意：这些警告目前特定于 BFD 链接器 (ld.bfd)，但类似的警告也可能会出现在 gold=、=lld 和 mold 链接器中。\nThe new warnings 链接器中添加了一些新的警告[1]。虽然新的警告通常不是问题，但这些警告很特殊，因为它们有可能在之前编译和链接没有任何问题的程序上触发。\n这些警告涵盖两个相关区域\n程序的堆栈 程序的代码和数据段 这两个区域都是攻击者的主要目标，如果他们可以将指令插入任一区域，那么他们就可以将它们用作接管程序的垫脚石。\n通常可以通过确保堆栈和数据段都不能包含代码并且代码段不能被修改来防止这种情况。新的警告是为了在这些安全条件不具备时提醒开发者。\n有时，拥有可执行堆栈或可写代码段是有充分理由的。程序加载器可能需要它才能使程序工作，或者编译器可能需要它才能实现程序的特定功能。但开发人员最好知道这种情况正在自己的程序上发生，并且这样的程序可能容易受到攻击，而不是生活在无知中。\nThe executable stack warnings 程序的堆栈用于记录有关函数调用的信息(如函数定义处、函数参数等)。它通常不应该包含自己的任何代码，因此它不应该具有可执行属性。\n当堆栈可执行时，链接器将生成以下警告消息之一：\nwarning: enabling an executable stack because of -z execstack command line option 此警告表明已通过链接器命令行选项 -z execstack 显式请求可执行堆栈，并且它只是作为提醒而存在 可以通过 –no-warn-exec-stack 命令行选项来抑制警告 审慎考虑为什么使用 -z execstack 选项。如果程序在没有它的情况下也能工作，那么最好根本不使用它。 warning: \u0026lt;file\u0026gt;: requires executable stack (because the .note.GNU-stack section is executable) 当编译器请求可执行堆栈时会生成这种警告 在某些情况下，编译器会决定它确实需要可执行堆栈，并且有一种机制可以告诉链接器这一点，参考[2]和[3] 编译器需要可执行堆栈的情况并不常见，消除警告的最佳方法是重新编写源代码，从而消除这种需要。 如消除嵌套函数等，标准C不支持嵌套，但GNU C支持嵌套函数，参考[4]；特别地，GNU C++不支持嵌套函数。 warning: \u0026lt;file\u0026gt;: missing .note.GNU-stack section implies executable stack 这是最严重的，因为程序在意想不到的情况下被赋予了可执行堆栈。 当程序与一个或多个未标记为需要或不需要可执行堆栈的目标文件链接时，就会发生这种情况 此类目标文件要么是从汇编程序源代码创建的，要么是由较旧的编译器创建的，这些编译器不知道用于向链接器传达堆栈要求的方法。 关于嵌套函数，这里举一个例子：\nextern int abandon(int (*)(int)); int bend (int arg1) { int cease (int arg2) { return arg2 * arg1; } return abandon (\u0026amp; cease) + arg1; } 这里的问题是，嵌套函数 cease() 无法在编译时创建，因为它使用了 bend() 的 arg1 参数，但它也必须存在，因为它的地址被传递给 abandon()~。因此编译器安排 ~cease() 在运行时在堆栈上构造。\n代码可以被重写为\nextern int abandon (int (*)(int)); static int saved_arg = 1; static int cease (int arg2) { return arg2 * saved_arg; } int bend (int arg1) { int res; int prev_saved_arg = saved_arg; saved_arg = arg1; res = abandon (\u0026amp; cease) + arg1; saved_arg = prev_saved_arg; return res; } 全局变量 saved_arg 用于调用 cease() 时保存 arg1 参数的值 修改 cease() 函数，不再捕获 bend() 的参数 arg1=，而是使用全局变量 =saved_arg 在 bend() 函数中保存与恢复 saved_arg 的值 需要注意的是：\n作用域 全局变量和函数默认是有外部链接的，意味着它们可以在程序的其他文件中被访问（如果有声明的话） 此处变量和函数使用 static 修饰是为了保持作用域，将变量或函数限制在单个源文件中，以避免名称冲突和保持封装性。 多线程 如果在多线程环境中使用重写后的代码，它会导致线程不安全。 The executable segment warnings 当加载到内存中时，程序通常被分成不同的段:\n代码段 数据段 其他段 用于各种特殊用途 这些段具有可读、可写和可执行等属性中的某一部分，如果它们同时具有这三个属性，那么它们很容易受到攻击。\n在这种情况下，链接器将产生以下警告之一：\nwarning: \u0026lt;file\u0026gt; has a LOAD segment with RWX permissions\n此警告表明存在一个或多个易受攻击的段 这些段可以通过 readelf -lW \u0026lt;file\u0026gt; 来找到 出现此警告的最常见原因是使用自定义链接描述文件进行链接，该链接描述文件不会将代码和数据分成不同的段，所以最好的解决办法就是更新脚本。 另一个潜在的原因是使用了 -z noseparate-code 链接器命令行选项。如果可以的话，这允许链接器组合代码和数据段。这确实会导致可执行文件变小，但也容易受到攻击。但是，除非程序大小确实很重要，否则不建议使用该选项。 warning: \u0026lt;file\u0026gt; has a TLS segment with execute permission\n这是 RWX 段警告的特殊形式。有些程序可以有一种特殊类型的数据段，称为 TLS（线程本地存储）段。这就像一个普通的数据段，只不过程序中的每个线程都有自己独立的副本。然而，与普通数据段一样，TLS 段永远不应该设置执行权限。 修复此警告可能很困难，因为它取决于线程代码试图实现的目标。不过，一般来说，该过程与修复有关编译器请求的可执行堆栈的警告相同：找到包含可执行 TLS 部分的目标文件，检查该文件的源代码并根据需要重写。 命令为 readelf -SW \u0026lt;file\u0026gt; | grep XT 在 LOAD segment with RWX permissions 问题中：\n在 readelf 的输出中，段的可执行标志标记为 E 而不是 X，因此查找 RWE 而不是 RWX。 显示的 readelf 命令将显示每个段包含哪些部分，因此应该可以计算出需要如何更新链接器映射，以便将代码部分与可写部分分开。通常这需要确保使用足够的对齐方式。 例如以下脚本：\nSECTIONS { .text : { *(.text) } .data : { *(.data) } } 很可能会触发警告，因为代码和数据彼此相邻放置。\n而以下脚本：\nSECTIONS { .text : { *(.text) } . = ALIGN (CONSTANT (COMMONPAGESIZE)); .data : { *(.data) } } 应该能防止出现警告，因为 ALIGN 指令会增加当前内存地址，使其成为所提供参数的倍数。这将确保 .text 和 .data 节之间至少有 COMMONPAGESIZE 字节的间隙，因此链接器将能够将这些节放置到不同的内存段中。\nEliminate the warnings Disabling the warnings 如有必要，可以通过链接器命令行选项禁用这些警告消息。\n使用 --no-warn-execstack 禁用有关创建可执行堆栈的警告 使用 --warn-execstack 重新启用警告 使用 --no-warn-rwx-segments 禁用有关可执行段的警告 使用 --warn-rwx-segments 重新启用警告 在CMake中有两种方法增加链接选项：\nset(CMAKE_EXE_LINKER_FLAGS \u0026quot;${CMAKE_EXE_LINKER_FLAGS} --no-warn-execstack --no-warn-rwx-segments\u0026quot;) add_link_options(-Wl,--no-warn-rwx-segments) 其中测试STM32构建时发现，后一种方法不会出错，前一种方法在构建时出错，因为它把链接选项传递给了 arm-none-eabi-gcc 而不是 arm-none-eabi-ld 。\n也可以在默认情况下禁用其中一个或两个选项的情况下重新编译和构建链接器。\n使用 --enable-warn-execstack=no 使用 --enable-warn-rwx-segments=no 最后，还可以编辑链接器源代码以根据目标配置设置这些警告的默认值。 ld/configure.tgt 文件开头有可用于此目的的代码。\nRewrite ld scripts 本节参考了[5]和[6]的解决方法。\n首先可以使用下面的命令查看构建的内存配置：\nreadelf -SW 1_KEYLED.elf readelf -lW 1_KEYLED.elf readelf -l 1_KEYLED.elf 检查链接脚本中每个段的权限配置，常见段的典型权限需求如下：\n.isr_vector 中断服务例程向量: 需要可读（R）权限，因为中断向量需要在程序运行时被CPU读取 不需要写（W）权限，因为在程序运行后中断向量表通常不会被修改 不需要执行（X）权限，因为中断向量表本身包含的是指针，而不是直接执行的代码 .text 程序代码: 需要可读（R）权限，因为包含程序的执行代码 不需要写（W）权限，因为执行代码在运行时不应被修改 需要执行（X）权限，因为这一段包含了要执行的机器代码 .rodata 只读数据: 需要可读（R）权限，因为包含了常量和只读数据 不需要写（W）权限，因为数据不应在运行时被改变 不需要执行（X）权限，因为它包含的是数据而不是代码 .preinit_array=、.init_array=、=.fini_array= 初始化和终止函数数组: 需要可读（R）权限，以便在程序启动和终止时访问这些函数指针 不需要写（W）权限，因为这些表在启动后通常不会修改 需要执行（X）权限，因为这些数组包含函数指针，这些函数将被调用 .data 初始化的全局变量和静态变量: 需要可读（R）权限和写（W）权限，因为变量在程序运行时会被读取和修改 不需要执行（X）权限，因为这里存储的是变量的值，不是要执行的代码 .bss 未初始化的全局变量和静态变量: 需要可读（R）权限和写（W）权限，因为变量在程序运行时会被读取和修改 不需要执行（X）权限，因为.bss段用于变量的存储，不包含可执行代码 总结各段的权限如下：\nsegment permission .isr_vector 4 .text 5 .rodata 4 .preinit_array 5 .init_array 5 .final_array 5 .data 6 .bss 6 在实际的链接器脚本中，可以通过在PHDRS子句中设置FLAGS来指定这些权限。\nPHDRS { ram PT_LOAD FLAGS(6); /* 可读可写 */ flash PT_LOAD FLAGS(5); /* 可读可执行 */ } 在修改时，需要注意：\n在各个段结尾加上对应的修饰 对于 \u0026gt;FLASH ，改为 \u0026gt;FLASH AT\u0026gt; FLASH : flash 对于 \u0026gt;RAM ，改为 \u0026gt;RAM AT\u0026gt; RAM : ram .data 段 它被配置为位于RAM中，但是它的初始内容来自FLASH（程序被烧录到FLASH后在启动时复制到RAM）这是典型的嵌入式系统配置，其中变量在启动时从非易失性存储（如FLASH）复制到易失性存储（如RAM）中 它的配置应该为 \u0026gt;RAM AT\u0026gt;FLASH:ram ","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/7-stm32-ld-segmentsissues/","tags":[],"title":"STM32 LD Segments \u0026 Issues"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"计算机系统概述 冯诺依曼结构是什么？\n冯提出了存储程序的概念，以该思想为基础的计算机称为冯诺依曼机。\n计算机硬件系统由运算器、存储器、控制器、输入设备、输出设备五部分构成； 指令和数据同等地存储在存储器中，并可按地址寻址； 指令和数据以二进制代码表示； 指令由操作码和地址码表示； 指令按顺序存放，按顺序执行； 以运算器为中心； 现代计算机组织结构与冯诺依曼机的区别\n以存储器为中心，IO操作绕过CPU，直接在IO设备和存储器之间完成；\n什么是MAR，MDR，MMU\nMAR是Memory Address Register，即地址寄存器，用于寻址，位数对应存储单元的位数。 MDR是Memory Data Register，即数据寄存器，位数等于存储字长。 MMU是Memory Management Unit，即内存管理单元，是CPU用来管理虚拟存储器、物理存储器的控制线路，同时将虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。 特别地，MAR和MDR逻辑上属于存储器，但在现代计算机结构中是存在于CPU中的。同样的还有高速缓存Cache。\nCPU如何区分数据和指令？\nCPU根据指令周期的不同阶段区分数据和指令。\n指令执行的过程？\n取指令\n根据指令地址（程序计数器PC提供）从存储器中取指令到指令寄存器IR\n分析指令\n对取出的指令进行译码分析，控制器根据指令的操作码生成相应的控制信号； 根据寻址方式将指令的地址码送MAR，送地址总线，控制单元CU读存储器，形成操作数的地址，取地址存至MDR； 执行指令\n根据操作码生成的相关控制信号和操作数的地址，通过运算器的算术逻辑单元ALU运算完成指令。\n低级语言与高级语言的概念，高级语言的优势？\n低级语言泛指机器语言和汇编语言，机器语言由01组成，直接对应CPU指令与内存位置；汇编语言用字母组合表示01组合，方便记忆； 高级语言对低级语言进行了封装与抽象，使它更接近我们平常的思维，需要由翻译程序（编译程序或解释程序）翻译成低级语言才能被计算机识别； 高级语言的优势：表达能力更强，可方便地表示数据的运算和程序的控制结构，能更好的描述算法，容易学习掌握； 数据的表示与运算 注：D代表十进制，B代表八进制，H代表十六进制。\n二进制如何转为八进制或十六进制？\n对于转八进制，将二进制数分为3位一组，最左边加0补齐，而后对每组二进制数分别用对应的八进制数替代。 对于转十六进制，将二进制数分为4位一组，同上。 任意进制如何转为十进制？\n使用按权展开相加法：将任意进制数的各位数码与它们的权值相乘，再把乘积相加；\n小数点前$n$位则乘以$k^n$，小数点后$n$位则乘以$k^{-n}$\n十进制如何转为任意进制？\n对整数部分，使用除基取余法，最高位在下，最低位在上； 对小数部分，使用乘基取整法，最高位在上，最低位在下； 特别地，不是每个十进制数都可以用二进制表示，但是每个二进制数都可以用十进制表示。\n字符编码ASCII码\n0-31和127是控制字符。32是空格，48-57是0-9，65-90是A-Z，97-122是a-z。\n海明码检错与纠错的关系\n两个合法编码对应比特取值不同的比特数称为海明距离。\n海明距离为$d+1$的编码能检测出d位差错。 因为在距离为$d+1$的检验码中，只改变d位的值，不可能产生另一个合法码。如奇偶校验码，海明距离为2，能查出单个错。\n海明距离为$2d+1$的编码，能纠正d位差错。 因为此时，如果一个码字有d位发生差错，它仍然距离原来的码字距离最近，可以直接恢复为该码。\n海明码校验原理\n设$n$是有效信息位数，$k$为检验信息位数，应满足$n+k \\leq 2^k-1$，若要检验两位错，则校验位需要增加一位。\n校验位$P_i$在海明位号为$2^{i-1}$上，其余各位为信息位。\n分组形成校验关系：被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。\n或者，用二进制通配符，海明位号依次能检验$1，1，1,\u0026hellip;$位上的数据。\n校验位的值等于由该校验位所检验的各数据位的值求异或。\n从高到低，每个校验位和参与形成该校验位的各数据位的异或，形成一列二进制数，若该数各位全0则代表无错。若某位为1说明该数据位有错，直接将该位取反。\n循环冗余校验码CRC\n首先已知信息码$k$位和生成多项式最高次幂为$r$； 移位，将原信息码向左移动$r$位，低位补0； 用该数对生成多项式的二进制数进行模2除法（即不借位），产生余数； 原信息码后附加上余数成为CRC码； 接收端对CRC码用生成多项式做模2除法，余数为0则无错，若某位为1说明该位出错，将该位取反。 原码，补码，反码\n浮点数标准化的目的？具体规则如何？\n统一进行表示有利于软件在不同环境上的移植。\n采用三元组（数符，阶码，尾数）表示浮点数； 一共有32位，其中数符1位，阶码8位，尾数23位； 阶码采用移码表示，实际为阶码减去偏移量$2^7-1$； 尾数采用原码表示，除非阶码全1或全0，否则尾数默认表示1以后的部分； 布尔运算\n与：全真则真，有假则假 或：有真则真，无真则假 非：取反 异或：相同则假，不同则真 或 同0异1 存储系统 DRAM和SRAM分别是什么？\nSRAM是静态随机存储器，存储元是双稳态触发器（六晶体管MOS），信息读出后不需要再生，存取快，集成低，功耗大，用于组成高速缓冲存储器； DRAM是动态随机存储器，存储元是一个晶体管，利用存储元电路中栅极电容上的电荷存储信息，电荷只能维持2ms，需要不断地刷新。密度更高，采用地址复用技术，容易集成，容量大，功耗低，但是存取比SRAM慢，用于组成大容量主存系统； 类型 SRAM DRAM 存储信息 双稳态触发器 栅极电容 破坏性读出 否 是 刷新或再生 否 是 送行列地址 同时送 分两次送 运行速度 快 慢 集成度 低 高 功耗 大 小 成本 高 低 用途 高速缓冲存储 主存内存 DRAM的三种刷新方式是什么？\n集中刷新，分散刷新，异步刷新；\n集中刷新：在一个刷新时间内利用固定的刷新时间对存储器所有行集中进行逐一再生，此时称为死时间，无法读写； 分散刷新：对每行的刷新分散到各个工作周期中，存储器工作周期因此分成两部分，前半部分用于正常读写或保持，后半部分用于刷新某一行； 异步刷新：异步刷新是前两种方法的结合，刷新周期除以行数，得到两次刷新的间隔t，在此间隔时间内对各行依次刷新一遍； Cache和主存的映射方式有哪些？\n直接映射\n主存中的每一个块只能装入Cache的唯一位置，冲突时原来的块会被无条件替换出去。 $$\rj=i \\ mod \\ 2^c\r$$ 其中，$j$是Cache的块号，$i$是主存的块号，$2^c$是Cache中的总块数。\n全相联映射\n主存中的每一块可以装入Cache中的任何位置。每行具有标记，用于指出该行取自主存的哪一块。 $$\rj=i\\ mod \\ 1\r$$ 组相联映射\nCache空间分为大小相同的组，主存上的一个块可以装入一个组内的任意位置。即组内直接映射，组外全相联映射。 $$\rj=i\\ mod \\ Q\r$$ 其中$Q \\in[1,Cache]$，Cache中的块从0开始计算。\n指令系统 CISC和RISC是什么？区别是什么？\nCISC是复杂指令系统计算机，如X86。主要特点：指令系统复杂庞大，指令长度不定，访存指令无限制，各种指令使用频率相差很大，执行时间相差也很大，控制器采用微程序控制，难以优化编译生成高效的目标代码程序； RISC是精简指令计算机，如ARM，MIPS。主要特点：指令系统简单，复杂指令由简单指令组合实现，指令长度固定，仅Load/Store指令访存，CPU中通用寄存器数量相当多，大部分指令在一个周期完成，以硬布线为主，特别重视编译优化工作，减少程序执行时间； 类型 CISC RISC 指令系统 复杂 简单 指令数目 多 少 指令字长 不定长 定长 可访存指令 无限制 仅Load/Store指令 指令执行时间 相差较大 多在一个周期 指令使用频度 相差较大 常用 通用寄存器 少 多 目标代码 难以优化 优化、高效 控制方式 微程序 组合逻辑、硬布线 指令流水线 可以实现 必须实现 兼容性 可兼容 难以兼容 运算速度 更慢 更快 成本 更高 更低 可靠性 更低 更高 XXX\n中央处理器 指令流水线有哪些冲突？如何克服它们？\n有结构相关、数据相关、控制相关三种冲突；\n结构相关（资源相关）：流水线中多条指令在同一时钟周期内争用同一功能部件的现象，即因硬件资源满足不了指令重叠执行的要求而发生的冲突；\n解决办法：令流水线在完成前一条指令对数据的存储器访问时访问暂停取后一条指令；\n数据相关：如某程序下一条指令会用到上一条指令计算的结果，称这两条指令为数据冒险；当各指令重叠操作可能改变对操作数的读写访问顺序从而导致数据相关冲突；\n解决办法：\n在前一条指令遇到数据相关时停顿后一条指令的执行； 设置相关专用通路，即数据旁路技术； 用编译器进行编译优化，调整指令顺序； 控制相关：执行转移、调用或返回等指令的时候改变程序计数器的值，从而造成断流；\n解决办法：\n对转移指令进行分支预测，尽早生成转移目标地址； 预取转移成功和不成功两个控制流方向上的目标指令； 加快和提前形成条件码； 提高转移方向的猜准率； 总线 数据线，控制信号线，地址线的数目分别有什么作用？\n数据线的总数决定计算机的存储字长，地址线的数目决定计算机的存储单元个数，控制线的数目决定计算机能够发出信号的种类数目；\n总线带宽的决定因素是什么？\n总线带宽(Bps)=总线工作频率(Hz)×总线宽度(B)\n总线带宽(bps)=总线工作频率(Hz)×总线宽度(bit)\n输入输出系统 什么是中断？中断有什么作用？\n中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，转而对异常情况或特殊请求进行处理。\n中断的作用：\nCPU与IO设备并行工作； 处理硬件故障和软件错误； 实现人机交互，用户干预； 实现多道程序、分时操作； 实时处理系统需要中断才能快速响应； 应用程序和操作系统之间的切换需要（管态与目态）； 多处理器系统中各处理器之间协作需要； 中断处理流程是怎样的？\ngraph TD\rA((1.关中断))--\u003eB[2.保存断点]\rB--\u003eC[3.引出中断服务程序]\rC--\u003eD[4.保存现场和屏蔽字]\rD--\u003eE((5.开中断))\rE--\u003eF[6.执行中断服务程序]\rF--\u003eG((7.关中断))\rG--\u003eH[8.恢复现场和屏蔽字]\rH--\u003eI((9.开中断))\rI--\u003eJ[中断返回]\r其中，1-3由中断隐指令完成，4-9由中断服务程序完成。\n中断控制器的功能\n中断源的识别 中断源的屏蔽 中断优先级处理 什么是单中断，什么是多重中断？\n在CPU执行中断服务程序的过程中，出现了新的中断请求，此时：\n对新的中断请求不予响应，则称为单中断； 转而处理新的中断请求，则称为多重中断； 两者的区别在于“开中断”的时间不同，单中断的“开中断”时间在最后的中断返回之前，而多重中断的“开中断\u0026quot;时间在“保存现场与屏蔽字”之后。\nXXX\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/computercomponents/","tags":[],"title":"组成原理"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　看着自己两侧的景色飞速向身后移动，张慎峰那颗急速跳动的心逐渐安定下来。不得不说，刚才绝对是他平生所遇到的最危险的境况了。若是稍有不慎，行为出错，很可能就被发现，进而被当作整个门派的反面典型在律令阁受罚思过。\n自己一个表面上看起来普通至极的真武第三代弟子，即使因“偷窥”受罚也不是什么大问题，然而自己被发现后，肯定会将今日曾有数十名弟子作“梁上君子”的事情和盘托出。寒湘子稍加查证，很容易就能证实他们的行为。之后，不论是来自天香门派的压力还是真武本派森严的门规都不会轻易放过他们。而在真武惩戒这些江湖各派的弟子又势必会引发其他江湖门派的不满，可以预见，果真如此，一场江湖上的腥风血雨就会来临。\n既然如此，那么张慎峰从律令阁悄无声息的溜走就并不仅仅是单纯的劫后余生了，而是附带了保存本门派传承的有生力量以及遏制一场江湖风波，使得本门和平发展的“伟大任务”以及“崇高使命”。此刻，某位圆满地完成了“任务”和“使命”的真武“功臣”自顾自地笑道：“幸亏我在关键时刻能保持举重若轻，灵活机变，镇定自若；同时不落窠臼，闪转腾挪，行之有效地脱离是非之地。否则，恐怕真武将不复真武，江湖将不复江湖矣。如此完美的处理，即使谓之当今豪杰，恐怕也绝非谬赞！”\n说着，某“豪杰”摇摇头，轻笑两声，逐渐放慢了自己前进的步子。此时张慎峰所在地已经是律令阁与真武殿的中点了，此处周遭林中鸟儿欢快鸣叫，泉水叮咚流淌，山中清风徐徐，一切尽皆如故，完全没必要亡命似地继续奔逃。若是再一路狂奔，反而会失之稳重，若是被真武殿的值守的二代弟子拦住，免不了又是一顿训斥。\n真武讲求的是行事稳重，时时刻刻都要保持沉心静意，不动如山。真武祖师张梦白在江湖中叱咤风云的时候，曾著数本心法。其中他最为推崇的一本，至刚至柔，灵活多变的代表，《啸天•镇岳》，详细论述了清、勤、慎、稳这四点：\n清：淡泊名利、清心寡欲；一介不苟、鬼伏神钦；\n勤：手眼俱到、死而后已；困知勉行、日以继夜；\n慎：深谋远虑、未雨绸缪；行有不得、投求诸己；\n稳：秉节持重、练达老成；从容自如、厚重少文。\n在这四点中，张梦白对慎和稳这两点最为欣赏，并以此要求门中弟子，平常行事必须时时刻刻胸有成竹，行事稳重，切不可六神无主，慌乱失度。真武殿作为真武派最宏大最气派也是最严肃最庄穆的建筑，更是严格要求座下弟子。若有真武弟子在真武殿疯闹嬉戏，追逐奔跑，周边值守的弟子即刻将其控制，严加训诫，并移送律令阁，思过静修。这也就是张慎峰接近真武殿后，逐渐放慢了脚步的原因。\n张慎峰一面向前继续行走，一面继续沉思自己今天才开始习练的功法：《紫霞功》。原先，他计划在太极道场中对这门神秘的功法加以练习，然而事与愿违，跳出来一个燕书磐与他争抢位置；后来他想在律令阁听寒湘子讲经论道，碰碰运气，看看是否有机会扩宽对功法修炼的认识。没想到，八荒门派正好在今日来此；没想到，今日天香姑娘们竟会齐聚律令阁。如此际遇，对张慎峰来说，虽然皆历历在目，但总是恍如黄粱一梦般，感觉不真实，不真切。\n既然自己的根本目的想要继续修炼这门神秘功法，然而又不想再生波折，那么不断地花时间寻找地点显然是不明智的。目前整个江湖皆是风起云涌，身处乱世，虽有门派庇护，始终不是上上之策，必须能有一技傍身。而此刻，《紫霞功》就是张慎峰最大的依仗，他必须尽快熟练的掌握这门功法，最好是将其练至大成。不若跳出象牙塔，径直寻觅一处无人的密林，仔细体会这所谓的上古功法的奥妙，岂不美哉？张慎峰打定主意，便从山路上离开，沿山峰而上，一头扎入密林之中，找寻着合适的练功地点。\n日光上移，密林中光影交错，在密林中投下斑斑点点的光影。然而，在密林中向山顶前进还没两柱香（作者注：一柱香为五分钟）的功夫，张慎峰突然感到一阵隐隐的不安，似乎，前方并不太正常？\n难道是自己今天出门没看黄历？张慎峰脸色有点发苦。俗话说，事不过三。今天已经发生了两次意外，第一次是点背与同门中人起了冲突，第二次是偶然遭遇了其他江湖派的二代弟子，现在他从密林往山顶上行走完全是临时决定，难道这也能出什么意外？张慎峰心中忖度着，这里人迹罕至，自己身份又普通之极，难不成还会有人埋伏他么？埋伏的意义何在呢？\n寻仇？自己与同门之间还没有过那么大的矛盾；寻财？一个普通的三代弟子能有什么财富可言？此处是真武山的腹地，既无宝物，又无美色，无物可掳，不过是空耗时间。虽说如今赶上八荒集会于真武，目前山上江湖人士肯定比之往日要多，但不管怎么说，都不会有人和他这样一个名不见经传的弟子起冲突吧？\n难道其实不是埋伏，而是师尊来此？很快，这种想法也被张慎峰所否决。因为越往前走，张慎峰内心就越是有一股压抑不住的警兆，就像一座火山，随时都有可能爆发一般，又如一块大石，压在张慎峰的心口，使他喘不过气来。终于，张慎峰决定在一处树木开阔的地方站定脚步，原地放出神识，仔仔细细地向前寻觅。看看是否真的有什么危机。\n可是，在神识连番搜索之下，得到的结果竟然是周边一切正常，没有任何有价值的线索。眼前的树木和身后的密林皆是一般，泛着自然而清新的空气，树枝随风摇曳，象征着它旺盛的生命力。若是非要说有什么区别的话，唯一的区别就是树木中既无虫鸣，亦无鸟叫，给人一种与世隔绝的感觉。\n与世隔绝？张慎峰的额头上一道冷汗划过，猛然回头，就要拔腿狂奔。突然一道人影自他身后出现。就像吃了一颗定身丸一般，刚刚还准备撒腿就跑的张慎峰停住了脚。\n“是刚才律令阁中抚琴的那位姑娘。”张慎峰的内心急速的思考着，“她发现了房顶上我的存在，并且一路跟到了这里。或者说，是把我截在了这里，更为贴切。”\n“此地荒凉，少有人迹，然而却已经比较开阔，树木稀少。我若是逃跑，势必难以躲藏。而且，进一步想，既然这位姑娘能悄无声息地跟踪到此，并将我截住，其武功修为必然远在我之上。逃跑只是徒劳，甚至会引发对方更大的怒火。”张慎峰继续思考着。\n“你来了。”江云梦看着张慎峰，轻轻地说道。衣裙无风自动，一股宏大的精神力如湖水一般渐次覆盖了这方圆五丈的所有空间。这一刻，地上的草与树，尽皆随着这股力量摇曳。\n真是夜路走多了碰到了鬼，可现在还是光天化日，朗朗乾坤啊！张慎峰内心直叹气，没想到这位演奏琴曲的姑娘精神力竟然如此惊人！若说她早就发现自己的话，那么，在那几位天香的姑娘飞鹤冲天之时，她只需出言提醒，自己肯定早已被拿下，根本不可能离去；自己必然是在墙角处向外狂奔的瞬间才被她发现的。隔墙亦能有如此强大的感知，岂不令人悚然！果然是山外有山，人外有人！张慎峰看起来面色如常，心中却已经激起了惊涛骇浪。\n“是的，我来了。”张慎峰此刻显得有些恍惚，倒不是被姑娘的漂亮迷乱了心智，而是张慎峰知道，他们两个此刻的问答虽然如同老友寒暄，但这不过是暴风雨前的宁静罢了。这位姑娘如此问话，是在营造一种一切尽皆在她掌控之下的气氛。俗话说，攻城为下，攻心为上。若是一般人，乍听此言，甚至可能会在心中炸起惊雷，牵一发而动全身，随即便会觉得自己全无秘密可言，进而心神失守，失魂落魄，交待行迹。\n但张慎峰并非等闲之辈，事情发展到这个地步，他心里也并不十分痛快：天香来此交流武学，以及在律令阁集会弹奏，这些自己事先并不知情，在房顶之上聆曲，实属无故冒犯，罪减一等；何况，自己是受他人胁迫，于房顶之上聆曲并非他之本意，罪应再减一等；再者，有缘听闻如此琴曲，难道欣赏也能算错么？欣赏琴曲何罪之有？想到这里，张慎峰浑身一震，一股磅礴的浩然正气涌出，正是以新习得的紫霞功与江云梦外露的精神力相抗衡。\n“房顶上的景色，好看么？”江云梦的脸上古井不波，对张慎峰身上涌出的这股浩然正气恍若未觉，只是自顾自地问道。\n“仙子误会了。在下虽然刚才确实居于房顶之上，但并不是前来欣赏风景的。”张慎峰在江云梦强劲的精神力的压迫下，激发出强烈的求生欲，身上的浩然正气如波涛般汹涌而出，将江云梦散发的精神力全部阻住。\n“不是？那你来干什么？”\n“自然是听仙子抚琴。”张慎峰手捻道指，向前鞠了一躬，而后朗声说道，“古有柳宗元‘隔篁竹，闻水声，如鸣佩环，心乐之’，君子知有美景存于世，尚且要‘伐竹取道’，前往一观；我等道士，虽不如君子般贤明，但也见贤思齐，难不成只能终日在殿中修习经文，或于炉前学习炼丹；虽逢良辰而不能往，虽遇琴曲而不能赏？仙子所奏琴曲精妙无穷，所谓‘清润玉箫闲久，天籁稀有。’我居真武已久，难得能在律令阁听到如此琴曲，若不前去细细品味，徒留房中沉思，岂不令心有所惋，腕有所扼？仙子不分青红皂白，申斥于我，只质问房顶景色怎样，直以为我是垂涎美色，一饱眼福，却不知我本意乃是为琴曲而来，更不知我曾听得琴曲几何。岂不闻‘十室之邑，必有忠信。’‘门内有君子，门外君子至。’？若是仙子欺负我真武山峦之中没有听琴之人，那么这夏日时分，律令阁内也不该有抚琴之客了。”\n见江云梦沉默不语，张慎峰趁热打铁，再度说道：“在下知似仙子这般心灵手巧，才貌双绝的姑娘，世间可谓百不存一，凤毛麟角；而姑娘的琴曲更是引入入胜，似有感天动地之能。我若贸然叩门而入，即打断了旋律，破坏了意境，实在不美；然而隔墙聆听，总觉得有音无韵，五律失魂，令人心痒难捺。考虑再三，在下才决定不打扰仙子清修，而是于房顶之上静观。让仙子误会，以至于斯，实在抱歉。若仙子执意认为在下乃好色之徒，于房梁之上乃是意图不轨、行为乖张，大可向律令执掌寒湘子具告之。在下行不更名，坐不改姓。真武门规森严，某自会受到惩戒。”说完，张慎峰将浑身的浩然正气渐渐回收于体表，不再外放，任由江云梦的那股精神力压迫而来，以示坦荡。\n张慎峰的一番言语，有理有据，江云梦一开始兴师问罪般沛然的气势陡然下降三分。而后一番慷慨陈词，义正辞严；最后气势回收，表现出一副问心无愧的模样，对江云梦放出的精神力不躲不避，更是显露出其“君子风范”。这下轮到江云梦犯起了嘀咕，难道是自己多想了？\n“既然是慕声而来，刚才不分青红皂白责斥师兄，是我唐突，师兄莫要放在心上。”江云梦一念至此，大大方方地说道，“适才师兄所说，‘清润玉箫闲久，天籁稀有’，想来师兄应是熟知音律之人。俗话说，闻弦歌而知雅意，不知师兄对我所奏之曲，有何体会，可否品评一二？稍后我向师兄赔罪。”\n有门！只要讲理那就好办，怕就怕秀才遇到兵，有“理”说不清。张慎峰心中暗自想道，同时对这位天香姑娘赞叹不已。一是赞叹她能听出自己以“天籁稀有”隐喻“知音稀有”，并以闻弦歌而知雅意作答，必是自幼便受书香熏陶，琴棋书画样样俱精也未可知。而能够有如此修养的同时武功进境亦是远在自己之上，实在平生仅见；二是赞叹她说的话水平极高，滴水不漏：若自己是慕声而来，那么自然会对琴曲有所体会，能够讲出个所以然来，但倘若自己是窥色而来，那么恐怕整个过程自己就一直盯着人家姑娘看了，至于弹奏的是什么，肯定是全然不知。这便是稍后赔罪的巧妙之处：若真是精通乐理，正人君子，那当然是要赔罪的；但若是附庸风雅，巧言令色，骨子里其实是好色之徒，那么赔罪是别想了，考虑考虑如何被狠狠教训一顿才比较现实。\n“既如此，我便试着说上一说，如有不妥之处，还望仙子恕罪。”张慎峰沉吟道，“仙子所奏琴曲，变化非常。总体上来说分为五个阶段，琴声首先婉转，舒缓，柔美，就像嫩芽在开枝散叶，换言之，琴曲开篇乃属蓄势；而后，琴声如渠水汇聚成为小溪一般，此一段就像人在少年之时一般，对未来满是美好的憧憬，无忧无虑；随着蓄势逐渐完成，琴声逐渐激荡昂扬，就像是少年逐渐长大成为青年，品尝世间的各种酸甜苦辣，所以才会起起落落，起伏越来越大，琴声变为悠悠荡荡……”\n“悠长是因为人从青年逐渐到了中年，历经世间的沧桑，觉得世间百态已然体会尽了，而急促则是因为人的时日无多，时间更加珍贵。便是在这急促与悠长的切换间，引得在下心神震荡，觉得人生仿佛正如‘寄蜉蝣于天地，渺沧海之一粟。’一般渺小而可悲，然后又生出‘哀吾生之须臾，羡长江之无穷。’的感慨，这才踩塌瓦片，至此，琴声戛然而止；但我知道其实后面还应有一段，那就是人生逐渐从中年到老年，在生命的尽头之前，琴声悠然而不停止，琴声抑制而不得放开……这首曲子，奏尽人的一生，我以为，曲之意，意在红尘。然而，仙子所奏之曲，虽有囊括红尘之意，却只有独取其中一人之心，如此反常的落差，令人觉得奇怪，似是曲中败笔。不过，仙子另辟蹊径的尝试确实令人很有启发，正所谓：弱水三千，我只取一瓢饮——”\n说到这里，张慎峰戛然而止，面色古怪之极，自己都被自己吓了一跳。难道说，面前这位美若天仙的天香姑娘，其实已经有心上人了吗？\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch7/","tags":[],"title":"第七章 待修改"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"栈的基本操作如下：\nbool InitStack(LinkStack \u0026amp;L); bool IsEmpty(LinkStack L); bool Push(LinkStack \u0026amp;L, ElemType x); bool Pop(LinkStack \u0026amp;L, ElemType \u0026amp;x); bool GetTop(LinkStack L, ElemType \u0026amp;x); bool DestroyStstack(LinkStack \u0026amp;L); 顺序栈 栈的顺序存储类型：\n#define MaxSize 50 typedef struct{ ElemType data[MaxSize]; int top; }SqStack; 初始化：\nbool InitStack(SqStack S){ S.top=-1; return true; } 判断栈空：\nbool IsEmpty(SqStack S){ if(S.top==-1) return true; else return false; } 元素进栈：\nbool Push(SqStack \u0026amp;S,ElemType x){ if(S.top==MaxSize-1) return false; S.data[++S.top]=x; return true; } 元素出栈：\nbool Pop(SqStack \u0026amp;S,ElemType \u0026amp;x){ if(S.top==-1) return false; x=S.data[S.top--]; return true; } 读栈顶元素：\nbool GetTop(SqStack S,ElemType \u0026amp;x){ if(S.top==-1) return false; x=S.data[top]; return true; } 链式栈 栈的链式存储结构为：\ntypedef struct LinkNode{ ElemType data; struct LinkNode *next; } LinkNode, *LinkStack; 注意，栈推荐不带头结点。\n初始化：\nbool InitStack(LinkStack \u0026amp;L){ L = NULL; return true; } 判断栈空：\nbool IsEmpty(LinkStack L){ return L == NULL; } 元素进栈：\nbool Push(LinkStack \u0026amp;L, ElemType x){ LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode)); if (s == NULL) return false; s-\u0026gt;next = L; s-\u0026gt;data = x; L = s; //注意体会写法 // 上两行代码对栈是否为空效果相同 return true; } 元素出栈：\nbool Pop(LinkStack \u0026amp;L, ElemType \u0026amp;x){ if (L == NULL) return false; //无结点可出 LinkNode *s = L; x = s-\u0026gt;data; //栈顶元素出栈 L = L-\u0026gt;next; free(s); return true; } 读栈顶元素：\nbool GetTop(LinkStack L, ElemType \u0026amp;x){ if (L == NULL) return false; else { x = L-\u0026gt;data; return true; } } 销毁栈：\nbool DestroyStstack(LinkStack \u0026amp;L) { if (L == NULL) return true; LinkNode *p = L-\u0026gt;next, *q = L; while (p != NULL) { free(q); q = p; p = p-\u0026gt;next; } free(q); //此时q指向尾结点 return true; } ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/stack-operation/","tags":[],"title":"栈基本操作"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"","permalink":"https://endlesspeak.github.io/docs/docs/stm32-doc/8-stm32-rust-develop/","tags":[],"title":"STM32 Rust Develop"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Crate crate 是 Rust 代码编译单元，它可以是库或者二进制\n二进制 crate 生成一个可执行文件 库 crate 可以被其他程序调用，但不能独自执行 Package 包对应一个项目/代码仓库，它可以包含一个或多个 crate\n主 crate 是项目的入口点 如果项目的目的是构建一个可执行文件，则用户编写的二进制 crate 是主 crate 如果项目的目的是供其他 crate 使用，则用户编写的库 crate 是主 crate 辅助 crate 或依赖 crate，用于给主 crate 提供功能 ","permalink":"https://endlesspeak.github.io/docs/docs/rust-programming-basic-doc/8-package-and-crate/","tags":[],"title":"Package And Crate"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"发行版 Linux分为哪些发行版？具体而言有什么区别？\n概括地讲，Linux的发行版本可以大体分为两类\n商业公司维护的发行版本，如Redhat Enterprise Linux 社区组织维护的发行版本，如Debian 主流分支包括以下部分\nDebian\nDebian分为三个版本分支 stable, testing 和 unstable。\nDebian最具特色的是apt-get / dpkg包管理方式。\nUbuntu\nUbuntu是基于Debian的unstable版本加强而来。\nDebian\nDebian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。\nDeepin\nDeepin基于Qt/C++（用于前端）和Go（用于后端）。\nLinux Mint\nSlackWare\n坚持KISS（Keep It Simple Stupid）的原则。该发行版的软件包都是通常的tgz(tar/gzip)格式文件再加上安装脚本。\nSUSE Linux Vector Linux RedHat\nCent OS（停止支持） Fedora Red Hat Enterprise Linux Oracle Linux Red Flag Arch Linux/Gentoo\nLinux发行版的区别在哪里？\n配置文件不同，不同的发行版具有不同的配置文件结构 包管理器不同，处理依赖的方式不同 软件源/软件仓库不同 常用命令 你在使用Linux的过程中分别使用过哪些命令？\n文件管理 cat 查看文件内容\ncat [文件名] chgrp 用于变更文件或目录的所属群组\nchgrp [参数] [群组] [文件名] chgrp -v lee test.txt #将test.txt的用户组更改为lee chgrp --reference=test.log test.txt #根据test.log的用户组更改test.txt的用户组 chmod 控制用户对文件的权限\nchmod [+-=] [参数] [文件名] chmod 775 test.txt chmod +x test chown\nchown [参数] 用户[用户组][文件名] chown root test.txt chown root:root test.txt diff\ndiff [文件名1] [文件名2] find\nfind [路径] [参数] [模式] -size n ：文件大小 是 n 单位。 -pid n： process id 是 n 的文件。 -type c：文件类型是 c 的文件。 -ctime n -mtime n -atime n 符号 文件类型 d 目录 c 字符装置文件 b 区块装置文件 p 具名贮列 f 一般文件 l 符号链接文件 s socket文件 find . -name \u0026quot;*.c\u0026quot; find . -type f find . -ctime 20 find /var/log -type f -mtime +7 -ok rm {} \\; less\nmv\ncp\nawk\n文档编辑 fgrep rgrep 磁盘管理 cd df du ls pwd mount tree 磁盘维护 fdisk mkfs.ext4 mkfs.fat mkswap 网络通讯 ping ifconfig netstat arp 系统管理 date kill who ps sudo uname chsh 压缩命令 tar gzip ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/interview-brief/linuxpoints/","tags":[],"title":"Linux Basic"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　江云梦并不知道张慎峰的内心在想些什么，之前她听着张慎峰这篇关于琴曲的评点，觉得相当满意，甚至自己有些未表达的内容都被张慎峰说了出来，此际正听得连连点头。然而突然，张慎峰就像一下子被掐住喉咙一般停止了说话，她觉得非常奇怪，于是出言相询，然而张慎峰仍旧毫无反应，目光低垂，眉毛紧撇，如同老僧入定般沉思。\n张慎峰此时的心中是既惋惜又懊恼。惋惜是因为面前这位姑娘十七八岁的年龄，正是如花般绚丽绽放，如花般娇艳欲滴的时候，然而操蛋的是，根据琴曲自己却推断出她似乎已然芳心暗许的结论，焉能不惋惜？\n至于懊恼，那就更属该然了。自己强提所有的精神力，冥思苦想才表现出张弛有度，文质彬彬，才华出众的形象；更兼心性坚韧，石赤不夺的优良品质，并以音律修养，展现自己任心猜度，闻而知之的能力，整个过程可以说是超高水平发挥，结果最后口干舌燥，却是竹篮打水，焉能不懊恼？\n终于，张慎峰回过神来。令他惊讶的是，此刻天地已经被一阵呜咽的箫声笼罩。眼前这位漂亮的天香姑娘不知何时已然倚着一颗古松，手中举着一杆玉箫，正在专注地吹奏。玉箫白里透蓝，蓝里泛着黛青的色彩，姑娘的脸白里透红，红中泛着润泽的光。耳边的箫声若以苏子的《赤壁赋》来形容，其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。箫声若虚若幻，含蓄深沉。\n也许别人的箫声是诉不完的衷肠，说不完的爱恋，而江云梦的箫声则更像是在讲述，讲述人各有异，生死轮回各安天命，看似冷漠般地一切顺遂自然，实则将那份无可奈何花落去渲染地入木三分。\n箫声的彼端，就像在揪着形形色色的人向前奔跑，有些人在起点没跑几步便已叹着气放弃，而有些人则一路勇往直前，然而无论是否向前，他们都一样经历春夏秋冬，如同花朵在凋谢之后，无奈地抛下身后的绿叶，如同果实在成熟之后，从枝条般的缠绕中落下，最终都入了轮回之中；又像是一滴滴水珠自天上滴落，落在广袤的大地上，有些水珠落入了清渠、落入了河流、落入了湖泊、落入了海洋、落入了温暖的水流的怀抱，而有些水珠，则落入了荒山，落入了乱石，落入了沙漠，落入了无尽的黑暗之中，水珠们自落下的一刻起，逐渐飘远，逐渐陌路。\n箫声，幽幽的箫声，轻柔而涓细，好似香炉中飘来的袅袅婷婷的烟，仿佛一片风就能将它剪断；箫声，呜呜的箫声，悠扬而飘渺，洇过雾的洁白，濯过水的清纯，仿佛来自琼霄碧落的仙曲。在这片日光被遮挡的密林里，箫声，夹着冰泉之气，忽如海浪层层推进，忽如雪花阵阵纷飞，忽如峡谷旋风急剧而上，忽如深夜银河静静流淌……\n日光斜照在山外的云海上，折射出一片金光，一望无垠；云朵们像是脚下生风，开始在空中翩翩起舞；四下里一片静谧。这片天地纳入张云峰眼中，便如同纳天地入芥子，渺沧海之一粟，让他在感到自身渺小的同时心生敬畏。\n张慎峰听得出来，这首曲子是他在拜入真武门墙之前，在襄州城外的镇集之中，时常听江湖艺人吹奏的那首《千人千面》，然而江湖艺人吹奏总是多有残缺，此时此刻，这首曲子被玉箫吹奏出来，张慎峰再一次感到恍惚。这是张慎峰今夜第二次因为曲乐而恍惚。\n箫声依旧，而自己已经不再单纯，世俗的弱肉强食，世事的磨练，门派中的尔虞我诈，显得如此的浅薄与无趣。是否前世与今生是一个循环，或者，轮回？否则自己为何又回想起了以前未拜入真武的那些摸爬滚打的日子？想起自己在城野捕猎，在市集里叫卖，在陈家帮忙的日子，最终拜入真武门墙，这个既熟悉又觉得陌生的地方；遇到的站在面前美若天仙的女子，吹奏着自己耳熟能详而又感到恍若新生的曲子，这一切，如梦一般飘过张慎峰的脑海；这一切，像一只温暖的手，拂过张慎峰的脸颊……\n箫声，戛然而止，顺带着张慎峰刚才想到的一切，都戛然而止。\n江云梦收起玉箫，发现张慎峰木然而立，两眼之中竟已泛着泪光。虽然箫声已止，但张慎峰的思绪还在渐渐飘飞。冠玉般的面容上两道剑眉斜斜地向摇曳的头发延展，朗星般的目光不住地闪动着思索的光芒。\n看着他这副模样，江云梦脸上露出了笑意，面前的这位师兄果然在音律方面远超常人，否则岂会由曲而痴？其实早在刚才，听闻这位师兄讲出自己琴曲的奥妙，她便已然生出欣赏之意，否则后面也就不会再度吹奏一曲。同时，看到自己吹奏的曲子能让他人感染至此，她感到很满足。平素里自己在天香谷时常吹奏这首曲子，姐妹们虽然也拍手称赞此曲精妙绝伦，却不知道曲子真正要表达的究竟是什么。\n终于，一片树叶摇曳声中，张慎峰恍然大悟一般回过神来，大声说道：“我明白了，我明白了！”\n江云梦偏头看着他，等待着后话。只听得张慎峰激动的说：“这前后两首曲子，一首琴曲，一首箫曲，仙子都悄然倾注了自己的灵魂，我一开始以为演奏的是只是普通的曲，然而仔细品味之后我发现，它们实际上并不是曲。”\n“不是曲，是什么？”江云梦问道。\n“是你，是仙子你自己。我本来以为演奏的是人，红尘中某一个人，正如在下刚才说的，‘弱水三千，只取一瓢饮’。后来我发现，曲子虽然不是仙子所谱，却随仙子所变化，万般皆在仙子心中；虽然每一个聆听仙子所奏曲子的人，都会因为自己的人生不同而有所感悟，有所体会，但是实际上，仙子演奏的这两首曲子都是仙子自己。”张慎峰大声说道。\n“若是我所料不错，仙子性格如云如梦，弹奏的琴曲和吹奏的箫声，是天边飘散不定的云海，是夜色里美好纯真的梦境，是恍惚而真切的现实，是扑朔而莫测的虚幻，是‘疏影横斜水轻浅，暗香浮动月黄昏。’”\n“你，你知道我叫云梦？”江云梦一双如水般的眸子悄然睁大，里面写着的满是疑惑和惊讶。\n“我可没这么说，这可是你自己说的。”张慎峰心里无声装下一个逼，表面却是不动声色的朗声道：“在下不过是根据曲中的变化，妄加猜度而已，言辞虚妄无迹，还望仙子见谅。”当然了，这里是在不着痕迹地坑蒙拐骗。因为之前在房顶上作梁上君子，看着这些姑娘们互相嬉戏打闹的时候，就听见了她们之间互相的称呼，知道了姑娘的姓名。戏法人人会变，各自巧妙不同，也许有人觉得如此忽悠实在不妥，然而其实若是以琴曲为引，用曲作掩，娓娓道来，更显得自然与高深。\n“你，你……”江云梦被张慎峰这番推断闪的不轻，然而张慎峰的“高光”时刻尚未停止，只听他继续道，“在下所知道的并不止于此，若是我所料不错，仙子的师尊，便是此次带队前来真武交流武学的天香长老，而且今番在律令阁演奏，实际上是仙子的师尊有意与我派律令执掌寒湘子交好，准备将自己的亲传弟子，也就是仙子你，许配给律令执掌的亲传弟子。”张慎峰一字字地道。同时，仔细盯视着江云梦脸上的表情，不放过任何一个变化。\n江云梦没料到这家伙话题转变居然这么迅速，一瞬间就羞红了脸。旋即她便想到，自己门派与真武之间的密谈，目前尚未公之于众，如此安排只有自己、师尊、两位师叔和寒湘子五人知晓而已。眼前这位师兄虽然音律不凡，但终究不过是真武普通三代弟子，如何能够得知这些事情？除非是早已伏于暗影之中，将自己师尊与寒湘子的谈话都偷听了去。既然是早就在院落之中，那么之前所谓的因为自己弹奏从而慕声而来全是扯淡，听琴也不过是适逢其会而已。\n想到这里，江云梦觉得自己受到了莫大的委屈，霎时间泫然欲泣。鼻音重重，仰头道：“其实，你早就在房顶上了，是不是？”\n江云梦眼一红，张慎峰瞬间愣在原地，不知所措。现在，张慎峰脑子里只有三个想法，一是后悔：自己特么的好不容易都走到这一步了，就在两人互相欣赏的完美时机道别多好，这样以后相见完全是水到渠成，结果自己非要加上几句显摆之词，端的是画蛇添足，怎么看怎么有些一招不慎，满盘皆输的意味；二是自己的推断看来是正确的，眼前这位漂亮师妹的师尊，真的要把她配给寒湘子的亲传弟子，而寒湘子的亲传弟子，可不就是今天早上与自己发生冲突的燕书磐么。其实是谁张慎峰心里都不太高兴，“父母之命，媒约之言。”古往今来，稍有地位的人家嫁女皆是一般，从来都不考虑当事人的主观感受。强扭的瓜不甜的道理家喻户晓，难道这些人竟连这一点也不懂？第三点比第一点和第二点更加的重要，那就是目前应该怎么解释，才能自证“清白”？\n“师妹，好师妹，别哭了。”这会事起紧急，张慎峰连仙子雅称也顾不上叫了，连忙解释道，“我并不是那种在房顶上窥伺之人，更没偷听什么，刚才所说的一切，其实都是分析推断的。”\n“推断？”江云梦半信半疑，眼眸中还是飞速地凝结着水雾，然后一滴滴地滴落下来，如果说瀑布的美景是水的奔流不息和一泻千里的壮观，那江云梦的泪珠就是大珠小珠落玉盘的精致，张慎峰一边克制自己驻足欣赏的想法，暗骂自己不分时间地点人物……一边抽出手帕，帮师妹擦拭脸颊上的泪水。\n一阵清风飘过，满鼻馨香，就好似卷起师妹身上的美好与纯真然后一股脑往张慎峰的鼻子里送一般，张慎峰差点……“咳咳，君子不趁人之危。”张慎峰再度低语一声，一面默念南无阿弥陀佛，一面绞尽脑汁继续编造，呃不，继续解释道：“真的是分析推断而来。师妹若是不信，听我细细道来。”\n“谁是你师妹。”江云梦扁着嘴，一双眼眸似睁实闭，目光低垂，看着站立的脚下，轻声道：“你说。”\n“师妹长居天香谷，对我真武并不了解，”张慎峰道，“律令阁乃是我真武圣地，寻常惟犯大过弟子及好学弟子于此，前者在此静修思过，后者在此听寒湘子讲经论道，殷切学习，以求能够在道之修养上百尺竿头，更进一步。再有，就是每到年关之时，真武开山，以让山下香客，上山前往律令阁进香，求签取运，希望未来一年内丰衣足食，生活无忧。”\n“换言之，按理来说，师妹一干人等是绝不应该出现于此的。”张慎峰顿了顿，悄悄看了眼江云梦的反应，继续说道，“然而师妹等人今日却实实在在地进入了律令阁，更是在第一进院中，也就是我真武律令执掌，寒湘子讲经论道的院中嬉戏玩耍。当时在下就怀疑，此中定有内情。”\n“即使师妹你的师尊，或师叔，天香一派的长老，与寒湘子是旧识，此番前来拜会的话，独自前来即可。试想，商谈机要之事，一人前来既可掩人耳目，又能有效防止人多耳杂，秘密泄露，岂不是一箭双雕，保险至极？”\n“然而你们却是所有人齐齐至此。及至师妹抚琴，在下循声而来之时，院中天香弟子整齐排满两个半圆，若论人数，足有三四十之多。更令人奇怪的是，我真武五名知客弟子尽在院中侍立，而寒湘子与师妹的师尊、两位师叔皆在院中正堂。呵呵，知客弟子不去服侍门中长老，却在外与天香的三代弟子待在一起，难道师妹认为我真武知客弟子尽皆是不谙礼数，不晓礼法之徒吗？”\n江云梦下意识地摇摇头，张慎峰再度出言道：“其实原因很简单，几位门派的中流砥柱正在商量要事，自然不会允许旁人在场。然而既然是商议事情，需要驱散本派的知客弟子，那么为何还要与门中弟子同来，又为何要在师妹抚琴之时商议呢？”\n“因为这件事商议的时候需要师妹抚琴，需要师妹展现自己的音律修养。”张慎峰此刻语调猛地一高，俨然已经把自己当成了说书人，而这一顿一提便是吸引观众的不二手段。虽然此际他的“观众”只有江云梦一人而已。\n“师妹的师尊与师叔引师妹等人到此，看似是一众天香姑娘前往律令阁嬉戏，实则仅是为了引师妹前往律令阁让寒湘子一观。若是我所料不错，师妹今日已经向寒湘子见过礼了 。而且很可能，寒湘子还赠与了师妹一些宝物。”\n“你……”江云梦想说话，张慎峰却摆了摆手，示意她等等，而后继续说道，“师妹自天香而来，临行前，想必师妹的师尊已经告诉过你此行的来意便是联姻。师妹心中不喜，却不敢轻易违逆师尊的意愿，只好在琴曲中暗下功夫。一曲琴音，述尽红尘之中万千景象，而自己独取一人，师妹是借此表达自己对媒约不喜。弱水三千，师妹只取一瓢饮，意思其实是说自己的郎君只有自己挑选才是真正中意的。”\n江云梦朱唇微张，眼眸中的吃惊已然达到见怪不怪的程度了。如此隐秘的事情，师尊再三叮嘱自己不能告之其他姐妹，并且许以三株天材地宝之诺。不夸张的讲，此次联姻关乎天香后续的发展，可谓是门派绝密。然而却在谈笑间被眼前的师兄推断出来，实在是令人惊讶，甚至有些悚然的感觉。\n同时，她又感到有些悲伤，自己的母亲，亦是自己是师尊，她作为天香的长老，为了天香未来的发展，而将自己许配给寒湘子的弟子，却不知道，自己与之从未谋面，甚至连姓甚名谁尚且不知，何谈喜欢，又何谈嫁娶呢？难道，自己就只是门派间互相交好的工具么？\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch8/","tags":[],"title":"第八章 待修改"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"二叉树存储结构 二叉树链式存储数据结构如下：\ntypedef struct BitNode {\rint data;\rBitNode *left;\rBitNode *right;\r}BitNode,*BiTree;\r二叉树遍历 设根结点为N，左结点L，右结点R。常见遍历有先序、中序、后序、层序遍历。\n递归算法 先序遍历\nvoid PreOrder(BiTree T)\r{\rif (T != NULL)\r{\rvisit(T);\rPreOrder(T-\u0026gt;lchild);\rPreOrder(T-\u0026gt;rchild);\r}\r}\r中序遍历\nvoid InOrder(BiTree T)\r{\rif (T != NULL)\r{\rInOrder(T-\u0026gt;lchild);\rvisit(T);\rInOrder(T-\u0026gt;rchild);\r}\r}\r后序遍历\nvoid PostOrder(BiTree T)\r{\rif (T != NULL)\r{\rPostOrder(T-\u0026gt;lchild);\rPostOrder(T-\u0026gt;rchild);\rvisit(T);\r}\r}\r栈迭代算法 思想：使用栈模拟递归中的调用过程。\n先序遍历\nvoid PreOrder2(BiTree T)\r{\rLinkStack S;\rInitStack(S);\rBiTree p = T; //p是工作指针\rwhile (p || !IsEmpty(S))\r{\rif (p) //先访问根结点，然后一路向左\r{\rvisit(p);\rPush(S, p);\rp = p-\u0026gt;lchild;\r}\relse //出栈，后转向右子结点（出栈条件是当前结点为空）\r{\rPop(S, p);\rp = p-\u0026gt;rchild;\r}\r}\r}\r中序遍历\nvoid InOrder2(BiTree T)\r{\rLinkStack S;\rInitStack(S);\rBiTree p = T; //p是工作指针\rwhile (p || !IsEmpty(S))\r{\rif (p) //一路向左\r{\rPush(S, p);\rp = p-\u0026gt;lchild;\r}\relse //出栈，访问根结点，后转向右子结点（出栈条件是当前结点为空）\r{\rPop(S, p);\rvisit(p);\rp = p-\u0026gt;rchild;\r}\r}\r}\r※ 后序遍历\n思想：\n①先沿着根找所有的左孩子，依次入栈，直到左孩子为；\n②读栈顶元素，若该元素的右孩子不空且未被访问过，则将其右子树转①；否则栈顶元素出栈并对其进行访问。\n关键在于分清返回到当前结点时是通过左子树返回的还是右子树返回的。代码实现中设辅助指针r指向最近访问过的结点。\nvoid PostOrder2(BiTree T)\r{\rLinkStack S;\rInitStack(S);\rBiTree p = T, r = NULL; //p是工作指针,r指向上一个访问的结点\r//工作指针有结点，则说明需要向左走，工作指针指向空，说明需要向右\rwhile (p || !IsEmpty(S))\r{\rif (p) //一路向左\r{\rPush(S, p);\rp = p-\u0026gt;lchild;\r}\relse //向右，元素出栈\r{\rGetTop(S, p); //读栈顶元素赋给p（并非出栈）\rif (p-\u0026gt;rchild \u0026amp;\u0026amp; p-\u0026gt;rchild != r) //右子树且尚未被访问\r{\rp = p-\u0026gt;rchild;\rPush(S, p);\rp = p-\u0026gt;lchild; //继续向左走\r}\relse\r{\rPop(S, p);//弹出结点\rvisit(p);\rr = p;\rp = NULL; //重置p指针\r}\r}\r}\r}\r层序遍历\n思想：使用队列实现\nvoid LevelOrder(BiTree T)\r{\rLinkQueue Q;\rInitQueue(Q);\rBiTree p;\rEnQueue(Q, T);\rwhile (!IsEmpty(Q))\r{\rDeQueue(Q, p);\rvisit(p);\rif (p-\u0026gt;lchild != NULL)\rEnQueue(Q, p-\u0026gt;lchild);\rif (p-\u0026gt;rchild != NULL)\rEnQueue(Q, p-\u0026gt;rchild);\r}\r}\r计算树深度 int treeDepth(BiTree T)\r{\rif (T == NULL)\rreturn 0;\relse\r{\rint l = treeDepth(T-\u0026gt;lchild);\rint r = treeDepth(T-\u0026gt;rchild);\rreturn l \u0026gt; r ? l + 1 : r + 1;\r}\r}\r","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/binary-tree-operation/","tags":[],"title":"二叉树的基本操作"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Installation 安装镜像：建议选用非官方 Ubuntu 的安装镜像，如 Kubuntu 或 Lubuntu 等； Ubuntu 安装镜像：5.7 GiB； Kubuntu 安装镜像：3.8 GiB； Lubuntu 安装镜像：3.1 GiB； 自 24.04 开始，安装时对于EFI分区： 可自由选择挂载 /boot 或 /boot/efi 分区； 之前只能选择 bootloader 安装位置； 多个 ubuntu 同时安装在一台计算机上稍微需要费点功夫 Software NVIDIA Drivers 自 24.04 开始，对于 Nvidia 驱动，可直接选择 Try or install Kubuntu 而不必 safe graphics 自 24.04 开始，third-party 软件集的选择更加丰富，但更可能在安装时错过图形驱动 错过后，图形驱动将使用 nouveau 驱动而非 nvidia-driver 需要手动安装 Memory Management 内存管理就是依托答辩。\nFstab 自 24.04 开始，ubuntu 终于可以使用 fstab 挂载由其他发行版格式化得到的 ext4 分区了。\n之前的版本你可以使用 mount 挂载，但企图写入 fstab 后开机自动挂载将会进入 emergency mode 之前的版本使用 fsck 检查硬盘可能得到 feature 不支持问题 Snap 安装某些程序将自动调用 snap 安装，真是贴心而又感人的设计。\n比如安装 firefox，将会自动调用 snap 安装该程序，如果安装过程出错，将需要：\nsnap install core snap refresh firefox snap remove firefox \u0026amp;\u0026amp; snap install firefox 使用 snap 安装带有 services 的软件时，可以这样管理相关的服务：\nsnap services snap services systemctl status snap.. Issue 这里记录一下 ubuntu 十宗罪：\n个人使用体验 临时挂载磁盘在 /media ，建议在 /run/media 启动的时候无法看到日志 locale 在 /etc/default/locale 而不是 /etc/locale.conf 用户不能在安装过程中自己选择需要的 locale 将生成一个语系的所有 locale 软件源软件太少 snap flatpak 24.04 推出了 DEB822 格式的软件源 当然，这个格式非常好 好就好在除了官方软件源，其他都是传统格式 软件包名命名不统一 当然这是为了用户的需要 有些用户只需要命令行工具 有些用户开发需要相关的库 拆包丧心病狂 当然这也是为了用户的需要 模糊匹配将导致搜索结果过多 一般人不会记忆究竟需要哪些包，libxxx-all-dev 用的更多 虚包/软件包组名称不统一 对于 boost 是 libboost-all-dev 对于 opencv 是 libopencv-dev 版本号命名不统一 libgtk-3-dev libgtk2.0-dev 使用 apt 安装本地包可能出错 sudo apt install ./xxx.deb 可能提示权限不够的情况 sudo dpkg -i ./xxx.deb 系统版本过旧 软件需要用户手动安装 可能由于混合软件源产生依赖缺失/依赖错误的情况 手动编译源码安装 运行提供的 deb 包安装 提示执行 apt install -f 提示依赖关系已被破坏 有软件包被要求保持现状导致的 可能需要手动指定解决办法 ","permalink":"https://endlesspeak.github.io/docs/build/operating-system-configuration/linux-technology-5-9-ubuntu/","tags":[],"title":"Ubuntu Linux 桌面环境"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"二叉树算法索引 二叉树的建立\n设二叉树初始由数组存储，生成为二叉链表存储，编写递归建立算法和非递归建立算法\n二叉树的遍历\n编写先序、中序、后序遍历的递归和非递归算法，层序遍历算法\n求先序遍历序列中第n个结点的值\n二叉树的深宽\n计算二叉树指定结点的高度/深度\n计算二叉树的最大宽度\n二叉树的形态\n判断二叉树是否是完全二叉树\n判断二叉树是否是镜像对称的\n对二叉树镜像翻转，或将二叉树所有结点的左右子树相互交换\n二叉树的结点\n计算二叉树的叶子结点、非叶子结点个数\n查找特定值的结点，并打印其所有祖先结点的值\n二叉树的遍历与建立综合\n通过先序遍历序列和中序遍历序列建立二叉树\n通过中序遍历序列和后序遍历序列建立二叉树\n将满二叉树的先序遍历序列转为后序遍历序列\n二叉树与链表综合\n将二叉树中所有叶子结点链接为链表，并返回头指针\n二叉树的建立 题目描述：设二叉树初始由数组存储，生成为二叉链表存储，编写递归建立算法和非递归建立算法。初始给定数组首地址指针和二叉树的深度。\n二叉树链式存储数据结构如下：\ntypedef struct BitNode {\rint data;\rBitNode *left;\rBitNode *right;\r}BitNode,*BiTree;\r解答：\n设虚结点在数组中用-1表示，递归建立算法如下：\nint size=pow(2,depth)-1;\rBiTree CreateBiTree(int *a,int index,int size){\rBiTNode *T=NULL;//初始化二叉树根结点\rif(size==0||a[index]==-1)\rreturn NULL;\rT=(BiTNode*)malloc(sizeof(BiTNode));\rT-\u0026gt;data=a[index];\rT-\u0026gt;lchild = CreateBiTree(a, 2 * index, size);\rT-\u0026gt;rchild = CreateBiTree(a, 2 * index + 1, size);\rreturn T;\r}\rBiTree T = CreateBiTree(a, 1, size); //创建二叉树\r非递归使用队列实现，类似层次遍历思想：\ntypedef struct TNode{\rBiTree bt;//二叉树结点指针\rint num;//指示当前结点在一维数组中的位序\r}TNode;\rTNode Q[MaxSize];//循环队列\rBiTree CreateBiTree(int *a,int depth){\rint size=pow(2,depth)-1;\rBiTree p;//用于暂存出队的元素\rint i=0;//指示暂存的出队元素在数组中的位序\rTNode tn;//队列元素\rBiTree T=(BiTNode*)malloc(sizeof(BiTNode));//根结点\rT-\u0026gt;data=a[1];\rtn.bt=T;\rtn.num=1;\rint front=rear=0;\rQ[rear++%MaxSize]=tn;\rwhile(front!=rear){\rtn=Q[front++%MaxSize];//出队\rp=tn.bt;\ri=tn.num;\rif(2*i\u0026gt;size||a[2*i]==-1)\rp-\u0026gt;lchild=NULL;\relse{\r//左结点\rp-\u0026gt;lchild=(BiTNode*)malloc(sizeof(BiTNode));\rp-\u0026gt;lchild-\u0026gt;data=a[2*i];\r//左结点入队\rtn.bt=p-\u0026gt;lchild;\rtn.num=2*i;\rQ[rear++%MaxSize]=tn;\r}\rif(2*i+1\u0026gt;size||a[2*i+1]==-1)\rp-\u0026gt;rchild=NULL;\relse{\r//右结点\rp-\u0026gt;rchild=(BiTNode*)malloc(sizeof(BiTNode));\rp-\u0026gt;rchild-\u0026gt;data=a[2*i+1];\r//右结点入队\rtn.bt=p-\u0026gt;rchild;\rtn.num=2*i+1;\rQ[rear++%MaxSize]=tn;\r}\r}\r}\r二叉树的遍历 先序、中序和后序遍历的非递归算法均使用栈实现。\n先序遍历 递归算法\nvoid PreOrder(BiTree T)\r{\rif (T != NULL)\r{\rvisit(T);\rPreOrder(T-\u0026gt;lchild);\rPreOrder(T-\u0026gt;rchild);\r}\r}\r非递归算法\nconst int MaxSize=1000;\rvoid PreOrder2(BiTree T)\r{\rint top=-1;//top指向栈顶元素\rBiTNode* stack[MaxSize];\rBiTree p = T; //p是工作指针\rwhile (p || top!=-1)\r{\rif (p) //先访问根结点，然后一路向左\r{\rvisit(p);\rstack[++top]=p;\rp = p-\u0026gt;lchild;\r}\relse //出栈，后转向右子结点（出栈条件是当前结点为空）\r{\rp=stack[top--];\rp = p-\u0026gt;rchild;\r}\r}\r}\r中序遍历 递归算法\nvoid InOrder(BiTree T)\r{\rif (T != NULL)\r{\rInOrder(T-\u0026gt;lchild);\rvisit(T);\rInOrder(T-\u0026gt;rchild);\r}\r}\r非递归算法\nconst int MaxSize=1000;\rvoid InOrder2(BiTree T)\r{\rint top=-1;//top指向栈顶元素\rBiTNode* stack[MaxSize];\rBiTree p = T; //p是工作指针\rwhile (p || top!=-1)\r{\rif (p) //一路向左\r{\rstack[++top]=p;\rp = p-\u0026gt;lchild;\r}\relse //出栈，访问根结点，后转向右子结点（出栈条件是当前结点为空）\r{\rp=stack[top--];\rvisit(p);\rp = p-\u0026gt;rchild;\r}\r}\r}\r后序遍历 递归算法\nvoid PostOrder(BiTree T)\r{\rif (T != NULL)\r{\rPostOrder(T-\u0026gt;lchild);\rPostOrder(T-\u0026gt;rchild);\rvisit(T);\r}\r}\r※ 非递归算法：\n①先沿着根找所有的左孩子，依次入栈，直到左孩子为空；\n②读栈顶元素，若该元素的右孩子不空且未被访问过，则将其右子树转①；否则栈顶元素出栈并对其进行访问。\n上述第②步中，关键在于必须分清返回到当前结点时是通过左子树返回的还是右子树返回的。若是左子树，则当前结点需要一路向左，若是右子树，则访问当前结点。\n为达到上述目的，代码实现中设辅助指针r指向最近访问过的结点。\nconst int MaxSize=1000;\rvoid PostOrder2(BiTree T)\r{\rint top=-1;//top指向栈顶元素\rBiTNode* stack[MaxSize];\rBiTree p = T, r = NULL; //p是工作指针,r指向上一个访问的结点\r//工作指针有结点，则说明需要向左走，工作指针指向空，说明需要向右\rwhile (p || top!=-1)\r{\rif (p) //一路向左\r{\rstack[++top]=p;\rp = p-\u0026gt;lchild;\r}\relse //向右，元素出栈\r{\rp=stack[top];//读栈顶元素赋给p（并非出栈）\rif (p-\u0026gt;rchild\u0026amp;\u0026amp;p-\u0026gt;rchild!=r) //右子树且尚未被访问\r{\rp = p-\u0026gt;rchild;\rstack[++top]=p;\rp = p-\u0026gt;lchild; //继续向左走\r}\relse\r{\rp=stack[top--];//弹出结点\rvisit(p);\rr = p;\rp = NULL; //重置p指针\r}\r}\r}\r}\r层序遍历\n思想：使用队列实现\nconst int MaxSize=1000;\rvoid LevelOrder(BiTree T)\r{\rBiTree Queue[MaxSize];\rBiTree p;\rint rear=front=0;\rQueue[rear++%MaxSize]=T;\rwhile (front!=rear)\r{\rp=Queue[front++%MaxSize];\rvisit(p);\rif (p-\u0026gt;lchild != NULL)\rQueue[rear++%MaxSize]=p-\u0026gt;lchild;\rif (p-\u0026gt;rchild != NULL)\rQueue[rear++%MaxSize]=p-\u0026gt;rchild;\r}\r}\r求先序遍历序列中第n个结点的值 假设二叉树共有$n$个结点，采用二叉链表存储结构，试设计算法求先序遍历序列中第$k(1\\leq k \\leq n)$的叶子结点的值。\nElemType PreOrder(BiTree T,int k,int \u0026amp;num){\rElemType value=NULL;\rif(T==NULL)\rreturn value;\rif(num==k)\rreturn T-\u0026gt;data;\rnum+=1;\r//当num\u0026lt;k时\rif(T-\u0026gt;lchild!=NULL){\rvalue=PreOrder(T-\u0026gt;lchild,k,num);\rif(value!=NULL)\rreturn value;\r}\rif(T-\u0026gt;rchild!=NULL){\rvalue=PreOrder(T-\u0026gt;rchild,k,num);\rreturn value;\r} }\rElemType PreNode(BiTree T,int k){\rreturn PreOrder(T,k,0);\r}\r二叉树的深宽 题目描述：设二叉树初始由二叉链表存储，编写计算二叉树的深度和最大宽度的算法。初始给定二叉树根结点。\n二叉树的深度 递归算法\n注：无论是给二叉树的根还是给指定结点，计算深度均可采用下面的算法。\nint treeDepth(BiTree T)\r{\rif (T == NULL)\rreturn 0;\relse\r{\rint l = treeDepth(T-\u0026gt;lchild);\rint r = treeDepth(T-\u0026gt;rchild);\rreturn l \u0026gt; r ? l + 1 : r + 1;\r}\r}\r二叉树的宽度 算法思想：\n采用层次遍历的方法，通过记录各层结点数最后得到最大结点数。\n遍历中需要区分不同层，区分方法有很多种，一是用整数保存当前层元素的个数控制出队和入队；二是保存当前层最右侧结点。\n法一，用整数保存当前层元素的个数控制出队和入队。\nconst int MaxSize=1000;\rBiTree Q[MaxSize];//定义队列\rint rear=front=0;\rint BiTreeWidth(BiTree T){\rif(T==NULL)\rreturn 0;\rcurrentWidth=0;//本层结点个数\rQ[rear++%MaxSize]=T;//根结点入队\rlastWidth=1;//上一层（即当前队列中的元素个数）\rmaxWidth=1;//根结点已入队，因此最大宽度从1开始计算\rwhile(rear!=front){\rwhile(lastWidth!=0){//当前队列中元素个数不为0，则持续出队\rBiTree p=Q[front++%MaxSize];\rif(p-\u0026gt;lchild){\rQ[rear++%MaxSize]=p-\u0026gt;lchild;\rcurrentWidth+=1;\r}\rif(p-\u0026gt;rchild){\rQ[rear++%MaxSize]=p-\u0026gt;rchild;\rcurrentWidth+=1;\r}\rif(currentWidth\u0026gt;maxWidth)\rmaxWidth=currentWidth;\rlastWidth-=1;\r}\rlastWidth=currentWidth;\rcurrentWidth=0;//清零当前层计数器，转下一层\r}\rreturn maxWidth;\r}\r法二，用整数保存当前层最右侧结点。\nconst int MaxSize=1000;\rBiTree Q[MaxSize];//定义队列\rint BiTreeWidth(BiTree T){\rif(T==NULL)\rreturn 0;\rint font=0,rear=0;\rint last=0;//last指向当前层的最右结点\rint maxWidth=0,currentWidth=0;\r//maxWidth保存最大宽度，currentWidth保存本层宽度\rQ[rear++%MaxSize]=T；//根结点入队\rBiTree p;\rwhile(front%MaxSize\u0026lt;last%MaxSize){//在当前层循环\rp=Q[front++%MaxSize]; currentWidth++; if(p-\u0026gt;lchild)\rQ[rear++%MaxSize]=p-\u0026gt;lchild;\rif(p-\u0026gt;rchild)\rQ[rear++%MaxSize]=p-\u0026gt;rchild;\rif(front\u0026gt;=last){//由于last=rear,rear指向下一个结点，因此这里相等也成立\rif(maxWidth\u0026lt;currentWidth)\rmaxWidth=currentWidth;\rlast=rear;//将下一层的最后一个结点赋给last\rcurrentWidth=0;//每一层宽度置空一次\r}\r}\rreturn maxWidth;\r}\r二叉树的形态 完全二叉树 使用队列进行层序遍历，如果某结点无左孩子，也必须无右孩子。\n特别注意两点：\n不能通过证明左右子树是完全二叉树，则该树是完全二叉树，证法是错误的； 不能在入队时只考虑左右孩子均有、有左无右、有右无左、都无这四种情况，因为可能存在左子树和右子树都只有左孩子无右孩子。 因此需要加设一个变量flag，指示当前结点的左兄弟的子树是否是满二叉树。\nconst int MaxSize=1000;\rBiTree Queue[MaxSize];\rbool judgeComplete(BiTree T){\rif(!T)\rreturn true;\rint flag=1;//判断当前层的左兄弟的子树是满二叉树(1)或无子树/仅有左子树(0)\rint front=rear=0;\rQueue[rear++%MaxSize]=T;\rwhile(front!=rear){\rBiTree p=Q[front++%MaxSize];\rif(p-\u0026gt;lchild\u0026amp;\u0026amp;flag){\rQueue[rear++%MaxSize]=p-\u0026gt;lchild;\r}\relse if(p-\u0026gt;lchild)//有左孩子，但左兄弟不是满二叉树\rreturn false;\relse\rflag=0;\rif(p-\u0026gt;rchild\u0026amp;\u0026amp;flag){\rQueue[rear++%MaxSize]=p-\u0026gt;rchild;\r}\relse if(p-\u0026gt;rchild)\rreturn false;\relse\rflag=0;\r}\rreturn true;\r}\r镜像对称 递归算法\n两个结点是镜像对称的需要满足以下两个条件：\n结点上的值相等 结点a的左孩子的值等于结点b的右孩子的值，结点a的右孩子的值等于结点b的左孩子的值。 bool isMirror(BiTree T1,BiTree T2) {\rif(T1==NULL\u0026amp;\u0026amp;T2==NULL)\rreturn true;\relse if(T1==NULL\u0026amp;\u0026amp;T2!=NULL)\rreturn false;\relse if(T1!=NULL\u0026amp;\u0026amp;T2==NULL)\rreturn false;\relse\rreturn (T1-\u0026gt;val==T2-\u0026gt;val) \u0026amp;\u0026amp; isMirror(T1-\u0026gt;left,T2-\u0026gt;right) \u0026amp;\u0026amp; isMirror(T1-\u0026gt;right,T2-\u0026gt;left);\r}\rbool isMirrorTree(BiTree T){\rif(T==NULL)\treturn true;\relse return isMirror(T1,T2);\r}\r非递归算法\n直接由递归算法修改而来，并不尽如人意。\nconst int MaxSize=1000;\rBiTree stack1[MaxSize];\rBiTree stack2[MaxSize];//定义两个栈\rBool isMirror(BiTree T1,BiTree T2) {\rint top=-1;\rBiTree p1,p2;\rstack1[++top]=T1;\rstack2[++top]=T2;//同时入栈\rwhile(top!=-1){\rp1=stack[top--];\rp2=stack[top--];\r//值判断\rif(p1-\u0026gt;data!=p2-\u0026gt;data)\rreturn false;\r//结构判断\relse if(!(p1-\u0026gt;lchild\u0026amp;\u0026amp;p2-\u0026gt;rchild))\rreturn false;\relse if(!(p1-\u0026gt;rchild\u0026amp;\u0026amp;p2-\u0026gt;lchild))\rreturn false;\relse{\rif(p1-\u0026gt;lchild)\rstack1[++top]=p1-\u0026gt;lchild;\rif(p1-\u0026gt;rchild)\rstack1[++top]=p1-\u0026gt;rchild;\rif(p2-\u0026gt;lchild)\rstack2[++top]=p2-\u0026gt;lchild;\rif(p2-\u0026gt;rchild)\rstack2[++top]=p2-\u0026gt;rchild;\r}\r}\rreturn true;\r}\r镜像翻转 递归算法思想：\n递归地对每层，使用三变量交换法交换左右子树。\nBiTree invertTree(BiTree T) {\rif(T == null)\rreturn T;\rBiTree temp = T-\u0026gt;left;\rT-\u0026gt;left = T-\u0026gt;right;\rT-\u0026gt;right = temp;\rinvertTree(T-\u0026gt;left);\rinvertTree(T-\u0026gt;right);\r}\r或者不使用三变量交换法，先递归得到左右子树，然后直接交叉赋值。\nBiTree invertTree(BiTree T){\rif (!T)\rreturn NULL;\rBiTree left = invertTree(T-\u0026gt;lchild);\rBiTree right = invertTree(T-\u0026gt;rchild);\rT-\u0026gt;lchild = right;\rT-\u0026gt;rchild = left;\rreturn T;\r}\r迭代算法思想：\n采用层次遍历，依次遍历结点并入队，出队时交换结点的左右孩子，并将左右孩子分别入队，循环直到队列为空。\nconst int MaxSize=1000;\rBiTree Q[MaxSize];//定义队列\rBiTree Mirror(BiTree T) {\rint rear=front=0;\rBiTree temp,current;\rif(T==NULL)\rreturn T;\rQ[rear++%MaxSize]=T;\rwhile(front!=rear) {\rcurrent=Q[front++%MaxSize];\rtemp=current-\u0026gt;left;\rcurrent-\u0026gt;left=current-\u0026gt;right;\rcurrent-\u0026gt;right=temp;\rif(current-\u0026gt;left!=NULL)\rQ[rear++%MaxSize]=current-\u0026gt;left;\rif(current-\u0026gt;right!=NULL)\rQ[rear++%MaxSize]=current-\u0026gt;right;\r}\rreturn T;\r}\r二叉树的子结构 给定两棵二叉树，要求判断树B是否是树A的子结构。\n//依次查找树T1的根、左子树、右子树\rbool HasSubtree(BiTree T1,BiTree T2){\rif(T1 == NULL || T2 == NULL) return false;\relse\rreturn (isSubtree(T1,T2))||HasSubtree(T1-\u0026gt;left, T2)||HasSubtree(T1-\u0026gt;right, T2);\r}\r//判断树T2（根结点）是否是树T1（根结点）的子结构\rbool isSubtree(BiTree T1,BiTree T2){\rif(T2 == NULL) return true;\rif(T1 == NULL) return false;//r2非空，r1为空\rif(T1-\u0026gt;data!=T2-\u0026gt;data)\rreturn false;\rreturn isSubtree(T1-\u0026gt;left, T2-\u0026gt;left) \u0026amp;\u0026amp; isSubtree(T1-\u0026gt;right, T2-\u0026gt;right);\r}\r二叉树的结点 计算二叉树叶子结点数与非叶子结点数 本节分别叙述二叉树以数组、二叉链表的存储方式存储时计算叶子结点和非叶子结点。\n数组形式，给定数组和二叉树深度：\nint leafCount=nodeCount=0;\rvoid leaves(int *a,int depth,int \u0026amp;leafCount,int \u0026amp;nodeCount){\rint size=pow(2,depth)-1;\rfor(int i=1;i\u0026lt;=size;i++){\rif(a[i]!=-1){//即不是虚结点\rnodeCount++;//总结点数加1\rif(i*2\u0026gt;size)\rleafCount++;//叶结点数加1\relse if(a[2*i]==-1\u0026amp;\u0026amp;2*i+1\u0026lt;=size\u0026amp;\u0026amp;a[2*i+1]==-1)\rleafCount++;\r}\r}\r}\rint nonLeafCount=nodeCount-leafCount;\r二叉链表形式，给定根结点：\nint leafCount=nodeCount=0;\rvoid Count(BiTree T,int \u0026amp;leafCount,int \u0026amp;nodeCount){\rif(T){\rnodeCount++;\rif(!T-\u0026gt;lchild\u0026amp;\u0026amp;!T-\u0026gt;rchild)\rleafCount++;\r}\relse\rreturn;\rCount(T-\u0026gt;lchild,leafCount,nodeCount);\rCount(T-\u0026gt;rchild,leafCount,nodeCount);\r}\rint nonLeafCount=nodeCount-leafCount;\r二叉链表形式\n计算二叉树某层的叶子结点数与非叶子结点数 题目描述：二叉树采用二叉链表存储结构，设计算法求指定某一层k(k\u0026gt;1)的叶子结点个数。\n递归算法\n算法思想：采用先序遍历，递归得到该层的叶子结点\nint level=1;\rint CountNode(BiTree T,int k){\rlevel=0;\rPreOrder(T,0,k);\rreturn level;\r}\rvoid PreOrder(BiTree T,int depth,int k){\rif(depth\u0026lt;k){\rif(T-\u0026gt;lchild!=NULL)\rPreOrder(T-\u0026gt;lchild,depth+1,k);\rif(T-\u0026gt;rchild!=NULL)\rPreOrder(T-\u0026gt;rchild,depth+1,k);\r}\relse{\rif(depth==k\u0026amp;\u0026amp;T-\u0026gt;lchild==NULL\u0026amp;\u0026amp;T-\u0026gt;rchild==NULL)\rlevel+=1;\r}\r} 非递归算法\n算法思想：采用层序遍历，设置整数记录当前层最后一个结点\nconst int MaxSize=1000;\rBiTree Q[MaxSize];//定义队列\rint BiTreeWidth(BiTree T,int k){\rint level=1,count=0;\rint font=0,rear=0;\rint last=0;//last指向当前层的最右结点\rQ[rear++%MaxSize]=T；//根结点入队\rBiTree p;\rwhile(front%MaxSize\u0026lt;=last%MaxSize){//在层内循环\rif(level==k){//已到指定层，队列中元素即为本层所有元素，依次出队\rwhile(front!=rear){\rp=Q[front++%MaxSize];\rif(p-\u0026gt;lchild==NULL\u0026amp;\u0026amp;p-\u0026gt;rchild==NULL)\rcount+=1;\r}\rreturn count;\r}\relse{\rp=Q[front++%MaxSize];\rif(p-\u0026gt;lchild)\rQ[rear++%MaxSize]=p-\u0026gt;lchild;\rif(p-\u0026gt;rchild)\rQ[rear++%MaxSize]=p-\u0026gt;rchild;\rif(front\u0026gt;=last){//该层结束，注意体会等号\rlast=rear;//记录下层最右结点\rlevel+=1;//跳到下层\r}\r}\r}\r}\r查找指定值结点及其祖先 题目描述：在二叉树中查找值为x的结点，设该结点不会多于1个，获得该结点的所有祖先。\n算法思想：后续遍历二叉树，当访问到该结点时，栈中所有值均为该结点的祖先。\nconst int MaxSize=1000;\rvoid PostOrder2(BiTree T)\r{\rint top=-1;//top指向栈顶元素\rBiTNode* stack[MaxSize];\rBiTree p = T, r = NULL; //p是工作指针,r指向上一个访问的结点\r//工作指针有结点，则说明需要向左走，工作指针指向空，说明需要向右\rwhile (p || top!=-1)\r{\rif (p) //一路向左\r{\rstack[++top]=p;\rp = p-\u0026gt;lchild;\r}\relse //向右，元素出栈\r{\rp=stack[top];//读栈顶元素赋给p（并非出栈）\rif(p-\u0026gt;data==x){\rtop--; //当前结点删除\rcout \u0026lt;\u0026lt; \u0026quot;当前结点的所有祖先为：\u0026quot; \u0026lt;\u0026lt; endl;\rwhile (top!=-1)\r{\rp=stack[top--];\rcout \u0026lt;\u0026lt; p-\u0026gt;data \u0026lt;\u0026lt; endl;\r}\rreturn;\r}\rif (p-\u0026gt;rchild\u0026amp;\u0026amp;p-\u0026gt;rchild!=r) //右子树且尚未被访问\r{\rp = p-\u0026gt;rchild;\rstack[++top]=p;\rp = p-\u0026gt;lchild; //继续向左走\r}\relse\r{\rp=stack[top--];//弹出结点\rvisit(p);\rr = p;\rp = NULL; //重置p指针\r}\r}\r}\r}\r二叉树的遍历与建立综合 先序遍历和中序遍历序列建立二叉树 BiTree PrePostCreate(int *pre,int *in,int l1,int h1,int l2,int h2){\r//pre和in是二叉树的先序和中序遍历序列\r//l1,h1是先序序列第一和最后一个结点的下标\r//l2,h2是中序序列第一和最后一个结点的下标\rBiTree T=(BiTree)malloc(sizeof(BiTNode));\rT-\u0026gt;data=pre[l1];\rfor(int i=l2;i\u0026lt;=h2;i++)//获取根结点在中序遍历序列中的位置i,第i个记为根\rif(pre[l1]==in[i])\rbreak;\rif(i==l2)\rT-\u0026gt;lchild=NULL;\relse\r//左子树在中序遍历的位置为前半部分，共i-(l2+1)+1=i-l2个，因此范围从l1到l1+i-l2\rT-\u0026gt;lchild=PrePostCreate(pre,in,l1+1,l1+i-l2,l2,i-1);\rif(i==h2)\rT-\u0026gt;rchild=NULL;\relse\r//右子树在中序遍历的位置为后半部分，因此范围从l1+i-l2+1到h1,第i个是根\rT-\u0026gt;rchild=PrePostCreate(pre,in,l1+i-l2+1,h1,i+1,h2);\r}\r中序遍历和后序遍历序列建立二叉树 BiTree InPostCreate(int *in,int *post,int l1,int h1,int l2,int h2){\r//in和post是二叉树的中序和后序遍历序列\r//l1,h1是中序序列第一和最后一个结点的下标\r//l2,h2是后序序列第一和最后一个结点的下标\rBiTree T=(BiTree)malloc(sizeof(BiTNode));\rT-\u0026gt;data=post[h2];//后序遍历的最后一个结点是根结点\rfor(i=l1;i\u0026lt;=h1;i++)//获取根结点在中序遍历序列中的位置i,第i个记为根\rif(in[i]==post[h2])\rbreak;\rif(i==l1)//处理左子树\rT-\u0026gt;lchild=NULL;\relse\r//左子树在后序遍历的位置为前半部分，共i-l1+1个，因此范围从l2到l2+(i-l1+1)\rT-\u0026gt;lchild=InPostCreate(in,post,l1,i-1,l2,l2-l1+i-1);\rif(i==h1)\rT-\u0026gt;rchild=NULL;\relse\r//右子树在后序遍历的位置为后半部分，范围从l2+(i-l1)到h2-1,最后一个是根\rT-\u0026gt;rchild=InPostCreate(in,post,i+1,h1,l2+i-l1,h2-1);\rreturn T;\r}\r满二叉树先序遍历转为后序遍历序列 void PreToPost(int *pre,int *post,int l1,int h1,int l2,int h2){\r//pre和post是二叉树的先序和后序遍历序列\r//l1,h1是先序序列第一和最后一个结点的下标\r//l2,h2是后序序列第一和最后一个结点的下标\rif(h1\u0026gt;=l1){\rpost[h2]=pre[l1];\rhalf=(h1-l1)/2;//half是左子树的结点数（或右子树的结点数）\rPreToPost(pre,post,l1+1,l1+half,l2,l2+half-1);\r//将左子树先序转为后序\rPreToPost(pre,post,l1+half+1,h1,l2+half,h2-1);\r//将右子树先序转为后序\r}\r}\r二叉树与链表综合 将二叉树中所有叶子结点链接为双链表 BiTree CreateLeafList(BiTree T){\rBiTree head=NULL,pre;\rif(T){\rCreateLeafList(T-\u0026gt;lchild);\rif(T-\u0026gt;lchild==NULL\u0026amp;\u0026amp;T-\u0026gt;rchild==NULL){\rif(head==NULL){\rhead=(BiTree)malloc(sizeof(BiTree));\rhead-\u0026gt;lchild=NULL;\rhead-\u0026gt;rchild=T;\rT-\u0026gt;lchild=head;\rpre=T;\r}\relse{\rpre-\u0026gt;rchild=T;\rT-\u0026gt;lchild=pre;\rpre=T;\r}\r}\rCreateLeafList(T-\u0026gt;rchild);\rpre-\u0026gt;rchild=NULL;//最后一个叶子结点为空\r}\rreturn head;//返回头指针\r}\r","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/binary-tree-algorithms/","tags":[],"title":"二叉树的算法"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　张慎峰看出来江云梦的难过，温言宽慰道：“师妹放心，我真武师叔一辈的人物皆是德高望重之辈，断不可能做出强娶强嫁之事。今日师妹以琴曲直抒胸臆，寒湘子师叔必已了然于心，不会为难师妹的。”\n江云梦低头不语，清风于密林中慢慢吹过，四下里一片寂静。\n日光渐高，此刻已经巳末午初（注：早上十一点），接近正午，终于，江云梦说道：“我要走了。仓促出门，师尊肯定放心不下，若是再不回去，师尊定然来寻我了。”\n张慎峰点点头，再度安慰道：“师妹千万不要沮丧，寒湘子师叔为人正直，师妹回去之后，一切如常即可。若是之后令师尊仍然提联姻之事，师妹不妨直接告诉寒湘子师叔，我相信，以寒湘子师叔的为人，会为师妹做主。”\n“我知道了。”江云梦仰起头，一双宛若湖水般的眼眸盯着他，问道，“对了，师兄，我还不知道你叫什么。”\n“啊？”张慎峰一时间心停了半拍，这才想起刚才自己之前扯大旗论高义，挂羊头卖狗肉，坦坦荡荡地说行不更名坐不改姓的时候，压根就没把自己的名字加上。于是连忙咳嗽两声清清嗓子，缓解尴尬的气氛，说道：“真武三代弟子，张慎峰。”\n“嗯。”江云梦点点头，重复道，“真武三代弟子，张慎峰，我记住了。”顿了一顿，又加上一句：“这几日江湖论剑，各大派都在真武山云集，我和姐妹们就住在真武客居之中，最后一进院子里。你若是前来拜访，报出姓名即可。”\n说罢，江云梦便飘身离去，地上卷起一阵香风。\n……\n日光逐渐升到天空最高处，这片树木稀少，视野开阔的地方，投下的日光几乎形成了一个光圈，将张慎峰整个框在其中。香风渐淡，张慎峰望着空中的倩影逐渐远去，站在原地，双目紧闭，皱眉沉思，就此入定。\n媒约之言。张慎峰心中默念着这四个字，暗自摇头。天香谷究竟遭遇了何事？为何要于此际向真武联姻呢？按理说，天香谷地处东越（东南临海，大概位置在福建省），比较偏僻，又由于是门派内俱是女子，很少与外来人士交流，若说是遭遇危机，总觉得不太可能。\n突然，张慎峰浑身一震，周身浩然正气再度涌出，几欲凝成实质！\n原来，自从他刚才上山遇到江云梦之时，直至此刻江云梦离去，他的紫霞功一直在周遭体表遍布，就如同一直在练功一般。江云梦一走，那股强大的精神力压迫也就随之散去，张慎峰整个人的识海感到一阵充盈。\n此际，神识在识海中沸腾一般，四散溢出，争先恐后地向外扩散，遍布周围。整个开阔地尽皆如同在张慎峰的脑海中一般，而他本人的气势也是逐渐增加。如同一个巨大的气旋一般，周边的空气飞舞的越来越快，渐渐围绕成了漩涡，而后，所有的灵气皆向身处气旋中心的张慎峰压迫而去，随着一声爆响，张慎峰竟然就此突破了！\n虽然说张慎峰以前也曾习练了很久四象诀的功法，然而却从未有过如此舒畅的体验。直到如今，他才算是真正的进入了武功修习的大门。感受着经脉之中传来的暖意，张慎峰心中升起一丝明悟：自己就像是一块生铁，需要在外力的打磨和锤击下才能改头换面，焕发出神兵的光辉。而刚才江云梦的那股精神力，便是自己的第一块磨刀石。\n摇摇头，张慎峰强行将天香的事情抛在脑后。毕竟此刻自己只是一名普通的真武弟子，知道这些也了无用处，天塌下来自然有个高的顶着。不过，张慎峰此刻脑海中却生出一股强烈地提升自身实力的欲望。不说别的，单说这位漂亮的师妹，与自己年龄相仿，然而论及武功进境，在自己看来这位师妹竟属于“深不可测”的境界，这可不是什么好事。再者，如今江湖动荡，风起云涌，江湖八荒也不再如同以前那般同气连枝，唯有变得更强，才能乱中求存。\n张慎峰定下心神，盘膝坐下，从道袍袖中取出自己誊抄的那本《紫霞功》，细细翻阅起来。早上的时候，自己只是记诵了这部神奇功法的口诀，却未曾学习过这部功法一招一式。如今既然机缘巧合之下，突破了紫霞功的入门第一阶段，自然可以学习一些浅显的招式。\n举凡功法，皆分为两大部分，一曰口诀，二曰招式。功法一般分为九篇，每篇再分九个阶段，每个阶段都将以功法冲击周身的经脉，遇障而破之，是为突破。每突破一个阶段，便可习练一些对应阶段的招式。张慎峰之前拾到的那本《四象诀》，描述的习练方法太过普通，只能给普通人强身健体之用，根本不能当做功法。\n之前与燕书磐切磋的时候，张慎峰仅仅只是将功法之中所描述的能量皆运用在师尊所授的“定魂一眼”上，瞬间在眼中爆射出定魂精光。这种使用方法其实并不正确，一来紫霞功的能量与师尊所授的定魂一眼并不是同根同源，而且张慎峰对紫霞功的运用也并不熟练，如此使用，会极大地浪费自己的内功；二来由于张慎峰对定魂一眼和紫霞功的运用并不随心所欲，因此不能发挥出最大的威力也就在情理之中。好在紫霞功果然是上古功法，精妙无比，即使如此，张慎峰仍然能一眼将燕书磐望的心神紊乱，气血翻涌，痛苦万分。\n翻到《紫霞功》的招式部分，张慎峰立刻便被第一个招式：生太极 所吸引。生太极，飞剑满天势。在周身产生气场。气场范围内提高自身躲避和格挡能力，同时限制其他人的移动。\n也许在一般人看来，这种气场食之无用，弃之可惜，实在鸡肋，然而在张慎峰眼中却并非如此。真武派一向讲求的是干戈止武，乃为真武。意思便是说，阻止他人使用武力才是真正的武道。\n生太极所产生的气场，虽然不能在对敌时帮助打击敌人，却能极大的干扰敌人；而提高自身的躲避和格挡，那就更是价值不可估量。正所谓“欲学打人，先学挨打”，这句话相信每一个江湖中人在最初学武之时都曾听说过，也许很多人不曾重视，然而其实学习挨打才是最有效的提升自己实力的法门。\n习武之人推崇以武证道，武道之中最重基础，基础不牢，地动山摇。而简简单单的挨打，便是基础中的基础。武功再高强，难免有失误的时候，如若不会挨打，那么一着不慎便是全盘皆输；反之，若是皮糙肉厚，那么暂时的劣势反而可能成为敌人放松警惕从而实现反扑的机会。个中门道，看似简单，实则是江湖至理。可惜，大多江湖中人不懂得这一点，故而虽江湖中天才层出不穷，但泯然众人的更多，而崭露头角的很少。\n正午的太阳毒辣地炭烤着真武山，山中连绵的密林对此早已习以为常。它们厚重的枝叶层层叠叠的交接，将毒辣的阳光严实地挡在外边，惟有张慎峰所在的这片树木稀少的开阔地却是例外。此地四周的树木并不繁茂，更兼枝叶稀少，太阳到达穹顶，此际已然将这方圆五丈的土地笼罩。随着阳光的投射，此处的地面温度骤然上升，许多动物都轻车熟路的跑向密林的更深处，就连地上的蚂蚁也在大举迁徙。然而张慎峰却依然紧闭着双眼，盘膝坐在原地，正对着太阳的炭烤，安之若素。\n此时的他，满脸淌着汗水，身上更是汗出如浆。但他本人却纹丝不动，宛如一尊铁塔。原因无它，此时正是他全心全意地习练着第一个招式——生太极的紧要时刻。\n虽然生太极只是紫霞功中最基础的招式，然而对目前的张慎峰来说却繁复无比。江湖中最有效的杀人招式可能是见血封喉的剑法，可能是力劈华山的刀术，可能是诡魅无形无影无踪的暗器，但江湖公认的最难习练的招式，一是轻功，二是气场。因为轻功与气场，均是以其所需的妙到毫巅的掌控力，习练时百折不挠的意志力闻名。谈及掌控力，即使是妙到毫巅的暗器也比不上气场百分之一。而生太极作为紫霞功这门上古功法的基础招式，可以想象，它的掌握难度更是远在一般的气场招式之上。\n难归难，张慎峰却是越挫越勇。从江云梦离去的巳末午初，到现在的未时，他已经习练了整整一个半时辰。在这段时间内，张慎峰纹丝不动。虽然已经接连失败了十余次，但他却丝毫不以为意。古之成大事者，不惟有超世之才，亦必有坚韧不拔之志。虽然他只需拍拍屁股动动脚，稍微腾挪一番，便能坐到阴凉之处，安心习练，但是他却没有这样做，而是在烈日之下，习练自己的招式。岂不闻茅厕背书，事半功倍；吊床练武，事倍功半的道理。接受太阳的炙烤，功不成身不退，人就会不断产生动力，当然这不仅是为了提高武功进境，同时也是锤炼自己的心志。\n“呼——”终于，经过一个半时辰的反复练习，张慎峰长长地出了一口气，站起身来开始第二十次尝试施展生太极。\n只见他双眼缓缓睁开，左手掐诀，右手后负，口中念念，脑海中的精神力暴涨。俄而一股浩然正气自他体内迸发而出，不多时便已笼罩了方圆十尺的空间。若是此时站在这十尺空间外，就会惊讶的发现，由外向内看，模糊一片，而由内向外看，却清楚万分。一个呼吸间，张慎峰的脚下已向四面八方延伸出数十道紫光，紫光延伸到距离张慎峰十尺之处止，而后互相连接形成了一个圆盘，张慎峰便站在这个圆盘之上。圆盘缓缓地旋转着，张慎峰仔细地体会着，感悟着周边的变化，仿佛这十尺空间尽皆在自己心中，空间中一点一滴的变化都在自己的识海之内。\n突然，张慎峰右手由掌握拳，而后向前挥出。令他惊讶的是，自己的拳风虽然威力并不十分巨大，但却有一种十分精准的感觉。与之相反，在这十尺空间之中，若是别人施招，张慎峰相信他一定会或多或少的感受到一种迟滞。而这种迟滞，在张慎峰这里，便是躲闪的依据。这便是气场，生太极的气场！\n……\n却说江云梦自密林之中飘身而起，赶回律令阁时，天香派的姑娘们已开始在律令阁吃饭了。见江云梦回来，众女纷纷上前迎接，一个个叽叽喳喳地叫唤个不停。江云梦心事重重，正要应付过去，坐在首位的那名女子扬声道：“云梦，过来。”\n“参见师尊。”江云梦不敢怠慢，连忙走上前来行礼。\n这名坐在首位的女子乃天香派的长老，江云梦的师尊，天香第一代弟子，“天香五秀”之三，卢文锦。坐在她旁边的则是天香五秀中的末两位，沈采薇和秦白露。卢文锦于三十年前便已立誓为天香奉献一生，可谓是天香的中流砥柱。如今她已知天命（注：表示年龄有五十岁了），仍在为三代弟子奔波操劳，指点武学。江云梦既是其女，又是其弟子。只是各派之中，弟子皆是十五年为一代，江云梦出生的比较晚，故而排在第三代。\n“云梦，”卢文锦柔声道，“刚才何故突然离席，一直耽搁到现在才回来？发生了什么事？”\n简简单单的一个问题，江云梦却不知道该怎么回答。说自己发现有不速之客在房顶鬼鬼祟祟，然后自己追出去截住了那人？但是却发现那人精通音律，自己对其音律造诣很欣赏，所以在林中待了半个多时辰？也许前半段能讲，但后半段话江云梦无疑是说不出来的。而且，如实告知师尊，师尊也决不会相信；以师尊的脾性，恐怕马上就会前去将张慎峰狠狠教训一顿，再严厉警告自己一番。支吾半天，江云梦决定囫囵过关，低声道：“刚才我抚琴时，感觉屋顶上有不速之客在旁观，故而追出去一探究竟，然而……然而却什么也没有发现。”\n卢文锦温柔看着江云梦，轻声道：“早就叫你勤加修习武学，你却置若罔闻，现在知道轻功的重要性了吧？须知天外有天，人外有人。以后要勤加修习，切不可如今日这般丢人现眼。”\n“是，师尊，弟子知错了。”江云梦俏脸一红，鞠身行礼。\n见师尊没有后话，江云梦恭谨地退下，和其余众女再度说起话来。然而卢文锦却绣眉微皱，陷入了沉思。刚才江云梦的回话可谓是漏洞百出，自己并没有揭穿她。江云梦身为自己的弟子，能发现墙外那人朝着律令阁外狂奔而去，难道自己和沈采薇、秦白露、寒湘子等师叔一辈的人物，坐在正房还能毫无所感么？不过是自重身份，不愿出手教训一无名小辈罢了。\n以卢文锦的感知，墙外那人的遁离速度远在江云梦之下，莫说是自墙角离开被发现，就是让他从真武殿往真武山门狂奔，让江云梦从律令阁开始追，两者相隔二十余里，卢文锦仍有把握江云梦能够将之截住。此番问询江云梦，她以为江云梦已然狠狠教训了那鬼祟小子，正要借此机会，教导她江湖中人心险恶，好色之徒众多，遇有此等货色，出手不必顾忌。没想到江云梦的答复却是“没有追到，什么也没有发现”。这大出她之所料。即使江云梦说的真的属实，确实没有追到那人，那么即刻返转便是，怎么会在外面待上半个多时辰呢？\n思索半天无果，卢文锦决定自己暗自调查一番。自己带着江云梦前来真武，首要的目的是要将联姻的事情敲定。门派利益高于一切，若是这个环节出了纰漏，天香很有可能陷入万劫不复的深渊。在此关头，不管江云梦刚才生出什么瓜葛，自己都要严防死守，不可生出纰漏。务必要如同母鸡一般守住自己的小鸡，把所有的意外都扼杀在萌芽之中。\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch9/","tags":[],"title":"第九章 待修改"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"What\u0026rsquo;s SLAM SLAM 是 Simultaneous Localization and Mapping，即同时定位与建图。\nhistory separate 最初，定位和建图问题是被看成两个独立问题研究的：\n定位问题的关键是事先给定环境地图； 建图问题的关键是实现给定机器人观测时刻的全局位姿； unify 1986 年将定位和建图问题放在概率论理论框架下统一研究 采用了基于概率论理论框架对机器人不确定性进行了讨论 将定位和建图中的机器人位姿量与路标点作为统一的估计量进行整体状态估计 2006 年使用 SLAM 名词进行表述 指定了详细的概率理论分析框架 对计算效率、数据关联、收敛性、一致性进行了讨论 aims SLAM 的目的是使装载了特定传感器的移动机器人能够：\n无先验环境知识的情况下 在移动过程中对周围进行建图 在移动过程中估计自己的运动和位置 status SLAM 在 无干扰 时，在 理论 层面上是一个已经被解决的问题 -\u0026gt; 工作环境限定在静态、刚体、光照变化不明显、没有人为干扰的场景时，SLAM 已相当成熟 现实中实现通用的 SLAM 解决方案存在实质性问题 -\u0026gt; 在构建和使用感知丰富的地图时存在重大问题(见数据关联部分) categories SLAM 依据概率图模型分为：\n基于贝叶斯网络的滤波方法(最大似然法) 基于因子图的优化方法(最小二乘法) classic 在贝叶斯网络中采用滤波法求解 SLAM 滤波法实时获取每一时刻的信息，并把信息分解到贝叶斯网络的概率中去 滤波法是在线 SLAM 系统，计算代价昂贵 滤波主要分为以下两种：\n参数滤波 参数滤波又分为卡尔曼滤波和信息滤波 SLAM 上目前应用广泛的是扩展卡尔曼滤波(EKF) 参数滤波在非线性问题上计算效率存在巨大问题，每一次观测后都需要对该协方差矩阵执行更新计算，地图规模很大时计算将无法进行下去 非参数滤波 粒子滤波(PF) -\u0026gt; Fast SLAM / Gmapping modern 在因子图中采用优化方法求解 SLAM 优化法简单地累积获取到的信息，然后利用之前所有时刻累积到的全局性信息离线计算机器人的轨迹和路标点 优化法是完全 SLAM 系统，一开始实时性较差，后来优化方法在稀疏性和增量求解方面的突破，以及闭环检测方面的研究具有重大价值 优化方法的计算信息存储在各个待估计变量的约束之中，利用这些约束条件构建目标函数进行优化求解，它是非线性化的最小二乘问题\n求解策略分为以下两种：\n线性化求解 对非线性化问题进行线性化近似处理 直接求解线性方程得到待估计量，如 Graph SLAM 迭代求解 利用迭代策略，让目标函数快速下降到最小处 如梯度下降法等 工具有：\nCeres-Solver 非线性优化 g2o 图优化 GTSAM 增量优化工具 iSAM mainstream 主流的 SLAM 多采用基于最小二乘的迭代优化求解\n激光 SLAM 粒子滤波 gmapping 室内 cartographer 室外 LOAM 视觉 SLAM 直接法 LSD_SLAM 半直接法 SVO_SLAM 稀疏法 ORB_SLAM 混合 SLAM 激光+视觉 rtabmap IMU + 视觉 VINS 深度 SLAM Key Definitions data association SLAM 建图是增量过程，环境路标信息需要被不断加入到已构建的地图中。\n数据关联的关键在于是否能将在 不同地方 观测到的 同一个实物 所产生的路标特征判断为同一个路标特征。\n数据关联可能由下列问题导致：\n传感器观测错误 -\u0026gt; 多传感器联合观测； 定位累积误差 -\u0026gt; 闭环检测是有效降低定位累积误差的方式； convergence 收敛用于衡量 SLAM 在理论上的可行性。\n机器人观测模型和运动模型都具有不确定性； 不确定性导致估计的路标特征与实际环境特征存在偏差； 在概率框架下，具有以下特性：观测越多，地标估计之间的相关性单调增加。即无论机器人运动如何，对地标相对位置的了解总是会提高，地标的联合概率密度会随观察次数增加而上升。\nconsistency 收敛的一致性讨论的是估计量收敛于实际数值的问题。\n弱一致收敛 -\u0026gt; 依概率收敛 -\u0026gt; 估计量取值与真值不一定一致 强一致收敛 -\u0026gt; 严格收敛 -\u0026gt; 估计量取值与真值一定一致 Probabilistic graphical model Bayes\u0026rsquo; theorem \\[ p(x|y)=\\frac{p(y|x)p(x)}{p(y)} \\]\n\\(p(y)\\) 与 \\(x\\) 是独立的，因此 \\(p(y)^{-1}\\) 对任何 \\(x\\) 的后验概率 \\(p(x|y)\\) 是相同的，故 \\(p(y)^{-1}\\) 在贝叶斯公式中常作归一化变量，用 \\(\\eta\\) 表示。\n\\[ p(x|y,z)=\\frac{p(y|x,z)p(x|z)}{p(y|z)} \\]\nPreliminaries 在一段连续时间中的运动分解到离散的时间 \\(t=1,2,\u0026hellip;K\\) 中，在这些时刻中：\n\\(x_k\\) 状态向量，描述在 \\(k\\) 时刻机器人的位置和方向 \\(u_k\\) 控制向量，描述在 \\(k-1\\) 时刻下达给机器人的指令，要求其在时刻 \\(k\\) 时状态转为 \\(x_k\\) \\(y_i\\) 地标向量，描述第 \\(i\\) 个位置的地标，假设其位置保持时间不变 \\(z_{k,j}\\) 在时刻 \\(k\\) 时（或在 \\(x_k\\) 状态时），观测到第 \\(j\\) 个地标点的观测向量 \\(X_{0:k}=\\{x_0,x_1,\u0026hellip;,x_k\\}=\\{X_{0:k-1},x_k\\}\\) 所有的状态向量的集合 \\(U_{1:k}=\\{u_1,u_2,\u0026hellip;,u_k\\}=\\{U_{1:k-1},u_k\\}\\) 所有的控制向量的集合 \\(y=\\{y_1,y_2,\u0026hellip;,y_n\\}\\) 代表所有的地标点的集合 \\(Z_{1:k}=\\{z_1,z_2,\u0026hellip;,z_k\\}=\\{Z_{1:k-1},z_k\\}\\) 代表所有的观测点的集合 Probabilistic SLAM probabilitiy distribution \\[ P(x_k,y|Z_{1:k},U_{1:k},X_{1:k})=P(x_k,y|Z_{1:k},U_{1:k},x_0) \\]\n它描述了机器人状态向量和地标集合在时刻 \\(k\\) 的联合后验概率密度。如果状态向量是完整的，那么它是所有以前时刻发生的所有状态的充分总结。\n具体来说， \\(x_{k-1}\\) 是直到 \\(k-t\\) 时刻的控制和测量的一个充分统计量，即 \\(U_{0;k-1}\\) 和 \\(Z_{0;k-1}\\) ，仅控制变量 \\(u_k\\) 关心状态 \\(x_{k-1}\\) 。\n\\[ P(x_k,y|Z_{1:k-1},U_{1:k},x_0)=P(x_k,y|x_{k-1},u_{k}) \\]\nobservation model \\[ P(z_k|Z_{1:k-1},U_{1:k},x_k,y)=P(z_k|x_k,y) \\]\n一旦机器人的状态和地图确定，观测值和给定地图和当前机器人状态是条件独立的。\nmotion model \\[ P(x_k|x_{k-1},u_k) \\]\n假设状态转换是一个马尔科夫链 观测和地图都是独立的 time-update \\[ P(x_k,y|Z_{1:k-1},U_{1:k},x_0)=\\int P(x_k|x_{k-1},u_k)P(x_{k-1},y|Z_{1:k-1},U_{1:k-1},x_0) dx \\]\nmesurement-update 测量更新过程：\n\\begin{align} P(x_k,y|Z_{1:k},U_{1:k},x_0)\u0026amp;=\\frac{P(z_k|Z_{1:k-1},U_{1:k},x_k,y)P(x_k,y|Z_{1:k-1},U_{1:k},x_0)}{P(z_k|Z_{1:k-1},U_{1:k})} \\notag \\\\ \u0026amp;=\\frac{P(z_k|x_k,y)P(x_k,y|Z_{1:k-1},U_{1:k},x_0)}{P(z_k|Z_{1:k},U_{1:k})} \\end{align}\nMath equation State 系统状态公式： \\[ P(x_k|x_{k-1},u_k) \\iff x_k = f(x_k-1,u_k,w_k) \\]\nObservation 观测状态公式： \\[ P(z_k|x_k,y) \\iff z_k = h(x_k,y,v_{k,j}) \\]\nClassical Visual SLAM Framework 传感器数据 -\u0026gt; 前端估计 -\u0026gt; 后端优化 -\u0026gt; 回环检测 -\u0026gt; 建图\nSensor data reading 相机图像信息读取和预处理，相机分为以下几类：\n单目(monocular) 立体(Stereo) 事件(event-based) 广角(omnidirectional) 深度(RGB-D) Visual Odometry 基于局部一致性提供机器人的位姿初步估计，估算相邻图像间相机的运动，以及局部地图的形状，并发送到后端进行优化\n特别地，视觉里程计的 累积漂移 被认为是不可避免的。\nOptimization 后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，得到 全局一致 的轨迹和地图。\n总体来说，后端优化处理 噪声 问题。\nLoop Closure Detection 回环检测判断是否达到过先前的位置，检测到回环会将信息提供给后端进行处理。\n通过判断图像相似性完成。\nMapping 根据估计的轨迹，建立地图。\nMetric Map 度量地图精确表示物体间的位置关系，分为稀疏和稠密两种。\n稀疏地图可用于定位 稠密地图可用于导航 度量地图目前有如下类别：\n2D 栅格地图 离散网格地图，稀疏表示 3D 点云地图 由激光雷达或 RGB-D 相机获取的大量点云数据，稠密表示 3D 网格地图 三角形或四边形网格，可提供高分辨率和精度的环境信息，稠密表示 Topological Map 拓扑地图强调元素之间的关系，只考虑节点的连通性。 2D 拓扑地图\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/1-slam-summary/","tags":[],"title":"SLAM Summary"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　“呼——”，习练完生太极招式的张慎峰长舒一口气，全身的心神不由得都放松下来，心中喃喃，“原先习练观水一式时，林林总总将近七天时间才略有小成，如今练习这紫霞功法的招式，只一下午便初见端倪，前后相比，实在令人惊诧不已。”转念一想，“难道竟真如师尊所说，自己在紫霞功上确实天赋异禀？”\n嘶，张慎峰倒吸一口凉气，自己都被自己心中跳起的这个想法吓了一大跳。随之他的内心也火热起来，试想，只一天苦练便能掌握一招一式，若是潜修三年五年，岂不是天下武功，尽入吾彀中矣？\n不过，很快他就冷静下来。师尊曾有教诲，“初生牛犊，血气方刚，争强好胜，此乃大忌。天下万事，铁杵磨针，水到渠成，此乃至理。贪功冒进，急功近利，竹篮打水，南柯一梦。”莫说是此刻他才刚刚略有小成，即使是功法趋于大成，也绝不能喜怒形于色，任性而为之。江湖险恶，洪荒万劫，不知道天高地厚之人，通常也不会知道自己什么时候就丢掉了性命。\n当然，冷静归冷静，毒辣的太阳很快让刚刚告诫自己需要有城府的某人破功。因为练完功后张慎峰还站在原地，保持着“茅厕背书，事半功倍；吊床练武，事倍功半”的指导思想；此刻接近巳时，按理说太阳蹉跌而下，开始偏西，不应该还是那么晒，然而烈日当空，毒辣丝毫未减，方才他站立的那片练功的土地，在太阳炙烤下干爽无比，仿佛之前汗出如浆，如同雨水般不停滴落在地，甚至要汇聚成一条小水渠的景象不过是一场幻觉，而唯一真实的，就是目前浑身上下哪都烫，加一勺鸡蛋可以马上煎荷包蛋那种。张慎峰瞬间破功，如同被踩了尾巴的松鼠一般跳将起来，毫无风度的大叫，“烫死我了，烫死我了。” 此刻的他，道袍虽然已被烈日曝晒蒸干，但之前浸透了汗水，此刻皱皱巴巴的完全不成样子；手中拂尘被水浸过以后更是绕成一绺，和之前在树下与师妹指点江山，激扬文字，雄姿英发，羽扇纶巾的他相比简直判若两人。不过形象毕竟讲究的是“恰逢其会”，此地是鲜有人至的密林，错非有师尊那样的大能者细细搜寻，或是如同刚才那位天香师妹般悄然跟随，根本没人想象的到他此刻究竟是什么狼狈模样。\n张慎峰擦擦汗，活动下双腿，施展开微风拂柳，灵巧地翻滚到阴凉的树荫下，一边向真武殿方向弟子居慢慢走去，一边心道下次练功完了沉思问题的时候要换个能遮阳的好树荫。\n比及他回到弟子居时，许多懒散的弟子早已经练完功法回来休息了，弟子居内叽叽喳喳的声音层出不穷，喧闹声在茅草屋前后徘徊，如同菜市场。众人谈天说地，热闹非凡。张慎峰径直回到自己的屋内，搬来木桶满上开水，准备泡了个热水澡，正在他跃入水中的功夫，几声低语传入了他的耳朵。\n“听说了吗，律令执掌寒湘子的亲传弟子燕书磐不知被谁给揍了，全身上下没一处囫囵样。我估摸着，没个一年半载的下不来床呢。”\n只这一句，张慎峰的耳朵连忙竖起，仔仔细细地捕捉着话语的细节。\n“解气！”门外的弟子声音中洋溢着“大仇得报”的兴奋，继续道，“燕书磐打着寒湘子的旗号作恶多端，我早就看他不顺眼了。上次我去太极道场，只想占个地方地打坐行功，没成想他姓燕的居然说中间整一块地都是他的专属，真是岂有此理！”\n“没办法，谁叫人家拜上了个好师父呢。若是天赋异禀的入室弟子，真武山九室岩哪里不能建石房？挑一处云海胜景，住的那叫一个舒坦自在，哪像咱们武道院的弟子，只能在弟子居住茅草屋，即使是有幸拜师，师父也是闲云野鹤，神龙见首不见尾。遇到事情的关键时刻没人帮忙出头，只能自认晦气。”\n“恶人终有恶报。下午我在太极道场，听一位二代弟子说，这次来真武山论剑的天香的姑娘们都住在律令阁呢。寒湘子本来想让燕书磐和天香的姑娘们见见面，交流交流，这下倒好，他姓燕的被打的只能躺在榻上，还怎么和天香姑娘见面？怕是只能在梦里交流了，哈哈哈……”\n张慎峰听着门外众人聊天的声音，心里细细盘算着。今天所发生的事情与平日迥然不同：早上是他张慎峰和燕书磐起了冲突。虽然说本来他是要教训燕书磐一番，没成想一云子师叔突然出现，帮他代劳了。只是不知道寒湘子师叔听了整件事的经过后会是什么反应。若是论公道论规矩自然是自己有理，怕只怕现在不比往日：若果真江师妹是天香与真武联姻的棋子，天香一行姑娘们不与其他门派一样在知客居起居，而把行止定在律令阁，就说明商谈联姻的事情着落在真武律令阁执掌寒湘子的座下弟子中。若是寒湘子的其他弟子还好说，可若寒湘子正是想让燕书磐联姻的话，事情就麻烦了。早上一云子师叔才把他打破相，岂不是“坏了大事”。寒湘子拍起桌子来，不比自家师尊差。这把火他没法冲一云子师叔发，会不会把气撒到他的身上呢？自家师尊又会不会出面保自己呢？\n想到这里，张慎峰感到一阵后悔。他拜入真武门墙不过区区两年，入武道院才一年有余，根基未稳，根本没必要和燕书磐起冲突。崭露头角是好事，若是寻常与寒湘子的亲传弟子切磋，双方点到为止，那么一展所学完全没有任何问题。借力打力，教训燕书磐，也无可厚非。只是眼下时机不对，寒湘子将燕书磐视若己出，以致于自己可能陷入是非之中。张慎峰脸上满是严肃，内心默默告诫自己，以后行事需要更加谨慎，更加稳健，三思而行。与其崭露头角，不如深藏功与名。\n“张慎峰回来没？张慎峰回来没？”门外传来呼喊声，惊得正在泡澡的张慎峰差点淹死在木桶里。不能吧，难道这么快寒湘子就查到早上和燕书磐在太极道场斗殴的是自己了？不应该啊，燕书磐并不认识自己，即使是自己曾经说漏了自称敝姓张，按照姓氏查没有一千也有五百弟子，怎么可能直接就找到他？再者万一他其实故意假称自己姓张呢，燕书磐根本没办法验证，至于寒湘子师叔他老人家，那更是三代弟子一个不识。张慎峰压住心神，又听了几声呼喊，终于反应过来，这是他在武道院的两位好友，冯道逸和荆法墨来找他交流心得来了。\n举凡真武山弟子，分为两派，一曰入室弟子，一曰武道院。武道院弟子属于天资平平无奇或武功进境不佳，一般没有机缘拜师，都是各师叔轮流教授。因此，平日练功，弟子们总会三两聚在一起交流功法心得。若是武道院的弟子有幸拜师，有些好心的弟子还会将师尊所授功法分享给其他尚未拜师的弟子。“苟富贵，勿相忘。”这种真诚的情谊只有在武道院才有所体现。而那些入门便被收作入室弟子的青年，一个个心比天高，莫说分享功法，恐怕就是和和气气打个招呼，都会互相打探半天。\n既然是好友来唤，张慎峰按下先前的疑惑，擦干水珠，一边穿上道袍，一边只将脑袋探出屋外道：“两位师兄，我已回来了。”\n“哎呀，今儿幸好你回来了，我们在路上都担心你还在山上勤奋练功，未曾回来呢！险些误了机缘！”冯道逸一面急急跑过来，对张慎峰说道，一面将拧成川字形的眉毛舒开。\n“机缘？”张慎峰一头雾水，练功便练功，回来便回来，哪里有什么机缘？\n“张师弟有所不知，”在远处站着的荆法墨打开一把墨色折扇，轻轻摇了起来，悠然道，“一年一度的江湖论剑将至，听二代弟子说，江湖之中其他门派已来到我真武山。”\n荆法墨一向话只说半句，非得显得他莫测高深才罢休。张慎峰暗自腹诽，心道这消息我早知道了，不光如此今天我还被一众二代弟子挟在律令阁房顶上听琴呢，结果某个倒霉弟子脚踩塌了瓦片，我被他们当作弃卒留在原地，差点被师叔们当场捉住。好不容易逃出生天，没想到被抚琴的天香师妹跟了一路……等等，江湖中其他门派已到真武和机缘有什么联系？\n当然，这些话张慎峰是肯定不会讲出来的，关键是讲出来也没人信哪。张慎峰摆出一副虚心求教的态度，认真道：“敢问师兄，机缘何在？”\n眼见得荆法墨又要摇折扇，冯道逸连忙摆手打断，道：“别听那酸道士的，我跟你讲，天香这次来了一百多位师妹，有素问轩的，有星罗居的，还有万蝶坪的；有长的，有短的；有可爱的，有冷艳的，总之什么样的都有。晚上她们将在长生楼放花灯，这可是千载难逢的好机会，来咱们真武山的其他门派的弟子估计很快也会得到消息，不久也会赶过去。僧多粥少，咱们真武派这次是主场，可得抓住机遇，若是到时候其他门派的弟子比咱们抱得美人归还要多一些，脸上须不好看。”\n张慎峰哭笑不得，这形容天香师妹有可爱的有冷艳的云云还算将就过得去，形容有长的有短的是什么鬼？再者说了，各派之中也不乏“师妹”啊，习武之人讲求修身养性，真武更是强调以天地万法为道，修身养性为\n就在这时，后面接连传来数十声破空声，旋即数十道身影迅速飞掠而过，向着真武殿方向急急奔去。张慎峰连忙抬眼\n","permalink":"https://endlesspeak.github.io/novel/volume1/ch10/","tags":[],"title":"第十章 待修改"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"二叉排序树 查找长度计算 查找成功情况下： $$\rASL_{成功}=\\frac{SearchLength}{N}\r$$ $SearchLength$是链表中搜索各有值结点的路径长度和；\n$N$是二叉排序树中结点的个数。 $$\rSearchLength=\\sum_{i=1}^{N}l_i\r$$ $l_i$是每个结点从根结点到该结点的长度。\n查找失败情况下： $$\rASL_{失败}=\\frac{SearchLength'}{N’}\r$$ $SearchLength\u0026rsquo;$是链表中搜索非满孩子的结点的虚拟子结点路径长度和； $$\rSearchLength'=\\sum_{i=1}^{N'}l'_i\r$$ $l\u0026rsquo;_i$是每个非满孩子的结点的虚拟子结点从根结点到该结点的长度。\n$N’$是二叉排序树中各叶子结点的虚拟子结点的个数。\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/binary-tree-sort-caculation/","tags":[],"title":"二叉排序树"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"　“为什么？为什么你的心中只有剑，难道我为你做的这一切，甚至拨不起你的心中的一道褶皱吗？”张慎峰披头散发，状若疯魔，脸上泛着血色的光，眼中似有火焰在燃烧，浑身冒着可怖的黑烟，眼前的妙人儿虽然如夜空的明珠，散发着无穷的魅力，但在此刻失心疯魔的眼里就像是轮回中的恶鬼，没有半点美好与纯真。\n江云梦低着头，轻声道：“我只是想要闭关一段时间，并不是……”她嘴唇翕忽，眼睛轻眨，“只是，只是我也没有想好，到底该把你放在什么位置……”言语逐渐声如蚊呐。\n“既然相见非欢，话不投机，何必再浪费时间？”失心疯魔挥舞起手中的狼牙棒，“与其饱受折磨，不如就此毁灭！我要将你化作永生魔魂，填我心缺！”说罢，他举起狼牙棒，急速朝着妙人奔来。\n“天裂！”黑发披散，完全遮住了失心疯魔的头；呼声高亢，惊地四地鸟儿急速掠起。目眦尽裂的双眼从落下的黑发中猛然探出，而狼牙棒也在此时如暴雨般向下砸落，看似狂野的动作中充满了艰涩和阻滞，但狼牙棒的速度未有丝毫衰减。江云梦眼神中闪过一丝挣扎，道：“不……”然而这细微的声音很快便被失心疯魔的高呼所掩盖，眼见其力势沉重无比，江云梦展开身形，迅捷地向旁边躲闪，同时快速抽出手中的寒柏剑向上挑隔，意图架开狼牙棒的砸击。\n“铛！”一声令人牙酸到极点的嗡鸣，狼牙棒与寒柏交会，而后沉重地砸落地面，江云梦向后踉跄几步，试图卸去狼牙棒上传来的沉重的力量。\n然而失心疯魔不给她缓气的机会，再度大吼道：“天憎！”狼牙棒在他手中灵活地探出，而后猛地横向朝着江云梦的脸庞打去。这一探打的速度之快，甚至带出了与空气摩擦的音震。江云梦不敢正面迎击，手中的剑忽地撑开作伞，似盾一般挡在身前。\n“铛！”又一声艰涩的哀鸣，江云梦连着她手中的伞剑一起朝后倒飞而出，白伞上多了点点血色。而失心疯魔的双手和脸庞溢出冒着黑气的血，一层一层的魔气在他身上缭绕，而后四散而开，散发着恐怖的气息。\n“天恶！”失心疯魔向头顶张开双臂，狼牙棒上举，一个巨型漩涡在他头顶出现，电光闪闪，风雨大作，而后如水桶粗细的闪电飞快地朝着前方砸去，刚刚站稳的江云梦举伞水平挥舞，播撒下一粒粒种子，而后迅速形成一棵棵坚实的树，温和的春风与盎然的绿色呈一字长蛇水平铺开，构成一堵坚硬的厚墙，横亘在她与张慎峰之间。\n“啪！”巨大的闪电在绿墙上砸开，砸的耳膜刺痛，脑中嗡鸣。刚刚还充满生机和绿意的厚墙此刻一片焦黑，而江云梦本身也如遭雷击般地跌坐在地，连声呛咳，脸上尽是潮红血色，手上亦是鲜血淋漓。\n“天恨！”失心疯魔将狼牙棒高举过头顶，似乎举起了整个世界，而后斜斜砸下，带起一阵劲风！雨水在此刻化作焦黄的脓水与焦黑的血水，雷电也在此刻闪烁着极度刺眼的白色光芒。白伞像是荷花上巨大的莲蓬，耷拉着撑开，竭力在此刻投下一片安定与祥和。然而随着一声爆炸巨响，白伞化成了漫天星光，伞下的雪白也蓦然化成四散炸裂的血肉，煞是恐怖。\n失心疯魔跪倒在地，双目无神，呐呐重复道：“怨憎会，爱别离；怨憎会，爱别离……”说罢，狼牙棒倒挥，顿时脖颈处血肉模糊，一颗大好头颅直冲天空，鲜血飙射不止，随后无穷尽的魔气爆裂开来，遮盖了整个天空……\n……　“要闭关？”\n“是。”\n“为何？”\n“心中杂念太多，剑法阻滞迟缓，失之锐气。希望借闭关之契，斩断杂念，悟得剑法精义，更上层楼。”\n“何者为杂念？”\n“非剑者皆杂念。”\n“你觉得，一个剑客，便该有斩杀一切的态度，面对任何事物，都有一剑斩断的决心。任世间千变万化，只要一剑在手，便无可怕。心中无所畏惧，便能一往无前。是也不是？”\n“是。”\n“你觉得，一个剑客，应该心中只有三尺长剑，剑出无他无我，心无旁骛，与剑真正鱼水相融，合为一体，方能臻至剑法巅峰，成为剑之宗师，剑法趋于大成，是也不是？”\n“是。”\n“你觉得，一个剑客，合该是傲如苍鹰，如高山之巅上的冰雪一般寒冷的人。是也不是？“\n“是。”\n“你还记得，当初你为何学剑吗？”\n江云梦的眼神中掠过一丝迟疑，逐渐变得犹豫，断续道：“师尊您曾说，学剑乃为求道，习武乃为止武。”\n卢文锦点点头，温声道：“嗯，难为你还记得，学剑求道，习武止武。既然如此，你应当知道，习武之初心与少林武训皆是同理，杀生为护生，斩业非斩人。你在万蝶坪时，由音入武，当知音律如露，涤荡三千红尘邪恶；你在素问轩时，由医入武，当知医术如泉，可解世人性命病渴；你在太白山时，由剑入武，当知剑法如海，可纳天下苍生安宁。”\n“吾辈习武之人，虽未尝从文，亦应有治人者的胸襟和志向，为天地立心，为生民立命，为往圣继绝学，为万世开太平。让世间贪恶无从匿形，让世间欲念无从遁身，让世间一切归于自然，归于平和，归于安宁，归于美好。”\n“你融寒柏剑心，修太白剑诀，练无痕剑意，剑法已有所成，但却始终看不到剑道为何物。其实，剑道，在人心，在守护，在情。剑道有情，如剑法得魂。”\n“圣人何以不可欺也？圣人以己度人者也，以心度心，以情度情，以类度类。我辈也许达不到圣人的境界，但也应时刻心怀善念，将心比心。”\n“剑法没有终点，道高一尺魔高一丈，因此需常修习之；但只练剑而不知为何练剑，是为练而练，最后只能将自身都合为剑，变成彻头彻尾的杀戮机器，也就违背了练剑的初衷，与剑道相去甚远。只有时刻牢记习武初心，剑与情相融合，与守护融合，剑才有魂魄，才能在遇到挫折的情况下不畏困难，得到继续前进下去的动力，如此，剑法才会在剑道的指引下进步，从而不断接近圆满。”\n“学剑需要爱剑，但不该唯爱剑。剑是手段，不是目的；剑是道路，不是风景；剑是叶，不是花；剑是云，不是雨，剑在手，不在心。”\n“可是师尊，剑不在心，心中为何物？”\n“剑不在心，是指剑客不能任由剑在心中变化，影响心境；心中有剑，是有剑法，有剑意，有剑道，有剑魂。剑意指导剑法，使其不失招式变化奥妙；剑道规整剑意，使其不致陷入狂暴与迷乱；剑魂升华剑道，为其赋生。”\n一阵氤氲，雾气散去，江云梦猛地坐起，映入眼帘的是满山遍野的鲜花，细微的像碎玉一般，红如血的宝珠山茶，白中隐青的单瓣梅花，盛开着如眼睛一样晶莹的紫罗兰，一轮红日从东方升起，这片无垠的花海一直绵延的山的尽头。一群群蝴蝶飞舞在花海中央，翅膀上一层薄薄的鳞片闪烁着七彩的光芒，一双双小小的眼睛看着四面八方，但一会儿又陶醉在了香甜的花蜜之中。这是天香谷？万蝶坪？江云梦这才反应过来，自己原来躺在万顷花海之中，刚才的桩桩件件都是南柯一梦。想到这里，她黛眉低垂，美目中浮上了一层厚厚地水雾，泪珠如同珍珠一般沿着洁白如玉的脸颊落在褐黄的土地上，“师尊……”\n站立在不远处眺望远方的青衫男子听到身后动静，转过身形，眼神温和，满脸平静，带着一丝笑意，和声道：“你醒了？身体如何？还有哪里不舒服吗？昨天你在昏迷中一直高喊哭泣不止，怎么也停不下来。几位师妹说万蝶玶的鲜花有宁神静意的功效，我便采了许多放在你房中。可是放满了鲜花也没用，柳师姐说不如让你在万蝶玶中静养，于是我便请她将你放在这花海之中。果然，在花海中你便平静了许多。此际清晨，花上多有露珠，我还怕……”话未说完，青衫男子突然蹲下，拿出一方蝴丝手帕，拭去妙人儿眼角的泪痕，轻声道：“怎么了，你怎么哭了？”\n江云梦尝试动了动，将整个人蜷在一起，桃杏般地双眼此刻红的透紫，颦蛾呜咽道：“我，我好像做了一个，不是，两个很奇怪的梦……”\n","permalink":"https://endlesspeak.github.io/novel/volume1/extra/","tags":[],"title":"第X章 待修改"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"图的定义 图G由顶点集V和边集E组成，记为G=(V,E)。\n其中V(G) 表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系集合（即边集）。 用|V|表示图G中的顶点个数，又称为图的阶。 用|E|表示图G中边的条数。 特别地，线性表可以是空表，树可以是空树，图不能是空图。即必须有顶点，可以无边。\n简单图 图满足不存在重复的边，也不存在顶点到自身的边，称为简单图。\n多重图 图某两个结点之间存在多条边，或允许顶点与自身相连，称为多重图。\n父子图 G=(V,E),G\u0026rsquo;=(V\u0026rsquo;,E\u0026rsquo;)，若V\u0026rsquo;是V的子集,E\u0026rsquo;是E的子集，则G‘是G的子图。\n如果G的子图的顶点集和G一样，即V(G\u0026rsquo;)=V(G)，则称该子图为G的生成子图。\n无向图 若E是无向边（简称边），则图为无向图。\n边是顶点的无序对，记为(v,w)。\n连通图和连通分量 在无向图中，若v到w有路径存在，则两点是连通的。\n若任意两点均连通，则图为连通图，否则为非连通图。\n连通分量指的是极大连通子图（极大指的是边数极大，即该连通子图包含它所有的边）\n常见结论：\n非连通图最多可能有$C_{n-1}^{2}$条边。\n连通图最少有$n-1$条边；小于$n-1$条边必是非连通图。\n$n$个顶点保证连通，则有$C_{n-1}^{2}+1$条边。\n注：必须前$n-1$个顶点互通，最后任连一条边到最后一个顶点上。\n生成树和生成森林 连通图的生成树指的是包含全部顶点的极小连通子图（极小指的是边数极小而保持连通）\n常见结论：\n$n$个顶点的生成树含有$n-1$条边。\n生成树任意去掉一条边则变成非连通图，任意加上一条边则形成环。\n推论：$n$个顶点$n$条边可能不是连通图，但一定有环。\n有向图 若E是有向边（简称弧），则图为有向图。\n弧是顶点的有序对，记为\u0026lt;v,w\u0026gt;。起点v为尾，终点w为头。\n强连通图和强连通分量 在有向图中，若从v到w和从w到v都有路径存在（即能往返），则两点是强连通的。\n若任意两点均是强连通的，则图为强连通图。\n强连通分量指的是极大强连通子图（极大指的是边数极大，即该强连通子图包含它所有的边）\n常见结论：强连通图最少有$n$条边。\n顶点的度 无向图中，顶点的度是依附于该顶点的边的条数，记为TD(v)。\n有向图中，顶点的度分为入度和出度，入度是以顶点v为终点（即指向该点）的有向边的数目，记为ID(v)；出度是以顶点v为起点（即从该点指向其他点）的有向边的数目，记为OD(v)。顶点的度等于其入度和出度数之和。即TD(v)=ID(v)+OD(v)。\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/map-basic-terms/","tags":[],"title":"图的基本概念"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Floyd算法 解题步骤：\n图的顶点从\\(V_0\\)开始，依次标记所有顶点位序；\n按图画出邻接矩阵\\(A^{-1}\\)；\\(path^{0}\\)矩阵全取-1。\n顶点 \\(i\\) 作中间顶点时遍历时，邻接矩阵\\(A^i\\)只画出第i行和第i列，补齐对角线中的0。\n对第 \\(i\\) 行和第 \\(i\\) 列中的每个元素求十字交叉的值与邻接矩阵\\(A^{i-1}\\)对应的值比较，小则替换之。\n如有替换，顺手把 \\(path^i\\) 的第 \\(i\\) 行第 \\(i\\) 列的值改成 \\(i\\) 。\n例题：（电子科技大学2016年）利用Floyd算法计算每次迭代的结果。 \\[ dist^{-1}=\\left[ \\begin{array}{c} 0 \u0026amp; 1 \u0026amp; 4 \u0026amp; \\infty \\\\ \\infty \u0026amp; 0 \u0026amp; 2 \u0026amp; 5 \\\\ \\infty \u0026amp; \\infty \u0026amp; 0 \u0026amp; 1 \\\\ 2 \u0026amp; \\infty \u0026amp; \\infty \u0026amp; 0 \\\\ \\end{array} \\right] \\ path^{-1}=\\left[ \\begin{array}{c} -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \\\\ -1 \u0026amp; -1 \u0026amp; 1 \u0026amp; 1 \\\\ -1 \u0026amp; -1 \u0026amp; -1 \u0026amp; 2 \\\\ 3 \u0026amp; -1 \u0026amp; -1 \u0026amp; -1 \\\\ \\end{array} \\right] \\]\n第一次迭代：\n\\[ dist^{0}=\\left[ \\begin{array}{c:ccc} 0 \u0026amp; 1 \u0026amp; 4 \u0026amp; \\infty \\\\ \\hdashline \\infty \u0026amp; 0 \u0026amp; 2 \u0026amp; 5 \\\\ \\infty \u0026amp; \\infty \u0026amp; 0 \u0026amp; 1 \\\\ 2 \u0026amp; 3 \u0026amp; 6 \u0026amp; 0 \\\\ \\end{array} \\right] \\ path^{0}=\\left[ \\begin{array}{c} -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \\\\ -1 \u0026amp; -1 \u0026amp; 1 \u0026amp; 1 \\\\ -1 \u0026amp; -1 \u0026amp; -1 \u0026amp; 2 \\\\ 3 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \\\\ \\end{array} \\right] \\]\n第二次迭代：\n\\[ dist^{1}=\\left[ \\begin{array}{c:c:cc} 0 \u0026amp; 1 \u0026amp; 3 \u0026amp; 6 \\\\ \\hdashline \\infty \u0026amp; 0 \u0026amp; 2 \u0026amp; 5 \\\\ \\hdashline \\infty \u0026amp; \\infty \u0026amp; 0 \u0026amp; 1 \\\\ 2 \u0026amp; 3 \u0026amp; 5 \u0026amp; 0 \\\\ \\end{array} \\right] \\ path^{1}=\\left[ \\begin{array}{c} -1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1 \\\\ -1 \u0026amp; -1 \u0026amp; 1 \u0026amp; 1 \\\\ -1 \u0026amp; -1 \u0026amp; -1 \u0026amp; 2 \\\\ 3 \u0026amp; 0 \u0026amp; 1 \u0026amp; -1 \\\\ \\end{array} \\right] \\]\n第三次迭代：\n\\[ dist^{2}=\\left[ \\begin{array}{cc:c:c} 0 \u0026amp; 1 \u0026amp; 3 \u0026amp; 4 \\\\ \\infty \u0026amp; 0 \u0026amp; 2 \u0026amp; 3 \\\\ \\hdashline \\infty \u0026amp; \\infty \u0026amp; 0 \u0026amp; 1 \\\\ \\hdashline 2 \u0026amp; 3 \u0026amp; 5 \u0026amp; 0 \\\\ \\end{array} \\right] \\ path^{2}=\\left[ \\begin{array}{c} -1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 2 \\\\ -1 \u0026amp; -1 \u0026amp; 1 \u0026amp; 2 \\\\ -1 \u0026amp; -1 \u0026amp; -1 \u0026amp; 2 \\\\ 3 \u0026amp; 0 \u0026amp; 1 \u0026amp; -1 \\\\ \\end{array} \\right] \\]\n第四次迭代：\n\\[ dist^{3}=\\left[ \\begin{array}{ccc:c} 0 \u0026amp; 1 \u0026amp; 3 \u0026amp; 4 \\\\ 5 \u0026amp; 0 \u0026amp; 2 \u0026amp; 3 \\\\ 3 \u0026amp; 4 \u0026amp; 0 \u0026amp; 1 \\\\ \\hdashline 2 \u0026amp; 3 \u0026amp; 5 \u0026amp; 0 \\\\ \\end{array} \\right] \\ path^{3}=\\left[ \\begin{array}{c} -1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 2 \\\\ 3 \u0026amp; -1 \u0026amp; 1 \u0026amp; 2 \\\\ 3 \u0026amp; 3 \u0026amp; -1 \u0026amp; 2 \\\\ 3 \u0026amp; 0 \u0026amp; 1 \u0026amp; -1 \\\\ \\end{array} \\right] \\]\n","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/map-floyd-algorithms/","tags":[],"title":"图的弗洛伊德算法"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"处理冲突方法 主要分为开放定址法、拉链法（链地址法）和再散列法。\n开放定址法 开放定址法意思是可存放新表项的空闲地址既向同义词开放，又向非同义词开放。 $$\rH_i=(H(key)+d_i)\\%m\r$$ 主要分为\n线性探测（再散列）法 平方探测（再散列）法；二次探测（再散列）法 伪随机序列（再散列）法。 查找长度计算 线性探测法 查找成功 $$\rASL_{成功}=\\frac{SearchCount}{N}\r$$ 对于查找次数$SearchCount$，它是通过哈希函数查找到各元素的次数总和，即： $$\rSearchCount=\\sum_{i=1}^{N}a_{i}\r$$ $$\ra_i=\\begin{equation}\r\\left\\{\r\\begin{array}{lr}\r1 \u0026 若元素无冲突 \\\\\r... \u0026 冲突次数不确定 \\\\ \\end{array}\r\\right.\r\\end{equation}\r$$ 查找失败 $$\rASL_{失败}=\\frac{SearchCount'}{p}\r$$ 对于质数$p$，它是哈希函数选取的用作MOD的数。\n对于查找次数$SearchCount’$，它是对长为质数$p$的表中各个元素一直查找到空为止的次数和，即： $$\rSearchCount'=\\sum_{i=1}^{p}p_i\r$$ $$\rp_i=\\begin{equation}\r\\left\\{\r\\begin{array}{lr}\r1 \u0026 若表的该处为空 \\\\\rN-i+1 \u0026 若该处一直到表的结尾均不为空 \\\\\r... \u0026 到空位置为止，空位置算一次 \\\\ \\end{array}\r\\right.\r\\end{equation}\r$$ 哈希表长$m\u0026gt;p$。\n链地址法 查找成功 $$\rASL_{成功}=\\frac{SearchLength}{N}\r$$ $SearchLength$是链表中搜索各有值结点的路径长度和； $$\rSearchLength=\\sum_{i=1}^{N}l_i\r$$ $l_i$是每个元素从链结点到该结点的长度；\n$N$是关键字序列的个数(即链表中的空元素不计算)；\n$p$是链表长度(拉链长度通常取质数$p$，小于表长)。\n查找失败 $$\rASL_{失败}=\\frac{N}{p}\r$$ ","permalink":"https://endlesspeak.github.io/docs/docs/interview-doc/data-structure/search-hash/","tags":[],"title":"散列查找"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Visual SLAM 在计算机视觉中，与同时定位与地图构建(Simultaneous Localization And Mapping)相似的是运动推断结构(Structure from motion,SFM)，实时的 SFM 属于 VSLAM 的范畴。\nBasic Principle VSLAM 的基本原理为多视图几何原理。\nVSLAM 的目标是同时恢复出每帧图像对应的相机运动参数 \\(C_1,\u0026hellip;,C_m\\) ，以及场景的三维结构 \\(\\boldsymbol{X}_1,\u0026hellip;,\\boldsymbol{X}_n\\) 。\nCamera Parameters 相机运动参数是描述相机在世界坐标系中的运动状态的向量 每个相机运动参数 \\(C_i\\) 包含了相机的位置和朝向信息，或者包含相机的平移和旋转的信息 相机运动参数通常表达为一个 3×3 的旋转矩阵(或四元数、欧拉角等) \\(R_i\\) 和一个三维位置变量 \\(p_i\\) (或位移向量)。 通过恢复相机运动参数，可以了解相机在场景中的位置和姿态变化，以将不同帧的图像对齐并构建出场景的三维结构 Three-dimensional Structure 场景的三维结构表示相机看到的场景中每个物体点的三维位置 三维结构向量通常由每个特征点的三维坐标组成，每个特征点代表场景中的一个 关键点 ，它们可以是角点、边缘、纹理等 通过恢复特征点的三维坐标，可以重建场景三维结构 Transform Equation VSLAM的目标是同时恢复出每帧图像对应的相机运动参数 $C_1 \\dots C_m$ 及场景三维结构 $X_1 \\dots X_n$，其中每个相机运动参数的含义和表达如前文所述。\n\\(R_i\\) 和 \\(p_i\\) 将世界坐标系下的三维点 \\(X_j\\) 变换到 \\(C_i\\) 的局部坐标系： \\[ (\\boldsymbol{X}_{ij},\\boldsymbol{Y}_{ij},\\boldsymbol{Z}_{ij})^T=\\boldsymbol{R}_i(\\boldsymbol{X}_j-\\boldsymbol{p}_i) \\]\n进而投影到图像中： \\[ \\boldsymbol{h}_{ij}=(\\frac{f_x\\boldsymbol{X}_{ij}}{\\boldsymbol{Z}_{ij}}+c_x,\\frac{f_y\\boldsymbol{Y}_{ij}}{\\boldsymbol{Z}_{ij}}+c_y)^T \\]\n其中，\\(f_x\\) 和 \\(f_y\\) 分别为沿图像 \\(x,y\\) 轴的图像焦距，\\((c_x,c_y)\\) 为镜头光心在图像中的位置，这些参数应当已事先标定且保持不变。\nVSLAM\u0026rsquo;s Target Function 三维点在图像中的投影位置 \\(\\boldsymbol{h}_{ij}\\) 可表示为如下函数： \\[ \\boldsymbol{h}_{ij}=h(C_i,\\boldsymbol{X}_j) \\]\nV-SLAM 需要将不同图像中对应于相同场景点的图像点匹配起来，求解优化函数： \\[ { \\underset{C_1\u0026hellip;C_m,\\boldsymbol{X}_1\u0026hellip;\\boldsymbol{X}_n}{\\arg\\min}} \\sum_{i=1}^{m} \\sum_{j=1}^{n} \\lVert h(C_i,\\boldsymbol{X}_j)-\\boldsymbol{\\hat{x}}_{ij} \\rVert \\]\n得到一组最优的 \\(C_1,\u0026hellip;,C_m,\\boldsymbol{X}_1,\u0026hellip;,\\boldsymbol{X}_n\\) 使得所有的 \\(\\boldsymbol{X}_j\\) 在\\(C_i\\) 图像中的投影位置 \\(h_{ij}\\) 与观测到的图像点位置 \\(X_{ij}\\) 尽可能靠近。\n以上过程假设图像观测点符合高斯分布\n\\begin{align} x_{ij} \\sim N(\\boldsymbol{\\hat{x}}_{ij}, \\Sigma_{ij}) \\notag \\\\ \\lVert e \\rVert_{\\Sigma} = e^T \\Sigma^{-1} e \\notag \\end{align}\n求解优化函数的过程称为集束调整(bundle adjustment,BA)，一般用线性方程的稀疏结构求解\nSensors Combination VSLAM 受图像特征匹配限制，稳定性很大程度依赖场景特征的丰富程度，因此加入多传感器用于帮助判断相机的运动是必要的。\nTarget Optimization function 常用的是在 VSLAM 中结合 IMU 数据，形成 VIN(Visual-aided inertial navigation)或 VI-SLAM(Visual-inertial SLAM)\n将相邻 2 帧 \\((C_i,C_{i+1})\\) 间所有 IMU 数据标记为集合 \\(Z_i={z_1\u0026hellip;z_{n_{i}}}\\) ，VI-SLAM 求解优化如下目标函数： \\[ { \\underset{C_1\u0026hellip;C_m,\\boldsymbol{X}_1\u0026hellip;\\boldsymbol{X}_n }{\\arg\\min}} \\sum_{i=1}^{m} \\sum_{j=1}^{n} \\lVert h(C_i,\\boldsymbol{X}_j)-\\hat{x}_{ij} \\rVert_{\\Sigma_{ij}} + \\sum_{i=1}^{m-1} \\lVert f(C_i,Z_i)-C_{i+1} \\rVert_{\\Gamma_{i}} \\]\nSport Equation VI-SLAM 引入了一个运动方程，其中 \\(f(C_i,Z_i)\\) 为 \\(Z_i\\) 作用于 \\(C_i\\) 后的运动参数，\\(\\Gamma_i\\) 是运动方程的协方差矩阵。常见的运动方程有：\n连续时间系统 预积分方程 通常，VI-SLAM 需要求解每一时刻的运动速度 \\(\\boldsymbol{v_i}\\) 和 IMU 数据的偏移量 \\(\\boldsymbol{b_i}\\) \\[ C_i=(\\boldsymbol{R}_i,\\boldsymbol{p}_i,\\boldsymbol{v}_i,\\boldsymbol{b}_i) \\]\nGPS 需要再引入一项 GPS 数据 \\(\\boldsymbol{p}_i^{G}\\)到目标函数中： \\[ { \\underset{C_1\u0026hellip;C_m,\\boldsymbol{X}_1\u0026hellip;\\boldsymbol{X}_n }{\\arg\\min}} \\sum_{i=1}^{m} \\sum_{j=1}^{n} \\lVert h(C_i,\\boldsymbol{X}_j)-\\hat{x}_{ij} \\rVert_{\\Sigma_{ij}} + \\sum_{i=1}^{m-1} \\lVert f(C_i,Z_i)-C_{i+1} \\rVert_{\\Gamma_{i}} + \\sum_{i=1}^{m-1} \\lVert \\boldsymbol{p}_i - \\boldsymbol{\\hat{p}}_i^{G} \\rVert_{\\Lambda_i} \\]\nVSLAM System 主流 VSLAM 系统分为 3 类：\n基于滤波 基于关键帧 BA 基于直接跟踪 Filter based VSLAM 基本思想：将每一时刻 \\(t\\) 的系统状态用一个高斯概率模型表达 \\(x_t \\sim N(\\boldsymbol{\\hat{x}}_t,\\boldsymbol{\\hat{P}}_t)\\)\n其中 \\(\\hat{x}_t\\) 为当前时刻系统状态估计值，\\(\\boldsymbol{P}_t\\) 为估计值误差的协方差矩阵。\nMonoSLAM MonoSLAM 的状态 \\(\\boldsymbol{x}_t=[C_1,\u0026hellip;,C_m,\\boldsymbol{X}_1,\u0026hellip;,\\boldsymbol{X}_n]\\)\n其每一时刻相机方位均带有一个概率偏差，每个三维点位也带有一个概率偏差，可用三维椭球表示，椭球中心为估计值，椭球体积表示不确定程度，场景点投影至图像的形状为一个投影概率椭圆。\nMonoSLAM 选用的是扩展卡尔曼滤波 EKF，预测阶段采用运动方程： \\[ C_{t}=f(C_{t-1},\\boldsymbol{a}_{\\nu}\\Delta t,\\boldsymbol{a}_{\\omega}\\Delta t) \\]\n其中，\\(\\boldsymbol{a}_\\nu\\) 和 \\(\\boldsymbol{a}_\\omega\\) 分别为线性和旋转加速度，并假设它们符合高斯分布 \\(\\boldsymbol{a}_\\nu \\sim N(0,\\Gamma_\\nu)\\) ，\\(\\boldsymbol{a}_\\omega \\sim N(0,\\Gamma_\\omega)\\) 在更新阶段采用投影方程： \\[ \\hat{x}_{j}=h(C_{t},\\boldsymbol{X}_{j})+\\boldsymbol{n}_{j} \\]\n其中，\\(\\boldsymbol{\\hat{x}}_j\\) 为当前帧观测到 \\(\\boldsymbol{X}_j\\) 的图像点位置，\\(\\boldsymbol{n}_j \\sim N(0,\\Sigma_j)\\)\nMonoSLAM 每一时刻仅需估计当前时刻的状态 \\(x_t\\) ，之前所有时刻的相机运动参数 \\(C_1,\u0026hellip;,C_{t-1}\\) 全部不参与计算，由此简化计算量\nEKF Problems EKF 局限性在于：\n预测函数和更新函数在非线性条件下不能保证全局最优，与迭代的非线性优化技术相比更容易造成误差累积 若将三维点引入状态变量，每一时刻的计算复杂度为 \\(O(n^3)\\) ，处理代价过大 Multi State Constraint Kalman Filter MSCKF 用于缓解 EKF 方法的计算复杂度问题，它是 VI-SLAM 方法\n在预测阶段，使用 IMU 数据传递系统状态 在更新阶段，MSCKF 将邻近的 \\(l\\) 帧相机运动参数包含进状态变量集合 \\(C=\\{C_{t-l+1},\u0026hellip;,C_t\\}\\) 其中 C 集合内的每个 \\(C_i\\) 的估计值均在不断优化，在被移出 \\(C\\) 前已经较为精确，以此缓解误差累积 MSCKF 对所有三维点进行消元(Marginalization)，将 \\(C_i\\) 与 \\(\\boldsymbol{X}_j\\) 之间的二元约束转换为 \\(\\{C_{t-l+1}\u0026hellip;C_t\\}\\) 间的多元约束，从而将 \\(O(n^3)\\) 的计算复杂度简化为 \\(O(nl^3)\\) 通过以上优化，将计算复杂度从立方关系降到了线性关系，大幅降低了计算代价\nFeature Points Method FAST FAST角点是一种在计算机视觉中常用的角点检测算法，它可以快速而准确地识别出图像中的角点。FAST角点(Features from Accelerated Segment Test加速段测试特征)设计目标是在保持较高的检测速度的同时，尽可能减少误检和漏检。\nFAST角点的原理是通过对图像像素进行快速的二进制测试，判断某个像素是否是角点：\nFAST算法选取一个中心像素，然后选择周围的16个像素点进行测试 如果中心像素与其中连续的n个像素（通常为9个）中有k个像素的亮度大于或小于中心像素的亮度阈值，那么中心像素就被认为是一个候选角点 FAST算法会对候选角点进行进一步的验证和优化，以提高角点检测的准确性。 FAST角点算法的优点：\n快速性：FAST算法通过设计高效的像素测试和优化策略，能够以非常快速的速度在图像中检测出角点。 鲁棒性：FAST算法对噪声和图像变换具有一定的鲁棒性，能够在一定程度上抵抗图像的干扰和变形。 低计算复杂度：FAST算法的计算复杂度相对较低，适用于实时应用和资源受限的环境。 FAST角点算法存在的问题：\n对角点尺寸不敏感：FAST算法在设计时忽略了角点的尺寸信息，因此对于尺寸较小或较大的角点检测效果可能不理想。 对噪声敏感：FAST算法对噪声比较敏感，当图像中存在较多噪声时，可能产生误检或漏检的情况。 不适用于非平面场景：由于FAST算法是基于图像亮度变化的测试，在非平面场景下，可能会导致角点检测不准确。 Harris Harris角点检测算法用于检测图像中的角点。它通过分析像素的亮度变化来确定图像中可能存在的角点位置。\nHarris角点检测算法基于以下观察：\n在角点附近，图像的任何方向上的移动都会引起亮度的明显变化; 在平坦区域或边缘上，只有沿着边缘方向的移动才会引起明显的亮度变化 基于这一观察，Harris角点检测算法通过计算图像中每个像素的角点响应函数，并根据响应函数的大小确定角点的位置。\nHarris角点检测算法的计算过程如下：\n计算图像中每个像素的梯度值，通常使用Sobel算子或Prewitt算子等。 根据梯度值计算每个像素的自相关矩阵（M矩阵），该矩阵描述了像素周围局部区域的亮度变化。 计算M矩阵的特征值，特征值的大小反映了该像素处的亮度变化情况。 根据特征值的大小确定角点的位置，通常选择特征值较大的像素作为角点。 Harris角点检测具有以下优点：\n旋转不变性：Harris角点检测算法可以通过计算像素的梯度和自相关矩阵来确定角点的位置和方向，从而实现一定程度上的旋转不变性。 精确性：Harris角点检测算法可以准确地检测出图像中的角点，并且对噪声的影响相对较小。 相对简单：Harris角点检测算法的实现相对简单，计算复杂度较低，适用于实时应用和资源受限的环境。 Harris角点检测存在以下问题：\n尺度不变性：Harris角点检测算法在计算时没有考虑尺度信息，对于尺度变化较大的图像或物体，可能无法准确地检测到相应的角点。 对边缘敏感：Harris角点检测算法在边缘区域可能会产生误检，将边缘也识别为角点。 参数选择：Harris角点检测算法中有一个参数k，用于调整角点响应函数的阈值，不同的图像和场景可能需要不同的参数选择。 BRIEF BRIEF（Binary Robust Independent Elementary Features）描述符用于对图像或图像中的关键点进行描述和匹配。它通过比较两个像素之间的亮度差异来生成二进制字符串，并将其作为描述符表示关键点。\nBRIEF描述符的生成过程如下：\n随机选择一组像素对，每个像素对(x,y)定义了一个比较器：如果x的亮度值大于y，则输出1，否则输出0。 通过比较器对关键点周围的像素进行比较，得到一个由二进制数构成的向量，向量的长度等于所选像素对的数量。 通常情况下，BRIEF描述符使用256位二进制字符串表示，即使用256对像素进行比较，生成256位的二进制向量作为描述符。 BRIEF描述符具有以下优点：\n快速：BRIEF描述符使用简单的亮度比较操作生成二进制字符串，计算复杂度较低，适用于实时应用和资源受限的环境。 稳定性：BRIEF描述符对图像旋转、缩放和光照变化等具有一定的不变性，可以在不同的环境中进行特征匹配。 低维度：BRIEF描述符使用256位二进制字符串表示，相比于其他描述符来说，它的维度较低，存储和处理都比较方便。 BRIEF描述符存在以下问题：\n不可扩展性：由于BRIEF描述符是通过随机选择像素对来生成的，因此无法在后续的应用中增加或减少描述符的长度。 对旋转变化敏感：由于BRIEF描述符没有考虑图像中关键点的旋转信息，因此对于旋转变化较大的图像或物体，可能无法准确地进行匹配。 视点变化敏感：由于BRIEF描述符只考虑了像素之间的亮度变化，没有考虑三维几何信息，因此对于视点变化较大的场景，BRIEF描述符可能无法准确匹配。 ORB ORB（Oriented FAST and Rotated BRIEF）特征结合了FAST角点检测和BRIEF描述符技术，同时加入了旋转不变性和尺度不变性的考虑。\nORB特征的计算过程主要分为三个步骤：角点检测、方向分配和描述符生成。\n采用FAST角点检测算法来检测图像中的关键点，FAST算法可以快速而准确地识别图像中的角点。 使用Harris角点检测算法来计算关键点的方向，以保证ORB特征具有旋转不变性。 使用BRIEF描述符提取算法来计算每个关键点的描述符，其中BRIEF算法是一种高效的二进制特征描述算法，可以在短时间内生成高质量的关键点描述符。 ORB特征具有以下几个优点：\n快速性：ORB算法通过结合FAST角点检测和BRIEF描述符技术来实现快速的图像特征提取，可以在实时应用和资源受限的环境中使用。 鲁棒性：ORB算法在角点检测时使用了Harris角点检测算法来计算关键点的方向，使得ORB特征可以在一定程度上抵抗图像旋转和变形等干扰。 描述性：ORB算法通过使用BRIEF描述符技术来生成关键点的特征描述符，可以准确地描述图像中的关键信息，具有良好的区分性能。 ORB特征存在以下问题：\n尺度不变性：ORB算法在计算时没有考虑尺度信息，因此对于尺度变化较大的图像或物体，可能无法准确地提取出相应的ORB特征。 难以处理遮挡：ORB算法没有考虑图像的遮挡和背景干扰等问题，在这种情况下可能会产生错误的ORB特征。 计算复杂度较高：ORB算法在计算描述符时需要进行比较多的计算，因此可能会占用较高的计算资源。 Keyframe BA based VSLAM Parallel Tracking And Mapping PTAM 是实时 SFM 系统，也是首个基于关键帧 BA 的单目 VSLAM 系统。\n特征：选取 FAST 角点作为特征点 运行：在 2 个线程中并行执行 2 个独立的任务 相机跟踪(Tracking) 地图构建(Mapping) 集束调整： 在地图构建线程中稀疏抽取关键帧及关键帧中可见的三维点进行 BA 根据 BA 恢复的精确三维结构，相机跟踪线程作为前台线程，仅需优化当前帧运动参数 \\(C_t\\) ，以达到实时的计算效率 前台线程通过一个匀速运动模型预测当前帧方位，以搜索地图中的三维点在当前帧图像中对应的*FAST 角点* ，并根据匹配关系优化当前帧方位 \\[ \\arg\\min\\limits_{C_t}\\sum\\limits_{j=1}^nw_j\\left\\|h(C_t,X_j)-\\hat{x}_j\\right\\|_{\\Sigma_j} \\]\n其中，\\(w_j\\) 是 Tukey 函数对应的权重,用于缓解误差匹配(Outliers)对结果的影响。\n将当前帧与已有关键帧的缩略图进行比较，选择最相似的关键帧作为当前帧方位的预测，重复特征匹配和方位优化步骤，如果跟踪成功，判断 \\(C_t\\) 是否满足关键帧条件，一旦符合，将当前帧作为新关键帧传递给后台构建地图。\n如果成功匹配点数不足（如图像模糊、快速运动），则判断跟踪失败，开始重定位。\n后台线程沿极线(Epipolar Line) 匹配不同关键帧之间对应于相同场景点的图像特征点，通过三角化(Triangulation) 恢复场景点的三维位置，并对所有关键帧和三维点运行 BA，恢复精确的三维地图。\n以下是一些相关内容的说明和注释：\n匀速运动模型表示 PTAM 假设相邻帧之间的相机运动是匀速运动，在相邻帧间相机的位移是线性变换\nTukey 是一种常见的鲁棒损失函数\n\\begin{equation} L( r)= \\begin{cases} \\frac{1}{2}r^2, \u0026amp; \\text{if } |r| \\leq c \\\\ c \\left(|r| - \\frac{1}{2}c\\right), \u0026amp; \\text{otherwise} \\end{cases} \\notag \\end{equation}\n其中，\\(r\\) 表示残差，$c$为一个阈值，称为 Tukey\u0026rsquo;s biweight 常数，在残差小于阈值时损失函数为平方误差（二次损失），超过阈值时损失函数线性增加。\n角点是图像中具有明显变化或边缘交汇的位置，它具有以下特征：\n强度变化，角点周围的像素强度在不同方向上有显著变化 边缘交汇，角点是多个边缘相交的位置 不变性，角点在旋转、平移、尺度变化下具有一定程度的不变性 用于检测角点的算法如下：\nFAST 用于快速检测具有显著变化的角点，用此法检测称为 FAST 角点 Harris Shi-Tomasi ORB SLAM ORB-SLAM 对 PTAM 的组件作了改进：\n选用 ORB 特征\n具有更好的视角不变性 新增三维点的特征匹配效率更高 加入回环检测模块\n检测回路\n采用与重定位相同的方法 匹配回路两侧关键帧上的公共点 通过方位图优化来闭合回路\n关键帧作为方位图的节点 每个关键帧赋予一个相似变换 \\(\\xi_i\\) 以矫正方位图的方位 方位图的边表示关键帧之间存在特征匹配 2 团匹配的三维点云通过坐标对齐可求解一个相似变换 \\(\\xi_{ij}\\) 优化过程如下所示：\n\\begin{equation} {\\underset{\\boldsymbol{\\xi}_1,\\cdots,\\boldsymbol{\\xi}_m}{\\arg\\min}} (\\boldsymbol{\\xi}_{ij},\\boldsymbol{\\xi}_i^{-1}\\circ\\boldsymbol{\\xi}_j)^{\\mathrm{T}}\\boldsymbol{\\Sigma}_{ij}^{-1}(\\boldsymbol{\\xi}_{ij}\\circ\\boldsymbol{\\xi}_i^{-1}\\circ\\boldsymbol{\\xi}_j) \\notag \\end{equation}\n其中，\\(\\sum_{ij}\\) 为 \\(\\xi_{ij}\\) 的协方差矩阵(文中设为单位阵)，操作符 \\(\\circ\\) 按顺序连接两个相似变换。\n采用 g2o 优化方位图，以闭合回路\n与全局 BA 相比，方位图优化极大简化了全局优化的计算量\n自动初始化 对于初始化来说，需要选取 2 帧，帧间需要有足够的公共点(相似性)，又需要有足够的平移量(特异性)。通过为公共点提供视差，才能三角化精确的三维位置\nPATM 需要手动初始化 用户指定 2 帧用于初始化系统， ORB-SLAM 自动初始化 通过检测视差自动选择初始化的 2 帧 扩展性强\nPTAM 要求新加入的关键帧提供足够的视差 ORB-SLAM 采用更鲁棒的关键帧和三维点的选择机制 先用宽松的条件判断尽可能及时地加入新的关键帧、三维点(鲁棒跟踪) 再用严格的条件判断删除冗余的关键帧、不稳定的三维点(提高 BA 过程的精度和效率) Direct tracking based VSLAM 基于滤波和基于关键帧 BA 的 VSLAM 需要在图像中提取和匹配特征点，因此对环境的特征、图像质量敏感。 直接跟踪法通过直接比较像素颜色求解相机运动，在特征缺失、图像模糊等异常情况下有更好的鲁棒性。\nDTAM DTAM 最显著的特点是实时恢复场景三维模型。\nDTAM 预测一个与当前帧相机方位 \\(C_t\\) 接近的虚拟相机 \\(C_v\\) ,并在 \\(C_v\\) 下绘制场景三维模型，以求解 \\(C_v\\) 和 \\(C_t\\) 之间的相对运动 \\(\\xi_{tv}\\)\n\\begin{equation} {\\underset{\\xi_{tv}}{\\arg\\min}} \\sum_{\\chi \\in \\Omega_{v}} \\lVert r(\\chi , D_v(\\chi),\\xi_{tv}) \\rVert_2^2 \\notag \\end{equation}\n其中，\\(r(\\cdot)\\) 是颜色残差,\n\\begin{equation} r(\\chi,D_v(\\chi),\\xi_{tv})=I_v(\\chi)-I_t(\\omega(\\chi ,D_v(\\chi), \\xi_{tv})) \\end{equation}\n\\(I_v\\) 和 \\(D_v\\) 分别是三维模型在 \\(C_v\\) 下绘制得到的亮度和深度图，\\(\\omega_v\\) 为亮度和深度有效像素的集合，函数 \\(\\omega(\\chi ,D_v(\\chi),\\xi_{tv})\\) 将虚拟帧 \\(v\\) 中的像素 \\(\\chi\\) 投影到当前帧 \\(t\\) 中。\nLSD-SLAM LSD-SLAM 仅恢复半稠密的深度图，每个像素深度独立计算，提高了计算效率。\nLSD-SLAM 每个关键帧包含图像 \\(I_k\\) 、逆深度图 \\(D_k\\) 和逆深度的方差 \\(V_k\\) ，系统假设每个像素 \\(\\chi\\) 的逆深度值服从高斯分布 \\(N(D_k(\\chi),V_k(\\chi))\\) ,LSD-SLAM 的前台线程采用直接跟踪法恢复当前帧 \\(t\\) 与关键帧 \\(k\\) 之间相对运动 \\(\\xi_{tk}\\) ,即求解优化式\n\\begin{equation} {\\underset{\\xi}{\\arg\\min}} \\sum_{\\xi \\in \\Omega_k} \\lVert \\frac{r^2(\\chi ,D_k(\\chi), \\xi_{tk})}{\\sigma_r^2(\\chi ,D_k(\\chi),\\xi_{tk})} \\rVert_\\delta \\end{equation}\n其中，\\(\\Omega_k\\) 是深度有效像素的集合；\\(r(\\cdot)\\) 的求解与上一节相同，\\(\\sigma^2(\\chi , \\xi)\\) 为 \\(r(\\cdot)\\) 的方差，用于减小深度误差对结果的影响。\n\\begin{equation} \\sigma_r^2(\\chi ,D_k(\\chi), \\xi)=2\\sigma_I^2+\\left ( \\frac{\\partial r(\\chi,D_k(\\chi),\\xi_{tk}) }{\\partial D_k(\\chi )} \\right )^2 V_k(\\chi ) \\end{equation}\nVSLAM Comparison VSLAM 的评价指标可以分为以下几个方面：\n定位精度 MonoSLAM 可能在变量未精确时消元，导致误差累积 MSCKF 虽然也基于滤波，但是推迟了消元，同时融合了 IMU 因此能提高精度 ORB-SLAM 和 PTAM 相比，其选择了匹配精度更高的 ORB 特征和更高效的 BA 实现，因此精度更高 DTAM 和 LSD-SLAM 对光照和动态敏感，因此低于 ORB-SLAM 定位效率 MonoSLAM 的计算复杂度为 \\(O(n^3)\\) MSCKF 的计算复杂度为 \\(O(nl^3)\\) ，其中 \\(l\\) 为系统维护的局部帧数 PTAM 和 ORB-SLAM 的前台线程只需要优化当前帧方位，因此定位效率最高 DTAM 和 LSD-SLAM 的定位效率取决于选取的图像分辨率，因此精度和效率也存在一定的权衡 场景尺度 MonoSLAM 仅适用于几百个点的小场景 MSCKF 由于只维护局部地图，因此对场景尺度不做限制 PTAM 受限于全局 BA 和特征点匹配效率，可实时处理数千点的中等尺度场景 ORB-SLAM 和 LSD-SLAM 用高效的方位图优化替代全局 BA，适用于较大尺度场景 DTAM 由于需要维护和渲染整个场景，仅适用于小场景 特征缺失鲁棒性 特征缺失对所有 VSLAM 都有较大影响，仅 DTAM 和 LSD-SLAM 能通过利用稠密或半稠密的图像信息缓解特征依赖 MSCKF 属于 VI-SLAM，可以利用 IMU 跟踪方位，因此此时鲁棒性最好 快速运动与扩展效率 处理相机运动依赖于两点： 匹配方法在大运动或快运动情况下的鲁棒性 场景地图的扩展效率 MonoSLAM 使用 EKF，对于大运动会失败(残差过大，滤波发散) PTAM 依靠运动预测的方式将关键帧的三维点投影到当前帧，通过金字塔模型匹配增加鲁棒性，但扩展场景需要长时间搜索，因此扩展效率比 MonoSLAM 差 DTAM 也采用基于金字塔模型的图像对齐估计相机姿态，然后绘制到这个视点下与当前帧图像进行进一步对齐优化，与 PTAM 类似 ORB-SLAM 与 MSCKF 采用对视角不变性的特征描述量(SIFT 特征和 ORB 特征)，同时采用高效的全局匹配特征检索方法(ORB-SLAM 采用 词袋模型 )，MSCKF 采用了 IMU，因此其扩展效率最高 LSD-SLAM 假设相机做平缓运动，因此对快速运动敏感；由于 DTAM 需要稠密地图，LSD-SLAM 需要半稠密地图，因此扩展效率最差 重定位能力 MonoSLAM 和 MSCKF 均不支持重定位 PTAM 需要将丢失前的已有帧与当前帧进行比较，如果不够接近以进行初始化就不容易成功 ORB-SLAM 和 LSD-SLAM 都采用对视角变化具有不变性的特征描述量实现重定位，并结合了高效的检索方法(LSD-SLAM 采用 FAB-MAP 方法) 近似纯旋转扩展鲁棒性 MonoSLAM 每帧同时优化三维点和相机方位，因此对近似纯旋转与很好的鲁棒性 MSCKF 仅跟踪轨迹结束时才三角化三维点，并且立即消元，且利用了 IMU 的信息，因此对近似纯旋转最鲁棒 PTAM 容易因为视差不够无法三角化新的三维点，导致跟踪丢失 ORB-SLAM、DTAM、LSD-SLAM 对纯旋转扩展的鲁棒性很大程度取决于后台场景地图的扩展和优化的效率；其中 ORB-SLAM 不需要恢复稠密深度，因此鲁棒性更好 场景变化鲁棒性 均假设场景是静止不变的，否则会跟踪失败 使用 IMU 理论上能够对动态变化提高鲁棒性 回路闭合能力 朴素 VSLAM 没有显式的回路检测 滤波 SLAM 依靠系统状态一致(即协方差真实反应了误差)可能可以检测回路 优化 SLAM 采用特征点进行匹配，其中 ORB-SLAM 和 LSD-SLAM 显式检测回路构建，具有较好的回路闭合能力 不同方法的各项指标如表所示。\n指标 MonoSLAM MSCKF PTAM ORB-SLAM DTAM LSD-SLAM 定位精度 1 3 2 3 2 1 定位效率 1 2 3 3 2 2 场景尺度 1 4 2 4 1 4 特征缺失鲁棒性 1 3 1 1 2 2 重定位能力 0 0 2 3 2 3 快速运动鲁棒性 2 4 3 4 3 1 扩展效率 3 4 2 3 1 1 近似纯旋转扩展鲁棒性 3 4 1 2 1 1 场景变化鲁棒性 1 2 1 1 1 1 回路闭合能力 1 0 0 3 0 3 Research Focus Feature Dependency VSLAM最大的问题是 过于依赖场景特征 。\n基于直接跟踪的方法通过直接对比像素颜色，避免了对特征缺失、图像模糊等敏感的特征提取和特征匹配过程 然而稠密或半稠密的直接跟踪会引入很大的计算量 半直接视觉测量(semi-direct VO,SVO)只对稀疏点进行直接跟踪，效率较高 VSLAM对场景特征的依赖本质上是使用的局部特征过于底层(点特征)\n如果用边缘、平面等更为高层的图像信息，可有效缓解特征依赖 更加高层的空间布局对VSLAM更有价值 Dense 3D Reconstruction VSLAM大多只能实时重建稀疏的三维点云，和深度相机等结合才提供彩色图像、深度图等。 如何使用单目摄像头实时重建稠密三维信息，尚待研究。\nMuti-Sensor Fusion 基于单一传感器定位有其固有的局限：\n基于图像则依赖场景纹理特征 基于IMU通常有一定的误差累积 基于深度的SLAM依赖场景几何特征 融合多传感器数据成为重要的研究方向。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/2-vslam-summary/","tags":[],"title":"VSLAM Summary"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"概述 数据类型用于声明不同类型的变量或函数，变量的类型决定了变量存储占用的空间和变量存储的格式。\n存储类型定义程序中变量/函数的范围（可见性）和生命周期。\n数据类型包括基本类型、派生类型、枚举类型(enum)和空类型(void)。\n基本类型 整型 浮点类型 派生类型 指针类型 数组类型 结构体类型(struct) 共用体类型(union) 函数类型 其中：\n基本类型和枚举类型变量都是都是值，统称为算数类型； 算数类型和指针类型变量的值都是以数字表示的，统称为纯量类型； 数组类型和结构体类型统称为组合类型，共用体类型不属于组合类型因为同一时间只有一个值。 注意：\n共用体类型与枚举类型的区别：\n共用体类型是多变量共享存储空间的派生类型，其中的元素是变量；共用体空间等于最大成员变量占据的空间，共用体不能赋初值； 枚举类型是多常量共享存储空间的数据类型，其中的元素是常量；因此枚举类型变量的值定义时确定，可以全部列出； 声明时必须注意到C语言区分大小写！\n整型 基本整型int\n输出格式：十进制%d，八进制%o或%#o，十六进制%x或%#x；\n16位机器上2字节，32位机器上4字节，64位机器上4字节；\n短整型short int\n输出格式：十进制%hd，八进制%ho或%#ho，十六进制%hx或%#hx；\n简记为16位int，因此占2字节；\n长整型long int\n输出格式：十进制%ld，八进制%lo或%#lo，十六进制%lx或%#lx；\n简记为32位int，因此占4字节；\n双长型long long int\n输出格式：十进制%ll，八进制%llo或%#llo，十六进制%llx或%#llx；\n至少分配8个字节；\n无符号数变体\n当存在unsigned前缀且需要用十进制表示时用%u替换%d，其他时候均不变；\n实型 利用浮点表示法表示实型数据。浮点表示法指的是小数点位置可以浮动，又称IEEE754标准。\n实型表示 浮点数用数符、阶码(移码)和尾数(隐藏首位的原码)表示。\n单精度浮点型float\n输出格式：%f\n分配4个字节；\n双精度浮点型double\n输出格式：%f或%lf或指数记数法%e，十六进制%a\n分配8个字节；\n长双精度浮点型long double\n输出格式：%Lf或指数记数法%Le，十六进制%La\n可能是8个字节，12字节，16字节；\n实型运算 注意事项 输出宽度控制\n可以用%g输出浮点数，系统自动选择f格式或e格式输出，自动选择长度较短的格式，不输出无意义的0。 可以用%m.nf指定数据宽度和小数位数，m表示浮点数所占的列数，n表示小数所占的位数。 浮点型常量写法\n有符号数字(包括小数点)+e/E+有符号数字(指数)。\n可以省略正号，可以省略小数点(2E5)或指数部分(19.28)，但不能同时省略两者； 可以省略小数部分(3.E16)或整数部分(.45E-6)，但不能同时省略两者。 不能在浮点型常量中加空格！\n浮点型变量比较\n不可将浮点变量用“==”或“!=”与任何数字比较!\n而应该设法转化成两数相减后用“\u0026gt; =”或“ \u0026lt;=”形式，比较的数称为误差。\n上溢与下溢\n上溢时显示inf或infinity(无穷大) 下溢时损失精度(尾数的末尾被舍去) 字符型 定义 char或unsigned char\n输出格式：%c\n分配1个字节，且该字节中第一位置为0。\nchar *类型\n输出格式：%s\n分配N个字节(存储N个字符时)\n概念区分 字符常量是用单括号括起来的一个字符；\n字符串常量是用一对双括号括起来的零个或多个字符组成的字符序列，结尾不需要加\u0026rsquo;\\0\u0026rsquo;。\n字符数组是用一对大括号括起来的零个或多个字符组成的字符序列，结尾不需要加\u0026rsquo;\\0\u0026rsquo;。\n注意：\n输出宽度控制\n可以用%md进行右对齐；\n可以用%ms指定输出字符串占的列数，少则左补空格，多则突破限制；\n可以用%m.ns指定输出字符串占的列数及只取字符串左边n个字符输出在m列的右侧，左补空格。\n使用整型输出格式可以输出字符型数据的ASCII码；\n字符常量中，\u0026lsquo;101\u0026rsquo;是八进制字符；\u0026lsquo;x41\u0026rsquo;是十六进制字符；他们都指代ASCII码为65的字符，即A；\n特别地，\u0026lsquo;101\u0026rsquo;可写为'0101\u0026rsquo;，\u0026lsquo;x41\u0026rsquo;可写为'0x41\u0026rsquo;；\n字符串常量中，\\101是八进制字符；\\x41是十六进制字符；他们都指代ASCII码为65的字符，即A；\n特别地，\\101不可写为\\0101，x41可写为\\0x41；\n赋值 char [] 类型的变量只有在定义时可赋const char []类型的初值，即字符串常量。\n若需要为其赋值，可用strcpy()，它位于string.h头文件中。\n数据类型判断 C语言中无判断数据类型的函数，可考虑使用sizeof运算符进行占用存储空间的计算，见下面：\n#include\u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026quot;%d\u0026quot;,sizeof(double)); printf(\u0026quot;%d\u0026quot;,sizeof(5/3.0)); } C++中可以使用typeid()函数判断数据类型，见下面：\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;typeinfo\u0026gt; int main(){ printf(\u0026quot;%s\u0026quot;,typeid(double).name()); printf(\u0026quot;%s\u0026quot;,typeid(5/3.0).name()); } ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/2-1-datatype/","tags":[],"title":"DataType"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"概述 存储类型指示编译器以何种方式使用变量，它定义程序中变量/函数的范围（可见性）和生命周期。\n数据类型用于声明不同类型的变量或函数，变量的类型决定了变量存储占用的空间和变量存储的格式。\n存储类型包括以下几种：\nauto static const register extern volatile auto auto 存储类型是所有局部变量默认的存储类。\n它声明的是在函数中的局部变量，它的生命周期在函数内。\n程序动态分配存储空间，所谓动态是指在调用该函数时给它们分配存储空间，在函数调用结束时就自动释放这些存储空间。\n该类局部变量称为自动变量，其数据存储在动态存储区。\nstatic static 指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。函数之间调用时，已创建的 static 变量的值不会被重置。\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。\n全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。\n#include \u0026lt;stdio.h\u0026gt; void func1(void);/*函数声明*/ static int count=10;/*全局变量，static 是默认的*/ int main(){ while (count--) { func1(); } return 0; } void func1(void){ /* 'thingy'是'func1'的局部变量，它只初始化一次。 * 每次调用函数 'func1'时'thingy' 值不会被重置。 */ static int thingy=5; thingy++; printf(\u0026quot; thingy 为 %d ， count 为 %d\\n\u0026quot;, thingy, count); } const 只读变量 const 存储类型限制一个变量为只读变量，产生静态作用。\nconst 推出的初始目的，正是为了取代预编译指令，消除它的缺点，同时继承它的优点：\n定义const只读变量，具有不可变性； 相较于宏定义来说，便于进行类型检查，消除隐患； 保护被修饰的只读变量，增强程序的健壮性 节省空间，宏定义给出的是立即数，因此在内存中有多份拷贝，const给出的对应内存地址，因此只产生一次内存分配； 编译期间确定值，效率更高。（宏定义确定值在预编译期） 只读变量与常量 常量是只读的，它被编译器放在内存中的只读区域，不能够修改。常量在声明的时候必须赋值；\n只读变量是在内存的堆区中申请空间来存放变量的值，被编译器显式地限制不能被修改。只读变量可以在使用时再赋值。\n对于C语言来说，在声明数组的时候必须用常量来初始化数组，不能用只读变量。常量与只读变量虽然都只读，且值不能修改，但它们在类型上不能混为一谈。\n只读限定范围 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; void printValandAddr(const char * p){ printf(\u0026quot;%d\\n\u0026quot;,p); printf(\u0026quot;%s\\n\u0026quot;,p); } int main() { typedef char * pStr; const char *p1 =\u0026quot;string\u0026quot;; const pStr p2 =\u0026quot;string\u0026quot;; char * const p3=(char *)malloc(sizeof(char)*10); strcpy(p3,\u0026quot;string\u0026quot;);//若要改变指针指向的值，必须为指针赋字符串变量，需用strcpy函数 printValandAddr(p1); p1++;//正确 printValandAddr(p1); printValandAddr(p2); *p2='a';//语法正确，但执行该句会使程序出错，因为字符串在常量区，报core dump printValandAddr(p2); printValandAddr(p3); *p3='a';//正确 printValandAddr(p3); } const 使用的基本形式：const type m;限定类型为type的变量m不可变。\n替换基本形式中的type为char，m为*p1，替换后可看作const char *p1;，限定*p1不可变，但p1是可变的； 替换基本形式中的type为pStr，m为p2，替换后可看作const (char*) p2;（实际无此语法），限定p2不可变，但*p2是可变的； 可变是语法上可变，修改后可能执行会使程序出错。本例中“string”是字面量，在常量区，改不了。 const与指针混用的判断原则：沿着*号划一条线，\n如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向的变量为常量； 如果const位于*的右侧，则const就是用来修饰指针本身，即指针本身是常量。 另外注意：对于const (char *) ; 来说，因为char *是一个整体，相当于一个类型(如 char)，因此，这是限定指针是const。\nextern extern 存储类型用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。\n当使用 extern 时，对于未初始化的变量，会把变量名指向一个之前定义过的存储位置。即：要么初始化该变量，要么该变量已经在其他地方定义。\n当有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\nregister register 存储类型用于将局部变量的值直接存放在CPU的寄存器中。该类型变量叫寄存器变量，用关键字 register 声明。即该存储类型的目的是优化速度，提高执行效率。\n一般地，register可存放整型，仅部分机器可存放浮点数。\n一般情况下，变量的值是存放在内存中的。当程序中用到哪一个变量的值时，由控制器发出指令将内存中该变量的值送到运算器中。经过运算器进行运算，如果需要存数，再从运算器将数送到内存存放。如果有一些变量使用频繁，则为存取变量的值要花不少时间。\nvolatile volatile 存储类型提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。即该存储类型的目的是保持原子操作，保证变量最新。\n","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/2-2-storetype/","tags":[],"title":"StoreType"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"运算符 优先级\n运算符\n名称或含义\n使用形式\n结合方向\n说明\n1\n[]\n数组下标\n数组名[常量表达式]\n左到右\n--\n()\n圆括号\n(表达式）/函数名(形参表)\n--\n.\n成员选择（对象）\n对象.成员名\n--\n-\u0026gt;\n成员选择（指针）\n对象指针-\u0026gt;成员名\n--\n2\n-\n负号运算符\n-表达式\n右到左\n单目运算符\n~\n按位取反运算符\n~表达式\n++\n自增运算符\n++变量名/变量名++\n--\n自减运算符\n--变量名/变量名--\n*\n取值运算符\n*指针变量\n\u0026amp;\n取地址运算符\n\u0026amp;变量名\n!\n逻辑非运算符\n!表达式\n(类型)\n强制类型转换\n(数据类型)表达式\n--\nsizeof\n长度运算符\nsizeof(表达式)\n--\n3\n/\n除\n表达式/表达式\n左到右\n双目运算符\n*\n乘\n表达式*表达式\n%\n余数（取模）\n整型表达式%整型表达式\n4\n+\n加\n表达式+表达式\n左到右\n双目运算符\n-\n减\n表达式-表达式\n5\n\u0026lt;\u0026lt;\u0026nbsp;\n左移\n变量\u0026lt;\u0026lt;表达式\n左到右\n双目运算符\n\u0026gt;\u0026gt;\u0026nbsp;\n右移\n变量\u0026gt;\u0026gt;表达式\n6\n\u0026gt;\u0026nbsp;\n大于\n表达式\u0026gt;表达式\n左到右\n双目运算符\n\u0026gt;=\n大于等于\n表达式\u0026gt;=表达式\n\u0026lt;\u0026nbsp;\n小于\n表达式\u0026lt;表达式\n\u0026lt;=\n小于等于\n表达式\u0026lt;=表达式\n7\n==\n等于\n表达式==表达式\n左到右\n双目运算符\n!=\n不等于\n表达式!= 表达式\n8\n\u0026amp;\n按位与\n表达式\u0026amp;表达式\n左到右\n双目运算符\n9\n^\n按位异或\n表达式^表达式\n左到右\n双目运算符\n10\n|\n按位或\n表达式|表达式\n左到右\n双目运算符\n11\n\u0026amp;\u0026amp;\n逻辑与\n表达式\u0026amp;\u0026amp;表达式\n左到右\n双目运算符\n12\n||\n逻辑或\n表达式||表达式\n左到右\n双目运算符\n13\n?:\n条件运算符\n表达式1?\n表达式2: 表达式3\n右到左\n三目运算符\n14\n=\n赋值运算符\n变量=表达式\n右到左\n双目运算符\n/=\n除后赋值\n变量/=表达式\n双目运算符\n*=\n乘后赋值\n变量*=表达式\n双目运算符\n%=\n取模后赋值\n变量%=表达式\n双目运算符\n+=\n加后赋值\n变量+=表达式\n双目运算符\n-=\n减后赋值\n变量-=表达式\n双目运算符\n\u0026lt;\u0026lt;=\n左移后赋值\n变量\u0026lt;\u0026lt;=表达式\n双目运算符\n\u0026gt;\u0026gt;=\n右移后赋值\n变量\u0026gt;\u0026gt;=表达式\n双目运算符\n\u0026amp;=\n按位与后赋值\n变量\u0026amp;=表达式\n双目运算符\n^=\n按位异或后赋值\n变量^=表达式\n双目运算符\n|=\n按位或后赋值\n变量|=表达式\n双目运算符\n15\n，\n逗号运算符\n表达式,表达式,…\n左到右\n--\n表达式 表达式可以包含有关的运算符，也可以是不包含任何运算符的初等量，如常数是算数表达式的最简单形式。\n算术表达式\n整型表达式：参与运算的是整型量\n实型表达式：参与运算的是实型量，运算自动转为double类型。\n逻辑表达式\n用逻辑运算符连接，结果类型为整型int；可认为是整型表达式的一种特殊形式。\n字位表达式\n用位运算符连接，结果类型为整型变量；可认为是整型表达式的一种特殊形式。\n强制类型转换\n用“(类型)”运算符进行强制类型转换；\n逗号表达式\n形式为表达式1，表达式2，\u0026hellip;，表达式n；计算方法为依次求出各个表达式的值，取最后一个值作为结果\n赋值表达式\n条件表达式\n指针表达式\nsizeof与strlen()的区别\nsizeof是运算符，strlen()是函数；\nsizeof计算实际占用存储空间，不受初始化影响；\nstrlen计算有效字符串的长度，不包括\u0026rsquo;\\0\u0026rsquo;，受初始化影响；\nsizeof可以用类型做参数，计算类型占内存的大小；\nstrlen只能以char*作参数，且必须以\u0026rsquo;\\0\u0026rsquo;结尾，用来计算字符串的长度。\n特别地，数组作sizeof的参数不变化，而传递给strlen时就变化成指针了。\nsizeof在编译时计算，strlen在运行时才计算。\n左值与右值\n左值指的是允许出现在赋值表达式左侧的值，它是可修改的值，如变量；\n右值指的是允许出现在赋值表达式右侧的值，它包括常量、表达式等；\n左值可作右值，右值不一定能作左值。\n常量表达式\n即参与运算的均为常量，不允许有变量，也不允许函数调用；\n个人推测常量表达式的值在编译时就已经确定。\n预处理语句 以#号开头的命令称为预处理命令，均由预处理器处理。\n包含指令 包含指令#include原理：将该头文件包括到用户源文件中。\n#include \u0026lt;stdio.h\u0026gt; //从C语言编译系统的目录寻找 #include \u0026quot;stdio.h\u0026quot; //从用户的当前目录寻找，未找到则再去编译系统目录查找 条件编译指令 根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。\n条件编译主要用于在不同环境或条件下启用不同的语句。\n#if //不同的平台下引入不同的头文件 #if _WIN32 //识别windows平台 #include \u0026lt;windows.h\u0026gt; #elif __linux__ //识别linux平台 #include \u0026lt;unistd.h\u0026gt; #else //识别其他平台 #endif #ifdef 该条件编译指令通常用于Debug/Release程序发布。\n#ifdef _DEBUG printf(\u0026quot;正在使用 Debug 模式编译程序...\\n\u0026quot;); #else printf(\u0026quot;正在使用 Release 模式编译程序...\\n\u0026quot;); #endif system(\u0026quot;pause\u0026quot;); #ifndef 该条件编译指令通常用于多文件结构的单次编译。\n#ifndef Function1_H #define Function1_H //some declaration codes #endif 特别注意：\n#if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的。\n#undef 用于取消已定义的宏。\n宏定义指令 宏定义指令概念 宏定义指令#define，用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。例如：\n#define M (n*n+3*n) ... #undef M //结束该宏的作用域 注意：\n宏定义中表达式两边的括号不能少，否则在宏展开以后可能会由于运算符的优先级产生歧义。 宏定义是简单替换，预处理程序不会检查，如有错误，只可能在编译时（展开宏）发现； 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换； 引号括起来的视为字符串常量，不会产生宏替换； 宏定义允许嵌套使用，即可以在宏定义中使用已定义的宏名； 宏定义可用于表示数据类型 宏定义与typedef 特别注意宏定义与typedef定义的区别：\n宏定义只是简单的字符串替换，以实参代换形参。由预处理器来处理； typedef 是在编译阶段由编译器处理的，它并不是简单的字符串替换，而给原有的数据类型起一个新的名字，将它作为一种新的数据类型。 #define PIN1 int * typedef int *PIN2; //也可以写作typedef int (*PIN2); PIN1 a, b;//宏替换后成为int *a,b;表示a是指针，b是整型； printf(\u0026quot;%d,%d\u0026quot;,sizeof(a),sizeof(b));//输出8，4 PIN2 a, b;//typedef定义则a和b均为int*类型 printf(\u0026quot;%d,%d\u0026quot;,sizeof(a),sizeof(b));//输出8.8 带参数的宏定义指令 C语言允许宏带有参数。\n在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。\n例1：\n#define M(y) y*y+3*y //宏定义 // TODO: k=M(5); //宏调用 例2：\n#define MAX(a,b) (a\u0026gt;b) ? a : b // TODO： max = MAX(x, y); 注意：宏调用在预处理时采用简单替换，这与函数的调用是不同的，函数调用时要把实参表达式的值求出来再传递给形参，而宏展开中对实参表达式不作计算，直接按照原样替换。\n例3：\n#define SQ(y) (y)*(y) // TODO: sq = SQ(a+1);//预处理后得到 sq=(a+1)*(a+1); 注意：对于带参宏定义不仅要在参数两侧加括号，还应该在整个字符串外加括号。\n例4：\n#define SQ(y) (y)*(y) // TODO: sq = 100/SQ(a+1); //预处理后得到 sq=100/(a+1)*(a+1);按运算符次序得到的与预期不相符。 #define SQ(y) ((y)*(y)) // TODO: sq = 100/SQ(a+1); //预处理后得到 sq=100/((a+1)*(a+1));现在能得到正确答案。 进一步体会宏定义与函数调用的区别：\n※ 例5：\n#include \u0026lt;stdio.h\u0026gt; int SQ(int y){ return ((y)*(y)); } int main(){ int i=1; while(i\u0026lt;=5){ printf(\u0026quot;%d^2 = %d\\n\u0026quot;, (i-1), SQ(i++)); } return 0; } 分析：\n在printf函数处，调用函数SQ(i++)，此时传入SQ函数的参数为i，而printf函数内i=i+1。\n输出为$1^2 = 1,2^2 = 4,3^2 = 9,4^2 = 16,5^2 = 25$\n※ 例6：\n#include \u0026lt;stdio.h\u0026gt; #define SQ(y) ((y)*(y)) int main(){ int i=1; while(i\u0026lt;=5){ printf(\u0026quot;%d^2 = %d\\n\u0026quot;, i, SQ(i++)); } return 0; } 分析：\n在printf函数处SQ(i++)会被简单替换为(i++)*(i++)；此时依次计算两次自增，i从3开始，依次为3，5，7。\n输出为$3^2=2,5^2 = 12,7^2 = 30$。\n带参数的宏也可以定义多个语句。始终记住宏是简单替换即可。\n总结 宏和typedef的区别 见 宏定义与typedef 内容。\n带参数的宏调用和函数的区别 函数调用时，若实参为表达式，先求表达式的值，再带入形参；而宏调用则是简单字符替换，如果未加入足够的括号声明优先级，可能由于优先级顺序不当使得运算结果不正确； 函数调用是在运行时处理，而宏则是在编译前进行预处理的时候完成； 函数的实参和形参有严格的类型限制，宏是字符替换，无类型限制； 宏会使得实际程序变长，函数调用则无此情况； 宏不占用运行时间，只消耗预处理时间和编译时间，函数调用则消耗运行时间； 在不利用指针作值传递的情况下，函数调用最多修改一个值，宏则可以修改多个值； ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/3-1-statement/","tags":[],"title":"Statement"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Point \u0026amp; Vector \u0026amp; Coordinate System 旋转矩阵的推导可以参考 姿态解算 部分。\n基是张成三维空间的一组线性无关的向量。三维空间中的某个点 $a$ 可以用 $\\mathbb{R}^3$ 来描述，假设线性空间中存在一组基 $(e_1,e_2,e_3)$，则由原地到点 $a$ 的向量 $\\mathbf{a}$ 在这组基下的坐标是：$(a_1,a_2,a_3)$ ，满足 $$ \\mathbf{a} = \\mathbf{e} \\cdot \\mathbf{a} = \\begin{bmatrix} e_1 \u0026 e_2 \u0026 e_3 \\end{bmatrix} \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{bmatrix} = a_1 e_1 + a_2 e_2 + a_3 e_3 $$ 对于向量 $\\mathbf{a},\\mathbf{b} \\in \\mathbb{R}^3$ 的内积： $$ \\mathbf{a} \\cdot \\mathbf{b} = \\mathbf{a}^T \\mathbf{b} = \\sum_{i=1}^3 a_ib_i = |a||b|\\cos\\langle \\mathbf{a},\\mathbf{b} \\rangle $$ 其中 $\\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle$ 是两个向量的夹角。内积可以描述向量间的投影关系。\n对于向量 $\\mathbf{a},\\mathbf{b} \\in \\mathbb{R}^3$ 的外积： $$ \\begin{aligned} \\mathbf{a} \\times \\mathbf{b} \u0026= \\left \\| \\begin{matrix} e_1 \u0026 e_2 \u0026 e_3 \\\\ a_1 \u0026 a_2 \u0026 a_3 \\\\ b_1 \u0026 b_2 \u0026 b_3 \\end{matrix} \\right \\| \\\\ \u0026= \\left( a_2 b_3 - a_3 b_2 \\right) e_1 - \\left( a_1 b_3 - a_3 b_1 \\right) e_2 + \\left( a_1 b_2 - a_2 b_1 \\right) e_3 \\\\ \u0026= \\begin{bmatrix} a_2b_3-a_3b_2 \\\\ a_3b_1-a_1b_3 \\\\ a_1b_2-a_2b_1 \\end{bmatrix} \\\\ \u0026= \\begin{bmatrix} 0 \u0026 -a_3 \u0026 a_2 \\\\ a_3 \u0026 0 \u0026 -a_1 \\\\ -a_2 \u0026 a_1 \u0026 0 \\end{bmatrix}\\mathbf{b} \\stackrel{\\mathrm{def}}{=} \\mathbf{a}^{\\wedge}\\mathbf{b} \\end{aligned} $$ 外积的结果是向量，且有以下性质：\n方向：垂直于两个向量 长度： $\\left |a \\right |\\left |b \\right | \\sin \\left \\langle \\mathbf{a},\\mathbf{b} \\right \\rangle$ 几何意义：两个向量张成的四边形的有向面积 记符号 $\\wedge$ 为反对称符号， $\\mathbf{a} \\times \\mathbf{b} = \\mathbf{a}^{\\wedge} \\mathbf{b}$ 将外积变成了线性运算。\n任何向量都对应唯一的反对称矩阵，反之亦然，其对应关系为： $$ \\mathbf{a}^{\\wedge}= \\begin{bmatrix} 0 \u0026 -a_3 \u0026 a_2 \\\\ a_3 \u0026 0 \u0026 -a_1 \\\\ -a_2 \u0026 a_1 \u0026 0 \\end{bmatrix} $$ Coordinate Systems\u0026rsquo; Euclidean transformation 坐标系之间的欧式变换由一个旋转加上一个平移组成，这种变换称之为刚体运动。\n设单位正交基 $(e_1,e_2,e_3)$ 经过一次旋转变成 $(e_1\u0026rsquo;,e_2\u0026rsquo;,e_3\u0026rsquo;)$，对同一个向量 $\\mathbf{a}$ 分别在两个正交基下的坐标 $\\begin{bmatrix} a_1,a_2,a_3 \\end{bmatrix}^T$ 和 $\\begin{bmatrix} a_1\u0026rsquo;,a_2\u0026rsquo;,a_3\u0026rsquo; \\end{bmatrix}^T$ 有： $$ \\begin{bmatrix} e_1,e_2,e_3 \\end{bmatrix} \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{bmatrix} = \\begin{bmatrix} e_1',e_2',e_3' \\end{bmatrix} \\begin{bmatrix} a_1' \\\\ a_2' \\\\ a_3' \\end{bmatrix} $$ 等式同时左乘下面的向量 $$ \\begin{bmatrix} e_1^T \\\\ e_2^T \\\\ e_3^T \\end{bmatrix} $$ 得到：\n$$ \\begin{bmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{bmatrix} = \\begin{bmatrix} e_1^Te_1' \u0026 e_1^Te_2' \u0026 e_1^Te_3' \\\\ e_2^Te_1' \u0026 e_2^Te_2' \u0026 e_2^Te_3' \\\\ e_3^Te_1' \u0026 e_3^Te_2' \u0026 e_3^Te_3' \\\\ \\end{bmatrix} \\begin{bmatrix} a_1' \\\\ a_2' \\\\ a_3' \\end{bmatrix} \\stackrel{\\mathrm{def}}{=} \\mathbf{Ra}' $$ 定义中间的矩阵为旋转矩阵，可以看到:\n旋转矩阵由两组基的内积组成。 矩阵各分量是两个坐标系基的内积，基的长度为1，因此实际上是各基向量夹角的余弦值，又称方向余弦矩阵。 旋转矩阵是正交矩阵，即 $R^{-1}=R^T$ 或 $R^{T}R=RR^{T}=I$，且行列式为1；反过来说，行列式为1的正交矩阵即为旋转矩阵 特别地，行列式为-1也称为旋转矩阵，这种旋转是瑕旋转，即一次旋转加上一次反射。\n旋转矩阵的集合定义为： $$ SO(n)=\\left \\{\\mathbf{R} \\in \\mathbb{R}^{n \\times n} | \\mathbf{RR^T=I},\\det(R)=1 \\right \\} $$ 旋转矩阵为正交矩阵，其逆等于转置，均描述了一个相反的旋转： $$ \\mathbf{a'}=\\mathbf{R}^{-1}\\mathbf{a}=\\mathbf{R}^T\\mathbf{a} $$ 平移相对旋转来说更加简单，只需要进行简单的坐标相加，若考虑世界坐标系中的向量 $\\mathbf{a}$ ，经过一次旋转 $\\mathbf{R}$ 和一次平移 $\\mathbf{t}$ 后得到 $\\mathbf{a}\u0026rsquo;$ ，那么把旋转和平移合到一起为： $$ \\mathbf{a}'=\\mathbf{Ra}+\\mathbf{t} $$ 若定义两个坐标系1和2，向量 $\\mathbf{a}$ 在两个坐标系下的坐标为 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$，则： $$ \\mathbf{a}_1=\\mathbf{R}_{12}\\mathbf{a}_2+\\mathbf{t}_{12} $$ 其中 \\(\\mathbf{R}_{12}\\) 表示把坐标系2的向量变换到1，而 \\(\\mathbf{t}_{12}\\) 对应的是坐标系1原点指向坐标系2原点的向量在坐标系1下的坐标。\n在完成旋转后，我们还需要考虑坐标系2相对于坐标系1的位置，这一步通过平移向量 \\( \\mathbf{t}_{12} \\) 来实现。 因此，在完成旋转变换后，我们需要再加上\\( \\mathbf{t}_{12} \\)来获得最终在坐标系1中的表示。\n反过来，\\(\\mathbf{t}_{21}\\) 虽然是坐标系2原点指向坐标系1原点的向量在坐标系2下的坐标，却并不等于 \\(-\\mathbf{t}_{12}\\) 。\n从向量层面上来看，两个向量是完全反向的关系，但是由于两个坐标系的方向可能发生了变化，因此它们在各自坐标系下的坐标值并非相反数。\nTransform Matrix \u0026amp; Homogeneous Coordinate 为了让旋转和平移满足线性关系，引入齐次坐标和变换矩阵： $$ \\begin{bmatrix} \\mathbf{a}' \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\mathbf{R} \u0026 \\mathbf{t} \\\\ 0^T \u0026 1 \\end{bmatrix} \\begin{bmatrix} \\mathbf{a} \\\\ 1 \\end{bmatrix} \\stackrel{\\mathrm{def}}{=} \\mathbf{T} \\begin{bmatrix} \\mathbf{a} \\\\ 1 \\end{bmatrix} $$ 在这里，三维向量末尾添加1变成了齐次坐标，矩阵 $\\mathbf{T}$ 是变换矩阵。\n关于该变换矩阵，称其为特殊欧式群： $$ \\operatorname{SE}(3) = \\left\\{ \\mathbf{T} = \\begin{bmatrix} \\mathbf{R} \u0026 \\mathbf{t} \\\\ \\mathbf{0}^\\mathrm{T} \u0026 1 \\end{bmatrix} \\in \\mathbb{R}^{4 \\times 4} \\mid \\mathbf{R} \\in \\mathrm{SO}(3), \\mathbf{t} \\in \\mathbb{R}^3 \\right\\} $$ 求解该矩阵的逆表示一个反向的变换： $$ \\mathbf{T}^{-1} = \\begin{bmatrix} \\mathbf{R}^T \u0026 \\mathbf{-R}^T\\mathbf{t} \\\\ \\mathbf{0}^\\mathrm{T} \u0026 1 \\end{bmatrix} $$ 为了实现计算 $\\mathbf{Ta}$ 时使用齐次坐标，计算 $\\mathbf{Ra}$ 时使用非齐次坐标，可以采用以下思路：\n先进行矩阵转换，后进行计算 定义运算符重载，以适应不同的矩阵 有关该部分的内容查看后面的 Eigen 编程实践内容。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/3-1-rotation-and-translation-matrix/","tags":[],"title":"Rotation \u0026 Translation Matrix"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"循环结构 continue\u0026amp;break 注意continue和break关键字的用法：\ncontinue指的是结束本次循环，进行下一次循环； break指的是结束本次循环并跳出循环体； for(int i = 0; i \u0026lt; 3; i++){ if (i == 0) continue; printf(\u0026quot;Count,%d\u0026quot;,i); } 如果循环1万次，需要循环到1000次后遇到断点进入调试模式，可考虑使用条件判断+断点：\nfor(int i = 0; i \u0026lt; 10000; i++){ if (i == 1000) ;//在这里下断点 ... } 如果希望在某个特定的地方终止程序的运行，可考虑使用断言：\n#include\u0026lt;assert.h\u0026gt; for(int i = 0; i \u0026lt; 10000; i++){ assert(i=1000); ... } while\u0026amp;do\u0026hellip;while while是先判断再执行；（可能一次都不执行）\ndo\u0026hellip;while是先执行再判断；（至少执行一次）\n分支结构 条件结构 如果if关键字禁止使用，可考虑：\n使用三目运算符实现； 使用函数指针数组实现： int ifconsq(){ /*if的执行内容*/ } int elseconsq(){ /*else的执行内容*/ } int main(){ int (*branch[2])()={elseconsq,ifconsq}; branch[2\u0026lt;3]();//等价于if(2\u0026lt;3) ifconsq();else elseconsq(); } 另外，可以使用存储函数指针的指针代替函数指针数组：\n#incldue\u0026lt;stdlib.h\u0026gt; //malloc函数需要该头文件 int main(){ int (**branch)()=(int(**)())malloc(2*sizeof(int(**)())); *branch=elseconsq; *(branch+1)=ifconsq; branch[2\u0026lt;3](); } 如果else关键字禁止使用，可考虑使用反条件：\nif(!(2\u0026lt;3)) 选择结构 使用switch语句进行多分支选择。\nswitch(x){ case 1: case 2: /* 1和2可以同组 */ break; case 3: /* 使用break跳出switch */ break; default: /*如果均不符合*/ } 其中，\ndefault可以没有，均不符合则均不执行； case后接常量表达式，常量表达式的值必须均不相同，在都有break的情况下次序不影响执行结果； break跳出当前选择结构 ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/3-2-structure/","tags":[],"title":"Structure"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"CMake Usage Eigen 是用头文件组成的库，对于它的使用，有两种办法：\n理论上只需要引入头文件即可，见下面代码中的“直接引入”； 按照官网说明和 cmake 规范，依次 find_package 并 target_link_libraries 下面提供了一些 Eigen 的 cmake 模板。\ncmake_minimum_required(VERSION 3.24) project(eigen_example) set(CMAKE_CXX_STANDARD 17) find_package(Eigen3 REQUIRED) # 直接引入的办法： # include_directories(\u0026quot;/usr/include/eigen3\u0026quot;) # 使用 include_directories 加入代码头文件 # 也可以用 target_include_directories include_directories( \u0026quot;src/eigen_matrix\u0026quot; \u0026quot;src/argparse\u0026quot; ) # 使用 file 递归加入代码文件 # 建议使用 add_executable 或 add_library 手动加入代码文件 file(GLOB_RECURSE SOURCES \u0026quot;src/*\u0026quot; \u0026quot;src/argparse/*\u0026quot; \u0026quot;src/eigen_matrix/*\u0026quot; ) add_executable(${PROJECT_NAME} ${SOURCES}) # 方法一：直接使用 Eigen3::Eigen target_link_libraries(${PROJECT_NAME} Eigen3::Eigen ) # 方法二：使用 ${EIGEN3_INCLUDE_DIR} 加上 ${EIGEN3_LIBS} target_include_directories(${PROJECT_NAME} PRIVATE #也可以使用 PUBLIC ${EIGEN3_INCLUDE_DIR} ) target_link_libraries(${PROJECT_NAME} ${EIGEN3_LIBS} ) 下面提供了一些 eigen 的代码模板。\nVariable 变量的声明如下：\n// 变量表 // Eigen 中所有向量和矩阵都是Eigen::Matrix，它是一个模板类。它的前三个参数为：数据类型，行，列 Eigen::Matrix\u0026lt;float, 2, 3\u0026gt; matrix_f23; // Eigen 通过 typedef 提供了许多内置类型，其底层是Eigen::Matrix Eigen::Vector3d v_3d_1; Eigen::Matrix\u0026lt;float, 3, 1\u0026gt; v_3f_1; // Matrix3d 实质上是 Eigen::Matrix\u0026lt;double, 3, 3\u0026gt; Eigen::Matrix3d matrix_d33 = Eigen::Matrix3d::Zero(); //初始化为0 // 如果不确定矩阵大小，可以使用动态大小的矩阵 Eigen::Matrix\u0026lt;double, Eigen::Dynamic, Eigen::Dynamic\u0026gt; matrix_dynamic; // 或者更简单的方式 Eigen::MatrixXd matrix_x; clock_t time_stt; Initialize 初始化部分代码如下：\n// 下面是对Eigen阵的操作 // 输入数据（初始化） matrix_f23 \u0026lt;\u0026lt; 1, 2, 3, 4, 5, 6; // 输出 std::cout \u0026lt;\u0026lt; \u0026quot;matrix 2x3 from 1 to 6: \\n\u0026quot; \u0026lt;\u0026lt; matrix_f23 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 用()访问矩阵中的元素 std::cout \u0026lt;\u0026lt; \u0026quot;print matrix 2x3: \u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) std::cout \u0026lt;\u0026lt; matrix_f23(i, j) \u0026lt;\u0026lt; \u0026quot;\\t\u0026quot;; std::cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } Mutiplication 矩阵与向量相乘代码如下：\n// 矩阵和向量相乘（实际上仍是矩阵和矩阵） v_3d_1 \u0026lt;\u0026lt; 3, 2, 1; v_3f_1 \u0026lt;\u0026lt; 4, 5, 6; // 但是在Eigen里你不能混合两种不同类型的矩阵，这样是错的 // Eigen::Matrix\u0026lt;double, 2, 1\u0026gt; result_wrong_type = matrix_f23 * v_3d_1; // 应该显式转换 Eigen::Matrix\u0026lt;double, 2, 1\u0026gt; result = matrix_f23.cast\u0026lt;double\u0026gt;() * v_3d_1; std::cout \u0026lt;\u0026lt; \u0026quot;[1,2,3;4,5,6]*[3,2,1]=\u0026quot; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // transpose 代表转置 std::cout \u0026lt;\u0026lt; \u0026quot;[1,2,3;4,5,6]*[3,2,1]=\u0026quot; \u0026lt;\u0026lt; result.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; Eigen::Matrix\u0026lt;float, 2, 1\u0026gt; result2 = matrix_f23 * v_3f_1; std::cout \u0026lt;\u0026lt; \u0026quot;[1,2,3;4,5,6]*[4,5,6]: \u0026quot; \u0026lt;\u0026lt; result2 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; std::cout \u0026lt;\u0026lt; \u0026quot;[1,2,3;4,5,6]*[4,5,6]: \u0026quot; \u0026lt;\u0026lt; result2.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 同样你不能搞错矩阵的维度 // 试着取消下面的注释，看看Eigen会报什么错 // Eigen::Matrix\u0026lt;double, 2, 3\u0026gt; result_wrong_dimension = matrix_23.cast\u0026lt;double\u0026gt;() * v_3d_1; Operation 矩阵运算与操作代码如下：\n// 四则运算直接用+-*/即可。 // 生成随机数矩阵 matrix_d33 = Eigen::Matrix3d::Random(); // 显示矩阵 std::cout \u0026lt;\u0026lt; \u0026quot;random matrix: \\n\u0026quot; \u0026lt;\u0026lt; matrix_d33 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 转置 std::cout \u0026lt;\u0026lt; \u0026quot;transpose: \\n\u0026quot; \u0026lt;\u0026lt; matrix_d33.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 各元素和 std::cout \u0026lt;\u0026lt; \u0026quot;sum: \u0026quot; \u0026lt;\u0026lt; matrix_d33.sum() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 迹 std::cout \u0026lt;\u0026lt; \u0026quot;trace: \u0026quot; \u0026lt;\u0026lt; matrix_d33.trace() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 数乘 std::cout \u0026lt;\u0026lt; \u0026quot;times 10: \\n\u0026quot; \u0026lt;\u0026lt; 10 * matrix_d33 \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 逆 std::cout \u0026lt;\u0026lt; \u0026quot;inverse: \\n\u0026quot; \u0026lt;\u0026lt; matrix_d33.inverse() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 行列式 std::cout \u0026lt;\u0026lt; \u0026quot;det: \u0026quot; \u0026lt;\u0026lt; matrix_d33.determinant() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; Matrix values \u0026amp; vectors 矩阵的特征值与特征向量代码如下：\n// 实对称矩阵可以保证对角化成功 // A^T*A 一定是实对称矩阵 Eigen::SelfAdjointEigenSolver\u0026lt;Eigen::Matrix3d\u0026gt; eigen_solver(matrix_d33.transpose() * matrix_d33); // 特征值 std::cout \u0026lt;\u0026lt; \u0026quot;Eigen values = \\n\u0026quot; \u0026lt;\u0026lt; eigen_solver.eigenvalues() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 特征向量 std::cout \u0026lt;\u0026lt; \u0026quot;Eigen vectors = \\n\u0026quot; \u0026lt;\u0026lt; eigen_solver.eigenvectors() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; Matrix inverse 矩阵求逆的三种方法：\n直接求逆 矩阵分解 QR 分解 正定矩阵 cholesky 分解 // 直接求逆法 int matrix_equation_direct(Eigen::Matrix\u0026lt;double, MATRIX_SIZE, 1\u0026gt; \u0026amp;x,const Eigen::Matrix\u0026lt;double, MATRIX_SIZE, MATRIX_SIZE\u0026gt; \u0026amp;matrix_NN,const Eigen::Matrix\u0026lt;double,MATRIX_SIZE,1\u0026gt; \u0026amp;v_Nd) { time_stt = clock(); // 计时 x = matrix_NN.inverse() * v_Nd; std::cout \u0026lt;\u0026lt; \u0026quot;time of normal inverse is \u0026quot; \u0026lt;\u0026lt; (double) (1000 * (clock() - time_stt)) / (double) CLOCKS_PER_SEC \u0026lt;\u0026lt; \u0026quot;ms\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } // 矩阵分解法，通常用此方法来求解，例如QR分解，速度会快很多 int matrix_equation_qr(Eigen::Matrix\u0026lt;double, MATRIX_SIZE, 1\u0026gt; \u0026amp;x,const Eigen::Matrix\u0026lt;double, MATRIX_SIZE, MATRIX_SIZE\u0026gt; \u0026amp;matrix_NN,const Eigen::Matrix\u0026lt;double,MATRIX_SIZE,1\u0026gt; \u0026amp;v_Nd) { time_stt = clock(); x = matrix_NN.colPivHouseholderQr().solve(v_Nd); std::cout \u0026lt;\u0026lt; \u0026quot;time of Qr decomposition is \u0026quot; \u0026lt;\u0026lt; (double)(1000 * (clock() - time_stt)) / (double) CLOCKS_PER_SEC \u0026lt;\u0026lt; \u0026quot;ms\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } // cholesky分解法 // 对于正定矩阵，还可以用cholesky分解来解方程 int matrix_equation_cholesky(Eigen::Matrix\u0026lt;double, MATRIX_SIZE, 1\u0026gt; \u0026amp;x,const Eigen::Matrix\u0026lt;double, MATRIX_SIZE, MATRIX_SIZE\u0026gt; \u0026amp;matrix_NN,const Eigen::Matrix\u0026lt;double,MATRIX_SIZE,1\u0026gt; \u0026amp;v_Nd) { time_stt = clock(); x = matrix_NN.ldlt().solve(v_Nd); std::cout \u0026lt;\u0026lt; \u0026quot;time of ldlt decomposition is \u0026quot; \u0026lt;\u0026lt; (double)(1000 * (clock() - time_stt)) / (double) CLOCKS_PER_SEC \u0026lt;\u0026lt; \u0026quot;ms\u0026quot; \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } Matrix Equation 解矩阵方程代码如下：\n// 解矩阵方程 int matrix_equation() { // 我们求解 matrix_NN * x = v_Nd 这个方程 // N的大小在前边的宏里定义，它由随机数生成 // 直接求逆自然是最直接的，但是求逆运算量大 //Eigen::Matrix\u0026lt;double, MATRIX_SIZE, MATRIX_SIZE\u0026gt; matrix_NN // = Eigen::MatrixXd::Random(MATRIX_SIZE, MATRIX_SIZE); Eigen::Matrix\u0026lt;double, MATRIX_SIZE, MATRIX_SIZE\u0026gt; matrix_NN = Eigen::Matrix\u0026lt;double, MATRIX_SIZE, MATRIX_SIZE\u0026gt;::Random(); matrix_NN = matrix_NN * matrix_NN.transpose(); // 保证半正定 Eigen::Matrix\u0026lt;double, MATRIX_SIZE, 1\u0026gt; v_Nd = Eigen::MatrixXd::Random(MATRIX_SIZE, 1); Eigen::Matrix\u0026lt;double, MATRIX_SIZE, 1\u0026gt; x{Eigen::Matrix\u0026lt;double,MATRIX_SIZE,1\u0026gt;::Random()}; matrix_equation_direct(x,matrix_NN,v_Nd); std::cout \u0026lt;\u0026lt; \u0026quot;x = \u0026quot; \u0026lt;\u0026lt; x.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; matrix_equation_qr(x,matrix_NN,v_Nd); std::cout \u0026lt;\u0026lt; \u0026quot;x = \u0026quot; \u0026lt;\u0026lt; x.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; matrix_equation_cholesky(x,matrix_NN,v_Nd); std::cout \u0026lt;\u0026lt; \u0026quot;x = \u0026quot; \u0026lt;\u0026lt; x.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } Homogeneous Computation 为了实现计算 $\\mathbf{Ta}$ 时使用齐次坐标，计算 $\\mathbf{Ra}$ 时使用非齐次坐标，可以使用以下办法：\n实现齐次坐标矩阵与非齐次坐标矩阵之间的转换 实现运算符重载 假设实现旋转和平移的矩阵叫作 SE3，则代码如下：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;Eigen/Dense\u0026gt; class SE3 { public: Eigen::Matrix3d rotation_matrix; Eigen::Vector3d translation_matrix; Eigen::Matrix4d homogeneous_matrix; SE3() { rotation_matrix = Eigen::Matrix3d::Identity(); translation_matrix = Eigen::Vector3d::Zero(); homogeneous_matrix = Eigen::Matrix4d::Identity(); } SE3(const Eigen::Matrix3d\u0026amp; R, const Eigen::Vector3d\u0026amp; t) { rotation_matrix = R; translation_matrix = t; to_homogeneous_matrix(); } // 转为齐次坐标矩阵 // 该函数不能为 const，因为他会修改成员变量 void to_homogeneous_matrix() { homogeneous_matrix = Eigen::Matrix4d::Identity(); homogeneous_matrix.block\u0026lt;3, 3\u0026gt;(0, 0) = rotation_matrix; homogeneous_matrix.block\u0026lt;3, 1\u0026gt;(0, 3) = translation_matrix; } // 与三维向量相乘 Eigen::Vector3d operator*(const Eigen::Vector3d\u0026amp; vec) const { return rotation_matrix * vec + translation_matrix; } // 与四维齐次向量相乘 Eigen::Vector4d operator*(const Eigen::Vector4d\u0026amp; vec) const { return homogeneous_matrix * vec; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const SE3\u0026amp; se3) { os \u0026lt;\u0026lt; \u0026quot;Rotation:\\n\u0026quot; \u0026lt;\u0026lt; se3.rotation_matrix \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; os \u0026lt;\u0026lt; \u0026quot;Translation:\\n\u0026quot; \u0026lt;\u0026lt; se3.translation_matrix.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; os \u0026lt;\u0026lt; \u0026quot;Homogeneous Matrix:\\n\u0026quot; \u0026lt;\u0026lt; se3.homogeneous_matrix \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return os; } }; int main() { // 定义一个旋转矩阵 (SO(3)) Eigen::Matrix3d R = Eigen::AngleAxisd(M_PI / 4, Eigen::Vector3d::UnitZ()).toRotationMatrix(); // 定义一个平移向量 Eigen::Vector3d t(1, 2, 3); // 创建一个 SE3 对象 SE3 se3(R, t); // 打印 SE3 对象 std::cout \u0026lt;\u0026lt; se3 \u0026lt;\u0026lt; std::endl; // 定义一个三维向量 Eigen::Vector3d a(4, 5, 6); // 使用非齐次坐标相乘 Eigen::Vector3d result_non_homogeneous = se3 * a; std::cout \u0026lt;\u0026lt; \u0026quot;Result (non-homogeneous):\\n\u0026quot; \u0026lt;\u0026lt; result_non_homogeneous \u0026lt;\u0026lt; std::endl; // 定义一个四维齐次向量 Eigen::Vector4d a_homogeneous(4, 5, 6, 1); // 使用齐次坐标相乘 Eigen::Vector4d result_homogeneous = se3 * a_homogeneous; std::cout \u0026lt;\u0026lt; \u0026quot;Result (homogeneous):\\n\u0026quot; \u0026lt;\u0026lt; result_homogeneous \u0026lt;\u0026lt; std::endl; return 0; } ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/3-2-eigen-exercise/","tags":[],"title":"Eigen Exercise"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Geometry Declaration 四元数，旋转矩阵和旋转向量的声明：\n// 3D 旋转矩阵直接使用 Matrix3d 或 Matrix3f Eigen::Matrix3d rotation_matrix; // 旋转向量使用 AngleAxis, 它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符） Eigen::AngleAxisd rotation_vector; Eigen::Vector3d v(1, 0, 0); // 向量v的旋转后坐标 Eigen::Vector3d v_rotated; // 欧拉角: 可以将旋转矩阵直接转换成欧拉角 Eigen::Vector3d euler_angles; // 四元数 Eigen::Quaterniond q; Rotation and translation 旋转矩阵和旋转向量：\n// Eigen/Geometry 模块提供了各种旋转和平移的表示 // 旋转矩阵初始化 rotation_matrix = Eigen::Matrix3d::Identity(); // 旋转向量初始化，沿 Z 轴旋转 45 度 rotation_vector = Eigen::AngleAxisd(M_PI / 4, Eigen::Vector3d(0, 0, 1)); std::cout.precision(3); std::cout \u0026lt;\u0026lt; \u0026quot;rotation matrix =\\n\u0026quot; \u0026lt;\u0026lt; rotation_vector.matrix() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; //用matrix()转换成矩阵 // 也可以直接赋值 // 由旋转向量转为旋转矩阵 rotation_matrix = rotation_vector.toRotationMatrix(); // 用 AngleAxis 可以进行坐标变换 v_rotated = rotation_vector * v; std::cout \u0026lt;\u0026lt; \u0026quot;(1,0,0) after rotation (by angle axis) = \u0026quot; \u0026lt;\u0026lt; v_rotated.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 或者用旋转矩阵 v_rotated = rotation_matrix * v; std::cout \u0026lt;\u0026lt; \u0026quot;(1,0,0) after rotation (by matrix) = \u0026quot; \u0026lt;\u0026lt; v_rotated.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; Euler angle 欧拉角和旋转矩阵、旋转向量之间的转换\n// 可以将旋转矩阵直接转换成欧拉角 euler_angles = rotation_matrix.eulerAngles(2, 1, 0); // ZYX顺序，即 yaw-pitch-roll 顺序 std::cout \u0026lt;\u0026lt; \u0026quot;yaw pitch roll = \u0026quot; \u0026lt;\u0026lt; euler_angles.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 可以将旋转向量直接转换成欧拉角 euler_angles = rotation_vector.eulerAngles(0, 1, 2); // XYZ 顺序，即 pitch-roll-yaw 顺序 std::cout \u0026lt;\u0026lt; \u0026quot;pitch roll yaw = \u0026quot; \u0026lt;\u0026lt; euler_angles.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 欧氏变换矩阵使用 Eigen::Isometry // 虽然称为3d，实质上是4＊4的矩阵 Eigen::Isometry3d T = Eigen::Isometry3d::Identity(); // 按照rotation_vector进行旋转 T.rotate(rotation_vector); // 把平移向量设成(1,3,4) T.pretranslate(Eigen::Vector3d(1, 3, 4)); std::cout \u0026lt;\u0026lt; \u0026quot;Transform matrix = \\n\u0026quot; \u0026lt;\u0026lt; T.matrix() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 用变换矩阵进行坐标变换 Eigen::Vector3d v_transformed = T * v;// 相当于R*v+t std::cout \u0026lt;\u0026lt; \u0026quot;v tranformed = \u0026quot; \u0026lt;\u0026lt; v_transformed.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 对于仿射和射影变换，使用 Eigen::Affine3d 和 Eigen::Projective3d 即可，略 Quaternion 四元数的相关操作：\n// 可以直接把AngleAxis赋值给四元数，反之亦然 Eigen::Quaterniond q = Eigen::Quaterniond(rotation_vector); // coeffs 方法返回一个包含四元数系数的 Eigen::Map\u0026lt;Eigen::Vector4d\u0026gt; 对象 std::cout \u0026lt;\u0026lt; \u0026quot;quaternion from rotation vector = \u0026quot; \u0026lt;\u0026lt; q.coeffs().transpose() \u0026lt;\u0026lt; std::endl; // 请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部 // 也可以把旋转矩阵赋给它 q = Eigen::Quaterniond(rotation_matrix); std::cout \u0026lt;\u0026lt; \u0026quot;quaternion from rotation matrix = \u0026quot; \u0026lt;\u0026lt; q.coeffs().transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 使用四元数旋转一个向量，使用重载的乘法即可 v_rotated = q * v; // 注意数学上是qvq^{-1} std::cout \u0026lt;\u0026lt; \u0026quot;(1,0,0) after rotation = \u0026quot; \u0026lt;\u0026lt; v_rotated.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; // 用常规向量乘法表示，则应该如下计算 std::cout \u0026lt;\u0026lt; \u0026quot;should be equal to \u0026quot; \u0026lt;\u0026lt; (q * Eigen::Quaterniond(0, 1, 0, 0) * q.inverse()).coeffs().transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; Transform Coordinate transform 四元数的坐标变换： 注意：\n四元数需要满足模长为1才能表示一个有效的旋转，而实际计算中由于运算的误差累积，四元数可能会丢失单位长度 仿射变换可以由单位矩阵初始化，然后使用 pretranslate 设置平移，使用 rotate 设置旋转；也可以直接由表示平移的向量或四元数初始化它。 Eigen::Quaterniond q1(0.35, 0.2, 0.3, 0.1), q2(-0.5, 0.4, -0.1, 0.2); q1.normalize(); // 归一化 q2.normalize(); Eigen::Vector3d t1(0.3, 0.1, 0.1), t2(-0.1, 0.5, 0.3); Eigen::Vector3d p1(0.5, 0, 0.2); Eigen::Isometry3d T1w(q1), T2w(q2); // 表示仿射变换的类 T1w.pretranslate(t1); // 进行平移变换 T2w.pretranslate(t2); // 对欧式变换矩阵求逆 Eigen::Vector3d p2 = T2w * T1w.inverse() * p1; std::cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot; \u0026lt;\u0026lt; p2.transpose() \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/3-4-geometry-exercise/","tags":[],"title":"Geometry Exercise"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"CMake Usage 下面提供了一个 pangolin 的 cmake 模板。\ncmake_minimum_required(VERSION 3.24) project(eigen_example) set(CMAKE_CXX_STANDARD 17) find_package(Eigen3 REQUIRED) find_package(Pangolin REQUIRED) find_package(GLEW REQUIRED) # find_package(OpenGL REQUIRED) # 非必须的，但还是加上 include_directories( ${Pangolin_INCLUDE_DIRS} ) include_directories( \u0026quot;src/eigen_geometry\u0026quot; \u0026quot;src/eigen_matrix\u0026quot; \u0026quot;src/argparse\u0026quot; \u0026quot;src/coordinate_transform\u0026quot; \u0026quot;src/visualize_plot\u0026quot; ) file(GLOB_RECURSE SOURCES \u0026quot;src/*\u0026quot; \u0026quot;src/argparse/*\u0026quot; \u0026quot;src/coordinate_transform/*\u0026quot; \u0026quot;src/eigen_geometry/*\u0026quot; \u0026quot;src/eigen_matrix/*\u0026quot; \u0026quot;src/visualize_plot/*\u0026quot; ) add_executable(${PROJECT_NAME} ${SOURCES}) target_link_libraries(${PROJECT_NAME} Eigen3::Eigen) target_link_libraries(${PROJECT_NAME} ${Pangolin_LIBRARIES}) 注意事项：\n对于 target_link_libraries(${PROJECT_NAME} Pangolin) 在 CMake Reload Project 的时候确实不会报错 编译时会提示大量关于 pangolin/gl/gl.hpp 以及 pangolin/gl/glsl.h 的错误 CSDN上 大部分 解决办法已能够想到对头文件进行设置，如： # Pangolin find_package(Pangolin REQUIRED) if(Pangolin_FOUND) include_directories(${Pangolin_INCLUDE_DIRS}) message(STATUS \u0026quot;Pangolin FOUND: ${Pangolin_INCLUDE_DIRS}\u0026quot;) else() message(STATUS \u0026quot;Pangolin not FOUND\u0026quot;) endif() 然后把 pangolin 从 v0.8 降级到 v0.6 。但这种方法可能忽略了链接的问题，或者说没有找到编译中断的根本原因。 实际上，上面这种链接的写法不会正确链接 Pangolin 的库文件，不妨注释这句链接，重新编译后还会出现相同的问题。因此建议使用以上给出的代码链接方法进行链接。 关于 eigen 的链接 理论上来说 eigen 是纯头文件库，不需要链接，即可以写 include_directories 的方式向项目添加 eigen 依赖 CMake 提供了 find_package 的方法，使用该方法需要写 target_link_libraries 添加链接，否则编译中断 pangolin 依赖 eigen ，因此链接 pangolin 的时候可以取消链接 eigen ，根据依赖关系，CMake会自动寻找 eigen 并进行链接 ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/3-5-pangolin/","tags":[],"title":"Pangolin Exercise"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Raise 在 SLAM 中，除表示位姿(旋转)外，还需要对其进行估计和优化。然而，旋转矩阵自身带有约束(正交矩阵且行列式为 1)，此时对其进行优化显得困难。通过一定的转换关系，可以把带约束的优化问题转为无约束的优化问题。我们将这种转换称为李群——李代数转换关系。\n三维旋转矩阵构成了特殊正交群 SO(3)，三维欧氏变换矩阵构成了特殊欧氏群 SE(3)，三维相似变换矩阵构成了相似变换群 Sim(3)。\n$$\r\\begin{aligned}\r\u0026\\operatorname{SO}(3) = \\left \\{\\mathbf{R} \\in \\mathbb{R}^3 | \\mathbf{R}\\mathbf{R}^T=\\mathbf{I},det( R)=1 \\right \\} \\\\\r\u0026\\operatorname{SE}(3) = \\left\\{ \\mathbf{T} \\in \\mathbb{R}^{4 \\times 4} \\mid \\mathbf{T} = \\begin{bmatrix}\r\\mathbf{R} \u0026 \\mathbf{t} \\\\\r\\mathbf{0}^\\mathrm{T} \u0026 1\r\\end{bmatrix}, \\mathbf{R} \\in \\mathrm{SO}(3), \\mathbf{t} \\in \\mathbb{R}^3 \\right\\} \\\\\r\u0026\\operatorname{Sim}(3) = \\left\\{ \\mathbf{S} \\in \\mathbb{R}^{4 \\times 4} \\mid \\mathbf{S} = \\begin{bmatrix}\rs\\mathbf{R} \u0026 \\mathbf{t} \\\\\r\\mathbf{0}^\\mathrm{T} \u0026 1\r\\end{bmatrix}, \\mathbf{R} \\in \\mathrm{SO}(3), \\mathbf{t} \\in \\mathbb{R}^3 \\right\\}\r\\end{aligned}\r$$ 注意到旋转矩阵和变换矩阵对加法不封闭，仅对乘法封闭。\nGroup Defination 群是一种集合加一种运算的代数结构，集合记作\\(A\\)，运算记作\\(\\cdot\\)，则群记为\\(G=(A,\\cdot)\\)，群满足 4 个条件：\n封闭性\n\\(\\forall a_1,a_2\\in A, a_1\\cdot a_2\\in A\\)\n结合律\n\\(\\forall a_1,a_2,a_3\\in A,(a_1\\cdot a_2)\\cdot a_3=a_1\\cdot(a_2\\cdot a_3)\\)\n幺元\n\\(\\exists a_0\\in A,\\mathrm{s.t.}\\forall a\\in A, a_0\\cdot a=a\\cdot a_0=a\\)\n逆\n\\(\\forall a\\in A,\\exists a^{-1}\\in A, s.t. a\\cdot a^{-1}=a_{0}\\)\n常见的群有：整数的加法，去掉 0 以后有理数的乘法，由 \\(n \\times n\\) 的可逆矩阵构成的一般线性群等。\n接下来验证 SO(3)、SE(3)和 Sim(3)关于乘法成群。\nSO(3) 首先验证 SO(3):\n\\begin{equation} \\operatorname{SO}(3)=\\{\\mathbf{R} \\in \\mathbb{R}^3 | \\mathbf{R}\\mathbf{R}^T=\\mathbf{I},det( R)=1\\} \\end{equation}\n首先验证封闭性\n\\begin{gather} \\mathbf{R}_1\\mathbf{R}_2 \\in \\mathbb{R}^{3 \\times 3} \\\\ (\\mathbf{R}_1\\mathbf{R}_2)(\\mathbf{R}_1\\mathbf{R}_2)^T=\\mathbf{R}_1\\mathbf{R}_2\\mathbf{R}_2^\\mathrm{T}\\mathbf{R}_1^\\mathrm{T}=\\boldsymbol{I} \\\\ \\det(\\mathbf{R}_1\\mathbf{R}_2)=\\det(\\mathbf{R}_1)\\det(\\mathbf{R}_2)=1 \\end{gather}\n其次验证结合律\n\\begin{equation} (\\mathbf{R}_1\\mathbf{R}_2)\\mathbf{R}_3=\\mathbf{R}_1(\\mathbf{R}_2)\\mathbf{R}_3) \\end{equation}\n再次验证幺元\n\\begin{equation} \\exists \\boldsymbol{E}_{3\\times 3}, s.t. \\boldsymbol{R}\\boldsymbol{E}=\\boldsymbol{R} \\end{equation}\n需要注意 3 维单位矩阵是旋转矩阵。\n最后验证逆\n\\begin{align} \\forall \\boldsymbol{R}, \\boldsymbol{R}_1^{-1}(\\boldsymbol{R}_1^{-1})^{\\mathrm{T}}=\\boldsymbol{R}_1^{-1}(\\boldsymbol{R}_1^{\\mathrm{T}})^{-1}=\\boldsymbol{R}_1^{-1}\\boldsymbol{R}=\\boldsymbol{I} \\\\ \\det(\\mathbf{R}_1^{-1})=\\det(\\mathbf{R}_1^{\\mathrm{T}})=\\det(\\mathbf{R})=1 \\end{align}\n因此证明得 SO(3)关于乘法成群。\nSE(3) 接下来验证 SE(3):\n$$\r\\operatorname{SE}(3) = \\left\\{ \\mathbf{T} \\in \\mathbb{R}^{4 \\times 4} \\mid \\mathbf{T} = \\begin{bmatrix}\r\\mathbf{R} \u0026 \\mathbf{t} \\\\\r\\mathbf{0}^\\mathrm{T} \u0026 1\r\\end{bmatrix}, \\mathbf{R} \\in \\mathrm{SO}(3), \\mathbf{t} \\in \\mathbb{R}^3 \\right\\}\r$$ 首先验证封闭性\n\\begin{equation} T_{1}T_{2} =\\begin{bmatrix}\\mathbf{R}_{1}\u0026amp;\\mathbf{t}_{1}\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;1\\end{bmatrix}\\begin{bmatrix}\\mathbf{R}_{2}\u0026amp;\\mathbf{t}_{2}\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;1\\end{bmatrix}=\\begin{bmatrix}\\mathbf{R}_{1}\\mathbf{R}_{2}\u0026amp;\\mathbf{R}_{1}\\mathbf{t}_{2}+\\mathbf{t}_{1}\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;1\\end{bmatrix} \\end{equation}\n由上面 SO(3)的证明过程得到\n\\begin{equation} \\mathbf{R}_1\\mathbf{R}_2 \\in \\operatorname{SO}(3) \\end{equation}\n且有\n\\begin{equation} \\mathbf{R}_1\\mathbf{t}_2+\\mathbf{t}_1 \\in \\mathbb{R}^3 \\end{equation}\n其次验证结合律\n\\begin{equation} (\\mathbf{T}_1\\mathbf{T}_2)\\mathbf{T}_3=\\mathbf{T}_1(\\mathbf{T}_2\\mathbf{T}_3) \\end{equation}\n再次验证幺元\n\\begin{equation} \\exists \\boldsymbol{E}_{4\\times 4}, s.t. \\boldsymbol{T}\\boldsymbol{E}=\\boldsymbol{T} \\end{equation}\n需要注意 4 维单位矩阵是旋转矩阵。\n最后验证逆\n\\begin{gather} \\forall \\boldsymbol{T}=\\begin{bmatrix} \\mathbf{R} \u0026amp; \\mathbf{t}\\\\ \\mathbf{0^{\\mathrm{T}}} \u0026amp; 1 \\end{bmatrix}, \\exists \\mathbf{T}^{-1}=\\begin{bmatrix} \\mathbf{R}^{-1} \u0026amp; -\\mathbf{R}^{-1}\\mathbf{t}\\\\ \\mathbf{0^{\\mathrm{T}}} \u0026amp; 1 \\end{bmatrix}, s.t. \\mathbf{T}^{-1} \\mathbf{T} = \\mathbf{E} \\\\ \\det{T}=\\det{T}^{-1}=1 \\end{gather}\n因此验证得 SE(3)关于乘法成群。\nSim(3) 接下来证明 Sim(3):\n\\begin{equation} \\operatorname{Sim}(3) = \\left\\{ S \\in \\begin{bmatrix} s\\mathbf{R} \u0026amp; \\boldsymbol{t} \\\\ \\boldsymbol{0}^{\\mathrm{T}} \u0026amp; 1 \\end{bmatrix} \\in \\mathbb{R}^{4\\times4} \\right\\} \\end{equation}\n首先验证封闭性：\n\\begin{equation} S_{1}S_{2} = \\begin{bmatrix} s_{1}\\mathbf{R_1} \u0026amp; \\mathbf{t_1} \\\\ \\mathbf{0}^{\\mathrm{T}} \u0026amp; 1 \\end{bmatrix} \\begin{bmatrix} s_{2}\\mathbf{R_2} \u0026amp; t_{2} \\\\ \\mathbf{0}^{\\mathrm{T}} \u0026amp; 1 \\end{bmatrix} = \\begin{bmatrix} s_{1}s_{2}\\mathbf{R_1R_2} \u0026amp; s_{1}\\mathbf{R_1t_2}+\\mathbf{t_1} \\\\ \\mathbf{0}^{\\mathrm{T}} \u0026amp; 1 \\end{bmatrix} \\in \\mathbb{R}^{4\\times4} \\end{equation}\n其次验证结合律\n\\begin{equation} (\\mathbf{S}_1\\mathbf{S}_2)\\mathbf{S}_3=\\mathbf{S}_1(\\mathbf{S}_2\\mathbf{S}_3) \\end{equation}\n再次验证幺元\n\\begin{equation} \\exists \\boldsymbol{E}_{4\\times 4}, s.t. \\boldsymbol{S}\\boldsymbol{E}=\\boldsymbol{S} \\end{equation}\n需要注意 4 维单位矩阵是特殊的相似变换矩阵。\n最后验证逆\n\\begin{equation} \\forall \\mathbf{S}=\\begin{bmatrix} s\\mathbf{R} \u0026amp; \\boldsymbol{t} \\\\ \\boldsymbol{0}^{\\mathrm{T}} \u0026amp; 1 \\end{bmatrix}, \\exists \\mathbf{S}^{-1}=\\begin{bmatrix} \\frac{1}{s}\\mathbf{R}^{-1} \u0026amp; -\\frac{1}{s} \\mathbf{R}^{-1}\\mathbf{t} \\\\ \\boldsymbol{0}^{\\mathrm{T}} \u0026amp; 1 \\end{bmatrix}, s.t. \\mathbf{S}^{-1}\\mathbf{S} = \\mathbf{E} \\end{equation}\n因此证得 Sim(3)关于乘法成群。\nLie Algebras Raise 李群是具有连续光滑性质的群。\n直观上看，刚体能够连续地在空间中运动，所以 SO(3)和 SE(3)都是李群 可以说 SO(3)和 SE(3)在实数空间上是连续的 考虑旋转矩阵 \\(\\mathbf{R}\\)\n\\begin{equation} \\mathbf{R}\\mathbf{R}^\\mathrm{T}=I \\end{equation}\n将旋转看作过程，即扩展到随时间变化的函数 \\(\\mathbf{R}(t)\\)\n\\begin{equation} \\mathbf{R}(t)\\mathbf{R}^\\mathrm{T}(t)=I \\end{equation}\n同时求导得到:\n\\begin{equation} \\dot{\\mathbf{R}}(t)\\mathbf{R}(t)^\\mathrm{T}+\\mathbf{R}(t)\\dot{\\mathbf{R}}(t)^\\mathrm{T}=0 \\end{equation}\n整理得:\n\\begin{equation} \\dot{\\mathbf{R}}(t)\\mathbf{R}(t)^\\mathrm{T}=-\\left(\\dot{\\mathbf{R}}(t)\\mathbf{R}(t)^\\mathrm{T}\\right)^\\mathrm{T} \\end{equation}\n于是$\\dot{\\mathbf{R}}(t)\\mathbf{R}(t)^\\mathrm{T}$是一个反对称矩阵。对每个向量，都可以反对称化为一个反对称矩阵；反之也成立。\n$$\ra^{\\wedge}=A=\r\\left[\\begin{array}{ccc}\r0 \u0026 -a_3 \u0026 a_2 \\\\\ra_3 \u0026 0 \u0026 -a_1 \\\\\r-a_2 \u0026 a_1 \u0026 0\r\\end{array}\\right],\\quad A^{\\vee}=a\r$$ 设三维向量 \\(\\phi(t) \\in \\mathbb{R}^3\\) 满足：\n\\begin{equation} \\dot{\\mathbf{R}}(t)\\mathbf{R}(t)^\\mathrm{T}=\\phi(t)^{\\wedge} \\end{equation}\n同时右乘 \\(\\mathbf{R}(t)\\)，由于正交阵具有\\(\\mathbf{R}^\\mathrm{T}\\mathbf{R}=I\\)\n\\begin{equation} \\left.\\dot{\\mathbf{R}}(t)=\\phi(t)^{\\wedge}\\mathbf{R}(t)=\\left[\\begin{array}{ccc}0\u0026amp;-\\phi_3\u0026amp;\\phi_2\\\\ \\phi_3 \u0026amp; 0 \u0026amp; -\\phi_1 \\\\ -\\phi_2 \u0026amp; \\phi_1 \u0026amp; 0 \\end{array}\\right.\\right]\\mathbf{R}(t) \\end{equation}\n即每次对旋转矩阵求一次导数，相当于左乘 \\(\\phi^{\\wedge}(t)\\) 。\n考虑简单情况，假设 \\(t_0=0\\) 时刻，旋转矩阵\\(\\mathbf{R}(0)=I\\)，则\n\\begin{equation} \\begin{aligned} \\mathbf{R}\\left(t\\right) \u0026amp;\\approx \\mathbf{R}\\left(t_{0}\\right) + \\dot{\\mathbf{R}}\\left(t_{0}\\right)\\left(t-t_{0}\\right) \\\\ \u0026amp;= \\mathbf{R}\\left(t_{0}\\right) + \\phi\\left(t_0\\right)^{\\wedge}\\mathbf{R}(t_0)\\left(t-t_{0}\\right) \\\\ \u0026amp;= I + \\phi\\left(t_{0}\\right)^{\\wedge}\\left(t\\right) \\end{aligned} \\end{equation}\n函数 \\(\\phi\\) 反映了 \\(\\mathbf{R}\\) 的导数性质，它在 SO(3)原点附近的正切空间上，同时在单位元 \\(t_0\\) 附近，称其为单位元是因为 \\(R(t_0)=I\\) 。\n设 \\(\\phi\\) 保持为常数 \\(\\phi(t_0)=\\phi_0\\)，则\n\\begin{equation} \\dot{\\mathbf{R}}(t)=\\phi(t_0)^{\\wedge}\\mathbf{R}(t)=\\phi_0^{\\wedge}\\mathbf{R}(t) \\end{equation}\n对上述微分方程，存在初始值 \\(\\mathbf{R}(0)=I\\)，因此其特解为：\n\\begin{equation} \\mathbf{R}(t)=exp(\\phi_0^{\\wedge}t) \\end{equation}\n综上所述，\n给定某时刻 \\(\\mathbf{R}\\) 即能够求出 \\(\\phi\\) ，它描述了 \\(\\mathbf{R}\\) 在局部的导数关系，且 \\(\\phi\\) 正是对应到 SO(3)上的李代数\\(\\mathfrak{so}(3)\\) 给定 \\(\\phi\\) 时，可以根据 \\(exp(\\phi^{\\wedge})\\) 计算李群，反之亦然，这正是李群与李代数之间的指数和对数映射。 Lie Algebras Definations 每个李群都有对应的李代数。\n注意到 SO(3)和 SE(3)只有定义良好的乘法，没有定义良好的加法，因此难以进行取极限和求导的操作 李代数对应单位元附近的正切空间，描述了李群的局部性质(导数) Definations 李代数由集合 \\(\\mathbb{V}\\) ，数域 \\(\\mathbb{F}\\) 和一个二元运算 \\([,]\\) 组成。称李代数为\\((\\mathbb{V},\\mathbb{F},[,])\\)，记为 \\(\\mathfrak{g}\\)\n封闭性\n\\(\\forall X,Y\\in\\mathbb{V},[X,Y]\\in\\mathbb{V}\\)\n双线性\n\\(\\forall X,Y,Z\\in\\mathbb{V},a,b\\in\\mathbb{F}\\),有：\n\\[ [aX+bY,Z]=a[X,Z]+b[Y,Z],\\quad[Z,aX+bY]=a[Z,X]+b[Z,Y]. \\]\n自反性\n\\(\\forall X\\in\\mathbb{V},[X, X] = 0\\)\n雅可比等价 \\[ \\forall X,Y,Z\\in\\mathbb{V},[X,[Y,Z]]+[Z,[X,Y]]+[Y,[Z,X]]=0 \\]\n满足上述性质的 \\((\\mathbb{V},\\mathbb{F},[,])\\) 称为李代数，二元运算称为李括号。\nExample and Provement 下面以三维向量叉积为例，证明 \\(\\mathfrak{g}=(\\mathbb{R}^3,\\mathbb{R},\\times)\\) 构成李代数。\n首先验证封闭性\n\\begin{equation} \\forall X,Y\\in\\mathbb{R}^3 X\\times Y\\in\\mathbb{R}^3 \\end{equation}\n然后验证双线性\n\\(\\forall X,Y,Z\\in\\mathbb{R}^3,a,b\\in\\mathbb{R}\\), 由叉乘的分配率可知\n\\begin{equation} \\begin{aligned} (aX+bY)\\times Z=a(X\\times Z)+b(Y\\times Z) Z\\times(aX+bY)=a(Z\\times X)+b(Z\\times Y) \\end{aligned} \\end{equation}\n其次验证自反性\n\\(\\forall X\\in\\mathbb{R}^3\\)，由叉乘定义可知 \\(X\\times X=0\\)\n最后验证雅可比等价\n\\(\\forall X,Y,Z\\in\\mathbb{R}^3\\)，由叉乘的定义，展开计算可以得到\n\\begin{equation} X\\times(Y\\times Z)=(X\\cdot Z)\\cdot Y-(X\\cdot Y)\\cdot Z \\end{equation}\n因此有\n\\begin{equation} X\\times(Y\\times Z)+Z\\times(X\\times Y)+Y\\times(Z\\times X)=\\mathbf{0} \\end{equation}\n该式类似球对称的性质。\nTwo Lie Algebras 下面讨论 SO(3)和 SE(3)上的李代数。\nSO(3) 记 SO(3)对应的李代数为 \\(\\phi\\)，它是定义在 \\(\\mathbb{R}^3\\) 上的向量。\n定义 \\(\\mathbf{\\Phi}\\) 满足\n\\begin{equation} \\mathbf{\\Phi}=\\phi^{\\wedge}=\\left[\\begin{array}{ccc}0\u0026amp;-\\phi_3\u0026amp;\\phi_2\\\\ \\phi_3 \u0026amp; 0 \u0026amp; -\\phi_1 \\\\ -\\phi_2 \u0026amp; \\phi_1 \u0026amp; 0 \\end{array}\\right]\\in\\mathbb{R}^{3 \\times 3} \\end{equation}\n则两个向量 \\(\\phi_1,\\phi_2\\) 的李括号为\n\\begin{equation} [\\phi_1,\\phi_2]=(\\mathbf{\\Phi}_1\\mathbf{\\Phi}_2-\\mathbf{\\Phi}_2\\mathbf{\\Phi}_1)^\\vee \\end{equation}\n下面证明该李代数满足上述性质。\n\\begin{equation} \\mathfrak{so}(3)=\\{\\phi\\in\\mathbb{R}^{3},\\Phi=\\phi^{\\wedge}\\in\\mathbb{R}^{3\\times3}\\} \\end{equation}\n对于 \\(\\mathfrak{so}(3)\\) 的封闭性\n\\begin{equation} \\forall\\phi_{1},\\phi_{2}\\in\\mathbb{R}^{3},[\\phi_{1},\\phi_{2}]=(\\Phi_{1}\\Phi_{2}-\\Phi_{2}\\Phi_{1})^{\\vee}\\in\\mathbb{R}^{3} \\end{equation}\n对于 \\(\\mathfrak{so}(3)\\) 的双线性\n\\begin{equation} \\begin{aligned} \u0026amp;\\forall\\phi_1,\\phi_2,\\phi_3\\in\\mathbb{R}^3,a,b\\in\\mathbb{R} \\\\ \\left[a\\phi_{1}+b\\phi_{2},\\phi_{3}\\right] \u0026amp;=[(a\\Phi_{1}+b\\Phi_{2})\\Phi_{3}-\\Phi_{3}(a\\Phi_{1}+b\\Phi_{2})]^{\\vee} \\\\ \u0026amp;=[a(\\Phi_{1}\\Phi_{3}-\\Phi_{3}\\Phi_{1})+b(\\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2})]^{\\vee} \\\\ \u0026amp;=a(\\Phi_{1}\\Phi_{3}-\\Phi_{3}\\Phi_{1})^{\\vee}+b(\\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2})^{\\vee} \\\\ \u0026amp;=a[\\phi_{1},\\phi_{3}]+b[\\phi_{2},\\phi_{3}] \\end{aligned} \\end{equation}\n同理可得\n\\begin{equation} [\\phi_{3},a\\phi_{1}+b\\phi_{2}]=a[\\phi_{3},\\phi_{1}]+b[\\phi_{3},\\phi_{2}] \\end{equation}\n对于 \\(\\mathfrak{so}(3)\\) 的自反性\n\\begin{equation} \\forall\\phi\\in\\mathbb{R}^3,[\\phi,\\phi]=(\\Phi\\Phi-\\Phi\\Phi)^\\vee=\\mathbf{0} \\end{equation}\n对于 \\(\\mathfrak{so}(3)\\) 的雅可比等价\n\\begin{equation} \\begin{aligned} \u0026amp;\\forall\\phi_1,\\phi_2,\\phi_3\\in\\mathbb{R}^{3} \\\\ \\left[\\phi_{1},[\\phi_{2},\\phi_{3}]\\right]\u0026amp;=[\\phi_{1},(\\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2})^{\\vee}] \\\\ \u0026amp;=(\\Phi_{1}(\\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2})-(\\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2})\\Phi_{1})^{\\vee} \\end{aligned} \\end{equation}\n关于上式的详细说明：\n对于给定的三个旋转向量 \\(\\phi_1, \\phi_2, \\phi_3 \\in \\mathbb{R}^3\\) ，考虑李代数 \\(\\mathfrak{so}(3)\\) 中的雅可比等式。\n\\begin{equation} \\left[\\phi_{1},[\\phi_{2},\\phi_{3}]\\right] = [\\phi_{1}, (\\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2})^{\\vee}] \\end{equation}\n这里，\\([\\phi_{1},[\\phi_{2},\\phi_{3}]]\\) 表示两次李括号运算，\\((\\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2})^{\\vee}\\) 表示将矩阵形式转换为向量形式（即反对称矩阵到旋转向量）。\n根据李括号的定义，有\n\\begin{equation} [\\phi_{1},[\\phi_{2},\\phi_{3}]] = [\\phi_{1}, \\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2}] \\end{equation}\n现在展开右侧的李括号运算，得到\n\\begin{equation} [\\phi_{1}, \\Phi_{2}\\Phi_{3}-\\Phi_{3}\\Phi_{2}] = (\\Phi_1 (\\Phi_2 \\Phi_3 - \\Phi_3 \\Phi_2) - (\\Phi_2 \\Phi_3 - \\Phi_3 \\Phi_2) \\Phi_1)^{\\vee} \\end{equation}\n因此上式成立\n同理\n\\begin{equation} \\begin{aligned} \\left[\\phi_{3},[\\phi_{1},\\phi_{2}]\\right]=(\\Phi_{3}(\\Phi_{1}\\Phi_{2}-\\Phi_{2}\\Phi_{1})-(\\Phi_{1}\\Phi_{2}-\\Phi_{2}\\Phi_{1})\\Phi_{3})^{\\vee} \\\\ \\left[\\phi_{2},[\\phi_{3},\\phi_{1}]\\right]=(\\Phi_{2}(\\Phi_{3}\\Phi_{1}-\\Phi_{1}\\Phi_{3})-(\\Phi_{3}\\Phi_{1}-\\Phi_{1}\\Phi_{3})\\Phi_{2})^{\\vee} \\end{aligned} \\end{equation}\n相加可得\n\\begin{equation} \\left[\\phi_{1},[\\phi_{2},\\phi_{3}]\\right]+\\left[\\phi_{3},[\\phi_{1},\\phi_{2}]\\right]+\\left[\\phi_{2},[\\phi_{3},\\phi_{1}]\\right]=0 \\end{equation}\n综上所述，\\(\\mathfrak{so}(3)\\) 满足李代数的性质，该李代数形式为:\n\\begin{equation} \\mathfrak{so}(3) = \\left\\{ \\phi \\in \\mathbb{R}^3 , \\Phi=\\phi^{\\wedge} \\in \\mathbb{R}^{3 \\times 3}\\right\\} \\end{equation}\n该李代数是一个由三维向量组成的集合，每个向量对应到一个反对称矩阵，它与特殊正交群 SO(3)的关系为指数映射\n\\begin{equation} \\mathbf{R}(t)=exp(\\phi^{\\wedge}) \\end{equation}\nSE(3) 与 \\(\\mathfrak{so}(3)\\) 相似，\\(\\mathfrak{se}(3)\\) 位于 \\(\\mathbb{R}^6\\) 空间中\n\\begin{equation} \\mathfrak{se}(3)=\\left\\{\\xi=\\left[\\begin{array}{c}\\boldsymbol{\\rho}\\\\phi\\end{array}\\right]\\in\\mathbb{R}^6,\\boldsymbol{\\rho}\\in\\mathbb{R}^3,\\phi\\in\\mathfrak{so}\\left(3\\right),\\xi^{\\wedge}=\\left[\\begin{array}{cc}\\phi^{\\wedge}\u0026amp;\\boldsymbol{\\rho}\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;0\\end{array}\\right]\\in\\mathbb{R}^{4\\times4}\\right\\} \\end{equation}\n把每个 \\(\\mathfrak{se}(3)\\) 元素记作 \\(\\epsilon\\) ，它是一个六维向量，\n前三维为平移(不是变换矩阵中的平移)，记为 \\(\\boldsymbol{\\rho}\\)， 后三维为旋转，记作 \\(\\phi\\)，实质上是 \\(\\mathfrak{so}(3)\\) 元素 此处 \\(\\wedge\\) 不再表示反对称，而是满足\n\\begin{equation} \\xi^{\\wedge}=\\left[\\begin{array}{cc}\\phi^{\\wedge}\u0026amp;\\boldsymbol{\\rho}\\\\ \\mathbf{0}^{\\mathrm{T}}\u0026amp;0\\end{array}\\right]\\in\\mathbb{R}^{4\\times4} \\end{equation}\n形式上仍然保留 \\(\\wedge\\) 和 \\(\\vee\\) 来指代从“向量到矩阵”和“从矩阵到向量”的关系，李代数 \\(\\mathfrak{se}(3)\\) 可以简单理解成一个平移加一个 \\(\\mathfrak{so}(3)\\) 构成的向量(此平移不直接是平移)\n李代数 \\(\\mathfrak{se}(3)\\) 具有李括号:\n\\begin{equation} \\left[\\xi_1,\\xi_2\\right]=(\\xi_1^{\\wedge}\\xi_2^{\\wedge}-\\xi_2^{\\wedge}\\xi_1^{\\wedge})^\\vee \\end{equation}\n下面证明 \\(\\mathfrak{se}(3)\\) 满足李代数的性质\n对于 \\(\\mathfrak{se}(3)\\) 封闭性，\n\\begin{equation} \\begin{aligned} \u0026amp;\\forall \\xi_1,\\xi_2 \\in \\mathbb{R}^6 \\\\ [\\xi_{1},\\xi_{2}]\u0026amp; =(\\xi_{1}^{\\wedge}\\xi_{2}^{\\wedge}-\\xi_{2}^{\\wedge}\\xi_{1}^{\\wedge})^{\\vee} \\\\ \u0026amp;\\left.=\\left(\\begin{bmatrix}\\phi_1^{\\wedge}\u0026amp;\\boldsymbol{\\rho}_1\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;0\\end{bmatrix}\\right.\\begin{bmatrix}\\phi_2^{\\wedge}\u0026amp;\\boldsymbol{\\rho}_2\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;0\\end{bmatrix}-\\begin{bmatrix}\\phi_2^{\\wedge}\u0026amp;\\boldsymbol{\\rho}_2\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;0\\end{bmatrix}\\begin{bmatrix}\\phi_1^{\\wedge}\u0026amp;\\boldsymbol{\\rho}_1\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;0\\end{bmatrix}\\right)^{\\vee} \\\\ \u0026amp;\\left.=\\left(\\begin{bmatrix}\\phi_1^{\\wedge}\\phi_2^{\\wedge}\u0026amp;\\phi_1^{\\wedge}\\boldsymbol{\\rho}_2\\\\mathbf{0}^\\mathrm{T}\u0026amp;0\\end{bmatrix}\\right.-\\begin{bmatrix}\\phi_2^{\\wedge}\\phi_1^{\\wedge}\u0026amp;\\phi_2^{\\wedge}\\boldsymbol{\\rho}_1\\\\mathbf{0}^\\mathrm{T}\u0026amp;0\\end{bmatrix}\\right)^{\\vee} \\\\ \u0026amp;=\\begin{bmatrix}\\phi_{1}^{\\wedge}\\phi_{2}^{\\wedge}-\\phi_{2}^{\\wedge}\\phi_{1}^{\\wedge}\u0026amp;\\phi_{1}^{\\wedge}\\boldsymbol{\\rho_{2}}-\\phi_{2}^{\\wedge}\\boldsymbol{\\rho_{1}}\\\\mathbf{0}^{\\mathrm{T}}\u0026amp;0\\end{bmatrix}^{\\vee} \\end{aligned} \\end{equation}\n由于 \\(\\mathfrak{so}(3)\\) 的封闭性可知\n\\begin{equation} (\\phi_{1}^{\\wedge}\\phi_{2}^{\\wedge}-\\phi_{2}^{\\wedge}\\phi_{1}^{\\wedge})^{\\vee}\\in\\mathfrak{so}(3) \\end{equation}\n由于 \\(\\phi_i^{\\wedge}\\) 为 \\(3 \\times 3\\) 反对称矩阵，且 \\(\\mathbf{\\rho}_i\\) 是三维向量，因此容易得到\n\\begin{equation} \\phi_1^\\wedge\\boldsymbol{\\rho}_2-\\phi_2^\\wedge\\boldsymbol{\\rho}_1\\in\\mathbb{R}^6 \\end{equation}\n对于 \\(\\mathfrak{se}(3)\\) 的双线性\n\\begin{equation} \\begin{aligned} \u0026amp;\\forall\\xi_{1},\\xi_{2},\\xi_{3}\\in\\mathbb{R}^{6},a,b\\in\\mathbb{R} \\\\ [a\\xi_{1}+b\\xi_{2},\\xi_{3}]\u0026amp; =[(a\\xi_{1}^{\\wedge}+b\\xi_{2}^{\\wedge})\\xi_{3}^{\\wedge}-\\xi_{3}^{\\wedge}(a\\xi_{1}^{\\wedge}+b\\xi_{2}^{\\wedge})]^{\\vee} \\\\ \u0026amp;=[a(\\xi_{1}^{\\wedge}\\xi_{3}^{\\wedge}-\\xi_{3}^{\\wedge}\\xi_{1}^{\\wedge})+b(\\xi_{2}^{\\wedge}\\xi_{3}^{\\wedge}-\\xi_{3}^{\\wedge}\\xi_{2}^{\\wedge})]^{\\vee} \\\\ \u0026amp;=a[\\xi_{1},\\xi_{3}]+b[\\xi_{2},\\xi_{3}] \\end{aligned} \\end{equation}\n对于 \\(\\mathfrak{se}(3)\\) 的自反性\n\\begin{equation} \\forall\\xi\\in\\mathbb{R}^6,[\\xi,\\xi]=(\\xi^\\wedge\\xi^\\wedge-\\xi^\\wedge\\xi^\\wedge)^\\vee=\\mathbf{0} \\end{equation}\n对于 \\(\\mathfrak{se}(3)\\) 的雅可比等价性\n\\begin{equation} \\begin{aligned} \u0026amp;\\forall\\xi_{1},\\xi_{2},\\xi_{3}\\in\\mathbb{R}^{6},a,b\\in\\mathbb{R} \\\\ \\left[\\xi_{1},[\\xi_{2},\\xi_{3}]\\right]\u0026amp; =[\\xi_{1},(\\xi_{2}^{\\wedge}\\xi_{3}^{\\wedge}-\\xi_{3}^{\\wedge}\\xi_{2}^{\\wedge})^{\\vee}] \\\\ \u0026amp;=[\\xi_{1}^{\\wedge}(\\xi_{2}^{\\wedge}\\xi_{3}^{\\wedge}-\\xi_{3}^{\\wedge}\\xi_{2}^{\\wedge})-(\\xi_{2}^{\\wedge}\\xi_{3}^{\\wedge}-\\xi_{3}^{\\wedge}\\xi_{2}^{\\wedge})\\xi_{1}^{\\wedge}]^{\\vee} \\end{aligned} \\end{equation}\n同理可得\n\\begin{equation} \\begin{aligned} \\left[\\xi_{3},[\\xi_{1},\\xi_{2}]\\right]=[\\xi_{3}^{\\wedge}(\\xi_{1}^{\\wedge}\\xi_{2}^{\\wedge}-\\xi_{2}^{\\wedge}\\xi_{1}^{\\wedge})-(\\xi_{1}^{\\wedge}\\xi_{2}^{\\wedge}-\\xi_{2}^{\\wedge}\\xi_{1}^{\\wedge})\\xi_{3}^{\\wedge}]^{\\vee} \\\\ \\left[\\xi_{2},[\\xi_{3},\\xi_{1}]\\right]=[\\xi_{2}^{\\wedge}(\\xi_{3}^{\\wedge}\\xi_{1}^{\\wedge}-\\xi_{1}^{\\wedge}\\xi_{3}^{\\wedge})-(\\xi_{3}^{\\wedge}\\xi_{1}^{\\wedge}-\\xi_{1}^{\\wedge}\\xi_{3}^{\\wedge})\\xi_{2}^{\\wedge}]^{\\vee} \\end{aligned} \\end{equation}\n三个式子相加即得\n\\begin{equation} \\left[\\xi_{1},[\\xi_{2},\\xi_{3}]\\right]+\\left[\\xi_{3},[\\xi_{1},\\xi_{2}]\\right]+\\left[\\xi_{2},[\\xi_{3},\\xi_{1}]\\right]=0 \\end{equation}\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/4-lie-group-and-lie-algebras-1/","tags":[],"title":"Lie Group and Lie Algebras 1"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"函数组成 概念 函数是以固定的格式封装，可以重复使用的代码模块，用于完成特定的功能。\n通过调用模块名来重复使用这段代码。\n特别地，\n函数不能嵌套定义。 函数外不能做运算，执行结构语句或调用函数。 参数 函数可以具有输入，这些输入被称为参数，一般是数据或变量，指示主调函数与被调函数之间的数据传递关系。\n形参与实参 定义函数时函数名后面括号的变量名称称为形式参数；\n主调函数调用函数时，赋给被调函数的参数称为实际参数（实参可以是常量、变量、表达式）；\n函数作参数 函数A作被调函数B的参数时，先调用函数A，函数A返回后执行函数B。\n特别地，函数A，B，C，\u0026hellip;作被调函数Z的参数时，按某种顺序依次调用，依次返回后调用函数Z。\n顺序具体如何由编译器决定，gcc按照从右往左顺序，猜测实现方式是将参数依次压栈，然后依次弹出计算。\n特别注意数组作为函数参数的情况：\n数组元素作函数参数\n数组元素可以作实际参数，不能作形式参数；当作实参时，向形参传递的是数组元素的值。\n因此实参的值传递给形参是变量作值传递方式。\n数组名作函数参数\n数组名可以作函数的实际或形式参数；当作实参时，向形参传递的是数组首元素的地址。\n因此实参的值传递给形参是指针作值传递方式。\n（引用传递方式需要慎重，C语言不支持形参引用传递。见值传递和引用传递节。）\n最后，尽量避免写如下例形式的代码。\n#include\u0026lt;stdio.h\u0026gt; int funA(int a){ printf(\u0026quot;A function Called.\\n\u0026quot;); a+=1; printf(\u0026quot;a is %d in A\\n \u0026quot;,a); return a; } int funB(int a){ printf(\u0026quot;B function Called.\\n\u0026quot;); a+=1; printf(\u0026quot;a is %d in B\\n\u0026quot;,a); return a; } int funC(int a){ printf(\u0026quot;C function Called.\\n\u0026quot;); a+=1; printf(\u0026quot;a is %d in C\\n\u0026quot;,a); return a; } int funD(int a,int b,int c){ return 0; } int main(int argc, char *argv[]){ int a=0; printf(\u0026quot;Main function Called.\\n\u0026quot;); funD(funA(a++),funB(a++),funC(a++)); } 假设时刻$t_i$和$t_{i+1}$是前后相继的两个顺序点，那么到了$t_{i+1}$，任何C/C++ 系统都必须实现$t_i$之后发生的所有副作用。\n但是当然它们也可以不等到时刻$t_{i+1}$，而是选择在时段$ [t, t_{i+1}] $之间的任何时刻实现在此期间出现的副作用，C/C++ 语言允许这些选择。\nC/C++ 语言的规定指出，任何依赖于特定计算顺序、依赖于在顺序点之间实现修改效果的表达式，其结果都没有保证。\n如果在任何“完整表达式”（形成一段由顺序点结束的计算）里存在对同一“变量”的多个引用，那么表达式里就不应该出现对这一“变量”的副作用。否则就不能保证得到预期结果。\n——北京大学数学科学学院教授裘宗燕\n返回 被调函数向主调函数返回的执行结果称为返回值。\n函数声明时必须声明返回值类型，若类型为void则函数也可以不返回任何值。\nreturn 语句是提前结束函数的唯一办法。\n声明 函数定义与函数调用\n原则上函数定义要出现在函数调用之前。\n函数声明的概念\n指向编译器传达信息：某函数将会被定义。如果函数调用时函数尚未定义，则需要声明。\n函数声明的格式\n去掉函数定义中的函数体，并在最后加上分号。\n特别地，可以不写形参，只写数据类型。 这是由于声明不需要对函数进行定义。\n多文件结构\n函数定义放到源文件，函数的声明放到头文件。\n使用函数时引入对应的头文件就可以，编译器会在链接阶段找到函数体。\n库函数 概念 系统或第三方建立开发的具有一定功能的函数的集合。存放在该集合中的函数称为库函数。\n库函数具有明确的功能、入口调用参数和返回值。\n常见库 标准输入输出库#include\u0026lt;stdio.h\u0026gt;\n该库定义了通用输入输出函数。\nint printf(char *format,args)\nint putchar(char ch)\nint puts(char *str)\nint scanf(char *format,args)\nFILE *fopen(char *filename,char *mode)\n有关区分fopen和open，参见本篇输入输出节。\nint fread(char *pt,unsigned size,unsigned n,FILE *fp)\nint fwrite(char *pt,unsigned size,unsigned n,FILE *fp)\nint fclose(FILE *fp)\n标准库#include\u0026lt;stdlib.h\u0026gt;\n该库定义了五种类型、部分宏和通用工具函数。\n类型包括size_t\n在64位系统中为long long unsigned int，在非64位系统中为long unsigned int\n宏包括EXIT_FAILURE、EXIT_SUCCESS、RAND_MAX\n通用工具函数包括：\nvoid *malloc(unsigned size)\nvoid *calloc(unsigned n,unsigend size)\n通过指定数据类型和个数实现空间分配\nvoid *free(void *p)\nvoid *realloc(void *p,unsigned size)\nvoid exit(int state)\nint rand(void)\n产生0-32767的随机整数。\n字符串库#include\u0026lt;string.h\u0026gt;\n数学库#include\u0026lt;math.h\u0026gt;\nint abs(int x)\ndouble fabs(double x)\ndouble exp(double x)\ndouble pow(double x,double y)\n计算$x^y$的值。\ndouble sqrt(double x)\n计算开方。（编程实现开方可用牛顿迭代法，参见算法篇sqrt）\n","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/4-1-function/","tags":[],"title":"Function"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"值传递 变量作值传递 函数参数通过值来传递，即传递给被调用函数的参数值存放在临时变量中，而不是原来的变量中。\nvoid swap1(int a,int b){ int temp = a; a = b; b = temp; } int main(){ swap1(a,b);//无法交换变量的值 } 该函数中的参数a和参数b都是临时变量，生存周期仅在该函数中，因此调用该函数无法完成变量交换。\n指针作值传递 若需让函数能够修改主调函数中的变量，调用者需要向被调用的函数提供待设置值的变量的地址（从技术角度看，地址就是指向变量的指针），而被调用函数则需将对应的参数声明为指针类型。\n指针作值传递的原理：虽然指针的地址未发生变换，但是 指针所指向的内存单元存储的值发生了变化。 通过这样的方式达到修改变量的目的。\nvoid swap2(int *a,int *b){ //通过指针访问变量的值，然后直接交换值 int temp=*a;//取出地址a的值，并赋值给整型变量temp *a=*b;\t//取出地址b的值，并将这个值赋给地址a指向的值 *b=temp;\t//将temp的值赋给地址b所指向的值 } int main(){ swap2(\u0026amp;a,\u0026amp;b); } 注意，指针作值传递的过程中，修改的对象必须是指针指向的内存单元而不是指针本身！ 看下面的例子，它无法完成变量的值的交换。\nvoid swap3(int *a,int *b){ //交换指针的值，从而达到交换指针所指向的变量的值 int *temp=a; a=b; b=temp; } int main(){ swap3(\u0026amp;a,\u0026amp;b); } 看下面的例子，理解指针作值传递：\n#include \u0026lt;stdio.h\u0026gt; //测试函数 int* test(int *a){ printf(\u0026quot;%d\\n\u0026quot;,\u0026amp;a); return a; } int main(){ int a[2]={1,2}; int *p=a; printf(\u0026quot;%d\\n\u0026quot;,\u0026amp;p); p=test(a); printf(\u0026quot;%d\\n\u0026quot;,\u0026amp;p); return 0; } 程序将指针作实参传入函数，结合对实参的存储地址和形参的存储地址分析，可以发现地址不同，因此判断是函数内形参是临时变量，因此应视为指针作值传递。\n引用传递 引用是变量的一个别名，调用这个别名和调用这个变量是完全一样的。\n注意：\n引用是别名，并不是一种数据类型，内存并不会给它单独分配内存，而是直接调用它所引用的变量。 特别地，C语言不接受引用，函数形参列表不接受引用传递；仅实参可以使用引用。 void swap4(int \u0026amp;a,int \u0026amp;b){//该代码无法通过编译，形参不接受引用传递 int temp=a; a=b; b=temp; } int main(){ int a=10; int \u0026amp;d=a;//该代码无法通过编译，C语言不接受引用 swap3(\u0026amp;a,\u0026amp;b);//仅实参可以使用引用 } ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/4-2-functionassignment/","tags":[],"title":"Pass By Value \u0026 Reference"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Lie Group \u0026amp; Lie Algebras 李群 \\(\\mathcal{L}\\) 是一个群同时也是一个光滑的(可微的)的流形, 定义其上的群乘法和求逆运算均可微;\n李代数 \\(\\mathcal{A}\\) 是 \\(\\mathcal{L}\\) 的在单位元 \\(\\mathcal{1}\\) 处的正切空间;最常见的李群就是 SO(n) 和 SE(n)\n李群/李代数/正切向量的映射关系:\n\\(\\wedge:\\mathbb{R}^n \\to \\mathcal{A}\\) 把正切向量映射到李代数 \\(\\mathcal{A}\\) 中的元素 \\(exp(\\phi^{\\wedge}):\\mathbb{R}^n \\to \\mathcal{L}\\) 把正切向量 \\(\\phi\\) 映射到李代数元素, 然后再映射到李群中的元素 \\(\\vee:\\mathcal{A} \\to \\mathbb{R}^n\\) \\(\\wedge\\) 的逆运算, 把李代数中的元素映射到正切向量 \\(ln⁡( R)^{vee}:\\mathcal{L} \\to \\mathbb{R}^n\\) \\(exp\\) 的逆运算，把李群中的元素映射导李代数中的元素，然后再映射到正切向量 其中 \\(\\mathbb{R}^n\\) 代表 n 维向量空间\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/5-lie-group-and-lie-algebras-exercise/","tags":[],"title":"Lie Group and Lie Algebras Exercise"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"所谓作用域，就是变量的有效范围。\n局部变量 定义在函数内部或代码块内部的变量称为局部变量，它的作用域仅限于函数或代码块内部， 否则无效。\n说明：\n在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；\n同时，main 函数中也不能使用其它函数中定义的变量。main 函数是一个函数，与其它函数地位平等。\n形参变量、在函数体内定义的变量都是局部变量。实参给形参传值的过程也就是给局部变量赋值的过程。\n可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆。\n在语句块中定义变量，它的作用域只限于当前语句块，如for、if等或单纯的语句块。\n全局变量 在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序。注意整个程序是所有的源文件，包括源文件和头文件。\n在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。\n就近原则 不同作用域定义的同名变量无关联；\n嵌套的作用域允许定义同名变量，使用变量的原则是就近原则，外层作用域的同名变量将被屏蔽。\n#include\u0026lt;stdio.h\u0026gt; int main(int args,int *argv[]){ int a=0; { double a=1.0; a+=1; printf(\u0026quot;%f\u0026quot;,a); } printf(\u0026quot;%d\u0026quot;,a); } ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/5-scope/","tags":[],"title":"Scope"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"概念 计算机程序在存储数据时需要跟踪三种属性：\n信息存储在何处 存储的值是多少 存储的信息是什么类型 声明变量时：\n通过声明语句指明的符号名跟踪内存单元； 程序为该变量分配内存来存储值； 声明语句指出值的类型和符号名； 变量的地址称为该变量的指针，保存变量地址的变量称为指针变量；\n通过变量A存储变量B的地址，并可以通过A访问B，则称A为指向B的指针变量，一般简称A为指向B的指针。\n指针 声明 定义指针变量：dataType * p;\n*在与数据类型结合时，表示这是一个指向该数据类型的指针类型；\n*与变量名结合时，作为间接值/间接访问/解除引用运算符，表示将通过该指针变量间接找到所指向的变量的值；或表示p是一个引用，通过解除引用该指针变量从而找到它指向变量的值；\n综上，称p是dataType*类型，而*p是dataType类型。\n连续定义时每个变量前都需要带*，否则只有第一个变量会被解析为指针变量。\nint *a,*b,*c; 特别地，数组名可以被认为是指针常量。\n赋值与取值 由于指针保存变量的地址，因此用取地址运算符对变量取地址，而后将地址赋给指针。\nint *p=\u0026amp;a; //这种声明即赋值的方法等效于下面两行： int *p; p=\u0026amp;a; 注意到p是int*类型，a是int类型，\u0026amp;a是int*类型。\n对指针作解除引用运算，得到指针所指向的变量的值。\nint c=*p; 对指针变量A所指向的变量B的值的操作等效于直接对B进行操作。\n#include\u0026lt;stdio.h\u0026gt; int main(){ int a=10; int *p=\u0026amp;a; *p=20; printf(\u0026quot;%d\u0026quot;,a); } 下面的操作等价：\nint a[2]={1,2}; int *p1=\u0026amp;a[0]; int *p2=\u0026amp;*a; int *p3=a; 地址 指针大小 指针变量保存的是地址，地址本质上是整数。\n一般地，指针变量大小由当前CPU运行模式的寻址位数决定。\n寻址位数(bit) 指针大小(字节) 16 2 32 4 64 8 指针移动 #include\u0026lt;stdio.h\u0026gt; int main(){ char a='A',*pa=\u0026amp;a，*paa = \u0026amp;a; int b=20,*pb=\u0026amp;b; double c=99.9,*pc=\u0026amp;c; printf(\u0026quot;\u0026amp;a=%#xc, \u0026amp;b=%#x, \u0026amp;c=%#x\\n\u0026quot;, \u0026amp;a, \u0026amp;b, \u0026amp;c); printf(\u0026quot;pa=%#X, pb=%#X, pc=%#X\\n\u0026quot;, pa, pb, pc); pa++; pb++; pc++; printf(\u0026quot;pa=%#X, pb=%#X, pc=%#X\\n\u0026quot;, pa, pb, pc); pa -= 2; pb -= 2; pc -= 2; printf(\u0026quot;pa=%#X, pb=%#X, pc=%#X\\n\u0026quot;, pa, pb, pc); //比较运算 if(pa == paa){ printf(\u0026quot;%d\\n\u0026quot;, *paa); }else{ printf(\u0026quot;%d\\n\u0026quot;, *pa); } return 0; } 注意到pa、pb、pc 每次加 1，它们的地址分别增加 4、8、1，正好是 int、double、char 类型所占字节的长度；减 2 时，地址分别减少 8、16、2，正好是 int、double、char 类型所占字节的长度的 2 倍。\n对于指向数据类型为T的指针p：\n表达式p+1 实际上地址值变化sizeof(T)； 当p保存数组首地址时，具体含义是指向下一个元素。 表达式\u0026amp;p+1 实际上地址值变化sizeof(p)； 不一定有具体含义。 特别注意：\n(*p)++代表指向的元素自增，去掉括号则代表指向下一个元素！因为单目运算符结合顺序是右到左。 不能对指针变量进行乘、除、取余等运算。 数组 数组概念 数组是一种数据格式，用来存储多个同类型的值。\n声明数组应指出：存储的元素的数据类型、数组名、数组元素个数。\n访问数组则应从0开始，一直到n-1结束。\n特别地，编译器不会检查下标是否有效。因此保证下标的有效性尤为重要。\n数组与指针 数组名可以认为是指针常量，指向数组的第0个元素。 数组第 0 个元素的地址也称为数组的首地址。\n数组名的本意是表示整个数组，且数组名和数组首地址并不总是等价。 其特点如下：\n编译时编译器知道数组的长度； 数组名在其作用域内编译器认为它是数组； 在作用域外数组名退化为指向数组第 0 个元素的指针； 下面的例子说明数组名可以认为是数组首地址的情况：\n#include \u0026lt;stdio.h\u0026gt; int main(){ int arr[] = { 1, 2, 3, 4, 5 }; int len = sizeof(arr) / sizeof(int); //求数组长度 int i; for(i=0; i\u0026lt;len; i++){ printf(\u0026quot;%d \u0026quot;, *(arr+i) ); //*(arr+i)等价于arr[i] } printf(\u0026quot;\\n\u0026quot;); return 0; } 下面的例子说明数组名在作用域内代表整个数组，在作用域外退化为指针常量：\n#include \u0026lt;stdio.h\u0026gt; int* test(int arr[]){ return arr; } int main(){ int arr[] = { 1, 2, 3, 4, 5 }; int len1=sizeof(arr)/sizeof(int); int *p=test(arr); int len2=sizeof(test(arr))/sizeof(int); int len3=sizeof(p)/sizeof(int); printf(\u0026quot;%d,%d,%d\u0026quot;,len1,len2,len3); return 0; } 注意：\nsizeof是运算符，它的值(或它代表的表达式)在编译时已经确定。\nC标准规定sizeof不能用于函数，但是GNU C扩展了，使之对void类型返回1，对函数类型返回函数指针的长度(在64位寻址能力的CPU上是8)。（注意划线部分也可能输出1）\n上述程序中函数test的返回值类型不要写错了。\n由于指针可以由整型变量保存，因此如果写int，编译器报“从返回类型为int的函数返回int * ，将指针转换为整型而不进行类型转换”，而后返回整型，执行时会抛出异常，非常“贴心”。\n指针引用数组元素 对于一维数组，引用方法如下：定义int a[10];\n下标法a[i] 指针法*(a+i) 指针运算方法：定义int *p=a; 注意对指针访问进行是否越界检查。\n下一个元素*(p+1)或*(p+=1)或*(++p)；\n上一个元素*(p-1)或*(p-=1)或`*(++p)；\n定义int *p1,*p2都指向同一数组的元素\np1-p2代表表示两个元素之间差了多少个元素。\n注意为什么不写a++，因为a的值是常量。\n对于二维数组，见二维数组指针节。\n指针数组 数组中所有元素保存的元素是指针，称为指针数组。类型上可以将它当做二级指针使用。\ndataType *arrayName[length]//[]优先级高于*，故应该理解为 dataType *(arrayName[length]) 在访问各个指针元素时使用*(*arrayName+j)或*arrayName[j]。\n下面是整型指针数组的例子：\n#include\u0026lt;stdio.h\u0026gt; int main(){ int a=1,b=2,c=3; int *arr[3]={\u0026amp;a,\u0026amp;b,\u0026amp;c}; int **parr=arr; //指针和二级指针的值输出 printf(\u0026quot;%d, %d, %d, %d\\n\u0026quot;,arr,parr,*arr,*parr); //二级指针指向的值的输出 printf(\u0026quot;%d, %d, %d\\n\u0026quot;, *arr[0], *arr[1], *arr[2]); printf(\u0026quot;%d, %d, %d\\n\u0026quot;, **(parr+0), **(parr+1), **(parr+2)); return 0; } 可以发现指针数组中一级指针和二级指针输出的地址不同。\n数组指针的应用：处理多个字符串，利用函数数组指针实现if-else功能。\n下面是字符串指针数组的例子：\n#include\u0026lt;stdio.h\u0026gt; int main(){ char *str[3] = { \u0026quot;String Test.\u0026quot;, \u0026quot;Using Char Data Type.\u0026quot;, \u0026quot;It is in C Language.\u0026quot; }; printf(\u0026quot;%s\\n%s\\n%s\\n\u0026quot;, str[0], str[1], str[2]); printf(\u0026quot;%d,%d,%s\u0026quot;,str,*str,*str); return 0; } 字符数组str中存放的是字符串的首地址，不是字符串本身。\n字符串存储的位置在其他的内存区域，和字符数组是分开的。\n一维数组和数组指针 数组名是常量，代表数组首元素的地址；\n对数组名进行取地址操作，其类型为整个数组\nint a[10]; int *p1=a;//相当于 int *p1=\u0026amp;a[0]; int (*p2)[10]=\u0026amp;a; 注意，在面对a+1和\u0026amp;a+1的区别时：\na表示数组首元素首地址，其类型为int *，因此a+1相当于数组首地址值+sizeof(int)；\n称p1是指向数组a的指针，通过p1[i]能够访问a的每一个元素。\n\u0026amp;a表示整个数组的首地址，其类型为int (*)[10]，因此\u0026amp;a+1相当于数组首地址值+sizeof(a)。\n称p2是指向数组a的首地址的指针，\n通过(*p2)[i]能够访问a的每一个元素； 通过(*p2)+i能够访问a的每一个元素的地址。 多维数组 二维数组 二维数组在逻辑上是二维的，在内存中所有的数组元素都是连续排列的； 二维数组中的各个元素存放顺序是按行优先排列的； 允许把二维数组分解成多个一维数组来处理； #include\u0026lt;stdio.h\u0026gt; int main(){ int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23}; //打印第一维数组的数组名，它保存的是a[0]的首地址；打印第二维数组的数组名，它保存着a[0][0]的首地址 printf(\u0026quot;%d %d\\n\u0026quot;,a,*a); //均打印第二维数组的数组名，它保存它第一个元素a[0][0]的首地址 printf(\u0026quot;%d %d\\n\u0026quot;,a[0],*(a+0)); //打印第一维数组的数组名，它保存的是a[0]的首地址；打印第一个元素a[0][0]的首地址 printf(\u0026quot;%d %d\\n\u0026quot;,\u0026amp;a[0],\u0026amp;a[0][0]); printf(\u0026quot;%d %d\\n\u0026quot;,a[1],a+1); printf(\u0026quot;%d %d\\n\u0026quot;,\u0026amp;a[1][0],*(a+1)+0); printf(\u0026quot;%d %d\\n\u0026quot;,a[2],*(a+2)); printf(\u0026quot;%d %d\\n\u0026quot;,\u0026amp;a[2],a+2); printf(\u0026quot;%d %d\\n\u0026quot;,a[1][0],*(*(a+1)+0)); return 0; } 设二维数组的数组名为a，则访问的元素的数据类型：\n形如*(*(a+i)+j)或a[i][j]或*(a[i]+j)或*(a+i)[j]，程序员需要注意检查是否越界； 形如a,*a,a[0],*(a+0),\u0026amp;a[0],\u0026amp;a[0][0]的均为首地址，具体代表内容需要根据情况判断； 其他指针类型的地址值具体计算方法见下： 设二维数组中第一级M个指针，第二级N个指针。数据类型为dataType\n一级指针每变化1，地址值变化sizeof(N*sizeof(dataType))，即到上一行或下一行 二级指针每变化1，地址值变化sizeof(dataType)，即到上一个元素或下一个元素； 二维数组与数组指针 首先明确：二级指针和二维数组不是一个概念！多维同理！\nint a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};//定义二维数组a int (*p1)[3][4]=\u0026amp;a;//\u0026amp;a为整个数组的首地址，类型为int (*)[3][4],定义指向\u0026amp;a的指针变量p1； int (*p2)[4]=a;//a为第一维数组的数组名，类型为int (*)[4]，定义指向a的指针变量p2 int *p3 =a[0];//a[0]为第二维数组的数组名，类型为int *，定义指向a[0]的指针变量p3 注意，在面对a+1、\u0026amp;a+1的区别时：\na[0]表示数组（第一行的）第一个元素的首地址，其类型为int *，因此a[0]+1相当于数组首地址值+sizeof(int)；\n称p3是指向数组a第一行的指针，能够访问a的第一行的每一个元素。\na表示数组第一行的首地址，其类型为int (*)[4]，因此a+1相当于数组首地址值+sizeof(int[4])；\n称p2是指向数组a的指针，能够访问a的每一个元素\n\u0026amp;a表示整个数组的首地址，其类型为int (*)[3][4]，因此\u0026amp;a+1相当于数组首地址值+sizeof(a)。\n称p1是指向数组a的首地址的指针，能够访问a的每一个元素的地址。\n特别地，数组名 a 在表达式中会被转换为和 p2 等价的指针！\n注意：写作int *p[4]，那么应该理解为int *(p[4])，p 就成了一个指针数组，而不是数组指针。\n指针数组和数组指针的区别 指针数组和数组指针在定义时非常相似，只是括号的位置不同：\nint *(p1[5]); //指针数组，可以去掉括号直接写作 int *p1[5]; int (*p2)[5]; //数组指针，不能去掉括号 指针数组和二维数组指针有着本质上的区别：\n指针数组是一个数组，只是每个元素保存的都是指针；\n它用于访问一系列指针。\n数组指针是一个指针，它指向一个数组；\n它用于访问一维数组中每个元素的地址*(*p)+n或二维数组中的每个元素*(*p+i)+j；\n实参 形参 类型名 类型 类型名 类型 数组的数组（二维数组） int c[8][10] 数组指针 int (*)[10] 指针数组 int *c[10] 指针的指针（二级指针） int ** c 数组指针 int (*)[10] 不改变 int (*)[10] 指针的指针（二级指针） char ** 不改变 char ** 作为函数参数的多维数组 本节摘自《C与指针》中的指针节。\nint matrix[3][10]; func(matrix); 函数原型应为：\nvoid func(int (*mat)[10]); void func(int mat[][10]); 该函数中，mat的第一个下标根据包含10个元素的整型数组长度进行调整，第二个下标根据整型的长度进行调整。\n关键在于编译器必须知道第二个及以后的维度的长度才能够对各下标求值，故原型中必须声明这些维的长度。而第一维的长度并不需要，计算下标值时用不到它（可被自动计算）。\n因此编写一维数组的形参的函数原型时，既可以写成数组形式，也可以写成指针的形式。但是对于多维数组，只有第一维可以如此选择。特别地，下面的原型是错误的：\nvoid func(int **mat); 语法检查的时候不会报错，但是运行的时候会出现段错误。\n这是因为该原型把mat声明为一个指向整型指针的指针，但是需要的是指向整型数组的指针。\n下面的例子更详细地讨论多维数组作参数时的情况：\n#include \u0026lt;stdio.h\u0026gt; int test1(int (*a)[2][3]) { printf(\u0026quot;%d\\n\u0026quot;, ***a);//a[0][0][0]=1 printf(\u0026quot;%d\\n\u0026quot;, *(*(*a + 1) + 1));//a[0][1][1]=5 return 0; } int test2(int (*a)[3]) { printf(\u0026quot;%d\\n\u0026quot;, *(*a));//a[1][0][0]=7 printf(\u0026quot;%d\\n\u0026quot;, *(*a + 1));//a[1][0][1]=8 printf(\u0026quot;%d\\n\u0026quot;, *(*a + 2));//a[1][0][2]=9 return 0; } int test3(int *a) { printf(\u0026quot;%d\\n\u0026quot;, *a);//a[0][1][0]=4 printf(\u0026quot;%d\\n\u0026quot;, *(a + 1));//a[0][1][1]=5 printf(\u0026quot;%d\\n\u0026quot;, *(a + 2));//a[0][1][2]=6 return 0; } int main(int argc, char const *argv[]) { int a[2][2][3] = {{{1, 2, 3},{4, 5, 6}},{{7, 8, 9}, {10, 11, 12}}}; test1(a); test2(*(a + 1)); test3(*(*a + 1)); return 0; } 函数指针 函数指针是指向函数的指针，保存函数的入口地址。通过函数指针可以调用该函数。\n函数指针声明：\nreturnType (*pointerName)(param list); 注意()的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(param list);就成了函数原型，它表明函数的返回值类型为returnType *。\n函数指针调用时可以直接用指针名pointerName(param list)，也可以用(*pointerName)(param list)。\n#include \u0026lt;stdio.h\u0026gt; //返回两个数中较大的一个 int max(int a, int b){ return a\u0026gt;b ? a : b; } int main(){ int x, y, maxval; //定义函数指针 int (*pmax)(int, int) = max; //也可以写作int (*pmax)(int a, int b) printf(\u0026quot;Input two numbers:\u0026quot;); scanf(\u0026quot;%d %d\u0026quot;, \u0026amp;x, \u0026amp;y); maxval = (*pmax)(x, y);//也可以写作maxval=pmax(x,y); printf(\u0026quot;Max value: %d\\n\u0026quot;, maxval); return 0; } 总结 定义 含义 int *p; p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。 int **p; p 为二级指针，指向 int * 类型的数据。 int *p[n]; p 为指针数组。[]的优先级高于 *，所以应该理解为 int *(p[n]); int (*p)[n]; p 为二维数组指针。 int *p(); p 是一个函数，它的返回值类型为 int *。 int (*p)(); p 是一个函数指针，指向原型为 int func() 的函数。 特别注意：\n指针变量可以进行加减运算，具体跟指针指向的数据类型有关。\n给指针变量赋值时，要将一份数据的地址赋给它，不能直接赋给数据；\n使用指针变量之前一定要初始化，否则指针就成了野指针，可能造成崩溃。\n对于暂时没有指向的指针，建议赋值NULL。\n若两个指针变量指向同一个数组中的某个元素，那么两个指针变量可以相减，相减的结果就是两个指针之间相差的元素个数。\n数组也是有类型的，数组名的本意是表示一组类型相同的数据。\n在定义数组时，或者和 sizeof、\u0026amp; 运算符一起使用时数组名才表示整个数组； 表达式或形参列表中的数组名会被转换为一个指向数组的指针。 ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/6-pointer/","tags":[],"title":"Pointer"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Matrix Derivative 下面介绍矩阵求导的相关内容。\n矩阵和向量求导是批量求导数的一种方式，其本质上还是矩阵或向量中的标量在求导，只是借助矩阵或者向量的形式，同时对多个因变量进行关于自变量的求导。\n矩阵求导的类型如下表所示：\nTypes Scalar Vector Matrix Scalar $\\frac{\\partial y}{\\partial x}$ \\(\\frac{\\partial \\mathbf{y}}{\\partial x}\\) \\(\\frac{\\partial \\mathbf{Y}}{\\partial x}\\) Vector $\\frac{\\partial y}{\\partial \\mathbf{x}}$ \\(\\frac{\\partial \\mathbf{y}}{\\partial \\mathbf{x}}\\) Matrix $\\frac{\\partial y}{\\partial \\mathbf{X}}$ Derivative of a scalar with respect to a vector 标量对向量求导。\n假设我们有一个标量值函数 \\( f(\\mathbf{x}) \\)，其中 \\(\\mathbf{x} = [x_1, x_2, \\ldots, x_n]^T\\) 是一个 \\( n \\) 维向量。标量对向量的导数结果是一个行向量（梯度），表示为： $$ \\nabla_{\\mathbf{x}} f = \\frac{\\partial f}{\\partial \\mathbf{x}} = \\begin{bmatrix} \\frac{\\partial f}{\\partial x_1} \u0026 \\frac{\\partial f}{\\partial x_2} \u0026 \\cdots \u0026 \\frac{\\partial f}{\\partial x_n} \\end{bmatrix}^T $$ Derivative of a vector with respect to a scalar 向量对标量求导。\n假设我们有一个向量值函数 \\(\\mathbf{f}(x)\\)，其中 \\(\\mathbf{f} = [f_1(x), f_2(x), \\ldots, f_m(x)]^T\\)，而 \\( x \\) 是一个标量。向量对标量的导数结果是一个列向量，表示为： $$ \\frac{d \\mathbf{f}}{d x} = \\begin{bmatrix} \\frac{d f_1}{d x} \\\\ \\frac{d f_2}{d x} \\\\ \\vdots \\\\ \\frac{d f_m}{d x} \\end{bmatrix} $$ Derivative of a vector with respect to a vector 假设我们有一个向量值函数 \\(\\mathbf{f}(\\mathbf{x})\\)，其中 \\(\\mathbf{f}\\) 是 \\( \\mathbb{R}^n \\to \\mathbb{R}^m \\) 的函数，\\(\\mathbf{f}(\\mathbf{x}) = [f_1(\\mathbf{x}), f_2(\\mathbf{x}), \\ldots, f_m(\\mathbf{x})]^T\\)，而 \\(\\mathbf{x} = [x_1, x_2, \\ldots, x_n]^T\\) 是一个 \\( n \\) 维向量。\n列向量 \\(\\mathbf{f}(\\mathbf{x})\\) 对行向量 \\(\\mathbf{x}\\) 的导数是雅可比矩阵（Jacobian matrix），定义如下： $$ \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}^T}= \\begin{bmatrix} \\frac{\\partial f_1}{\\partial \\mathbf{x}^T} \\\\ \\frac{\\partial f_2}{\\partial \\mathbf{x}^T} \\\\ \\vdots \\\\ \\frac{\\partial f_m}{\\partial \\mathbf{x}^T} \\end{bmatrix}= \\begin{bmatrix} \\frac{\\partial f_1}{\\partial x_1} \u0026 \\frac{\\partial f_1}{\\partial x_2} \u0026 \\cdots \u0026 \\frac{\\partial f_1}{\\partial x_n} \\\\ \\frac{\\partial f_2}{\\partial x_1} \u0026 \\frac{\\partial f_2}{\\partial x_2} \u0026 \\cdots \u0026 \\frac{\\partial f_2}{\\partial x_n} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ \\frac{\\partial f_m}{\\partial x_1} \u0026 \\frac{\\partial f_m}{\\partial x_2} \u0026 \\cdots \u0026 \\frac{\\partial f_m}{\\partial x_n} \\end{bmatrix} $$ 这是雅可比矩阵的分子分布，还有一种是分母分布，即行向量对列向量求导得到的，结果是以上雅可比矩阵的转置。\n这个矩阵的第 $i$ 行第 $j$ 列的元素是函数 $ f_i $ 对变量 $ x_j $ 的偏导数。换句话说，雅可比矩阵的每一行对应于向量值函数的一个分量对所有变量的偏导数组成的行向量。\n对于一个具体的例子，假设 $\\mathbf{f}(\\mathbf{x})$ 是一个二维向量值函数： $$ \\mathbf{f}(\\mathbf{x}) = \\begin{bmatrix} f_1(x_1, x_2) \\\\ f_2(x_1, x_2) \\end{bmatrix} $$ 则雅可比矩阵为： $$ \\mathbf{J} = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}^T} = \\begin{bmatrix} \\frac{\\partial f_1}{\\partial x_1} \u0026 \\frac{\\partial f_1}{\\partial x_2} \\\\ \\frac{\\partial f_2}{\\partial x_1} \u0026 \\frac{\\partial f_2}{\\partial x_2} \\end{bmatrix} $$ 这是向量对向量求导的公式和方法。\nDerivative of a matrix with respect to a vector Key Derivative 下面介绍几个重点导数：\n假设我们有两个向量 \\(\\mathbf{a}\\) 和 \\(\\mathbf{x}\\)，其中 \\(\\mathbf{a} = [a_1, a_2, \\ldots, a_n]^T\\) 和 \\(\\mathbf{x} = [x_1, x_2, \\ldots, x_n]^T\\)，则 $\\frac{\\partial \\mathbf{a}\\mathbf{x}}{\\partial \\mathbf{x}}$ 推导如下：\n首先，向量 \\(\\mathbf{a}\\) 和 \\(\\mathbf{x}\\) 的内积定义为： \\[ f(\\mathbf{x}) = \\mathbf{a}^T \\mathbf{x} = a_1 x_1 + a_2 x_2 + \\cdots + a_n x_n \\] 我们需要对 \\(\\mathbf{x}\\) 求导。根据向量微积分的定义，对 \\(\\mathbf{x}\\) 求导时，每个分量 \\(x_i\\) 的偏导数是 \\(a_i\\)。因此，梯度（导数）可以表示为一个列向量： $$ \\nabla_{\\mathbf{x}} (\\mathbf{a}^T \\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial (\\mathbf{a}^T \\mathbf{x})}{\\partial x_1} \\\\ \\frac{\\partial (\\mathbf{a}^T \\mathbf{x})}{\\partial x_2} \\\\ \\vdots \\\\ \\frac{\\partial (\\mathbf{a}^T \\mathbf{x})}{\\partial x_n} \\end{bmatrix} = \\begin{bmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{bmatrix} = \\mathbf{a} $$ 因此，向量 \\(\\mathbf{a}\\) 和 \\(\\mathbf{x}\\) 的内积对 \\(\\mathbf{x}\\) 的导数结果是向量 \\(\\mathbf{a}\\) 本身。\n假设 $x$ 是一个 $n \\times 1$ 的列向量，$A$ 是一个 $n \\times n$的对称矩阵，则 $\\frac{\\partial x^TAx}{\\partial x}$ 推导如下：\n展开 $x^TAx$: $$ x^TAx=\\sum_{i=1}^{n}\\sum_{j=1}^{n}x_iA_{ij}x_j $$ 其中 $x_i$ 是 $x$ 的第 $i$ 个分量，$A_{ij}$ 是 $A$ 的第 $i$ 行第 $j$ 列的元素。\n对 $x_k$ 求导： $$ \\frac{\\partial }{\\partial x} \\left ( \\sum_{i=1}^{n} \\sum_{j=1}^{n} x_i A_{ij} x_j \\right ) = \\sum_{i=1}^n\\sum_{j=1}^n \\frac{\\partial }{\\partial x_k}(x_i A_{ij} x_j) $$ 考虑每一项 $x_i A_{ij} x_j$ 的导数： $$ \\frac{\\partial}{\\partial x_k} \\left ( x_i A_{ij} x_j \\right ) = \\delta_{ik} A_{ij} x_j + x_i A_{ij} \\delta_{jk} $$ 其中 $\\delta_{ik}$ 和 $\\delta_{jk}$ 是克罗内克 $delta$ 函数，当且仅当 $i=k$ 或 $j=k$ 时其值为 1，否则为 0。\n非零项的和为： $$ \\sum_{i=1}^{n} \\sum_{j=1}^{n} (\\delta_{ik} A_{ij} x_j + x_i A_{ij} \\delta_{jk})=\\sum_{j=1}^{n}A_{kj}x_j + \\sum_{i=1}^{n}x_iA_{ik} $$ 由于 $A$ 是对称的，即 $A_{ij}=A_{ji}$ ，所以： $$ \\sum_{j=1}^{n}A_{kj}x_j + \\sum_{i=1}^{n}x_iA_{ik} = \\sum_{j=1}^{n}A_{kj}x_j + \\sum_{j=1}^{n}x_jA_{jk} = 2\\sum_{j=1}^{n}A_{kj}x_j $$ 相当于： $$ \\frac{\\partial}{\\partial x_k}(x^TAx)=2(Ax)_k $$ 因此向量形式的求导结果是： $$ \\frac{\\partial}{\\partial x}(x^TAx)=2Ax $$ 不失一般性，若 $A$ 不是对称矩阵，则推导如下： 考虑函数的微分形式：\n\\[ df = d(\\mathbf{x}^T \\mathbf{A} \\mathbf{x}) \\] 根据微分的性质：\n\\[ d(\\mathbf{x}^T \\mathbf{A} \\mathbf{x}) = (\\mathbf{d x})^T \\mathbf{A} \\mathbf{x} + \\mathbf{x}^T \\mathbf{A} (\\mathbf{d x}) \\] 这可以进一步简化为：\n\\[ df = (\\mathbf{d x})^T \\mathbf{A} \\mathbf{x} + \\mathbf{x}^T \\mathbf{A} (\\mathbf{d x}) \\] 注意到 \\((\\mathbf{d x})^T \\mathbf{A} \\mathbf{x}\\) 是一个标量，等于它的转置，即：\n\\[ (\\mathbf{d x})^T \\mathbf{A} \\mathbf{x} = (\\mathbf{x}^T \\mathbf{A}^T \\mathbf{d x})^T = \\mathbf{d x}^T \\mathbf{A}^T \\mathbf{x} \\] 因此我们有：\n\\[ df = (\\mathbf{d x})^T \\mathbf{A} \\mathbf{x} + (\\mathbf{d x})^T \\mathbf{A}^T \\mathbf{x} = (\\mathbf{d x})^T (\\mathbf{A} + \\mathbf{A}^T) \\mathbf{x} \\] 由此可以看出：\n\\[ \\frac{\\partial (\\mathbf{x}^T \\mathbf{A} \\mathbf{x})}{\\partial \\mathbf{x}} = (\\mathbf{A} + \\mathbf{A}^T) \\mathbf{x} \\] 如果 \\(\\mathbf{A}\\) 是对称矩阵：\n\\[ \\frac{\\partial (\\mathbf{x}^T \\mathbf{A} \\mathbf{x})}{\\partial \\mathbf{x}} = 2 \\mathbf{A} \\mathbf{x} \\] 如果 \\(\\mathbf{A}\\) 不是对称矩阵：\n\\[ \\frac{\\partial (\\mathbf{x}^T \\mathbf{A} \\mathbf{x})}{\\partial \\mathbf{x}} = (\\mathbf{A} + \\mathbf{A}^T) \\mathbf{x} \\] Least Squares Introduce 接下来探讨为什么SLAM问题中使用优化方法时需要引入最小二乘。\n在SLAM（Simultaneous Localization and Mapping，即时定位与地图构建）中，最小二乘法是用于优化的问题解决方法之一。我们需要从SLAM中的条件概率分布出发，通过后验概率分布的最大化，再到最大似然估计，最终引出最小二乘的使用。\n即，最小二乘问题的解等价于状态的最大似然估计。\nConditional Probability Distribution 在SLAM中，我们需要估计机器人在环境中的位置和地图，这可以表示为状态变量 $\\mathbf{x}$（包括机器人的位置和地图的所有特征）。SLAM问题可以描述为在给定所有观测数据 $\\mathbf{z}$ 和运动数据 $\\mathbf{u}$ 的条件下，求状态变量 $\\mathbf{x}$ 的概率分布：\n$$ p(\\mathbf{x} \\mid \\mathbf{z}, \\mathbf{u}) $$ Posterior Probability Distribution 我们希望找到最有可能的状态变量 $\\mathbf{x}$，即后验概率最大的状态。这涉及最大化上述条件概率分布。根据贝叶斯公式，后验概率可以表示为： $$ p(\\mathbf{x} \\mid \\mathbf{z}, \\mathbf{u}) = \\frac{p(\\mathbf{z}, \\mathbf{u} \\mid \\mathbf{x}) p(\\mathbf{x})}{p(\\mathbf{z}, \\mathbf{u})} \\propto p(\\mathbf{z},\\mathbf{u} \\mid \\mathbf{x})p(\\mathbf{x}) $$ 其中，分母 $p(\\mathbf{z}, \\mathbf{u})$ 对于给定的观测和运动数据是一个常数。分子中左侧的 $p(\\mathbf{z},\\mathbf{u} \\mid \\mathbf{x})$ 代表似然，而 $p(\\mathbf{x})$ 称为先验。\n直接求后验分布是困难的，但是求一个状态最优估计，使得在该状态下后验概率最大化，则是可行的。\n最大化后验概率 $p(\\mathbf{x} \\mid \\mathbf{z}, \\mathbf{u})$ 等价于最大化联合概率 $p(\\mathbf{z}, \\mathbf{u} \\mid \\mathbf{x}) p(\\mathbf{x})$: $$ \\mathbf{x}_{\\text{MAP}} = \\arg\\max_{\\mathbf{x}} p(\\mathbf{x} \\mid \\mathbf{z}, \\mathbf{u}) = \\arg\\max_{\\mathbf{x}} p(\\mathbf{z}, \\mathbf{u} \\mid \\mathbf{x}) p(\\mathbf{x}) $$ Maximum Likelihood Estimation 在许多情况下，先验概率 $p(\\mathbf{x})$ 被假设为均匀分布或者对所有可能的状态 $\\mathbf{x}$ 来说是相同的，或者我们可能没有关于状态变量 $\\mathbf{x}$（例如机器人的位置或路标的位置）的先验知识。\n此时，最大化后验概率就简化为最大化似然函数 $p(\\mathbf{z}, \\mathbf{u} \\mid \\mathbf{x})$ ，即最大似然估计（Maximum Likelihood Estimation, MLE）： $$ \\mathbf{x}_{\\text{MLE}} = \\arg\\max_{\\mathbf{x}} p(\\mathbf{z}, \\mathbf{u} \\mid \\mathbf{x}) $$ Leads to Least Squares 为了实际进行计算，我们需要对似然函数 $p(\\mathbf{z}, \\mathbf{u} \\mid \\mathbf{x})$ 进行建模。常见的做法是将观测误差和运动误差建模为高斯分布。假设观测误差 $\\mathbf{e}_{\\mathbf{z}}$ 和运动误差 \\(\\mathbf{e}_\\mathbf{u}\\) 是独立的高斯分布，即：\n$$ \\mathbf{e}_{\\mathbf{z}} \\sim \\mathcal{N}(0, \\mathbf{R}) \\quad \\text{和} \\quad \\mathbf{e}_{\\mathbf{u}} \\sim \\mathcal{N}(0, \\mathbf{Q}) $$ 其中 $\\mathbf{R}$ 和 $\\mathbf{Q}$ 分别是观测和运动误差的协方差矩阵。于是，似然函数可以表示为： $$ p(\\mathbf{z}, \\mathbf{u} \\mid \\mathbf{x}) \\propto \\exp\\left(-\\frac{1}{2} \\left( \\mathbf{e}_{\\mathbf{z}}^T \\mathbf{R}^{-1} \\mathbf{e}_{\\mathbf{z}} + \\mathbf{e}_{\\mathbf{u}}^T \\mathbf{Q}^{-1} \\mathbf{e}_{\\mathbf{u}} \\right)\\right) $$ 最大化这个似然函数等价于最小化其负对数似然函数： $$ \\mathbf{x}_{\\text{MLE}} = \\arg\\min_{\\mathbf{x}} \\left( \\mathbf{e}_{\\mathbf{z}}^T \\mathbf{R}^{-1} \\mathbf{e}_{\\mathbf{z}} + \\mathbf{e}_{\\mathbf{u}}^T \\mathbf{Q}^{-1} \\mathbf{e}_{\\mathbf{u}} \\right) $$ 这实际上就是一个加权最小二乘问题，因为我们在最小化误差的平方和。\nLeast Squares Solution Introduce 考虑最简单的最小二乘问题： $$ \\min_x F(x)=\\frac{1}{2} \\| f(x) \\|_2^2 $$ 其中，自变量 $x \\in \\mathbb{R}^n$， $f$ 是任意标量非线性函数 $f(x): \\mathbb{R}^n \\to \\mathbb{R}$ 。\n当求解 $$ \\frac{\\mathrm{d} y}{\\mathrm{d} x}=0 $$ 较为困难时，可以使用迭代的方式，从初始值出发，不断更新当前的优化变量，以令目标函数下降：\n给定初始值 $x_0$ 对于第 $k$ 次迭代，寻找增量 $\\Delta x_k$，使得 \\(\\| f(x_k+\\Delta x_k) \\|_2^2\\) 达到极小值 若 $\\Delta x_k$ 足够小，则停止 否则，令 $x_{k+1}=x_k+\\Delta x_k$，返回2 Gradient Descent Method 考虑第 $k$ 次迭代，将目标函数 $F(x)$ 在 $x_k$ 处泰勒展开： $$ F(x_k+\\Delta x_k) \\approx F(x_k) + \\mathbf{J}(x_k)^T\\Delta x_k + \\frac{1}{2}\\Delta x_k^T\\mathbf{H}(x_k)\\Delta x_k $$ 其中 $\\mathbf{J}(x_k)$ 是 $F(x)$ 关于 $x$ 的一阶导数（或雅可比矩阵），而 $\\mathbf{H}$ 是二阶导数（海塞Hessian矩阵）。\n由于梯度是向量，自变量沿着该向量方向变化时，函数增长最快，因此保留一阶梯度时，取增量为反向的梯度保证函数下降： $$ \\Delta x^* = -\\alpha \\mathbf{J}(x_k) $$ 其中 $\\alpha$ 是学习率或者步长，以上的方法称为最速下降法(Gradient Descent Method)。\nNewton Method 保留二阶梯度时，增量方程为 $$ \\Delta x^* = \\arg\\min \\left ( F(x)+\\mathbf{J}(x)^T\\Delta x + \\frac{1}{2}\\Delta x^T\\mathbf{H}\\Delta x \\right ) $$ 设 $$ G(\\Delta x)=\\mathbf{J}(x)^T\\Delta x + \\frac{1}{2}\\Delta x^T\\mathbf{H}\\Delta x $$ 我们希望找到 $\\Delta x$ 使得 $G(\\Delta x)$ 最小。求解其关于 $\\Delta x$ 的导数并令其为零，得到 $$ \\mathbf{J}+\\mathbf{H}\\Delta x=0 \\Rightarrow \\mathbf{H}\\Delta x=-\\mathbf{J} $$ 最终得到 $$ \\Delta x_k=-\\mathbf{H}(x_k)^{-1}\\mathbf{J}(x_k) $$ 该方法称为牛顿法。\nDerivative 对 $\\Delta x$ 向量，$\\frac{1}{2} \\Delta x^T \\mathbf{H} \\Delta x$ 关于 $\\Delta x$ 求导：\n由于 $\\mathbf{H}$ 是 Hessian 矩阵，因此它是对称的\n根据 $$ \\frac{\\partial}{\\partial x}(x^TAx)=2Ax $$ 其中，$A$ 是对称矩阵。\n我们有： $$ \\frac{\\partial}{\\partial x}(\\frac{1}{2} x^T\\mathbf{H}x)=\\mathbf{H}x $$ Gauss-Newton Method 高斯牛顿法用于求解非线性最小二乘问题，它的思想是将 $f(x)$ 进行一阶泰勒展开，注意是 $f(x)$ 不是目标函数 $F(x)$。 $$ f(x+\\Delta x) \\approx f(x) + J(x)^T \\Delta x $$ 其中 $ J(x)^T $ 是 $f(x)$ 关于 $x$ 的雅可比矩阵。根据前面所述，目标是寻找增量 $\\Delta x$ 使得 \\( \\| x+\\Delta x \\|^2\\) 达到最小 $$ \\begin{aligned} \\Delta x^*\u0026=\\| x+\\Delta x \\|^2 \\\\ \u0026=\\frac{1}{2} \\| f(x_k) + J(x_k) \\Delta x \\|^2 \\end{aligned} $$ 接下来，我们需要化简这个目标函数。首先展开并利用矩阵范数性质： $$ \\frac{1}{2} \\| f(x_k) + J(x_k) \\Delta x \\|^2 = \\frac{1}{2} (f(x_k) + J(x_k) \\Delta x)^T (f(x_k) + J(x_k) \\Delta x) $$ 展开内积： $$ = \\frac{1}{2} \\left( f(x_k)^T f(x_k) + f(x_k)^T J(x_k) \\Delta x + (\\Delta x)^T J(x_k)^T f(x_k) + (\\Delta x)^T J(x_k)^T J(x_k) \\Delta x \\right) $$ 注意到 $ f(x_k)^T J(x_k) \\Delta x $ 和 $ (\\Delta x)^T J(x_k)^T f(x_k) $ 是标量，且它们互为转置，因此相等： $$ = \\frac{1}{2} \\left( f(x_k)^T f(x_k) + 2 f(x_k)^T J(x_k) \\Delta x + (\\Delta x)^T J(x_k)^T J(x_k) \\Delta x \\right) $$ 我们可以进一步简化： $$ = \\frac{1}{2} f(x_k)^T f(x_k) + f(x_k)^T J(x_k) \\Delta x + \\frac{1}{2} (\\Delta x)^T J(x_k)^T J(x_k) \\Delta x $$ 这个目标函数是关于 $ \\Delta x $ 的二次函数。为了最小化它，我们对 $ \\Delta x $ 求导并设导数为零： $$ \\nabla_{\\Delta x} \\left( \\frac{1}{2} f(x_k)^T f(x_k) + f(x_k)^T J(x_k) \\Delta x + \\frac{1}{2} (\\Delta x)^T J(x_k)^T J(x_k) \\Delta x \\right) = 0 $$ 求导得到： $$ J(x_k)^T f(x_k) + J(x_k)^T J(x_k) \\Delta x = 0 $$ 解得： $$ \\Delta x = - (J(x_k)^T J(x_k))^{-1} J(x_k)^T f(x_k) $$ 因此，高斯-牛顿法的迭代更新公式为： $$ x_{k+1} = x_k + \\Delta x = x_k - (J(x_k)^T J(x_k))^{-1} J(x_k)^T f(x_k) $$ 这个更新公式将新的迭代值 $ x_{k+1} $ 计算为当前迭代值 $ x_k $ 减去修正量 $\\Delta x$，其中 $\\Delta x$ 由雅可比矩阵 $ J(x_k) $ 和函数值 $ f(x_k) $ 计算得到。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/7-nonlinear-optimize/","tags":[],"title":"Non linear Optimize"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"结构体 存储空间：所有成员变量占用内存空间的和。\n结构体定义：\nstruct student{ int num; char name[20]; char sex; char addr[20]; }std1,std2;//分号前可以直接声明具有结构体类型的变量 声明结构体变量：\nstudent a; 共用体 共用体允许在相同的内存位置存储不同的数据类型。\n可以定义带有多成员的共用体，但是任何时候只能有一个成员带有值。为某成员赋值会破坏其他成员存储的值。\nunion Data{ int i; float f; char str[20]; }data1,data2; 存储空间：等于最大成员占的内存空间。\n","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/7-customdatatypes/","tags":[],"title":"Custom Data Type"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Output puts()：只能输出字符串，并且输出结束后会自动换行； putchar()：只能输出单个字符； printf()：可以输出各种类型的数据； Printf() int printf(const char *format, ...) 功能：发送格式化输出到标准输出 stdout。\n格式控制 格式控制符\n说明\n%hd、%d、%ld\n以十进制、有符号的形式输出 short、int、long 类型的整数\n%hu、%u、%lu\n以十进制、无符号的形式输出 short、int、long 类型的整数\n%ho、%o、%lo\n以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数\n%#ho、%#o、%#lo\n以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数\n%hx、%x、%lx、%hX、%X、%lX\n以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。\n%#hx、%#x、%#lx、%#hX、%#X、%#lX\n以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。\n%f、%lf\n以十进制的形式输出 float、double 类型的小数\n%e、%le、%E、%lE\n以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。\n%g、%lg、%G、%lG\n以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。\n%c\n输出一个单一的字符\n%s\n输出一个字符串\n高级用法 %[flag][width][.precision]type 注释：\ntype表示输出类型，如d、f、c等；\nwidth表示最小输出宽度，即至少占用多少字符\n当输出结果小于最小宽度，则左对齐时右补空格，右对齐时左补空格（默认）。\n当输出结果大于最小宽度，该限制失效。\nprecision表示只取输出的左边字符数（保留有效数字位数）。\nflag指示左右对齐方式，默认为右对齐，-为左对齐；+为输出数据的符号。\n下面是一些应用举例(m为常数)：\n可以用%m.nf指定数据宽度和小数位数，m表示浮点数所占的列数，n表示小数所占的位数。\n可以用%md进行右对齐；\n可以用%-md进行右对齐；\n可以用%ms指定输出字符串占的列数，少则左补空格，多则突破限制；\n可以用%m.ns指定输出字符串占的列数及只取字符串左边n个字符输出在m列的右侧，左补空格\n补充 如果需要输出%，则需要额外用一个%转义。\nputs() int puts(const char *str) 功能：把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。\nputchar() int putchar(int char) 功能：把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。\n输出缓冲区 见下面的例子：\n#include\u0026lt;stdio.h\u0026gt; #if linux #include\u0026lt;unistd.h\u0026gt; #elif _WIN32 #include\u0026lt;windows.h\u0026gt; #endif int main() { printf(\u0026quot;Before sleep.\u0026quot;); #if linux sleep(5);//该函数以秒为单位 #elif _WIN32 Sleep(5000);//该函数以毫秒为单位 #endif printf(\u0026quot;After sleep.\\n\u0026quot;); return 0; } printf函数执行结束以后数据并没有直接输出到显示器上，而是放入了缓冲区，直到遇见换行符\\n才将缓冲区中的数据输出到显示器上。\nInput scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。 getchar()、getche()、getch()：这三个函数都用于输入单个字符。 gets()：获取一行数据，并作为字符串处理。 scanf() 最重要的事情：等待输入的变量必须加\u0026amp;。\n特别地，输入字符串的变量不加\u0026amp;，因为字符串的名字会自动转换为字符串的地址。加上\u0026amp;会产生警告。\n格式控制 格式控制符\n说明\n%c\n读取一个单一的字符\n%s 读取一个字符串（以空白符为结束） %hd、%d、%ld\n读取一个十进制整数，并分别赋值给 short、int、long 类型\n%ho、%o、%lo\n读取一个八进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型\n%hx、%x、%lx\n读取一个十六进制整数（可带前缀也可不带），并分别赋值给 short、int、long 类型\n%hu、%u、%lu\n读取一个无符号十进制整数，并分别赋值给 unsigned short、unsigned int、unsigned long 类型\n%f、%lf\n读取一个十进制形式的小数，并分别赋值给 float、double 类型\n%e、%le 读取一个指数形式的小数，并分别赋值给 float、double 类型 %g、%lg 既可以读取一个十进制形式的小数，也可以读取一个指数形式的小数，并分别赋值给 float、double 类型 %p 读入一个指针 %[] 扫描字符集合 %% 读入%符号 scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。\n输入缓冲区 当遇到 scanf() 函数时，程序会先检查输入缓冲区中是否有数据：\n无数据，就等待用户输入。直到产生换行符，输入结束；\n有数据，是否符合控制字符串的规则：\n匹配控制字符串，读取；\n仅匹配前半部分控制字符串，则等待用户输入剩下的数据；\n不符合，尝试忽略一些空白符，如空格、制表符、换行符；\n特别地，仅控制字符串是%d、%c、%f等开头时，可以忽略空白符。\n尝试成功，重复匹配过程； 尝试不成功，读取失败。 例1，scanf()输入读取失败\n#include\u0026lt;stdio.h\u0026gt; int main(){ int a,b=999; char str[30]; printf(\u0026quot;b=%d\\n\u0026quot;,b); scanf(\u0026quot;%d\u0026quot;,\u0026amp;a); scanf(\u0026quot;%d\u0026quot;,\u0026amp;b); scanf(\u0026quot;%s\u0026quot;,str); printf(\u0026quot;a=%d,b=%d,str=%s\\n\u0026quot;,a,b,str); return 0; } 程序分析：\n第一个 scanf() 时等待用户输入，从键盘输入内容100 testScanf，按下回车键，scanf() 匹配到 100，赋值给变量a，同时将内部的位置指针移动到 100 后面。 第二个 scanf()，缓冲区中有数据，直接读取。此时缓冲区中的内容为testScanf\\n，忽略开头的空格，不是 scanf() 想要的整数，匹配失败。不会给变量 b 赋值，b 的值保持不变。 第三个 scanf() 时，控制字符串要求输入一个字符串，而缓冲区的位置指针由于匹配失败而未发生改变，正好将testScanf赋给str。此时缓冲区仅剩\\n，它在下次控制字符串符合要求时会被忽略。 例2，scanf()无法忽略空白符的情形\n#include\u0026lt;stdio.h\u0026gt; int main(){ int a=1,b=2; scanf(\u0026quot;a=%d\u0026quot;,\u0026amp;a); scanf(\u0026quot;b=%d\u0026quot;,\u0026amp;b); printf(\u0026quot;a=%d,b=%d\\n\u0026quot;,a,b); return 0; } 程序分析：\n若输入a=10，按下回车键，程序直接运行结束。只有第一个 scanf() 成功读取了数据，第二个 scanf() 没有给用户任何机会去输入数据。 当控制字符串不是以格式控制符%d、%c、%f 等开头时，空白符就不能忽略了，它会参与匹配过程，如果匹配失败，就意味着 scanf() 读取失败。 若输入a=10 b=20，按下回车键，程序运行结束。第二个 scanf() 又读取失败。执行到第二个 scanf() 时，缓冲区中剩下 b=200\\n，开头的空格依然不能忽略，然而空格与控制字符串不匹配，所以读取失败。 程序修改：\n考虑输入两个变量的时候中间不留空白符号； 考虑不在scanf()中添加多余的控制字符，仅保留格式控制符； ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/9-1-io-standard/","tags":[],"title":"Standard I/O"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"概述 文件输入输出主要包括：\n文件打开与关闭 打开函数fopen() 关闭函数fclose() 文件状态 是否到文件尾函数feof() 检查错误函数ferror() 文件读写 读取函数fread() 写入函数fwrite() 文件输入输出 输入函数fscanf()，fgetc() 输出函数fprintf()，fputc() 文件定位 rewind() fseek() ftell() 文件的打开与关闭 fopen #include\u0026lt;stdio.h\u0026gt; FILE *fopen(const char *filename, const char *mode) filename 要打开的文件路径和名称\nmode 文件访问模式\n模式\n描述\n\"r\"\n打开一个用于读取的文件。该文件必须存在。\n\"w\"\n创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容文件被视为一个新的空文件。\n\"a\"\n追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。\n\"r+\"\n打开一个用于更新的文件，可读取也可写入。该文件必须存在。\n\"w+\"\n创建一个用于读写的空文件。\n\"a+\"\n打开一个用于读取和追加的文件。\n注意：添加b参数可指明操作对象是二进制文件。\nfclose() int fclose(FILE *fp) 如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回EOF(-1)。\n该函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。\nopen() #include\u0026lt;fcntl.h\u0026gt; int open(const char *path, int access,int mode) path 要打开的文件路径和名称\naccess 访问模式，宏定义和含义如下：\nO_RDONLY 1 只读打开 O_WRONLY 2 只写打开 O_RDWR 4 读写打开 还可选择以下模式与以上3种基本模式相与：\nO_CREAT 0x0100 创建一个文件并打开 O_TRUNC 0x0200 打开一个已存在的文件并将文件长度设置为0，其他属性保持 O_EXCL 0x0400 未使用 O_APPEND 0x0800 追加打开文件 O_TEXT 0x4000 打开文本文件翻译CR-LF控制字符 O_BINARY 0x8000 打开二进制字符，不作CR-LF翻译 mode 该参数仅在access=O_CREAT方式下使用。\nfopen与open的区别 缓冲文件系统与非缓冲系统的区别\n缓冲文件系统(fopen) 在内存为每个文件开辟一个缓存区，当执行读操作，从磁盘文件将数据读入内存缓冲区，装满后从内存缓冲区依次读取数据。写操作同理；\n借助文件结构体指针对文件管理，可读写字符串、格式化数据、二进制数据；\n非缓冲文件系统(open)：通过操作系统的功能对文件进行读写，是系统级的输入输出。 不设文件结构体指针，只能读写二进制文件；\nopen属于低级IO，fopen属于高级IO；\nfopen返回文件指针，在用户态缓存，减少了内核态和用户态的切换；\nopen返回文件描述符，读写需进行用户态与内核态切换；\nopen是系统函数，不可移植；\nfopen是标准C函数，可移植（猜测是用open封装操作）；\n一般地，fopen打开普通文件，open打开设备文件（因为设备文件不可作为流式文件处理）；\nfopen适合顺序访问文件；\nopen适合随机访问文件；\n文件状态 feof(FILE *fp)判断文件是否到末尾，若到达文件末尾返回非0；\nferror(FILE *fp)用来检查错误，若为0则未出错，否则出错。\n文件的读取与写入 文件写入 int fputc(int c,FILE *fp); 函数fputc()把参数 c 的字符值写入到 fp 所指向的输出流中。\n如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。\nint fputs(const char *s,FILE *fp) 函数fputs()把一个以 null 结尾的字符串写入到 fp 所指向的输出流中。\nint fprintf(FILE *fp,const char *format, ...) 函数fprintf()把一个字符串写入到文件中。\n见下面的例子：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE *fp = NULL; fp = fopen(\u0026quot;/tmp/test.txt\u0026quot;, \u0026quot;w+\u0026quot;); fprintf(fp, \u0026quot;This is testing for fprintf...\\n\u0026quot;); fputs(\u0026quot;This is testing for fputs...\\n\u0026quot;, fp); fclose(fp); } 文件读取 int fgetc(FILE *fp); 函数fgetc()从 fp 所指向的输入文件中读取一个字符。\n返回值是读取的字符，如果发生错误则返回 EOF。\nchar *fgets(char *buf,int n,FILE *fp) 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。\nt特别地，如果这个函数在读取最后一个字符之前就遇到一个换行符 '\\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。\nint fscanf(FILE *fp,const char *format, ...) 函数fscanf()从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。\n见下面的例子：\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE *fp = NULL; char buff[255]; fp = fopen(\u0026quot;/tmp/test.txt\u0026quot;, \u0026quot;r\u0026quot;); fscanf(fp, \u0026quot;%s\u0026quot;, buff); printf(\u0026quot;1: %s\\n\u0026quot;, buff );//只读取This fgets(buff, 255, (FILE*)fp); printf(\u0026quot;2: %s\\n\u0026quot;, buff );//读取is testing for fprintf... fgets(buff, 255, (FILE*)fp); printf(\u0026quot;3: %s\\n\u0026quot;, buff );//This is testing for fputs... fclose(fp); } 二进制文件读写 下面两个函数用于二进制输入和输出：\nsize_t fread(void *ptr, size_t size_of_elements,size_t number_of_elements, FILE *a_file); size_t fwrite(const void *ptr, size_t size_of_elements,size_t number_of_elements, FILE *a_file); 这两个函数都是用于存储块的读写，通常是数组或结构体。简单记法：\nfread(buffer,size,count,fp); fwrite(buffer,size,count,fp) void *ptr指向的是被写入/被读出的元素（或它的数组的首对象）的指针； size_t size说明被写入/被读出的元素的大小，大小是字节； size_t num说明操作的元素的个数； FILE *fp是指向FILE对象的指针； 文件定位 rewind() void rewind(FILE *stream) 设置文件位置为给定流stream的文件的开头。\nfseek() int fseek(FILE *stream,long offset,int fromwhere) 函数设置文件指针stream的位置:\n如果执行成功，stream将指向以fromwhere为基准，偏移offset个字节的位置。 如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。 取值：SEEK_CUR(当前位置)、 SEEK_END(结尾位置) 或 SEEK_SET(起始位置) ftell() long int ftell(FILE *stream) 返回给定流 stream 的当前文件位置。\n","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/9-2-io-file/","tags":[],"title":"File I/O"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"ORB SLAM3 orb-slam3 的项目地址：https://github.com/UZ-SLAMLab/ORB_SLAM3 目前 orb-slam3 的代码直接编译会报错，因此需要解决一些冲突。\nOpencv orb-slam 系列要求 opencv 版本包含了对 gtk 的支持，这一点尤其重要。\n在 NixOS 中可以使用下面的代码开启对 gtk 的支持。\nlet pkgs = nixpkgs.legacyPackages.${system}; opencv = pkgs.opencv; opencvGtk = opencv.override( old:{ enableGtk2 = true; gtk2 = pkgs.gtk2; enableGtk3 = true; gtk3 = pkgs.gtk3; enableDocs = true; }); in { devShells.default = pkgs.mkShell { packages = with pkgs; [ opencvGtk ]; } } Eigen Eigen 是一个矩阵运算库，可以直接从系统包管理器安装，也可以从源码编译。\n官方项目地址：https://gitlab.com/libeigen/eigen 官方文档地址：https://eigen.tuxfamily.org/index.php?title=Main_Page 有关如何在 CMake 项目中使用 Eigen，可以在对应版本的 Eigen 文档中参考 Using Eigen in CMake Projects Sophus Sophus 是一个李群李代数库，一般发行版不提供安装，可以从源码编译，但是 编译测试部分时会报错误 。\n官方项目地址：https://github.com/strasdat/Sophus 该项目可选依赖于 fmt ，可以通过包管理器安装该库。 安装说明：\n若安装到系统环境下，为以后所有依赖 Sophus 的项目使用，可以添加参数去除测试部分的编译（仅对较新的版本有效） cmake .. -DBUILD_SOPHUS_TESTS=OFF -DBUILD_SOPHUS_EXAMPLES=OFF 若作为项目依赖，仅为单个项目使用，可以在 CMakeLists.txt 中添加如下代码 add_compile_options(-Wno-error=array-bounds) NixOS 上可以通过编写 sophus.nix 的方式安装到系统\n{ lib , stdenv , fetchFromGitHub , cmake , pkgs , ... }: stdenv.mkDerivation rec { pname = \u0026quot;sophus\u0026quot;; version = \u0026quot;1.22.10\u0026quot;; src = fetchFromGitHub { owner = \u0026quot;strasdat\u0026quot;; repo = \u0026quot;Sophus\u0026quot;; rev = \u0026quot;d270df2be6e46501b1e7efc09b107517e0be0645\u0026quot;; sha256 = \u0026quot;sha256-t0PkXdXO+2PChlsMeKK3IPxudurqrDD4oOllNKphglk=\u0026quot;; }; buildInputs = with pkgs;[ eigen fmt ]; nativeBuildInputs = [ cmake ]; cmakeFlags = [ \u0026quot;-DBUILD_SOPHUS_TESTS=OFF\u0026quot; \u0026quot;-DBUILD_SOPHUS_EXAMPLES=OFF\u0026quot; ]; meta = with lib; { homepage = \u0026quot;https://strasdat.github.io/Sophus\u0026quot;; description = \u0026quot;C++ implementation of Lie groups commonly used for 2d and 3d geometric problems\u0026quot;; license = licenses.lgpl3Plus; maintainers = with maintainers; [ endlesspeak ]; platforms = platforms.unix; }; } Pangolin Pangolin 是一个轻量可移植的 OpenGL 显示管理图形库。 Pangolin 可以直接从系统包管理器安装，也可以从源码安装。\n官方项目地址：https://github.com/stevenlovegrove/Pangolin 该项目建议安装到系统环境，因为各 SLAM 框架基本都依赖 Pangolin 。 由于 Gcc13 不再包含 cstdint 头文件，在 NixOS 中需要显式指明：\n(pangolin.overrideAttrs(old:{ env.CXXFLAGS = toString [ # GCC 13: error: 'uint32_t' does not name a type \u0026quot;-include cstdint\u0026quot; ]; })) Other Dependencies realsense2 orb-slam3 可选依赖于该库，去掉该依赖项仅会导致与 realsense2 有关的测试代码不能正确生成\ndependencies orb-slam3 的运行需要 qt 界面显示运行结果，可以安装 Qt5 或 Qt6 。 orb-slam3 的 src/System.cc 引入了 openssl 的头文件。 orb-slam3 的 DBoW2 模块要求 boost 库。 NixOS configuration devShells.default = pkgs.mkShell { packages = with pkgs; [ qt6.full boost openssl ]; } ROS support orb-slam3 可选依赖于 ROS，但是 ROS 在非 Ubuntu 上的安装并不容易，因此该部分建议使用 docker 或虚拟机部署。\nC++14 support orb-slam3 需要 C++ 14 的支持， 即使 Readme 上说只需要 C++ 11 。为此，需要修改所有和 C++11 有关的内容，这包括 CMakeLists.txt 和代码中的宏。\n可以使用下面的代码替换掉 CMakeLists.txt 中的内容\nsed -i 's/++11/++14/g' CMakeLists.txt 代码中还需要手动将 COMPILEDWITHC11 替换为 COMPILEDWITHC14 宏。\nCompile 给它一个编译核心，它能从 1.8GiB 干到 6.1GiB。如果不想内存寄掉就别 make -j\nORB SLAM2 ORB SLAM2 需要的依赖同上，例外的是不需要 Sophus 和 realsence2 。 项目地址：https://github.com/raulmur/ORB_SLAM2/\nProblems C++ 14 support 根据“保持最新”理念，升级到 C++14 已成必然。步骤与 ORB SLAM3 类似。\nCMake Modules 删除 cmake_modules 文件夹，因为它指示了错误的 Eigen 依赖寻找方法。\nstatic assert std map Corrected typedef so that map value_type and allocator are the same. 参考 PullRequest #585 或 Repo\n更改 include/LoopClosing.h 第 50 行。\ntypedef map\u0026lt;KeyFrame*,g2o::Sim3,std::less\u0026lt;KeyFrame*\u0026gt;, Eigen::aligned_allocator\u0026lt;std::pair\u0026lt;KeyFrame* const, g2o::Sim3\u0026gt; \u0026gt; \u0026gt; KeyFrameAndPose;//原来是 const KeyFrame* double free or corruption 这是由于 -march=native 导致的，这个问题在 orb-slam3 上不存在，具体原因尚不明确。\n修改时，需要为 所有 依赖的构建都取消该编译选项。\nOpenCV Version 关于 OpenCV 的 PullRequest，参考 PullRequest #1076 或 Repo\ncmake 将所有 cmake 文件中的 find_package 中的 opencv 版本更正到 OpenCV 4 。 如果需要与 ROS 集成调试，需要在 Examples/ROS/ORB_SLAM2/CMakeLists.txt 中添加 -lboost_system 链接选项 header 将所有 #include\u0026lt;opencv/cv.h\u0026gt; 更正为 #include\u0026lt;opencv2/opencv.hpp\u0026gt;\n在下列文件范围内进行操作。 操作内容：\n新增 #include\u0026lt;opencv2/imgproc/types_c.h\u0026gt; 新增 #include\u0026lt;opencv2/opencv.hpp\u0026gt; [deprecated]新增命名空间标识符或 using namespace cv; 文件范围：\ninclude/PnPsolver.h include/Sim3Solver.h include/System.h src/FrameDrawer.cc src/LoopClosing.cc src/Optimizer.cc src/Tracking.cc 在下列文件中新增 #include\u0026lt;opencv2/core/core_c.h\u0026gt;\nsrc/Sim3Solver.cc 在头文件 System.h 中新增 #include \u0026lt;unistd.h\u0026gt; 需要说明的是：\n这是为了解决 usleep() 函数未定义的问题 相当一部分 PullRequest 给每个使用到 usleep() 的函数都添加了该头文件，个人认为这是没有必要的 cv macro 更改下列标识符 CvMat → cv::Mat 由于：\ncvCreate(rows,cols,type) 返回的是 CvMat 类型的指针 cv::Mat(rows,cols,type) 返回的是 cv::Mat 类型的对象 因此：\n形参中，~CvMat *~ 改为 cv::Mat * ，到时候实参传 \u0026amp;M 进去 函数内 CvMat * 或 CvMat 都改为 cv::Mat ，同时 cvCreateMat() 也改为 cv::Mat 经过 2 的修改，函数内临时变量变为 cv::Mat 类型，在进行其他函数运算时可以去掉 \u0026amp; cvMulTransposed() → cv::mulTransposed()\ncvMulTransposed(PW0,\u0026amp;PW0tPW0,1); cv::mulTransposed(PW0,PW0tPW0,1); cvSVD() → cv::SVD::compute()\ncvSVD(\u0026amp;PW0tPW0, \u0026amp;DC, \u0026amp;UCt, 0, CV_SVD_MODIFY_A | CV_SVD_U_T); cv::SVD::compute(PW0tPW0,DC,UCt,cv::Mat(), cv::SVD::MODIFY_A | cv::SVD::NO_UV); cvSVD(\u0026amp;ABt, \u0026amp;ABt_D, \u0026amp;ABt_U, \u0026amp;ABt_V, CV_SVD_MODIFY_A); cv::SVD::compute(ABt, ABt_D, ABt_U, ABt_V, cv::SVD::MODIFY_A); cvInvert → cv::invert()\ncvInvert(\u0026amp;CC, \u0026amp;CC_inv, CV_SVD); cv::invert(CC, CC_inv, cv::DECOMP_SVD); (CvMat *)M-\u0026gt;data.db + x → (cv::Mat *)M-\u0026gt;ptr\u0026lt;double\u0026gt;(x)\n//data成员的db数组是double数组 double * M1 = M-\u0026gt;data.db + row * 12; //使用cv::Mat::ptr 成员函数访问矩阵某行的指针，该行是double double * M1 = M-\u0026gt;ptr\u0026lt;double\u0026gt;(row * 12); cvSetZero(CvMat *) → cv::Mat.setTo(0)\ncvSetZero(\u0026amp;ABt); ABt.setTo(0); cvmSet() → cv::Mat-\u0026gt;at\u0026lt;double\u0026gt;\ncvmSet(\u0026amp;L_6x4, i, 0, cvmGet(L_6x10, i, 0)); cvmSet(\u0026amp;L_6x4, i, 1, cvmGet(L_6x10, i, 1)); cvmSet(\u0026amp;L_6x4, i, 2, cvmGet(L_6x10, i, 3)); cvmSet(\u0026amp;L_6x4, i, 3, cvmGet(L_6x10, i, 6)); L_6x4.at\u0026lt;double\u0026gt;(i, 0) = L_6x10-\u0026gt;at\u0026lt;double\u0026gt;(i, 0); L_6x4.at\u0026lt;double\u0026gt;(i, 1) = L_6x10-\u0026gt;at\u0026lt;double\u0026gt;(i, 1); L_6x4.at\u0026lt;double\u0026gt;(i, 1) = L_6x10-\u0026gt;at\u0026lt;double\u0026gt;(i, 3); L_6x4.at\u0026lt;double\u0026gt;(i, 1) = L_6x10-\u0026gt;at\u0026lt;double\u0026gt;(i, 6); cvSolve() → cv::solve()\ncvSolve(\u0026amp;L_6x4, Rho, \u0026amp;B4, CV_SVD); cv::solve(L_6x4, *Rho, B4, cv::DECOMP_SVD); 更正下列 OpenCV 颜色宏 将 CV_BGR2GRAY 更正为 cv::COLOR_BGR2GRAY 将 CV_RGB2GRAY 更正为 cv::COLOR_RGB2GRAY 将 CV_BGRA2GRAY 更正为 cv::COLOR_BGRA2GRAY 将 CV_RGBA2GRAY 更正为 cv::COLOR_RGBA2GRAY 更正下列 OpenCV 加载宏 将 CV_LOAD_IMAGE_UNCHANGED 更正为 cv::IMREAD_UNCHANGED 将 CV_REDUCE_SUM 更正为 cv::REDUCE_SUM ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/10-orb-slam3-adjustments/","tags":[],"title":"ORB SLAM Adjustments"},{"authors":[],"categories":[],"content":" Module Develop 一般地，C 中的模块化开发可以归纳为：\n在头文件中定义接口 在源文件中实现接口 链接模块 一般地，C++中的模块化开发可以归纳为：\n在声明类的头文件中定义接口 在实现类的源文件中实现接口 链接模块 Head files 头文件包含“防止重定义”，定义类型，文件包含，宏定义，条件编译，函数和变量声明等部分。\nRedefinition 模块间依赖关系复杂，可能存在重定义的情况。\n有鉴于此，需要对头文件定义的内容作“保护”处理。\n法一，宏定义法 该方法依赖于宏名不能冲突。它既可以保证同一个文件不会被多次包含，又能保证内容完全相同的两个文件不会被同时包含。\n#ifndef FILE_H_ #define FILE_H_ //声明函数原型 int add(int,int); int sub(int,int); #endif 法二，编译指令法 该方法由编译器提供保证，即同一个文件不会被包含多次。\n该方法有以下缺陷：\n若存在内容相同的两个文件，则无法保证它们不被重复包含。 操作对象是文件整体，不能仅控制部分内容。 该方法是非标准 但被广泛支持的方式。\n#pragma once Macro \u0026amp; Condition Compilation 宏定义指令和条件编译指令见 语句 小节。\nVariables Or Functions Statement 变量定义和声明的区别：\n定义用于为变量分配空间，也可以为变量赋初值。特别地， 定义也是声明。 声明用于向其他代码表明变量的信息，特别地，函数声明可以不带形式参数。 仅 声明变量则不会分配空间，而看作是一种 变量作用域的扩充。 Source Files 模块化开发中，可以使用一个头文件定义所有的接口（声明函数），其他各个模块分别实现头文件中定义的功能。\n编译模块务必用 -c 选项！否则将报错无法找到程序入口！\nSymbol Table 可以使用 nm 命令查看模块的符号表，符号表包含模块使用的符号。\n函数的名字，全局变量的名字，静态局部变量的名字都是符号。\n特别地， filename 必须是二进制的可执行文件或目标文件。\nnm filename 以下内容是个人理解，可能不严谨：\n用户自定义的头文件可能在编译各个模块时被编译多次，但将会在链接时仅链接一次 多余的目标代码将在链接生成可执行代码时被清理。 如果动态链接用户自定义的库文件或标准库中的库文件，则在链接后相关的符号仍然未定义，但会标注链接位置。它们的链接过程推迟到运行时进行。 如果静态链接上述内容，则在链接后所有符号均已定义，且相关代码均包含在可执行文件中。 ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/10-modules-development/","tags":[],"title":"Module Development"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"Stereo Kitti Yaml modification 修改 KITTI00-02.yaml 文件中的 Viewer.ViewpointY: -100 改为 Viewer.ViewpointY: -100.0\nSettings Orb slam3 在运行 stereo 时，输出第二个摄像头参数位置报 segment fault\n//for(size_t i = 0; i \u0026lt; settings.originalCalib2_-\u0026gt;size(); i++){ // output \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; settings.originalCalib2_-\u0026gt;getParameter(i); //} if (settings.cameraType_ == Settings::PinHole) { for(size_t i = 0; i \u0026lt; settings.originalCalib2_-\u0026gt;size(); i++){ output \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; settings.originalCalib2_-\u0026gt;getParameter(i); } } else if (settings.cameraType_ == Settings::Rectified) { for (size_t i = 0; i \u0026lt; settings.originalCalib1_-\u0026gt;size(); i++) { output \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; settings.originalCalib1_-\u0026gt;getParameter(i); } } ","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/11-orb-slam3-stereo/","tags":[],"title":"ORB SLAM3 Stereo"},{"authors":[],"categories":[],"content":" GDB 调试符号 在编译的时候加上 -g 选项，以使程序能够执行调试。如果是 makefile ，可以指定全局选项。\nCXX = g++ CXXFLAGS = -Wall -g 调试界面 调试界面包括两种：\ngdb 不显示程序代码界面，仅回显步进执行结果 gdb --tui 提供执行的字符界面 调试命令 常见的调试命令如下\n命令 简写命令 命令含义 ","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/11-debug-method/","tags":[],"title":"Debug Method"},{"authors":["Serene Feather Pavilion"],"categories":[],"content":"EVO 在使用evo对ORB-SLAM或OpenVSLAM等SLAM系统在KITTI数据集上以双目模式运行的结果进行评估时，你首先需要确保你的轨迹文件和基准轨迹（ground truth）文件格式是一致的。KITTI数据集的data_odometry_poses提供了基准轨迹，通常这些文件是按照KITTI轨迹格式给出的。\nKITTI KITTI轨迹格式是一种特定的格式，用于存储车辆或相机在3D空间中的位置和姿态。每行包含12个浮点数，表示一个4x4的变换矩阵（仅前三行，因为最后一行总是\\(0, 0, 0, 1\\)），按照如下排列：\nr11 r12 r13 tx r21 r22 r23 ty r31 r32 r33 tz 这12个元素分别对应于旋转矩阵的前三行和平移向量，描述了从世界坐标系到车辆坐标系的变换。\nTUM 另一种常见的格式是TUM格式，它通常用于表示相机的轨迹。每行包含8个元素：\ntimestamp tx ty tz qx qy qz qw 其中，tx ty tz是平移部分，qx qy qz qw是四元数形式的旋转部分，timestamp是时间戳。\nTraj 使用evo评估，假设你已经有了SLAM系统生成的轨迹文件和KITTI的data_odometry_poses基准轨迹文件，你可以使用evo进行评估。下面是一个使用evo对KITTI格式的轨迹进行评估的基本命令示例：\nevo_traj kitti /path/to/your_trajectory.txt --ref=/path/to/KITTI_ground_truth.txt -p --plot_mode=xyz 这个命令会加载你的轨迹文件(/path/to/your_trajectory.txt)和参考轨迹(/path/to/KITTI_ground_truth.txt)，并生成一个XYZ平面上的轨迹对比图。这里-p参数表示要生成图表，\u0026ndash;plot_mode=xyz指定了图表的模式。\nAPE 如果你需要进行更深入的评估，比如计算轨迹的APE（Absolute Pose Error）或RPE（Relative Pose Error），你可以使用evo_ape或evo_rpe命令。例如，计算APE的命令如下：\nevo_ape kitti /path/to/KITTI_ground_truth.txt /path/to/your_trajectory.txt -va 这将计算并显示绝对位姿误差的统计数据和图表。\n确保在运行这些命令之前，你的轨迹文件和基准轨迹文件都是正确的格式，并且已经正确安装了evo。如果你的轨迹文件不是KITTI格式，evo也支持其他格式，如TUM，你只需在命令中相应地更改格式参数。\n","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-basic/12-slam-evo/","tags":[],"title":"SLAM Evaluation"},{"authors":[],"categories":[],"content":" C with C++ C 和 C++ 有一些不同的语法和命名规则，其中一个重要的区别是函数的名称修饰(Name Mangling):\nC 编译器不进行任何名称修饰。 C++ 编译器会对函数和变量的名称进行修饰，以支持函数重载和其他特性 当在 C++ 代码中包含 C 的 头文件 时，如果不采取适当的预处理措施，令 C++ 编译器对其中的函数和变量名称进行修饰，就会导致其与 C 代码中的实际定义不匹配，从而引发链接错误。\n通过使用 #ifdef __cplusplus 和 extern \u0026#34;C\u0026#34; ，可以将 C 代码中的函数和变量声明放置在单独的块中。它将告诉 C++ 编译器使用 C 的命名规则，而不进行修饰。这样就能够确保 C 和 C++ 之间的接口正确匹配，使得 C 和 C++ 代码可以混合编译和链接。\n#ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif // C header files content #ifdef __cplusplus } #endif 特别地，如果使用 gcc -x c++ -lstdc++ 编译 C++文件，默认不会定义 __cplusplus 宏，这可能导致：\n条件编译错误：一些 C++ 代码中使用了条件编译，通过判断 __cplusplus 的值来选择性地包含或排除某些代码块。如果该宏未定义，可能会导致条件判断出错，无法按预期进行代码包含或排除。 编译器特性缺失：一些库或框架在编译时会依赖于 __cplusplus 宏来确定编译器的 C++ 特性支持情况。如果未定义 __cplusplus ，可能导致某些 C++ 特性不可用或编译器行为有所差异。 平台兼容性问题：某些平台架构或其编译器可能依赖于 __cplusplus 宏来正确处理 C++ 代码的兼容性。如果未定义 __cplusplus ，可能会导致在特定平台上编译或执行出现问题。 因此，建议尽量使用 g++ 编译 C++代码，或者为 gcc -x c++ -lstdc++ 添加宏定义 -D__cplusplus 。\n","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/1-basic-doc/12-ccpp-mix-programming/","tags":[],"title":"C\u0026CPP Mix Programming"},{"authors":[],"categories":[],"content":" Import 多年以后，面对开源社区的欢呼，Eelco Dolstra 工程师将会回想起他撰写博士毕业论文的某个遥远的下午。[1]\nPackage Management SAT 包管理器的依赖解决过程本质上是一个SAT(Boolean Satisfiability Problem) 求解器。\nSAT 求解器是一种精确的求解方法，可以确定是否存在一组满足约束条件的变量赋值。\n其目的是在满足\n版本约束\n用户要求的版本约束 依赖关系定义的版本约束 条件约束\n编译选项约束 额外功能约束 文档约束 … 其他条件约束的约束 以上所有约束的情况下尽可能安装版本最高的软件。\nSAT作为NPC问题，没有多项式时间复杂度的算法。\n现代 SAT 求解器使用的主要技术 [2] 包括\nDavis-Putnam-Logemann-Loveland (DPLL) 完整的、基于回溯的搜索算法，思想和深度优先搜索相似 冲突驱动子句学习(conflict-driven clause learning CDCL) 在DPLL算法基础上发展的增强算法，通过学习新的子句来减少搜索空间，并使用冲突分析和回溯机制来指导搜索过程。区别在于CDCL 的回跳是非时间顺序的。 随机局部搜索算法(如 WalkSAT) 启发式算法通常用于解决大规模的SAT问题，尤其是当问题的解空间非常大时。 一般各个包管理器使用的是启发式算法。\n用户在安装软件前等待了很长的时间，最终得到的也不一定是最优解，甚至可能得到的是无解。\nKiss Arch能从一众发行版包中脱颖，是因为KISS原则。\nKISS(Keep It Simple, Stupid)是一种设计原则，强调简单性和直接性。\n在设计和开发过程中尽量保持简洁、直观和易于理解的方式来解决问题，避免复杂性和不必要的细节。\n简洁而灵活的安装：用户可以根据自己的需求进行自定义安装 滚动更新：持续提供最新版本的软件包和系统更新 自由的软件选择：鼓励用户自由选择他们喜欢的软件包和工具，而不仅限于预设的选项 文档和社区支持：拥有详细而全面的文档，以及活跃的社区支持 其中，在包管理方面保持KISS原则的体现是：\n分级管理 保证包的“相对最新性” 为每个软件仅提供“一个”相对最新的版本 上述方案避免了大量的依赖求解过程，显著减少求解空间\nArch将软件分为多个等级：\ncore extra/multilib arch user repository 为什么是相对最新，因为绝对最新具有以下不可实现性：\nmain分支并不保证所有功能都立即完全可用 较新tag的部分并不保证没有严重bug 以上所说的“一个”指代的是：\n核心仓库仅提供“尽可能少”的相对最新版本，降低冲突可能性 用户有额外需要，可以从用户仓库获取其他各种版本 对于核心仓库，频繁维护；对于用户仓库，降低依赖冲突的检查力度，责任自负\nCosts and Problems Pacman 发行版的包管理方式都是有代价的，对于Pacman来说，具体有三个方面：\n不是所有的人都遵循保持最新的理念，或者有意愿保持最新 当软件被陈旧的技术和依赖所裹挟的时候，它已经不再是一件精美的艺术品，而是一座难以言喻的山\n典型技术：=gcc 4.8.5= 、=java8= 典型依赖：XX软件园、DLL下载专区\n我并不想批判追求技术和追求盈利的问题，因为\n它们本就陌路 完全追求技术很难成功，而完全追求盈利却很可能成功 [3]，于是产生了“软件灾难” 大部分人从利出发，对技术没有“足够”热爱 在这种背景下，如果某个程序的所有依赖(包括软件本身)都“碰巧”被其他人提供(而不是一种规范的提供方式)，大部分人不会去思考有关依赖的深层次的问题 因此，合理的原因造就了客观上的现实，不能不说是一种遗憾。\n软件开发者的水平也是参差不齐，因为本可避免的问题而导致不能保持适配\n这里不得不说一句暴论，即绝大部分软件开发者（至少嵌入式软件开发者）的水平已经差到一种令人发指的程度——这很容易理解，因为大部分嵌入式工程师都是从硬件入行，他们也许并没有机会深刻学习和思考过软件的开发 [4]。\n无意批判已成定式的现实，但这种现象令人担忧：我们知道新人都很菜，也理解由新人成长为专家需要代价，但是当一群自以为是的“专家”因为害怕所谓的“新技术”会导致不可控因素而规劝新人不要尝试的时候，我很难抑制失望，进而厌恶“专家”本身。他们就像是行业蛀虫，“洋洋自得”地散发着肮脏的气息。\n由于代码详细设计上能力的不足导致软件需要增加更多冗余的依赖关系 由于代码灵活性或可扩展性不足导致先期开发预设的立场后期不能改变 频繁的滚动更新对软件开发“不一定利”\n试想编译一个稍有规模的程序，这也许需要5-10分钟的时间。\n现在假设你的程序依赖的动态链接库是opencv 4.9.0-1，结果当你第二天顺手更新了系统的时候，它们变成opencv 4.9.0-2了，于是你的程序不能够再正常运行（因为动态链接库变化了）；\n此时你正在开发，你尚不能知道是否有其他问题导致程序不能运行，但你已经对代码进行了修改，这导致你需要完全编译所有代码（而不是现行修改部分代码）来解决动态链接问题；\n同时，假设你希望回到上一次成功的生成来查看效果，也不现实，除非你通过版本管理工具回到上个版本重新编译源码，或者使用 patchelf 等工具；\n综合来说，你的调试不会特别顺利，这对开发是一种不小的打击。\nDependency 包管理器求解依赖有很多问题 [5]\n依赖全面度 在FHS的模式下，维护者（甚至有时候是软件包开发者）无法精确地知道一个软件包究竟依赖哪些包，一旦 /usr/include 和 /usr/lib 碰巧有程序所必须的内容，软件可能直接就成功运行了。但是这样的构建可能是不可复现的。\n就像一千个人眼中有一千个哈姆雷特一样。\n依赖多样性 当存在同一软件的多个版本时，依赖路径问题难以解决。可能的解决办法是：\n小版本软件迭代\n子版本不同的软件的库文件放到不同的目录中 可执行文件或其他会冲突的文件使用实用工具进行软链接管理，如 eselect 、=archlinux-java-run= 等 大版本软件更新\n可执行文件更名，如使用 python2 和 python3 创建虚拟环境 多用户依赖冲突\n当系统中存在多个具有管理员权限的用户时，每个用户可能都需要以系统管理员身份安装一些软件，这可能导致多用户依赖冲突。 产生依赖冲突问题时，在系统层面上可能无法做到在不破坏其他用户安装的依赖的情况下解决冲突 升级安全性 目前，一般的包管理工具均采用“同名替换”或“增量更新”策略，这会导致软件更新操作不是“直接可逆”的，在系统软件包的升级过程（对以前的Arch来说甚至是升级后）是危险的，需要配置快照等手段进行回滚。 Why Nix and why not Nix is good 这就是我要说的重点。为什么人们应该需要Nix ?为什么自从遇见NixOS，我就一直在尝试接近它。\nNixOS是人类群星闪耀时的现代版本 NixOS的推出是现代Linux的全面革新 曲一线说，五年高考三年模拟让每一位学生分享高品质教育；\n我想说，NixOS会让每一位用户得到高品质使用体验。\nWhy Nix is good 如果说二十年前的Nix还是咿呀学语，天真烂漫，那么二十年后的Nix已经玲珑有致，狡黠率然。我热切的希望每个能认识到Nix优势的人们都能陷入和Nix沟通的美好意境中。\nNix包管理器解决了以上讨论的通用包管理器问题 [5]：\n精确依赖 由于每一个软件的构建和运行都在完全隔绝的环境中，每一个通过Nix构建的软件它的依赖关系会完全展现在维护者面前；\nNix不会从除了软件包所声明的依赖以外的其他任何地方寻找依赖，因此如果构建的软件依赖“不全”，软件将不会正确运行。这保证了所有成功构建的软件它们的依赖都是完全的。\n多样性依赖共存 可以同时安装一个软件包的多个版本或变体。由于哈希方案，包的不同版本最终会出现在 Nix 存储中的不同路径中，因此它们不会相互干扰； 多用户支持 任何属于不同依赖关系的软件都会独立构建，任何被其他软件所依赖的软件互相隔离，因此多用户安装软件不会破坏已有的依赖关系； 原子升级和回滚 包管理操作不会覆盖已有的软件包，而是在不同路径中添加新版本，包升级不会干扰已有包的运行，而切换后自动替换到新包，因此不会产生问题； 还有一些其他优点，如：\n记录式、声明式的构建 Nix具有高度可移植性 这是Nix的完美之处，卓越之处，精彩之处，绝妙之处，非凡之处。每一次和nix的交流都是有效的；构建的每一个结果都是精确且可复现的；换言之，蓝图所描述的每一句都会被Nix用于构建安全、稳定的“未来”。\n人最害怕什么？“不确定性”。人生就像囚徒，困在某个维度的茧房之中动弹受限。随着时间推移，囚牢中的人越来越少，同时不可言喻的东西也就越来越多。在不确定性扩大的过程中，解脱不是理想的结果，但解脱客观上已经渐渐成为了一种理想。\nWhy Nix is bad 这一节其实想探讨的不是Nix的问题，而是“目前”Nix所“面临”的问题 [6] 。\n软件发行与维护问题\n开发者不一定比发行版维护者更懂Linux\n国内很多网页默认Linux端就是安卓，因此你能在Linux上正常访问网页已经很不容易了。\n开发者可能会作出各种符合 FHS 标准的假设，因此可能需要打补丁纠正。\n软件开发者不一定开放源代码 开发者不使用标准的编译方式，或者使用了非正常的目录结构 开发者不声明完全所需的依赖，或运行时额外需要其他依赖，导致 autopatchelf 不能达到预期效果 程序主动探测运行环境或对其本身的修改 (SaaS类型软件) 手动打包需要掌握的前置知识过多\n即使没有上述问题，手动完成一次打包也可能需要耗费大量的时间和精力，学习门槛过高。\n软件间通信问题\n通常可以用Xdg Open来解决软件“唤起”的问题 如果已经为某个包创建了FHS虚拟环境，当它唤起其他非FHS环境的包的时候存在问题 使用动态链接库魔改浏览器内核的方式唤起页面内浏览器，基本不可行 使用理念问题 使用理念问题可以归为“狂热Nix信徒”，“自由Nix门徒”两派。\n狂热Nix信徒希望 all in nix way\nVSCode 所有插件均转为Nix表达式 Python所有功能包均转为Nix表达式\n尽管现在稍新一些的发行版都已禁用Python全局安装功能包，但是它们支持创建类似conda的虚拟环境，而这对于NixOS来说似乎是不可接受的，因为有观点认为Nix已经是最好的conda了。\nRust/Nodejs所有依赖库均转为Nix表达式 家目录下所有配置文件均转为Nix表达式 自由Nix门徒则希望 all in soft way\nVSCode 安装FHS版本，想装哪个插件就装哪个 Python/Rust/Nodejs等等的问题留给它们自己的包管理器解决 家目录只管理重要的配置 存储空间占用问题 Nix目前对依赖的复用介于“完全复用”和“完全不复用”之间，完全安装一个软件相较于其他发行版可能更加耗费存储空间 Why Nix Combined with Arch is bad 既然完全使用Nix会面临以上问题，于是很自然地想到一个可能性，平常用Arch，编程开发用Nix环境。\n很难在非NixOS环境上安装Nix软件包\n一般视频都用的是 nix run 和 nix-shell -p 这种临时性选项 nix profile install 或 nix-env -iA 这种方式没有 flake.nix 的优点 目前我能想到的方案是单独安装 home manager 使用Nix软件不方便访问到 /nix 目录以外的依赖，而使用Arch的工具则很难查找 /nix 内的依赖\n使用 Nix 软件时， gcc 和 g++ 自动默认用 nix 提供的 cmake 在 Nix下安装时，见 001-search-path.diff 图形化程序不能正常工作 如 pangolin 由于依赖 xorg.libX11 ， 在 /nix 内的 xorg.libX11 不能正确显示图形，如果改用 Arch安装的 pangolin ，则需要增加 cmake 的搜索路径 环境变量问题\n需要安装 direnv 和 nix-direnv 更改 $HOME/.config/direnv/direnvrc 中的内容 Summary 没有绝对完美的包管理系统，Nix还有很长的路要走。\n有人说当一个人开始回忆起过去的时候，他就老了。Nix无疑是成功的，但是我的探索Nix的应用之旅却显得有些失败。\n我不知道Eelco Dolstra 工程师回忆起过去是什么样的，我回忆起4个月前刚接触NixOS的时候，脑海里想到的一句话是“花未凋，月未缺，人就在天涯，一切都很好。”\nReference [1] 包构建/管理系统简史\n[2] Algorithms for solving SAT\n[3] 世界上没有技术驱动型公司\n[4] 单片机工程师要求C++\n[5] Nix Reference Manual\n[6] NixOS 软件打包从入门到放弃\n","permalink":"https://endlesspeak.github.io/posts/linux/linux-technology-8-dependency-management/","tags":[],"title":"Linux Dependency Management"},{"authors":["Serene Feather Pavilion"],"categories":["杂谈"],"content":"Hugo 是 Go 编写的静态网站生成器，速度快，易用，可配置。Hugo 具有基于各种主题生成的内容和模板目录，以把markdown文件（包括org文件）渲染到完全静态的 HTML 网站。\nEureka是一个功能丰富且可高度定制化的Hugo主题，使用Eureka可以轻松快捷地定制并部署网站。\nSSG 最原始的 Blog 应该就是纯静态的HTML页面，后来 Blog 开始火的时候，各种线上平台一统天下，而对于有点折腾能力的人来说，WordPress 、VuePress等不失为一种选择。后来，GitHub 当道，由 GitHub Pages 及其原生支持的工具链 Jekyll/Octopress 吸引了足够的眼球和人气，再后来便演变成 static site generator（本文简称为 SSG）的回归。\n从技术上来讲，传统的 blog 就是一个简化的CMS系统。相较于 CMS，blog 更多的是个人开放给外界的一个展示窗口，并不需要太多的交互和额外的用户注册管理系统（如各种 bbs/forum/group 等），其主要技术特性是：\n面向个人用户 页面排版简单 内容管理单一，基本上以 post 为主 需求模块较少，基本上就是 Comments, Categories, Tags, Archives 在这方面，SSG 所遵循的 fast, lightweight, easy-deployment 是很有优势的。最简单的 blog 完全可以只是一个 post list 页面。但是纯静态的 blog 又太简陋了，因此需要通过一些 hack 的手段，在 static 的页面上加入一些 dynamic 的东西，这个 hack 的手段，就是各种 SSG 中所谓的 compile 步骤。\ncompile 步骤是所有 SSG 的核心，它的设计好坏决定了一个 SSG 的品质。大体上讲，SSG 的工作方式如下：\n格式转换： 扫描所有 post，进行初步 compile（这步 compile 主要作用是进行格式转换，比如 markdown/textile -\u0026gt; html）。 汇总 metadata： 汇总所有 post 的 metadata（比如 tag/category 可以用来做反向映射，datetime 可以用来给 post 进行排序），这些 metadata 信息可以在 template 渲染的时候访问。 渲染模板： 根据相应的 layout 规则，将 compile 后的 content 以及已有的 metadata 信息渲染成相应的页面（比如每篇 post 都需要有 navbar 和 footbar，这可以设定一下基础的页面 layout，包含公用的页面元素，然后通过模板继承或组合的方式，将 post 的内容以及相应的 metadata 信息渲染到这个 layout 中合适的位置，这就形成了最终看到的 static page）。 撰写 Blog 的群体对于 SSG 框架往往还有一些特别的需求：\n代码高亮 数学公式 版本控制 编译部署 Hugo 所以为什么要选择Hugo作为SSG平台，又为什么选择Eureka主题？\norg-mode 这里不得不提到 Emacs 中 org-mode 这样一个神奇的模式。我在4月份开始接触Emacs，大概花费了5天时间入门了这款古老而又现代的，完全符合GNU精神的编辑器，在我看来，它能延续至今且依然活力满满的原因有二，一是插件生态，二就是org-mode。\norg-mode 是一个用文本方式来快速高效地做笔记、维持待办事项和做项目计划的模式。它是一个高校的GTD系统，同时也是一个创作发布系统。可能平白说这样两句并不能让人明白 org-mode 究竟是什么，但是如果你用过幕布的话，你就会发现，幕布等大纲模式的软件其原型便来自org-mode。当然，org-mode 的功能并不仅仅只是大纲这样简单，我会另写一系列文章详细描述 org-mode\nhugo\u0026rsquo;s feature 本文讲 org-mode 是为了说明，Hugo 的特点就是支持 markdown 与 org-mode 文件并存渲染（仅部分主题）下面是 Hugo 和基于它的主题 Eureka 的优点：\nHugo 是 Go 编写的静态网站生成器，快速，易用，可配置。\n易用：Hugo 有一个内容和模板目录，把他们渲染到完全的 HTML 网站。用户可以从任意的目录中运行 Hugo，支持共享主机和其他系统。Hugo 当前提供 Windows，Linux，FreeBSD，NetBSD 和 OS X (Darwin) 的 x64, i386 和 ARM 架构的二进制预构建包。\n快速：Hugo 只需要几分之一秒就可以渲染一个经典的中型网站，最好网站的每个部分渲染只需 1 毫秒。\n可配置：Hugo 的源代码可以通过 Go 编译器工具链编译到任意地方运行，各主题源代码开放，方便进行个性化修改。\nquick start 在 Arch Linux及其衍生发行版上运行hugo简单且快速，执行下面的代码：\n$ sudo pacman -S hugo $ hugo new site hugosite #生成一个叫hugosite的文件夹，即站点根目录 只需不到5秒的时间，你的电脑就就成功安装了hugo并且创建了一个demo站点。\nEureka 回忆一下刚才所提到的撰写 Blog 的群体对于 SSG 框架的特别的需求，包括代码高亮、数学公式、版本控制、编译部署等，其中编译部署可以简单地写一个独立可执行的shell文件，因此这里略过，介绍 Eureka 对其他特性的高度支持。末尾会说明如何安装该主题。\nMarkdown Syntax Eureka 具有良好的 Markdown 高亮支持。这里介绍引用块、表格、代码块、列表和其他元素。\nBlockquotes Blockquote without attribution 这是不带属性的引用块。\n注意你可以在引用块中使用 Markdown 高亮支持。\nBlockquote with attribution 下面是一段带属性的引用块示例。\nDon\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables 表格并不是 Markdown 核心的一部分，但是对于 Hugo 来说，Hugo 支持它们开箱即用。\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Markdown 提供了对代码块的支持。即使你但\nCode block with backticks 普通代码块标注。\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces 仅仅只是对代码块做四个空格这样简单的处理。\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode Hugo 具有支持内联代码块显示的特性，使用双括号包裹高亮 HTML 的声明标签开头，最后以双括号包裹结束高亮声明的标签结尾，具体见本文源码。\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types 下面是 Hugo 对 Markdown 列表的支持效果。\nOrdered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements Eureka 还提供对其他 HTML 元素的原生支持，包括 abbr、sub、sup、kbd、mark 等属性。\nGIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nFeaturedImage 为每一篇文章赋特征图像，见于文章列表或文章详情页起始点，本文即为例。\nEmoji Support Emoji 能够在 Hugo 项目中以多种方式启用。以下是原文档说明。\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } Diagram Support Eureka 支持以 Mermaid 方式渲染 Markdown 的简图。以下是原文档的说明。\nPlease include the Mermaid diagram as below. Every mermaid chart/graph/diagram definition, has to have separate \u0026lt;div\u0026gt; tags.\nIn order to render the HTML code in the Markdown file correctly, please make sure that markup.goldmark.renderer.unsafe in config.yaml is true.\nHere is one mermaid diagram:\ngraph TD A[Client] --\u003e B[Load Balancer] B --\u003e C[Server1] B --\u003e D[Server2] And here is another:\ngraph TD A[Client] --\u003e|tcp_123| B(Load Balancer) B --\u003e|tcp_456| C[Server1] B --\u003e|tcp_456| D[Server2] Math Support Eureka 默认支持以 KaTex 插件来渲染数学公式，下面是一些测试。\nYou can type inline equation like $E=mc^2$.\nAnd also displayed equation like:\n\\[ \\int u \\frac{dv}{dx}\\, dx=uv-\\int \\frac{du}{dx}v\\,dx \\] Matrix:\n\\[ \\begin{pmatrix} a\u0026b\\\\c\u0026d \\end{pmatrix} \\quad \\begin{bmatrix} a\u0026b\\\\c\u0026d \\end{bmatrix} \\quad \\begin{Bmatrix} a\u0026b\\\\c\u0026d \\end{Bmatrix} \\quad \\begin{vmatrix} a\u0026b\\\\c\u0026d \\end{vmatrix} \\] Aligned equation:\n\\[\\begin{aligned} x ={}\u0026 a+b+c+{} \\\\ \u0026d+e+f+g \\end{aligned}\\] And many other kinds of formulas.\nInstallation Guide 安装 Eureka 不需要安装额外的第三方插件或 npm 库。\n法一：可在下面两种克隆方式中任选其一。\n$ git clone https://gitee.com/wangchucheng/hugo-eureka.git hugosite/themes/eureka $ git clone https://github.com/wangchucheng/hugo-eureka.git hugosite/themes/eureka 法二：如果需要对主题提供长期支持，同时又不需要对主题作修改，可考虑以子模块注册（以根目录是站点，同时已经初始化仓库的情况下）。\n$ git submodule add \u0026lt;上面的url地址\u0026gt; hugosite/themes/eureka Eureka 使用单独的配置文件夹而不是独立的 config.toml 文件，因此需要使用该主题，需要进行如下操作：\n$ cd hugosite $ mv config.toml config.toml.bak # 备份原生hugo的配置文件 $ cp -r themes/eureka/examplesite/config ./ # 拷贝配置文件夹到站点根目录 更多配置详情内容请参阅：Eureka\n下面补充我个人站点构建的其他内容。需求是使用git管理站点仓库，推送时希望推送到源码到该仓库的develop分支，生成的页面内容推送到master分支。\n使用站点生成命令hugo自动在站点目录下生成public目录。\n创建一个自动部署博客的脚本：\n#!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 进入生成的文件夹 cd public # 如果是发布到自定义域名 # echo 'www.example.com' \u0026gt; CNAME git init git add -A git commit -m 'deploy' # 如果发布到 https://\u0026lt;USERNAME\u0026gt;.gitee.io/\u0026lt;REPO\u0026gt; git push -f git@gitee.com:endlesspeak/endlesspeak.git master # 如果发布到 https://\u0026lt;USERNAME\u0026gt;.github.io/\u0026lt;REPO\u0026gt; # git push -f git@github.com:\u0026lt;USERNAME\u0026gt;/\u0026lt;REPO\u0026gt;.git master cd - #返回到上一次的工作目录。 为站点初始化git仓库，然后指定远程分支\n$ cd hugosite $ git init $ git remote add origin git@gitee.com:endlesspeak/endlesspeak.git $ git push origin master:develop 最后一行代表将当前本地仓库推送到远程，其中origin是远程仓库名，master是准备推送的本地仓库分支，develop是希望推送到的远程仓库分支。\n也可以使用关联分支命令，将本地master分支与远程的develop分支关联起来，这样以后只需要直接push就可以了，操作如下：\n$ git remote -v #查看远程仓库设置 $ git branch -a #查看所有分支，也可选择-r查看远程分支 如果未显示远程分支的内容，则检查远程仓库设置是否正确。若不正确，修改远程仓库设置；若远程仓库正确，则重新fetch一次。\n$ git remote rm [远程仓库别名] $ git remote add [远程仓库别名] [远程仓库地址] $ git fetch 一切正常后，关联本地master分支与远程的develop分支。\n$ git branch -u origin/develop master $ git push The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://endlesspeak.github.io/posts/tattle/base-hugo-theme-eureka/","tags":["Hugo","Blog"],"title":"Hugo及其Eureka主题"},{"authors":["Serene Feather Pavilion"],"categories":["杂谈"],"content":"站在年关的十字路口，我不禁回忆起刚刚结束的2020年——失败的一年，我这样称呼它，不是对今年忙于考研无暇做事的批判，而是对我所应当专注的事情不能全身心地投入而遗憾和愤恨。\n回顾过去 梳理起去年年关所定下的雄心壮志，才发现自己竟然一个都未完成，这可真是小母牛的腿拉伸到了南极——拉胯到了极点。更惊奇于自己定的目标都是不切实际的幻想，以如今的眼光来看，根本不可能实现，也不知道我当初为何会定下如此荒谬的目标，也许是好高骛远习惯了吧。\n我早就该做一些改变了，去年1月份的时候，我几乎踏上了正轨——我所认为的正轨，就是从POSIX标准开始，了解编程语言的前世今生，知道它为何而存在，最终的目的是何方。这是我个人认为最正统的路线——可惜，工欲善其事，必先利其器。在“利器”的过程中，我沉迷在缤纷多彩的配置和外观中无法自拔，追求金玉其外，结果败絮其中，错失了继续深入学习原理的时机——我真正的兴趣在计算机科学而不是软件工程——我认识到这一点花费的代价太大了。\n我特别欣赏在 The Hard way learn C 中作者所说的一句话，IDE会使你变笨。我认为不仅仅是IDE，Windows 会使人变懒。我一直不能下定决心进入真正有兴趣的领域去学习，这是习惯使然，纠正会很困难，但好在我的信念是坚定的。即使我永远无法抵达，至少我不断地在尝试去拥抱它。\n纵观去年一年，我觉得我最需要弥补的就是执行力。执行力是目标存在的价值之根本所在，如果我的执行力同我的信念一般坚定，不以其他人的意志为转移，那么我即使不能做到事事圆满，至少也会学有所成，而不必如现在这般，需要近乎重新开始。\n把握现在 人最可贵的品质就是正视自己的错误。当然仅仅是这样是远远不够的。哲学认为认识的起点和归宿是实践，认识的目的是通过实践改造世界，认识之于实践有如识错之于改错。所以对我来说目前最重要的问题就是如何改错。\n首先，加强行动，也就是执行力。我当前阶段编程学习的核心目标是夯实基础，做到“不动如山”。我给自己制定了下面的任务，时间期限就定在参加工作前完成：\n毕业设计前:\nPython numpy \u0026amp; pandas Machine Learning 周志华 Support Vector Machine implement Netural network implement 21.9前:\nThe hard way learn C The hard way learn Python C Programming language 中文版 机械工业出版社 及习题解答 22.3前：\nC 程序设计语言 浙江大学教材 C 程序设计语言 实验与习题解答 浙江大学教材 C Primer Plus Edition 6 C Primer Plus Edition 6 习题解答 Python Cookbook 注：这些书有相当部分的内容是重复的，而且我有一定的C语言基础，学习起来会非常迅速，不会存在阅读任务完成不了的问题。\n展望未来 给自己的未来制定太多的束缚或者详细的目标是没有意义的，矛盾的特殊性限制了对未来具体形象的描绘，不过即使是伟大的共产主义事业，想象它的未来的乐趣也被马克思称作大错特错，因此我不会给出具体的发展目标，而只有一个大概的发展方向。\nC \u0026amp; C++、Java、Python、Golang等几种主流常见语言。 版本控制、虚拟化容器、构建工具、正则表达式等工具。 操作系统和计算机网络方面的理论和实践内容。 在进行毕业设计的过程中，我对未来的发展有了新的规划：\n深度学习方向 ","permalink":"https://endlesspeak.github.io/posts/tattle/2021-what-is-the-learn-plan-as-coder/","tags":["Hugo","Blog"],"title":"新目标，新征程，新的2021"},{"authors":["Serene Feather Pavilion"],"categories":["Linux Basic","解决方案"],"content":"本文主要尝试叙述Linux系统在运行某些守护进程或者启动服务时出错后，应该如何进行修复操作。同时阐述比较常见的导致登陆时挂机/关机的情况。\n","permalink":"https://endlesspeak.github.io/posts/linux/linux-technology-7-linux-rescue-mode/","tags":["Linux"],"title":"Linux救援模式"},{"authors":["Serene Feather Pavilion"],"categories":["Linux Basic","解决方案"],"content":"在这一部分中我尝试讲述常用软件的安装过程中遇到的问题，以及我自己探索的解决思路。\n本节主要讨论的是家目录和QQ的解决方案汇总。\nXDG user directories 问题的提出：我的实体机Linux每次进入用户目录的时候需要输入类似如下的命令：\n$ cd 下载/ 进入用户目录需要切换两次输入法，相当麻烦。于是萌生了将家目录下的用户目录整体改为英文。\nArch Wiki的定义：用户目录指位于 $HOME 下的一系列常用目录，例如 Documents，Downloads，Music，还有 Desktop。用户目录会在文件管理器中显示为不同的图标，且被多种应用程序所参照。可以使用 xdg-user-dirs命令自动生成这些目录。\nGnome解决办法 我不知道是因为Ubuntu还是因为Gnome作为桌面环境的缘故，总之这些Linux用户可以采用以下办法：\n输入命令export LANG=en_US 和xdg-user-dirs-gtk-update\n在弹出的窗口中询问是否将目录转化为英文路径，同意并关闭\n使用命令epxort LANG=zh_CN\nKDE解决办法 由于我是Manjaro Linux，基于Arch，同时安装的是KDE桌面环境，故命令xdg-user-dirs-gtk-update会提示找不到。查阅Arch Wiki内容如下：\n创建默认目录 可以用 xdg-user-dirs 命令在 $HOME 下创建一整套默认的经本地化的用户目录。运行：\n$ xdg-user-dirs-update 运行后该命令还会自动地：\n创建一个本地的 ~/.config/user-dirs.dirs 配置文件：应用程序通过他来查找使用特定帐号指定的用户目录。 创建一个本地的 ~/.config/user-dirs.locale 配置文件：根据使用的 locale 指定语言。 由于我的发行版Manjaro在安装的时候Manjaro Installation软件已经自动帮我完成了上述工作，因此这里我不需要做任何操作。其实Arch Linux也不需要做这一步操作，上述内容只是在解释xdg-user-dirs-update命令的工作原理。\nArch Wiki注明说使用 LC_ALL=C xdg-user-dirs-update --force 命令可以强制创建英语目录。但就我个人实践情况来看，这条命令并不起作用。我想可能必须在刚安装完的Arch系统上，尚未创建用户目录的系统，使用该命令才可以，或者需要先手动将所有用户目录先改成英文。\n创建自定义目录 本地的 ~/.config/user-dirs.dirs 和全局的 /etc/xdg/user-dirs.defaults 配置文件都使用如下的环境变量格式： XDG_DIRNAME_DIR=\u0026quot;$HOME/目录名\u0026quot;。\n比如，我原先家目录下的配置如下所示：\n~/.config/user-dirs.dirs XDG_DESKTOP_DIR=\u0026quot;$HOME/桌面\u0026quot; XDG_DOCUMENTS_DIR=\u0026quot;$HOME/文档\u0026quot; XDG_DOWNLOAD_DIR=\u0026quot;$HOME/下载\u0026quot; XDG_MUSIC_DIR=\u0026quot;$HOME/音乐\u0026quot; XDG_PICTURES_DIR=\u0026quot;$HOME/图片\u0026quot; XDG_PUBLICSHARE_DIR=\u0026quot;$HOME/公共\u0026quot; XDG_TEMPLATES_DIR=\u0026quot;$HOME/模板\u0026quot; XDG_VIDEOS_DIR=\u0026quot;$HOME/视频\u0026quot; Linux本地化后目录都会是中文，而我想将其改为英文，故我应该先将~/.config/user-dirs.dirs中的内容改为如下形式：\n~/.config/user-dirs.dirs XDG_DESKTOP_DIR=\u0026quot;$HOME/Desktop\u0026quot; XDG_DOCUMENTS_DIR=\u0026quot;$HOME/Documents\u0026quot; XDG_DOWNLOAD_DIR=\u0026quot;$HOME/Downloads\u0026quot; XDG_MUSIC_DIR=\u0026quot;$HOME/Music\u0026quot; XDG_PICTURES_DIR=\u0026quot;$HOME/Pictures\u0026quot; XDG_PUBLICSHARE_DIR=\u0026quot;$HOME/Public\u0026quot; XDG_TEMPLATES_DIR=\u0026quot;$HOME/Templetes\u0026quot; XDG_VIDEOS_DIR=\u0026quot;$HOME/videos\u0026quot; 然后切记不要立刻执行xdg-user-dirs-update，否则会提示：\n(用户目录) has been removed,($用户目录) has been renamed. 紧接着你会发现你刚才编辑的文件内容全都被改回原样了，别问我是怎么知道的。\n出现这样的原因就是此时本地的文件夹还没有重命名，只是更改了配置文件。家目录下的常用目录必须被手动重命名之后再行更新命令。\n于是我在Dolphin(KDE File Manager)中为各个用户目录手动重命名，顺便提一句，重命名的快捷键是F2。\n值得注意的是，KDE中可能设置有单击文件夹视为直接进入的选项，故如果在KDE中，需要点击文件夹左上角的加号以选中文件夹或文件。其他桌面环境的文件管理器如Gnome的Nautilus，XFCE的Thunar等等或在窗口管理器运行的Dolphin都不需要考虑这段。\n手动重命名完成后，使用如下命令更新：\n$ LANG=en_US.UTF-8 xdg-user-dirs-update Deepin QQ Install 问题的提出：我希望在Linux上安装QQ。\nQQ 是腾讯公司开发的即时通讯软件，为 ICQ 的仿制品，是中国最流行的 IM 软件。关于QQ的内容，Arch wiki中总共有两种大体的解决思路：\n虚拟机 Wine 虚拟机自不必多说，主要是资源占用过高，而我的实体机Linux安装的时候分配的磁盘空间又过小，故无法安装虚拟机，只能用Wine的思路。\n此处推荐Deepin社区的deepin-wine-qq/deepin-wine-tim或deepin.com.qq.im/deepin.com.qq.office,至于手动实现wine方案等等，我推荐参考官方文档。说实话，耗时耗力还不一定讨好，比如之前很出名的清风老师的解决方案已经近两年没更新了，再比如那个手动实现wine方案，光配置代码就超过一个屏幕了。\n安装Deepin-wine-qq/tim 安装及配置 结合我自己尝试的经历，我并不是很推荐deepin-wine-qq/tim，主要原因就是安装的依赖过多。一个聊天软件居然要占800多MiB的空间，在我看来是不敢想象的。但是既然已经尝试过了，就说一说：\n$ yay -S deepin-wine-qq #或者deepin-wine-tim，二者任选其一 依次等待安装依赖，下载构建文件，从源代码编译，打包，安装最后结束。\n很可能打开QQ或TIM会发现字体全部显示为□，而且巨卡无比，别问我是怎么知道的。\n在Linux的/usr/share/fonts中查找wqy-microhei.ttc字体。\n之前试着用的是微软的simsun宋体字体，结果因为日常文件往来里面字体很多是宋体，不安装宋体会造成排版不一致，但是安装上宋体后wine QQ就又会巨卡，并且聊天窗口标题栏字体还是有概率显示成方框，令人自闭。\n如果你没有装文泉驿的字体，那就pacman把这个装上；如果对文泉驿不放心，还可以选择微软雅黑msyh.ttc。因为我是双系统，很容易就从C:\\Windows\\System\\Fonts中找到这个字体。\n(可选的步骤)修改wine系统注册表，输入命令：\n$ vim ~/.deepinwine/Deepin-WeChat/system.reg 更改下面两行内容为：\n\u0026quot;MS Shell Dlg\u0026quot;=\u0026quot;msyh\u0026quot; \u0026quot;MS Shell Dlg 2\u0026quot;=\u0026quot;msyh\u0026quot; 我说这一步是可选的，原因就是我当时就并没有做这一步。\n注册字体，输入命令：\n$ vim msyh_config.reg 添加如下内容：\nREGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] \u0026quot;Lucida Sans Unicode\u0026quot;=\u0026quot;msyh.ttc\u0026quot; \u0026quot;Microsoft Sans Serif\u0026quot;=\u0026quot;msyh.ttc\u0026quot; \u0026quot;MS Sans Serif\u0026quot;=\u0026quot;msyh.ttc\u0026quot; \u0026quot;Tahoma\u0026quot;=\u0026quot;msyh.ttc\u0026quot; \u0026quot;Tahoma Bold\u0026quot;=\u0026quot;msyhbd.ttc\u0026quot; \u0026quot;msyh\u0026quot;=\u0026quot;msyh.ttc\u0026quot; \u0026quot;Arial\u0026quot;=\u0026quot;msyh.ttc\u0026quot; \u0026quot;Arial Black\u0026quot;=\u0026quot;msyh.ttc\u0026quot; 最后输入命令完成字体注册：\n$ deepin-wine regedit msyh_config.reg 然后应该就可以正常使用了，当然，图片和头像应该还是加载不出来，这一点见后文。\n安装Deepin.com.qq.im/office 安装及配置 $ sudo pacman -S deepin.com.qq.office deepin.com.qq.im #需要ArchLinuxCN源才能安装 #或者直接yay安装 $ yay -S deepin.com.qq.office deepin.com.qq.im 检查安装包gnome-settings-daemon是否存在，如果不存在，就安装该包。\n$ sudo pacman -Qs gnome-settings-daemon $ sudo pacman -S gnome-settings-daemon 可通过以下命令来启动 gnome-settings-daemon\n$ /usr/lib/gsd-xsettings 在QQ/TIM的执行脚本中添加语句使其在软件启动前自动启动。\n$ vim /opt/deepwine/apps/Deepin-QQ/run.sh #或者为Deepin-TIM 在文件首添加下面的内容：/usr/lib/gsd-xsettings \u0026amp;\n问题与解决方案 问题1：Tim和QQ可能会在点击好友图像时卡死 原因是pulseaudio进程的问题。可以考虑结束，但会影响到声音的调整。\n(鬼知道这两个千里之外的包为什么会产生冲突，就像我不知道为什么deepin社区在打包QQ和TIM的时候需要加上gnome-settings-daemon依赖一样。)\n问题2：在i3wm中图标可能无法正常使用 i3wm的system tray实现方式比较特殊，QQ/TIM的托盘为wine system trayer。不过天无绝人之路，deepin-TIM和deepin-QQ在目录/opt/deepinwine/tools中有工具sendkeys.exe，使用时需要指定wine路径，运行下面的代码会向qq和TIM进程发送ctrl+alt+z，QQ和TIM如果使用默认的快捷键会被弹出：\n$ env WINEPREFIX=/home/\u0026lt;username\u0026gt;/.deepinwine/Deepin-QQ deepin-wine /opt/deepinwine/tools/sendkeys.exe $3 z 释义：env是外部命令，用于列出环境变量或赋值；此处即给环境变量WINEPREFIX赋值为/home//.deepinwine/Deepin-QQ，而后启动deep-wine容器(其环境变量前面已定义)，在其中执行/opt/deepinwine/tools/sendkeys.exe，sendkeys.exe需要传入参数，此处传入$3和z两个参数($3被定义为宏 Ctrl+Alt )。\n注：同一文件目录下sendkeys.sh 文件做了封装，直接运行sendkeys.sh z在有的环境下会出bug。(因为环境变量可能无法识别)\n执行：通常情况下会报错，但QQ/TIM界面会收到快捷键并弹出。\nWine cannot find the ncurses library (libncurses.so.5). key down: (ctrl+alt+Z), 3, 0 key up: (ctrl+alt+Z), 3, 0 问题3：QQ、TIM、微信的图标可能显示不正确 下面以微信为例说明这个问题。\n在Linux下面桌面图标快捷方式是由一个desktop文件配置，比如微信的内容基本上如下：\n#!/usr/bin/env xdg-open [Desktop Entry] Encoding=UTF-8 Type=Application X-Created-By=Deepin WINE Team Categories=chat; Icon=deepin.com.wechat Exec=\u0026quot;/opt/deepinwine/apps/Deepin-WeChat/run.sh\u0026quot; -u %u Name=WeChat Name[zh_CN]=微信 Comment=Tencent WeChat Client on Deepin Wine StartupWMClass=WeChat.exe MimeType= 其中比较关键的地方，是Icon，Exec，Name和StartupWMClass 。默认情况下，Linux是根据可执行文件的名称判定是属于哪个desktop文件配置的，大部分desktop文件的Exec配置的可执行文件刚好就是实际执行的文件名，所以很多没有StartupWMClass配置项。但这个配置项其实很重要，比如说在上面的微信的配置里面这个值是”WeChat.exe“，但是为什么还是不行呢？\n通过xprop WM_CLASS获取窗口的属性值，在命令行下执行这个命令，鼠标会变成+，然后点击要微信的窗口，输入和输出如下：\n$ xprop WM_CLASS WM_CLASS(STRING) = \u0026quot;wechat.exe\u0026quot;, \u0026quot;Wine\u0026quot; 检查WM_CLASS(STRING)字段和desktop文件配置中的区别，然后修正。这可能可以解决图标问题。\n问题4：Deepin QQ无法加载头像和图片 这是IPV6的问题，我先提一下IPV6：\n理想情况下，由IPV4向IPv6过渡的进程不应该被最终的用户所看见，但是IPv4/IPv6混合环境有时会让你碰到各种源于IPv4和IPv6之间不经意间的相互碰撞的问题。举个例子，你会碰到应用程序超时的问题，比如pacman或ssh尝试通过IPv6连接失败、DNS服务器意外清空了IPv6的记录、或者你支持IPv6的设备不兼容你的互联网服务提供商遗留下的IPv4网络，等等。\n当然这不意味着你应该盲目地在你的Linux机器上禁用IPv6。鉴于IPv6许诺的种种好处，作为社会的一份子我们最终还是要充分拥抱它的，但是作为给最终用户进行故障排除过程的一部分，如果IPv6确实是罪魁祸首，那你可以尝试去关闭它。\n再提一下我对于QFL的观点：\n19年10月24日QQ推出了QQ for linux，大部分人以为这是腾讯对Linux的支持，必须指出，这是幻想。推出QFL的原因应该是QQ的图片传输开始使用ipv6传输，原先在Linux上运行的八仙过海QQ版本基本上图片加载都成了问题。\n个人观点：QFL太过敷衍，无良软件注定得不到使用者的认可。\n法一：禁用IPV6 禁用IPV6分为三种办法，分述如下：\n一是输入下列三个命令将Linux上的ipv6全部禁用即可。\n$ sudo sysctl -w net.ipv6.conf.all.disable_ipv6=1 $ sudo sysctl -w net.ipv6.conf.default.disable_ipv6=1 $ sudo sysctl -w net.ipv6.conf.lo.disable_ipv6=1 注：这种方法是永久禁用；禁用后开启很简单，把命令的1改为0即可。\n第二种禁用IPV6的办法是：写文件以禁用\n$ sudo sh -c 'echo 1 \u0026gt; /proc/sys/net/ipv6/conf/\u0026lt;interface-name\u0026gt;/disable_ipv6' 举个例子，你的Linux通过eth0接口访问网络，那么禁用IPv6代码如下:\n$ sudo sh -c 'echo 1 \u0026gt; /proc/sys/net/ipv6/conf/eth0/disable_ipv6' 重新启用eth0接口的IPv6：\n$ sudo sh -c 'echo 0 \u0026gt; /proc/sys/net/ipv6/conf/eth0/disable_ipv6' 如果你想要将整个系统所有接口包括回环接口禁用IPv6，使用以下命令：\n$ sudo sh -c 'echo 1 \u0026gt; /proc/sys/net/ipv6/conf/all/disable_ipv6' 注：这种方法不是永久禁用IPv6，你一旦重启系统IPv6还是会被启用。\n三是在开机的时候传递一个必要的内核参数：\n这种实现思路与开源驱动nouveau在开机的时候自动禁用同理。\nManjaro Linux和Arch Linux在具有独显却未安装独显驱动的时候，需要在boot的时候按e，在第一个quiet字符串后面输入一串开机神秘代码：nouveau.modest=0；或者将之保存到grub.cfg文件中。\n输入下面的命令编辑文件：\n$ vim /boot/grub/grub.cfg 向文件中添加如下内容：\nGRUB_CMDLINE_LINUX=\u0026quot;xxxxx ipv6.disable=1\u0026quot; 上面的\u0026quot;xxxxx\u0026quot;代表任何已有的内核参数，注意是在它后面添加\u0026quot;ipv6.disable=1\u0026quot;。修改完后，使用下面的命令保存对grub的更改(这应该是可选的)。\n$ sudo update-grub #Debian，Ubuntu，Linux Mint，Arch Linux系统使用该命令 $ sudo grub2-mkconfig -o /boot/grub2/grub.cfg #Fedora、CentOS/RHEL系统： 现在只要你重启你的Linux系统，IPv6就会完全被禁用。重新开启的方法也很简单，就是从文件中将此参数删去。\n法二：http代理 安装privoxy，并查看默认监听端口。\n$ pacman -S privoxy $ vim /etc/privoxy/config 在文件中搜索搜索listen-address，默认为：\nlisten-address 127.0.0.1:8118 输入下面的命令启动privoxy\n$ systemctl start privoxy 然后设置http代理：即在QQ/TIM的登录界面点击右上角的设置，然后选择http代理，输入之前记录下的信息和端口，默认为127.0.0.1和8118。再登录就能看到图片和头像了。\nNetease-Cloud-Music 问题：想听个歌放松一下，打开网易云却不能在搜索框输入中文以搜索歌曲。\n查找问题：\n第一反应是DWM(dynamic window manager)标签的设定，使得我只能在单个程序上使用fcitx而不能多个程序均使用fcitx，故右击fcitx打开配置，选择全局配置，调整在多个窗口之间共享显示从None到All。\n然后我发现在不同标签处打开不同的程序都可以呼出fcitx，但是唯独网易云音乐不行。\n第二反应是网易云音乐不支持fcitx，百度一下果然有很多人遇到了和我一样的问题。\n失效的解决办法 2020年1月以前可以用如下解决方案：\n查看本机是否安装有qcef软件包\n$ pacman -Q qcef 如果查询发现没有，那就安装一个包。\n$ sudo pacman -S qcef 编辑网易云音乐的脚本\n$ vim /opt/netease/netease-cloud-music/netease-cloud-music.bash 变化内容如下：\n- export LD_LIBRARY_PATH=\u0026quot;${HERE}\u0026quot;/libs #注释原有的LD_LIBRARY_PATH，以下是修改过的 + export LD_LIBRARY_PATH=/usr/libs 但是现在这个方案已经不起作用了，原因是qcef软件包已经被Arch社区移出了软件仓库。\n目前的解决办法 法一，构建，编译，安装网易云音乐的qcef 经过在AUR上查找，两名受信任的开发者用户提供了如下的解决思路，分享如下：\n首先感谢这两名开发者：@springzfx和@laomocode。据@springzfx分析，网易云音乐linux版v1.2.1，在arch和manjaro中无法输入中文，是软件自带库qcef所导致的，具体为以下目录和文件：\n/opt/netease/netease-cloud-music/libs/qcef /opt/netease/netease-cloud-music/libs/libqcef.so /opt/netease/netease-cloud-music/libs/libqcef.so.1 /opt/netease/netease-cloud-music/libs/libqcef.so.1.1.4 输入如下的命令编辑启动文件。\n$ sudo vim /opt/netease/netease-cloud-music/netease-cloud-music.bash 内容变化如下：\n#!/bin/sh HERE=\u0026quot;$(dirname \u0026quot;$(readlink -f \u0026quot;${0}\u0026quot;)\u0026quot;)\u0026quot; - export LD_LIBRARY_PATH=\u0026quot;${HERE}\u0026quot;/libs - export QT_PLUGIN_PATH=\u0026quot;${HERE}\u0026quot;/plugins - export QT_QPA_PLATFORM_PLUGIN_PATH=\u0026quot;${HERE}\u0026quot;/plugins/platforms + export XDG_CURRENT_DESKTOP=DDE + export LD_LIBRARY_PATH=/usr/lib + exec \u0026quot;${HERE}\u0026quot;/netease-cloud-music $@ 然后安装qcef，由于aur已经移除qcef，所以只能自己构建安装包。\n这个包能还在github上找到，需要克隆下来自己构建。构建见后面的内容。如果有人上传已经构建好的软件包，则直接安装：\n$ sudo pacman -U qcef-1.1.6-1-x86_64.pkg.tar.xz 法二：构建，编译，安装整个软件 操作步骤、输入的命令如下：\n$ yay -Rsn netease-cloud-music $ git clone https://github.com/springzfx/archlinux # compile qcef 1.1.6 and build it $ cd qcef makepkg -si # compile netease-cloud-music and build it $ cd netease-cloud-music makepkg -si 注意：安装运行时的依赖包括gconf、gtk2、libxss、nss、libpulse、qt5-webchannel、qt5-x11extras。你可能会缺少gconf这个软件包。\n安装编译时的依赖cmake、qt5-tools。你应该不缺少这些打包工具，除非你从未用过yay安装软件。安装base-devel软件包组以解决编译打包的问题。\n还有一位大佬提出的观点是：Linux版网易云由Deepin和网易合作开发，无法输入中文是因为软件使用了deepin魔改过的cogl，安装deepin-cogl就解决了，但是其他使用cogl的软件又会出问题……所以这种安装deepin-cogl的方法仅供参考。\n法三，以wine为兼容层安装windows版网易云 虽然网易云音乐已经推出了 linux 版，但是诸如本地歌曲扫描、心动模式等功能有所缺失，并且更新相对较慢，因此这里介绍使用 wine 完美运行网易云音乐windows版本的方法。\nPS：我试着用Deepin-Wine安装和运行网易云音乐，测试发现安装和卸载都可以正常进行，这些过程没什么大问题，但是运行就不行了，所以还是得安装wine版本。\n$ sudo pacman -S wine 然后一个非常关键的步骤：你需要将windows系统中的字体拷贝到你的wine容器中，否则启动网易云会提示崩溃。\n由于我是实体机双系统，因此直接切换到Windows系统下C:\\Windows\\Fonts，将之复制到Linux系统的家目录中wine目录Windows文件夹下~/.wine/Windows/Fonts\n在Linux下你的Windows磁盘的字体文件应该被挂载为如下的路径：\n/run/media/\\\u0026lt;user name\u0026gt;/C:/Windows/Fonts 直接下载网易云的客户端(Win可执行文件exe)，然后切换到终端用wine安装该软件：\n$ wine \u0026lt;your package setup\u0026gt;.exe wine提示安装三个软件以提供支持，这是可选的，由于众所周知的原因，安装异常的缓慢。\n安装完毕后运行如下的设置：\n$ wine winecfg 关闭允许桌面管理器装饰窗口：\n运行 winecfg 在 显示 选项卡中取消勾选 允许窗口管理器装饰窗口以修复网易云音乐最大化后超出屏幕边界的问题\n调整屏幕分辨率：\n将屏幕分辨率调整至 105 以上，以修复托盘图标无法点击的问题（在屏幕分辨率大于一定值后即可点击，但不确定具体为多少，可以自行尝试）\n修改 windows 版本:\n网易云音乐只能在 Windows XP 容器中运行。\n启动网易云时只需要输入:(命令可能在不同机器上不同)\n$ wine ~/.wine/c:/Program\\ Files (x86)\\\\Netease\\\\Cloudmusic\\\\cloudmusic.exe ","permalink":"https://endlesspeak.github.io/posts/linux/linux-technology-6-1-linux-software-usage-1/","tags":["Linux"],"title":"Linux 软件使用问题与解决方案"},{"authors":["Serene Feather Pavilion"],"categories":["Linux Basic"],"content":"Linux中”桌面“的概念——由X窗口系统组成的，可以卸载的图形环境——复杂且抽象，好在那些试图解释清楚这件事情的人也有同样的感受。\n图形用户界面是可以为Linux工作站提供图形化工作界面的强大工具，但许多新用户会碰到一个令他们十分惊奇的事实： 如此强大的工具只不过是运行在系统上的一个应用程序。它不是Linux内核的一部分，也并非集成在Linux系统中。它需要额外安装，只不过一些发行版将这种安装过程自动化了而已。\nUNIX like操作系统需要图形界面(Graphical User Interface)。由于标准的重要性，有人为窗口的绘制和移动、通过鼠标的移动和键盘实现程序和用户间的互动，以及其它重要的方面创建了一种标准，这种标准就叫做X 窗口系统，它通常缩写为 X11 或者X。它广泛应用于Unix，Linux，以及其他类Unix操作系统上。\nX窗口系统概述 X窗口系统，是一种以位图方式显示的软件窗口系统。它是Linux图形用户环境的基础。 X窗口系统作为UNIX、类UNIX、OpenVMS等操作系统所一致适用的标准化软件工具包及显示架构的运作协议。\nX窗口系统通过软件工具及架构协议来创建操作系统所用的图形用户界面，而且是利用网络架构来进行图形界面的运行与绘制的。此后其逐渐扩展适用到各形各色的其他操作系统上。现在几乎所有的操作系统都能支持与使用X。如今一些知名的桌面环境，例如GNOME和KDE，都是以X窗口系统为基础建构而成的。\n总体来说，X窗口系统由以下若干重要部分组成：\nX Server (X服务器，其中包括重要内容：X session)\nX Client (X客户端程序)\nWindow Manager (窗口管理器)\nDisplay Manager (显示管理器)\nwidget library (widget 库)\nDesktop Environment (桌面环境)\nX Server X Server，译作X服务器，是X的核心。X Server驱动硬件，提供基本的图形显示能力。X Server用于实际控制输入设备(例如鼠标和键盘)和位图式输出设备(例如显示器)。合理但并不十分科学地，可以把它看作视频卡的驱动程序。只有在运行了X Server的Linux系统上X Client才能利用X Server绘出相应的图像。准确地说，X Server定义了给X客户机使用这些设备的抽象接口。\n和大部分人的想法不同，X Server没有定义高级实体的编程接口，这意味着它不能理解“画一个按钮”这样的语句，而必须告诉它：“嗯……画一个方块，这个方块周围要有阴影，当用户按下鼠标左键的时候，这些阴影应该消失……对了，这个方块上还应该写一些字……”\n这种设计的意义在于，X Server能够做到最大程度上的与平台无关。用户可以自由选择窗口管理器和widget库来定制自己的桌面，而不需要改变窗口系统的底层配置。\nX Server早期使用的是XFree86，自4.4版本后，XFree86改用GPL发布的分支在此开始被称为Xorg。\nwidget library widget库又被称为GUI程序使用的库函数，如GTK+和QT。它定义了一套图形用户界面的编程接口。应用程序开发人员通过调用widget库来实现具体的用户界面，如按钮、菜单、滚动条、文本框等。程序员不需要理解X服务器的语言，因为widget库会把“画一个按钮”这句话翻译成X服务器能够理解的表述方式。\nX Client X Client泛指在X下实际执行的所有应用程序。X Client只负责和X server交互，由X server管理显示界面与在屏幕上绘图，然后将输入设备的行为告知X Client，由X Client依据输入设备的行为开始处理，然后将图示的显示数据回传给X Server，X Server根据X Client传来的绘图子类将它描绘在自己的屏幕上，来得到显示的结果。例如Firefox，gedit，kate等等都属于X Client程序。\nDisplay Manager 显示管理器(简称DM)是管理X session的程序。DM提供了一个登录界面，其任务就是验证用户的身份，让用户登录到系统。可以说，图形界面的一切（除了它自己）都是由这个显示管理器启动的，包括X服务器。用户也可以选择关闭显示管理器，如果这样做，就必须通过命令行运行startx命令(或者使用.login脚本)来启动X服务器。\n注：这里所说的“脚本”是指Shell脚本，它是一段能够被Linux理解的程序。\nWindow Manager X Server提供了基本的图形显示能力。然而具体怎么绘制应用程序的界面，却是要由应用程序自己解决的。Window Manager(窗口管理器，简称WM)提供统一的GUI组件(窗口、外框、菜单、按钮等)，负责控制应用程序窗口的各种行为，例如移动、缩放、最大化和最小化窗口，在多个窗口间切换等。从本质上来说，窗口管理器是一种特殊的X客户端程序，负责管理其他所有的X Client软件。因为这些功能都是通过向X Server发送指令实现的。Window Maker、FVWM、IceWM、Sawfish等是目前比较常见的窗口管理器。\nWM的启动由DM控制，一般在DM的登录窗口可以进行选择。常见的WM有:Metacity(Gnome默认的WM),KWin(KDE默认的WM)等。\n从本质上来说，窗口管理器是一种特殊的X客户端程序，因为这些功能也都是通过向X服务器发送指令实现的。\nDesktop Environment 如前所述，要启动X window system，主机上必须要有 Xorg 的X server核心，才能提供屏幕绘制；为了使用更方便，在上面加装了X Client(它们是窗口应用软件，与X server交互以提供自己的图形界面)；为了让窗口管理更方便，在上面加装了window manager；为了取得X window的控制，使用Display Manager提供图形接口登入。\n现在终于到了问题的关键，究竟什么是桌面环境？以KDE和Gnome为代表的Linux桌面环境都是集成的工作环境，是完整X window system的一个组成部分。换句话说，它们是一整套从DM到WM到一揽子X Client的程序集合，是把各种与X有关的东西（除了X服务器）整合在一起的大杂烩，这些程序包括普通的应用软件、窗口管理器、显示管理器和widget库。以GNOME为例：DM是gdm，WM有多种选择，比如可以是metacity，等等；以KDE为例，DM是sddm(KDE4以前是kdm)，WM是KWin，等等。但是，无论桌面环境如何复杂，最后处理图形输出的仍然是X服务器。\n不过要注意到，即使没有这些组件，我们像Linux的前辈们一样用startx登录X，用fvwm做窗口管理器，用那些最最原始的应用程序，仍然可以实现一个高效的X工作环境。GNOME/KDE的出现只是让这一切整合地更好而已。\nX窗口系统的启动流程 基本上目前都是使用Window Manager来管理窗口界面风格的。取得X窗口系统的方法有两种，一种是通过登录到文本模式界面(terminal)，输入startx来启动X窗口；或者通过登录管理器(Display Manager)提供的登录界面来登录取得X窗口。\n控制台终端 Linux系统中计算机显示器通常被成为控制台终端(console)，有一些设备特殊文件与之相关联，它们被称为tty0、tty1等等。当在控制台上登录时，一般使用的是tty1(如果Linux已安装有X窗口系统则tty1转为X窗口系统)。使用Ctrl+Alt+[F1—F6]组合键时，可以切换到tty2、tty3等上面去。tty2–tty6等称为文本模式下的虚拟终端，tty1称为图形虚拟终端；tty0则是当前所使用虚拟终端的一个别名(它也叫控制台终端)，不管当前正在使用哪个虚拟终端，系统信息都会发送到控制台终端。\n归纳：tty2-6是文本型控制台,tty1是x-window(图形)控制台，不论使用何种控制台，当前所使用的控制台可以用它的tty序号表示，也可以用tty0表示。\n通过文本模式启动(选阅) startx 在文本模式，且首次登录X窗口时，可通过输入startx命令在文本模式启动X窗口系统。\n本质上startx是一个shell script，它是一个“用户友好”的脚本，会主动建立X所需要引用的设置文件。startx最重要的作用是找出用户或者系统默认的 X server 与 X Client 的设置文件，当然用户也能够使用startx外接参数来取代设置文件的内容。即startx可以直接启动，也能够外接参数。\nstartx的语法和使用例如下：\n$ startx [x client parameter] -- [x server parameter] # For example $ startx -- -depth 16 注：startx 后面接的参数以两个减号\u0026quot;\u0026ndash;\u0026ldquo;隔开，前面是X client的设置，后面是X server的设置。上面的范例是让X server以色彩深度16 bit色(即每一像素占用16bit，共65536色)显示，因为色彩深度与X server有关，故参数写在\u0026ndash;后面。\n事实上，启动 X 的是xinit这个程序，startx只是在找出X Server/X Client的设置值。\n※ startx 寻找设置值的可用顺序：\nX Server parameter\n使用startx后接参数 若无参数，则查找用户根目录的文件，即~/.xserverrc 若无上述两者，则以/etc/X11/xinit/xserverrc 若无上述三者，则仅执行/usr/bin/X (此即X server可执行文件) X Client parameter\n使用startx后接参数 若无参数，则查找用户根目录的文件，即~/.xinitrc 若无上述两者，则以/etc/X11/xinit/xinitrc 若无上述三者，则仅执行xterm (此为X下面的终端软件) xinit 当 startx 找到需要的设定值后，就将获取的参数传递给xinit，并呼叫 xinit 实际启动X。xinit 主要的工作是启动 X server 与 X client，其语法如下：\n$ xinit [client options] -- [server or display options] 注1：上面[client]和[server]代表的是程序的具体路径，其必须以/或者./开头。\n注2：client option 与 server option 两个参数由 startx 获取。 通过 startx 找到适当的 xinitrc 与 xserverrc 后，启动 X 交给 xinit 来执行。 在预设的情况下 (使用者初次登录，尚未有 ~/.xinitrc 等档案时)，输入 startx ， 就等于执行：\n$ xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc 初次登录的时候， 由于xserverrc 也不存在，参考之前的参数搜寻顺序，实际上的指令是：\n$ xinit /etc/X11/xinit/xinitrc -- /usr/bin/X 注：不直接执行 xinit 而是使用 startx 来呼叫 xinit 就是因为 xinit 需要取得参数，而 startx 这个脚本可以快速地找到这些参数而不必手动输入。如果只是单纯执行 xinit ，系统的默认 X Client 与 X Server 的内容如下：\nxinit xterm -geometry +1+1 -n login -display :0 -- X :0 分析：\n在 X client 方面： xterm 是 X Window底下的虚拟终端机，后面接的参数是这个终端机的位置与是否登入， 最后面会接一个 -display :0 表示这个虚拟终端机是启动在第 :0 号的 X 显示接口的意思，且 xterm 在加载时，必须要使用 -display 参数来说明。 在 X Server 方面， 启动的 X server 程序是 X 。 X 在此即是 X Server 的主程序， 所以启动 X 挺简单，直接执行 X 即可，同时还指定 X 启动在第 :0 个 X 显示接口。 如果单纯以上面的内容来启动你的 X 系统时，你就会发现tty1有画面了，但是很丑，因为还没有启动 window manager。 前面提到，启动 X Server 需要由 startx 获取 xserverrc ;启动 X Client 需要由 startx 获取 xinitrc ，故下面展开叙述 xserverrc 和 xinitrc 。\nxserverrc X 窗口最先需要启动的就是 X server ，而 X server 启动的脚本与参数是通过 /etc/X11/xinit/ 里面的 xserverrc 得到的 。如果Linux中没有 xserverrc 这个档案， 用户家目录也没有 ~/.xserverrc ，则系统会直接执行 /usr/bin/X 这个指令。 这个指令也是系统最原始的 X server 执行命令。\n以Deepin OS 15.11 desktop为例，/etc/X11/xinit/xserverrc文件内容如下：\nexec /usr/bin/X -nolisten tcp \u0026quot;$@\u0026quot; 启动 X Server 时，Xorg 会去读取 /etc/X11/xorg.conf 这个配置文件。该配置文件的内容，在后面会提到。如果一切顺利，X 会顺利的在 tty1 的环境中启动。\n注：单纯的 X 启动时，画面为一片漆黑，中心有鼠标的光标(也可能没有)。\n由前面的说明中，可以发现， X 启动的时候可以指定启动的接口，即 :0 这个参数。事实上，Linux 可以同时启动多个 X！第一个 X 的画面会在 :0 是 tty1 ，第二个 X 则是 :1 即 tty2 。 后续还可以有其他的 X 存在。注意： X server 未注明加载的接口时，默认是使用 :0 。但是 X client 未注明加载的接口时，就无法执行。\nxinitrc 启动了 X server 后，接下来的工作就是加载 X client 到 X server 上面。\n假设你的家目录并没有 ~/.xinitrc ，则此时 X Client 会以 /etc/X11/xinit/xinitrc 来作为启动 X Client 的预设脚本。\n仍以Deepin OS 15.11 desktop为例，/etc/X11/xinit/xinitrc文件内容实质如下：\n. /etc/X11/Xsession #执行Xsession脚本 注：如果需要执行多个 X client，需将除最后一个以外的其他项目都添加 \u0026amp; 以在后台执行。\nsummary 归纳1: Linux启动X的过程/startx脚本工作流程/X window的启动流程(X Client用具体的程序代替)：\n归纳2: Linux启动X的过程实际相当于执行下面的命令:\nxinit /etc/X11/Xsession -- /usr/bin/X11/X -nolisten tcp \u0026quot;$@\u0026quot; 归纳3: Desktop Environment(桌面环境)启动流程(Gnome或KDE等的启动流程)\nX 启动流程测试 到现在为止，关于X window的两个最关键的组件 X Server 和 X Client 及其所做的工作已经阐述的比较明白了(这些知识可能对现在的大多数Linux桌面发行版毫无用武之地，但对Arch Linux或者是安装在服务器而不是个人计算机上的Linux却相当有用)。\n例1 由于目前Linux桌面发行版的图形界面(X window)被看做第一个X( :0)，故下面的练习指定到第二个X( :1)。\n笔者自己的测试在 Deepin OS Desktop 15.11 上进行，由于Deepin采用DDE桌面环境，自身的窗口管理器Kwin (dde-Kwin)运行在第一个X中，如果在第二个X中调用会报错:FATAL ERROR while trying to open display；同时深度终端 Deepin-terminal 在创建的第二个 X 上运行会报错 Unable to init server: Could not connect: Connection refused; Gtk-WARNING: cannot open display，故需要安装两个能够在X上“单独”运行轻量软件 (一个窗口管理器，一个终端) 来完成本次小测试。\n打开Deepin，进入Deepin Desktop，按Ctrl+Alt+F2切换到tty2，以root登录，输入命令： 注：Deepin默认未设置root，如果没有设置root，请先设置root账户和密码。\n# apt install xterm twm #xterm是轻量级X终端，twm是轻量级X窗口管理器 输入以下命令启动第二个X在:1中 # X :1 \u0026amp; #注意加上\u0026amp;以在后台执行，防止执行过程中出现问题而无法结束进程 Linux会在tty3处生成第二个X并自动切换到tty3，仔细观察屏幕内容(正常情况下是一片漆黑，或者屏幕中心会有一个鼠标的独特标记)，按Ctrl+Alt+F2切换到tty2，输入命令： #每执行一次指令就应当切到tty3观察，注意执行前后的区别，而后再切回tty2 # xterm -display :1 \u0026amp; #可以执行这条指令两次 # xclock -display :1 \u0026amp; # xeyes -display :1 \u0026amp; 正常情况下会出现一个终端，一个时钟和一双大眼睛。可惜你并不能移动它们，也不能在该终端中输入命令，输入下面的命令加载窗口管理器： # twm -display :1 \u0026amp; 现在你就可以随意地移动和放大缩小窗口了，而且每个部分都有标题提示。在黑屏幕处按下鼠标按键(不同Linux有区别，可能是左键也可能是右键)，会出现菜单，你也许可以进行额外的管理。 注：你完全可以尝试一下还有哪些程序能在这个“简陋”的X上运行。\n解除刚才的所有工作，输入命令： # kill %6 # kill %5 # …… # kill %1 通过显示管理器启动 X Window 的启动过程可以基本上由显示管理器（Display Manager）完成。在计算机进入Linux后，会先启动显示管理器，在显示管理器启动后会依次完成下面这些工作。\n启动X Server。 提供一个界面友好的屏幕，等待验证用户的身份。 执行用户的引导脚本，这个脚本用于建立用户的桌面环境。 简单提一下“引导脚本”：桌面环境的引导脚本是一段用Linux命令组成的脚本程序，叫做X session。X session通过启动窗口管理器、任务栏，设定应用的默认值、安装标准键绑定等来启动整个桌面环境。例如非常有名的桌面环境KDE和Gnome，它们都有自己的启动脚本，这些通常不需要用户操心。\nX session X session(X 会话)是指X server启动后直到X server关闭之间的这段时间。这期间一切跟X相关的动作都属于X session的内容。管理X session的程序称为Display Manager，常听说的gdm或sddm就是gnome/kde所分别对应的Display Manager。\n开启一个X session，也就开始了图形界面的使用。在开启的过程中，Display Manager会对用户进行认证(也就是用户名密码的输入)，并运行事先设置好的程序(比如fcitx输入法，比如Deepin的开机音乐就是在这个时候启动的)等等。\nX session会一直运行，直到用户退出，或者说，当X session运行结束后，用户就退出了。Window Manager是X session启动的唯一前台程序(其他程序都在后台执行)，如果没有这个前台程序，那么用户会在登录后又立即退出登录。\n在开启过程中，用户计划执行的一系列操作都可以在/etc/X11/Xseesion或/etc/X11/Xsession.d/目录下看到，其他还有一些配置文件如Xsession.options, Xresources等，都是执行的X session的初始化过程。仔细阅读这些脚本或配置文件，可以帮助更好地理解X。\nXsession是一个重要的文件，不管是通过Display Manager登录X，还是通过xinit(startx)登录X，它都会被执行。Xsession是一个全局文件。\nXorg.conf xorg.conf是X Server的主要配置文件，它包含一个当前系统的硬件资源列表。X Server就是根据这些硬件资源“组织”出基本的图形能力。\n要获取X Server的版本信息，输入以下命令：\n$ X -version xorg.conf文件在/etc/X11/xorg.conf，主要包含下面的字段。\nModule: 被加载到X Server中的模块(某些功能的驱动程序) InputDevice: 输入设备，如键盘鼠标的信息 Files: X系统使用的字体存放目录(字体的具体使用由FontConfig工具配置) Monitor: 显示器的设置，如分辨率，水平/垂直刷新率等，与硬件有关 Device: 显示适配器芯片组的相关设定 Screen:由Monitor和Device组装成一个Screen，表示由它们向这个Screen提供输出能力 ServerLayout:将一个Screen和InputDevice组装成一个ServerLayout 在具有多个显示设备的系统中，可能有多个Screen和多个ServerLayout，用以实现不同的硬件搭配。在最近的xorg版本中，X Server已经开始自动侦测硬件，现在的xorg.conf已经都成了默认名称。具体细节还待查，但基本原理不变。\n在修改该文件之前，注意要将该文件备份，以免修改出错导致X Server无法启动。通用的备份方法是在源文件文件名后添加“.bak”。Xorg.conf 文件的内容分成数个段落，每个段落以Section开始，以EndSection结束，里面含有该Section的相关设定值。\n(未完待续)\n","permalink":"https://endlesspeak.github.io/posts/linux/linux-technology-4-x-environment/","tags":["Linux"],"title":"Linux的桌面环境"},{"authors":["Serene Feather Pavilion"],"categories":["杂谈"],"content":"很多年轻人打算搞IT，问要看什么书，以下是比较专业的回答：\n第一阶段：《数据结构》《C语言》《C++》《C#》《PHP》《Java》《设计模式》《框架》 第二阶段：《莫生气》《佛教》《道》《思想与政治》《论持久战》 第三阶段：《脊椎匡扶指南》《腰间盘突出康复指南》《心脏病的预防与防止》《高血压降压宝典》《强迫症的自我恢复》 第四阶段：《迷恋》《谢谢你折磨我》《自私与贪婪》《走向奴役之路》《精神变态日记》 第五阶段：《活着》 第六阶段：《棺材的质量与选材》《墓地的风水与选择》《死后的思想》 第七阶段：《中国传统丧葬礼仪概述》 第八阶段：《论投胎的方法与技巧》 第十阶段：《论出生后如何不成为程序员》\n你可能很疑惑，为什么没有第九阶段。别问，问就是喝孟婆汤忘记了。\n规划的原则——因材施教 我想从一个经典的知乎问题开始讲起：计算机专业有哪些必读的书籍/计算机专业应该如何提升自己。\n关于这个问题，可谓是仁者见仁，智者见智。\n常言道，一千个人眼中有一千个哈姆莱特；常言又道，一千个人心中有一千部红楼梦；据此类比推出：常言还道，一千个人脑海里有一千种书单。\n想要笼统而概括地论述计算机专业\u0026amp;编程专业的发展路线，其实不是一件容易的事情。我的观点是：因材施教。每个刚刚接触计算机或者接触编程的青年，都应该对自己未来的发展有明确的认识，应该广泛了解各方面的知识，然后在这个基础上，选择自己适宜的发展方向，并规划自己的发展路线。\n首先我们来看下一般大学的科班——计算机科学与技术的课程表：数字电路原理、模拟电子技术、数字逻辑、数值分析、计算机组成原理、微型计算机技术、计算机网络、高级语言（C++、Java）、汇编语言、数据结构、操作系统原理、数据库原理、编译原理、计算机图形学、离散数学、概率统计、线性代数以及算法设计与分析、面向对象程序设计。\n高数，概率，线代，复变，离散数学等基础学科，打下了 逻辑思考的基础，以及工作中需要使用到复杂的数学运算时的数学基础。使人更加易于理解和分析如何吧现实问题转化为程序逻辑并实现。\n模电主要让人明白信号传递的原理同时又作为数字电路的基础，而数电主要让人明白计算机内部数据到底是如何存储，如何运算，如何传输的。\n计算机组成原理，微机原理等，主要是来解释计算机是如何组成的，早期是什么样子的，发展历程是什么，为什么会有这样的发展，现在的计算机的复杂结构下的简单核心是什么？\n操作系统则真正讲述了，一个应用程序是如何层层传递，调用了最终硬件的；操作系统，驱动，应用程序，分别都是什么关系；cpu的运算方式是什么样子的；为什么要有多线程；为什么会有死锁；在多线程的模型下，硬件到底在做什么。\n计算机网络，让人明白在计算机的基础之上，到底是如何传输数据的。OSI七层模型和TCP/IP协议五层模型分别有哪些层；每一层在做什么；为什么RFC的各种协议里会有那么多奇奇怪怪的头和尾；各种不同的协议是怎么产生和怎么发展的；分别有什么特色；以及我们为什么在某一种场景下使用某一种网络协议；假如我们需要一个自己的协议，该如何构建。\n数据结构，让人明白数据是如何存储的，目前常见的存储的模型有那些？这些模型在内存里以什么样的方式存储？这些存储方式都有什么优劣？在那些场景中最为适用？\n编译原理，让人明白高级语言到底是怎么被解释编译成机器语言的。\n汇编语言，让人明白在接近硬件的层面上，程序到底是怎么运作的。去理解去思考，我们的操作和编写的程序，对硬件到底做了什么。不同的操作系统，不同的编译器，不同的写法，不同的逻辑，在硬件层面上，会有什么样的不同？\n算法和高级语言，一般来讲，到这个层面往上，非科班和科班的差距开始变小。因为大部分人在实用性的学习过程中。必须来学习和接触到高级语言和算法。\n综上所述，计算机的基础，不是你会什么C、C++、C#、Java、python、PHP、Object-c这样的语言；也不是你学了多少linux，Win32，IOS，Android，MFC，.net，Apache，Struts，Spring这样的框架；更不是你会Oracle，MySQL，SQL server这样数据库的使用；而是你是否明白，从最基础的电路和电讯号传递开始，到今天的计算机体系的大厦，是如何一步步构建出来的，每一步的取舍都是为了什么。\n大部分的人，要么是半路出家，上了几个编程培训班而自以为技术成熟，要么是非科班出生，对科班这一整套课程体系不屑一顾。诚然，直接从高级语言和算法开始学起，可以做到知其然，并且熟练的编程，设计生产出非常优秀的应用。但是如果知其所以然，那么就可以做得更好，在出现新东西的时候，能够更快的去理解这些新东西的缘由，发展和价值。\n我劝各位想要接触计算机行业的初学者——当然我本人也不过是初学者而已——不要学了一点皮毛就沾沾自喜。今天我们之所以不用去了解那么多基础，就可以从事这个行业，正是因为无数前人帮助我们构建了一个相当完善的知识体系，在这个基础上，我们可以轻松的去学习，去操作。但我们的梦想就仅此而已了吗？我们该如何往前进一步的去推进呢？在工作学习的过程中，进步远非是要学习怎么做那样简单，更要多问问为什么。只有这样才能走的更高，更远。\n参考书单——循序渐进 我想基于我刚才提到内容的基础，结合我之前参考的很多知乎、微博和Bilibili上从事程序设计、软件架构、前端后端开发的工程师的经验和建议，以及科研工作者对计算机学习的规划与指导，谈谈我的一点浅薄之见——计算机初学者应该怎样发展自己的计算机学习。\n如果真真正正是零基础开始学习计算机，我的建议是需要注重兴趣，但是不能永远以兴趣为由放弃基础知识的学习。如果不能适应计算机底层的枯燥知识，最好是直接转行，不要继续待在计算机行业里。\n计算机学习的最开始，当然是需要对计算机整体有个清晰的把握，然后一面深究计算机底层层面，一面发展高级语言层面。按照这个思路，我提供如下的书单，以供参考。\n底层原理 数字电路与模拟电路。\n数字逻辑电路(南理工)\n数字电路绝对是完全被低估的一门计算机基础课，我在大学期间就没有严肃地对待这门课，这导致我只了解基本的逻辑门电路，对更高级的知识知之甚少。由于有关数字电路的书籍很难找得到出众的，故这里只推荐中国大学MOOC上的公开课。\n模拟电路大体同上，在中国大学MOOC上搜索即可。\n计算机组成原理\n《大话处理器》\nCODE: The Hidden Language of Computer Hardware and Software\n《编码:隐匿在计算机软硬件背后的语言》\n《穿越计算机的迷雾》\n※ Computer Systems: A Programmer\u0026rsquo;s Perspective\n《深入理解计算机系统》\n※ Structure and Interpretation of Computer Programs\n《计算机程序的构造和解释》\n首先推荐的两本都是比较通俗易懂的书，这两本书都偏科普一些，阅读起来相当轻松，非常具有趣味性，是入门的上佳选择，如同看小说一般过一遍即可；另一本穿越计算机的迷雾目前已经绝版了，不过它的内容也是不错的，网络上可以搜索一下相关资源。\n第三第四本是需要重点介绍的正规教材：\n《深入理解计算机系统》 它从程序员的视角详细阐述了计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。\n《计算机程序的构造和解释》讲的是从数据抽象、过程抽象、迭代、高阶函数等编程和控制系统复杂性的思想，到数据结构和算法，到编译器/解释器、编程语言设计。\n计算机组成原理很好地向我们阐述了计算机如何工作，如何计算和输出我们想要的数据的。由于本门课还是大部分大学的考研科目，所以各个大学都会有一些公开课视频，可以自行查找。\n汇编语言\n《汇编语言(第2版)》(王爽著)\n汇编语言是一门相对比较难并且比较抽象的课程，但是却可以方便地进行实操，就像学习编程一样，可以实际运行书中的一些代码。\n计算机操作系统\nLinux操作系统入门\n《典藏大系-Linux从入门到精通》 《鸟哥的Linux私房菜》 操作系统原理详解\n※Modern Operating System《现代操作系统》\nLinux环境编程及内核分析（必须先修C/C++语言后再读）\n《UNIX环境高级编程》 《Linux程序设计》 《Linux内核设计与实现》 计算机操作系统和计算机组成原理一样是考研课程。首先推荐的两本是科班所教授的Linux操作系统基础知识（当然Linux不属于考研范畴之内）为后面的Linux环境编程打下基础。\n《现代操作系统》是相当经典非常需要读的一本书，《UNIX环境高级编程》相比之不遑多让，这本书之经典，三言两语无法说清。之所以推荐第二本，还有一个原因就是该书是基于UNIX的，UNIX/Linux在服务器中的重要性和广泛应用我相信不必强调。 第四本较之第三本略逊一筹，参考价值也很大。\n至于第五本，则是在当你对操作系统有一定理解以后阅读，它将为你打开学习Linux内核的大门，当然在此之前你得有一定的C语言开发能力，以及对Linux的了解。\n计算机编译原理\n《编译原理 (原理、技术、工具)》（龙书） 《现代编译原理》（虎书） Advanced COMPILER DESIGN IMPLEMENTATION （鲸书） 很多编程学习者都并不是很清楚编译时到底发生了什么事情，什么是编译期什么是运行期相信有些人还是一知半解，编译原理就是告诉我们高级语言是如何一步一步地被转化为低级语言，最终在计算机上运行的。\n编译原理的学习分为三大阶段，龙书阶段考虑原理、技术和工具；虎书阶段考虑技术实现和实践；鲸书阶段考虑知识的前瞻和增广扩充。\n离散数学\n《离散数学及其应用》\n离散数学个人认为对于计算机学生而言是非常重要的一门课，可惜的是我在本科期间对计算机的认知不够，导致在学习这门课的时候只是把它当成一门数学来学习，并且也没有花费太多的时间以及精力，相信对于大部分计算机专业的学生来说也是这样的。\n不过我认为如果有时间和精力，一定要重新学习这门课，因为日后的编程与离散数学的逻辑是紧密相连，不可分割的。\n计算机网络\n《图解HTTP》（兴趣阅读） 《网络是怎样连接的》（兴趣阅读） ※《计算机网络——自顶向下方法》 ※《TCP/IP详解》 ※《UNIX网络编程》 计算机网络的原理认知对日后的发展有非常大的帮助，非常典型的例子就是分布式系统。对于计算机网络的学习，我认为可以分为两个阶段，第一阶段是快速地把两本兴趣阅读的读物给过一遍，建立起对网络的认知，然后迅速地进入第二阶段，精心研读第三、四两本史诗级巨著；最后一本讲解了Unix内核是如何实现网络通信的，其中涉及到很多网络，操作系统的知识，并且你要熟悉c语言。它也是被奉为网络编程神书的存在。\n高级语言的学习\n这一节实在是太重要了，重要到必须另起一阶段，详细地阐述。\n高级语言 高级语言大体上使用率高的基本上有：C++、Java、Python、Go、JavaScript等等，分述如下：\nC++ 如何学好C++？唯一的办法就是读书，读大量的书，才可以学好。\n要把C++作为日常语言，而不是一种程序语言，这样才更容易掌握。\n检验大家C语言学的好不好的两个最重要的指标，一是指针，二是内存管理。\n基本上中国大学的计算机专业都会把C++当作第一门语言课，C++相对其它语言来说，入门上手会相对比较难，可能会打消掉一部分同学的积极性。但是C++又是一门可以进行类比的语言，C++学习到一定程度后，学习其他语言也会变得非常容易。(关于这个观点存在一些争议，如果确实对C++并不看好，可以从java开始，不必要非得学习C++)\n学任何东西其实都有一个学习曲线，只要沉下心去学，多花点时间，总会跨过那个曲线，后面学习过程就会变得很平滑。学C++也类似，不要知难而退，而是要迎难而上，翻过大山也许就能看到彩虹。\n入门书籍：\nThe C++ Programming Language (Bjarne Stroustrup)\nC++之父的经典之作，无论如何也应该读个四五遍！这是一切C++的书本的源泉。推荐英文版，如果英文不好再看中文版，此书由浅入深，知识全面，代码具有代表性。如果把书上的代码都上机打一遍，C++绝对入门了。\n进阶阶段1：\nEssential C++ C++ Primer Plus C++ Primer 后两本书都可以精读，其中第二本虽然比第三本多一个Plus，但其实第二本书更加基础一些，涵盖的内容也没有第三本广泛。C++ Primer的体量非常巨大，故此一定要品味第二、三本。可以先从*Essential C++*开始，它将四个C++的范型都讲了，而且讲得非常清楚。当然，也有一部分人一直认为C++Primer带着太过强烈的C的痕迹，对于学习C++未必是好事。读者需要先读这本巨著，然后再作判断。\n进阶阶段2：\nThinking in C++ (Bruce Eckel著、候捷译)\n这本书每过半年建议重读一遍。可以说每一章都是写得发人深省的，这本书可以让人感受到技术运用的高超境界，语言非常平实，只要认真地读，即使基础不行，也一定可以懂。\nEffective C++\nMore Effective C++\n要更上一层的话，就要慢一步，先要把握C++设计习惯的良好。这是Scott Meyers的*Effective C++和More Effective C++*带给我们的无尽收益。这两本书是真正的经典，作者对C++的纯熟，使得语言的风格非常具有魅力，虽然C++本身并不十分有趣，但书读起来却甘之如饴，就像他站在对面在讲课。\n如果你已经深刻地理解了Effective C++和More EffectiveC++，那你可以发现，你在众人中已经是鸡群之鹤。可以指导项目运作了，可以编写一切你想做的程序了，可以指出别人看起来不错的代码的大小问题了。如果你能一眼看出有人的代码是对应于\u0026quot;条款27\u0026quot;或\u0026quot;条款M6\u0026quot;，那你可真是令人刮目了。\n高级阶段：\nExceptional C++\nMore Exceptional C++\n如果要写程序，*EC++和MEC++*的境界已经足以使你自如应付，可是如果你还不满足，想关注一些理论层面的问题，或是想看看实现的代码，你就不应该错过上面这两本好极了的书。(由Herb Sutter所著)\n这两本书的难度是非常大的。每一条的阅读笔记都应该有十多页。特别是泛型程序设计的部分，这两本书旁征博引，极尽深入探讨之能事，每每看懂一条，都该大感酣畅淋漓，每每学到一点，都值得浮一大白。\n《STL源码剖析》(侯捷著)\n它是以实际的例子一点点地讲解一个STL是怎么样实现的。\nInside the C++ Object Model\n从这本书中可以了解无数的编译器解释源代码的细节，以及记忆体分配的细节。\nC++沉思录\n经典之作，语言是苍白无力的，必须读一遍，呃不，读无数遍，深刻体会。\n补充：\n如果还觉得不够的话，就订购一本C++标准，但是仅作为参考工具书使用。\n中国大陆作者的书，尽量不要看。一切VC++或讲特定的编译器的书，一概不要看。\n这里要特别提一句伟大的谭先生、谭教授THQ编写的巨著，书名就不叙述了；业内人士将其称之为谭++；我计划专门整理一篇博客，细数一下伟大的谭先生为我国C++教学事业所作的杰出贡献。另外，我要正告各位读者，如果不是为了计算机二级考试，千万不要购买谭++，入邪教而恍然不知，悔时晚矣！\n如果需要补C语言的课，买一本非常小的K\u0026amp;R的The C Programming Language足矣，其它的书一概不要看。不要先学C，再学C++，而要直接学C++。你不是先学古文，再学白话的，对不对？相信我，直接来更容易。\n其他的书：\nAccelerated C++ 从各方面评价来看，完全值得推荐。 《C++ Templates全览》 (STL参考) 《C++设计新思维：泛型编程与设计模式之应用》 (STL参考) 《C++标准程序库：自修教程与参考手册》 (STL参考) 《C++网络编程》(卷1，卷2) (网络参考) 《C和指针》 深入了解指针，看完以后对指针不再害怕。 《C陷阱和缺陷》 看完后可以避免C语言开发的一些坑。 《C专家编程》 Java 如果是真真正正完全0基础入门编程的话，其实Java作为入门语言是非常合适的。\n虽然Go，Kotlin等目前比较火的动态语言对Java这种静态语言造成了一定的威胁，但是短期内其冲击远远不会到影响Java的程度。Java依旧是当今当之无愧的第一就业语言，绝大部分互联网企业都选择Java作为它们的开发语言。\n信息化系统的建设(各种各样的业务系统，及互联网服务等)，其主流的驱动技术就是Java，而其他语言，例如PHP是呈下降状态，而Go语言目前的份额也并不大；另外一点就是Java目前的业务需求是比其他语言要大得多的。\n从难度上讲，Java相比c＋＋是真的容易很多。\n有人推荐Python，至少在中国目前这个纯就业的环境下，学Python去找个工作简直要发狂，不要相信培训公司吹的那样，搞Python不走人工智能是很难的 ，而AI，机器学习，算法这些现在的趋势都是研究生起步，学历这方面相当重要，这些东西不是经过努力学点程序就行的，更何况，有些技术不是想学就能学会的——就像有些人这辈子注定无法获得诺贝尔奖一样，现实是很残酷的……\n当然，不可否认的是，Python语言编写的脚本在某些方面确实给日常生活带来了便利，就这一点来说，它的易用性其实是非常优秀的，我认为Python是一门非常有价值的编程语言。虽然就现实来说，在就业方面可能并不是那么理想。换言之，只有优秀的Python编程者才有机会。\n入门书籍：\nHead First Java 《疯狂Java讲义》 《Java核心技术 卷I\u0026amp;II》 我没有把《Java核心技术》排在第一位的原因是：这本书的治学精神是非常值得学习的，但是入门Java并不需要在Java SE里那些不常用的技术上浪费时间，而初学者又不知道如何鉴别哪些需要学习，哪些不需要学习，基于这个原因，我个人建议先看前两本书。\n进阶书籍：\n《Java编程思想》 Effective Java 《Java并发编程实战》 《深入理解Java虚拟机》 《编程思想》书是Java界极其经典的圣经书籍，地位相当于Java界的辞海。里面相当多的内容是非常非常值得学习的。如果错过了这本书，那么Java的学习只能用遗憾来形容。\nEffective Java 作为技术人员的参考用书。介绍了在 Java 编程中 7到8 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。\n《并发编程》则具备企业级开发里常用的知识，多线程/多进程的精髓就在于此。当然，这本书的难度也更大一些。\n《Java虚拟机》虽然基于OPEN JDK1.7，但是其中的Java编程思想永不过时！不论是对于现在的Oracle JDK12，还是以前的版本，对原理的理解是没有影响的。\n拓展书籍：\n《函数式编程思维》 《TCP/IP 详解》 《函数式》这本书对于提高代码的信噪比是非常有帮助的，当然，可能在日后的重构方面会存在一些困难。《TCP/IP》书则是为了帮助进行Java网络编程，该书在之前的计算机网络处已经叙述过了，这里不再赘述。\n信噪比，也就是信号噪声比，在此处意思是说用少量的代码得到更高的运行效率。\n补充书籍（并发系列）\n《Java并发编程艺术》 同样是讲Java并发编程的。Java并发编程实战相对来说全是干货，看起来可能比较晦涩。这本书可能看起来更通熟易懂些，但是没有Java并发编程实战全面，大家可以搭配着读。\n补充书籍（Android系列）\n《第一行代码 Android》 Android开发入门书籍。 Android开发是基于Java的。\n《Android 开发艺术探索》 这本书强烈推荐。是从Android初级向中高级进阶的必看书籍，里面讲的知识点都很好。重要的是Android面试会问到很多这本书里面的知识点，找Android开发必看。\n《Android 系统源码代码情景分析》 从源码分析Android系统的书，经典程度不亚于上本。\n补充书籍（Java Web和Spring模块）\n《深入Java Web技术内幕》 从Android向后台转型过程中看的一本书。比较全面的介绍了Java Web知识，可以当作Java Web的入门辅助书籍。\n《Spring in action 中文版》 学习Spring时候看的书，主要介绍了官方文档的知识。讲的很全面，准确度也高。\n《Spring MVC学习指南》\n《Maven实战》\nJava Web离不开Maven，这本是Maven入门书籍，讲的很全面。\n《Spring实战》 \u0026amp; 《Spring Boot实战》\n※《Spring技术内幕》 建议精读。\nPython 入门书籍：\nPython cookbook 该书被多平台，多位大神联合推荐，毫无疑问，这是一本很不错的书籍。但有人会考虑，这本书适合入门吗？回答是肯定的。当然，这本书比着有些\u0026quot;入门书籍\u0026quot;要稍微深一些，这正是推荐这本书而不推荐其他书籍的原因：《Python Cookbook》和其他入门书籍、教程一样，都是在围绕数据结构、基本概念在展开，但是它对比于其他教程\u0026quot;蜻蜓点水\u0026quot;式的阐述，这本书做了更多延伸，讲解了更多高阶用法，我觉得高阶用法你不一定要记住，但是知道有这么一回事，对后期进阶、实战会有很多帮助。\n除此之外，还有以下Python入门书籍可供选择：\n《Python编程：从入门到实践》 《Python编程快速上手》 《像计算机科学家一样思考Python》 《Python基础教程 第2版》 《笨办法学Python 3》 《流畅的Python》 《流畅的Python》致力于帮助Python开发人员挖掘这门语言及相关程序库的优秀特性，避免重复劳动，同时写出简洁、流畅、易读、易维护，并且具有地道Python风格的代码。尤其深入探讨了Python语言的高级用法，涵盖数据结构、Python风格的对象、并行与并发，以及元编程等不同的方面，适合精读。\n进阶练习和书籍：\nPython练习册，每天一个小程序 这是GitHub上超1W Star的项目。\nPython项目练习 包括十个项目的练习和代码\n500 line or less 一本Python神书，而且还有源码。\nPython - 100天从新手到大师 骆昊 (jackfrued) 规划的一条从“从新手到大师”的百天之路。\nPython for Data Analysis\n高级阶段：\n选择一个学习的方向：\n机器学习 图像处理 自然语言 数据分析 web \u0026hellip;\u0026hellip; 选择一个学习的方向，然后才清楚自己该朝着哪个方向努力、该拿哪些项目练手，对编程能力进一步巩固，这样要比“无头苍蝇”式的漫无目的学习效率要高很多。\n然后，可以找一些比较优秀的项目进行实战，扩展自己知识面的同时对编程能力进行巩固。\n以下是三个可供参考的学习链接：\ntensorflow_cookbook\nAwesome-pytorch-list\nWebAPP\nGo和SQL Go书籍推荐：《Go语言实战》\u0026amp;《Go In Action》\nSQL书籍推荐：\n《MySQL必知必会》\n※《数据库系统概念》第六版\n《深入浅出MySQL》\n注：《MySQL必知必会》虽然在语法上看起来是《SQL必知必会》的子集，但是实际上其内容更加全面，更加精细。\n数据结构与算法 学习算法，不要一上来就开始啃《算法导论》，这本书有太多关于算法的数学证明（除非你喜欢这种风格，那么你就看这本）。既然这本书并不适合新手学习，而如果你之前的算法基础又比较薄弱，那么只会一直陷在“拿起来又放下”的循环里。\n入门书籍：\n《算法图解》：“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂 《大话数据结构》：把理论讲得有趣不枯燥；每个数据结构和算法，作者都结合了生活中的例子，能让你有非常直观的感受。 标准教材：\n《数据结构与算法分析》 非常系统、全面、严谨，适合掌握了至少一门编程语言的同学。\n这本书有三个语言的版本：C语言描述，C++语言描述和Java语言描述\n进阶书籍：\n※《算法 第4版》 ※《算法导论》 这两本书都是经典，建议细细品味。\n拓展书籍：\n《算法之美》 算法科普，从生活中的各种问题说起：租房、谈恋爱、老虎机、拍电影、面试、买彩票、各种排序、找停车位、寻找新药、临床试验、奥巴马拉赞助、预估电影票房等等，非常生活化，可以作为补充阅读。 《算法帝国》 同样是科普类书籍，并无涉及算法的原理与实现细节，也可以作为补充阅读。 殿堂级书籍：\n※ The Art of Computer Programming 《计算机程序设计艺术》 包含共四大卷，其深度、广度、系统性、全面性是其他所有数据结构和算法书籍都无法相比的。该书建议慢慢阅读，可以当做一种挑战！\n其他书籍：\n《算法设计与分析基础》 《算法引论：一种创造性方法》 《编程原本》 《算法竞赛入门经典》 《算法艺术与信息学竞赛》 设计模式与架构 轻量级书籍推荐：\n《大话设计模式》\n《设计模式》 （刘伟著）\n可以读此书配套的《设计模式实训教程》。还有《C#设计模式》和《 设计模式的艺术——软件开发人员内功修炼之道 》，后者贴近于工程实践方面的应用。另外风格相近的还有 《设计模式之禅》与《研磨设计模式》 可以作为进阶。\n《Head First 设计模式》\n重量级书籍推荐(以下神书排名不分先后)：\nRefactoring 《重构——改善既有代码的设计》\nCode Complete 2 《代码大全2》\nThe Pragmatic Programmer 《程序员修炼之道》\nClean Code 《代码整洁之道——程序员的职业素养》\nProgramming Pearls (2nd Edition) 《编程珠玑》\nDesign Patterns 《设计模式：可复用面向对象软件的基础》\nThe Mythical Man-Month 《人月神话》\nWorking Effectively with Legacy Code 《修改代码的艺术》\n结语 本文从立意到结尾历时2天，撰写时间逾10个小时，参考和借鉴了80多位从事计算机及编程行业的工作者和爱好者在知乎的回答和在B站的视频推荐。\n原先，我本意是想简略的列一份计算机需要读的书单，但我整理的目的是想让自己按照规划的这条路线走下去，因此在整理的过程中，我花了相当多的精力考察每一本书，包括它的目录，它涉及的内容以及它的编写目的及作用。最终，在给每一本书赋予一个特定的地位的时候，我都附注了自己或者他人的理解和感悟。不同的人对同一本书的看法肯定是不同的，所以并不是说所阅读的书局限于上述书单里。书单的意义 ，是给我自己规划的一条计算机从入门到略有体会的道路。\n希望我整理的内容能够帮助各位有志于提高自己水平的青年学者；无论你之前是否接触过编程。国外的名著之所以比国内的教科书更加具有价值和历史意义，就是因为它们是给人看的，看书的过程也就是对话、沟通、交流、理解的过程。名著是兼容的，无论水平高低，读者都能在其中获取到知识；我希望我自己也能始终坚持谦虚好学的态度，不搞鄙视链，向各类人士兼容。\n真正的大师，永远都怀着一颗学徒的心。\n","permalink":"https://endlesspeak.github.io/posts/tattle/the-brief-talk-of-computer-and-programming/","tags":["Programming"],"title":"浅谈计算机\u0026编程发展路线——自顶向下脱发方法"},{"authors":["Serene Feather Pavilion"],"categories":["杂谈"],"content":"时光，匆匆，像是天空中，自由变幻的一缕缕云烟；人生，短暂，像是电影剪辑里的一帧帧片段。\n简单的事物，总是比想象中更美一些，而博客的作用，大抵就是记录下这些瞬间。多年之后，再点开博客，饱含着记忆的旧时光如同投入镜湖中的石子，在脑海中荡漾起一圈圈的涟漪；又仿佛清晨的微风，扑面而来，令人心旷神怡。\n1 数一数，离2019年结束只剩下三天了。最近时不时的总会感叹：这一年过得飞快，时间都到哪去了？\n我知道，倘若这个问题让每一个人都来回答，肯定有人会感慨这一年都没干什么，浑浑噩噩的，就像混过来似的。\n再往前想，一年又一年，仿佛都是时间黑洞，前年、大前年也都没干什么，过往就是在不断轮回。 想完了，沮丧，焦虑，负面情绪也就都上来了。\n其实，没有平庸的字，只有平庸的文字；同样的，没有平庸的人，只有平庸的人生。\n难道，这一年就没干什么大事吗？不一定是那种折腾出很大规模的，给学校或给社会折腾出的，而是对自己有点成长意义的事？\n有一两件大事能立住也好，还能安慰一下自己这一年没白过；也许确实这一年确实无所作为，没去做的想破了脑袋也想不出，这只能怪自己了。\n但也可能做了一些事，大脑和记忆却欺骗了自己。\n我们的大脑在思考上有巨大的潜力，在记忆上却并不可靠，大事之外的事都会被它给忽略掉。不建立在可靠的基础上，只能得出不可靠的结论。如果你有可靠的记录，那么你在年底就不会这么悲伤。\n2 苏格拉底说，“未经审视的人生不值得过。”\n人是很容易陷入到浑浑噩噩，跟着情绪和冲动走的状态中，随波逐流，没有自己的主线和方向。\n其实，写博客就是不断审视人生方向的好办法。\n虽然不写博客也不会坏到哪儿去。但是，每天写一篇博客，翻翻这一年，日拱一卒，每天进步一点点，记录下来，这一年有满满的收获。有了这个，就能客观地看待自己。\n很多人发微博、发朋友圈，把它们看作是对生活的记录。然而，给外人看的终究不同于写给自己看的，缺点、教训、人性黑暗面，只能自己去直面。\n在社交媒体上前台表演美化，并不能像后台自我剖析再缝上伤口那样有实效。\n上学时，我们都被老师要求写过日记，但无一例外留下的是害怕写作文的阴影。过去的教育就是这么失败，好心办坏事，让人们得出个日记没用的结论。\n记录的力量其实很强大: 任何问题的解决，都是要先了解情况和症结所在，无论对象是时间、精力、财务还是你每日的生活和成长。时间管理，要求记录时间的去向，你才会知道每天刷手机花费了多少宝贵时间。理财，要求你去记账，你才知道不该花的娱乐消费原来有那么多，投资在自己成长上的花销却少得可怜。而你的成长，每天的日子，记录再看过，自我管理会不断改进迭代。这些记录都需要一些时间的积累，否则仅凭模糊的印象是得不出正确结论的。\n博客，它像一个自我印证。我写下的，为了它更好看，我就会做得更好，然后我的记录就会更好，形成一个正向循环。\n3 我记简单的日记，一旦有两三天忘写了就会搞不清哪个是哪天的事。昨天和前天颠倒顺序，也没有任何不便。我不时想，这叫什么人生啊!但也没有因此感觉光阴虚度。我仅仅是感到惊讶，惊讶于昨天与前天毫无区别，惊讶于自己被编排入这样的人生，惊讶于自己留下的足迹甚至还未及认清，就在转瞬间被风吹走变得无影无踪。 \u0026ndash;村上春树《眠》\n以前看到一位前辈的文章，说技术博客就是用来记录自己技术的成长历程，每天的记录形成了习惯，技术也就点点滴滴的积累起来了。\n我很赞成这个观点，作为一名计算机专业的学生，自身技术的提高是很值得高兴的。但是，我认为，技术博客未必非得全是技术，程序员们也是人，也有感情，在博客里面记录自己的心情与故事，即是记录自己的人生。\n在心情里面，写写自己的生活，自己的情感，自己的学习计划。这并不是为了给别人看，这些文字，静静地躺着那里，它们是留给自己以后的感慨，留给自己的回忆。\n其实人的一生很短暂，只有三万多天。我时常在思考一个问题，当我临终前，回首我这一生，我究竟是活了三万多天，还是仅仅只是把一天活了三万多次？\n4 有人说：无知是人的内禀性质。\n所以，生活的索然无味是因为觉得自己没有价值并且不能创造价值。 能够创造价值，比当下具有价值更重要。\n一旦发现自己其实还能创造价值，生活就会有趣起来。\n生活的索然无味是否是源自于自己的无知？\n我认为是的。\n生活像钟摆一样，要么无聊，要么痛苦。当人们对外在世界发生的琐碎事情表现出不停的关注时，他们内心的空虚状态也就会暴露。\n正如叔本华所说，内心空虚的人会为了追求刺激，而不断地用社交、娱乐方式等无谓的东西来充斥大脑。为了打发时间，他们会饥不择食地追求五花八门、毫无意义的消遣，结果自然是以痛苦告终。\n而要让生活丰富有趣，只能依靠内在的力量，亦即精神的财富。这时，快乐不依赖于外在的刺激，而来自于自我创造与发现。只有有活力的思想才不会枯竭，才能从内心和大自然不断探索到新事物。\n因此，唯有拥有充盈的内心，才能有发现乐趣的能力，生活才能过得有滋有味。故而，“性情乐观、体格健康、充满活力、温文尔雅、有良知、有能够洞察事物本质的能力”正是让生活丰富有趣的好办法。\n真巧，不断丰富自己的思想，不断充盈自己的内心，不断洞察事物的本质，这也正是博客建立最本源的意义。\n5 每一次阅读自己的博客，就像是一场久别的重逢，一个人，一句话，一段故事，一个微小的进步，值得一生去回忆。\n撰写自己的博客，能够提醒自己，时刻为自己的目标而努力，全身心投入一件事情的时候，就不再整天想睡懒觉，不再熬夜看偶像，也不用刻意去想怎样好好生活，删掉那些原以为离不开的东西，其实，这才是生活原本的样子。\n人生无常，世事难料，难的是不为艰难困苦而却步，不为鲜花掌声而迷失；高山无语，深水无波，难的是心灵淡然若水，让人生如行云流水一般轻盈飘逸。\n于是，忽然之间，我自心底涌起强烈的渴望，而且前所未有：我要学会生活，把眼前的一世当作一百世一样。这其中的道理浅显易懂：我思故我在，既然我存在，就不能装作不存在。无论如何，我要为自己负起责任。\n这便是我最初的观点：撰写博客，就是记录人生。生活是一条道路，一段历程，更是一种态度。淡泊，醒悟，超脱；有所不为然后有所为，特立独行而非趋炎附势，稳重坚韧而不浮华躁动，义无反顾而举重若轻——这才是真真正正的人生。\n6 三个月前，我曾经创建过一个博客，兴致勃勃而又踌躇满志，可惜后来博客和相当一部分代码文件随着一次课程设计中程序调试的意外而被电脑“遗忘”在了硬盘中，并随着硬盘的读写而消失在“历史”的长河里。\n如今我重整旗鼓，在这即将结束的2019的末尾，我为新博客立序，希望新博客能够和我一起，度过我最宝贵的青年时光。\n冬天早已悄然而至，紧接着是腊八和小寒。\n我在这逐渐刺骨的寒风中,等待一场雪来。\n大雪的时候，每一朵雪花都是那么安静，心中涌上对自然的敬畏的同时，觉得可以看雪的季节是如此的美好。\n在那些被喧闹掩埋的角落里，雪花就像是给生命留的独白，它简单明了而又快乐安然，留一些素色的烟火沉积过往，踽踽独行。\n一场雪，就是一片心境。心若简单，一切都很简单。\n大道至简，知易行难；繁在人心，简在我心。\n是为新博客的Hello World.\n","permalink":"https://endlesspeak.github.io/posts/tattle/2020-helloworld-from-blogs-to-life/","tags":["随笔","Blog"],"title":"Hello World——从写博客到记录人生"},{"authors":[],"categories":[],"content":"","permalink":"https://endlesspeak.github.io/docs/docs/cpp-programming/3-interview-doc/3-pointer/","tags":[],"title":""},{"authors":[],"categories":[],"content":"","permalink":"https://endlesspeak.github.io/docs/docs/slam-doc/slam-related/6-camera/","tags":[],"title":""}]