<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux技术基础-3-2 Arch Linux物理机的安装、引导与配置</title>
    <url>/LinuxNotes/2020/01/Linux%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80-3-2%20Arch%20Linux%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%BC%95%E5%AF%BC%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Arch Linux 是通用 x86-64 GNU/Linux 发行版，初始安装仅提供命令行环境：用户不需要删除大量不需要的软件包，而是可以从<strong>官方软件仓库</strong>成千上万的高质量软件包中进行选择，搭建自己的系统。支持x86-64架构。Arch采用滚动升级模式，尽全力提供最新的稳定版软件。Arch 之道，或者叫Arch哲学，一言以蔽之，Keep It Simple, Stupid.(保持简单，一目了然)</p>
<p>简洁：Arch Linux 将简洁定义为：<strong>避免任何不必要的添加、修改和复杂增加</strong>。它提供的软件都来自原始开发者(上游)，仅进行和发行版(下游)相关的最小修改。</p>
<p>现代：Arch尽全力保持软件处于最新的稳定版本，只要不出现系统软件包破损，都尽量用最新版本。</p>
<p>实用：Arch 注重实用性，避免意识形态之争。</p>
<p>以用户为中心：许多 Linux 发行版都试图变得更“用户友好”，Arch Linux 则一直是，且永远会是“以用户为中心”。Arch是为了满足贡献者的需求，而不是为了吸引尽可能多的用户。</p>
<a id="more"></a>

<p>本文拟以<a href="https://wiki.archlinux.org/" target="_blank" rel="noopener">Arch Wiki</a>与<a href="https://wiki.archlinux.org/index.php/installation_guide" target="_blank" rel="noopener">Installation guide</a>为原本，附带一些自己的理解，尝试说明在物理机上安装Arch Linux。</p>
<p>一般来说，安装Arch最好的也是最完备的教程就是官方的<a href="https://wiki.archlinux.org/index.php/installation_guide" target="_blank" rel="noopener">Installation guide</a>与<a href="https://wiki.archlinux.org/" target="_blank" rel="noopener">Arch Wiki</a>，虽然部分内容有中文版，但是中文的翻译有些时候会落后于英文版，所以不推荐完全依赖于中文Wiki。另外， 官方Wiki的写作方式更偏向于文档，没有我们所习惯的按步骤编排的安装过程，给不熟悉这种写作方式的人们造成了阅读与使用上的困难。 </p>
<h2 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h2><h3 id="硬盘空间"><a href="#硬盘空间" class="headerlink" title="硬盘空间"></a>硬盘空间</h3><p>检查硬盘，需要有一块空闲的磁盘空间来进行安装，大小在30GiB以上。</p>
<h3 id="安装介质"><a href="#安装介质" class="headerlink" title="安装介质"></a>安装介质</h3><p>安装之前需要准备安装介质，这里推荐U盘作为安装介质。对于Arch Linux来说，不能使用UltraISO (软碟通)制作U盘启动盘。因为软碟通制作启动盘使用的是ISO镜像，而Arch Linux制作启动盘需要<strong>DD镜像</strong>。</p>
<ol>
<li><p>安装镜像的官方下载地址可参阅<a href="https://www.archlinux.org/download/" target="_blank" rel="noopener">下载页</a></p>
</li>
<li><p>Windows系统下制作安装介质，推荐使用<code>usbwrite</code>，参阅<a href="https://sourceforge.net/projects/usbwriter/" target="_blank" rel="noopener">下载页</a>。</p>
</li>
<li><p>Linux系统下制作安装介质，要使用<code>dd</code>命令制作，可参阅<a href="http://www.runoob.com/linux/linux-comm-dd.html" target="_blank" rel="noopener">教程</a> </p>
</li>
</ol>
<h3 id="启动Live环境"><a href="#启动Live环境" class="headerlink" title="启动Live环境"></a>启动Live环境</h3><p>选择U盘启动的顺序(参阅上一篇博客)，在出现Arch Linux启动界面后选择Boot Arch Linux。</p>
<p>然后将会以 root 身份登录进入虚拟控制台，默认的shell是zsh。</p>
<h3 id="检查引导方式"><a href="#检查引导方式" class="headerlink" title="检查引导方式"></a>检查引导方式</h3><p>目前的引导方式主要分为EFI引导+GPT分区表与BIOS(LEGACY)引导+MBR分区表两种。具体可参见上一篇博客中关于引导的内容。</p>
<p>在终端中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ls &#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars</span></pre></td></tr></table></figure>

<blockquote>
<p>注：Arch Linux Live环境默认集成了类似bash- completion的软件包，在输入命令的时候<strong>Tab键</strong>可以对命令进行自动补全。</p>
<p>方法：键入命令或文件名的前几个字符，然后按<strong>Tab键</strong>，它会自动补全命令或显示匹配你键入字符的所有命令，此时为终端提供你所需命令的更多信息并按Tab键可使得终端识别你所需要的命令。</p>
<p>其他提示：</p>
<ol>
<li><p>方向键↑(或Ctrl+p) 显示上一条命令</p>
</li>
<li><p>方向键↓(或Ctrl+n) 显示下一条命令</p>
</li>
<li><p>Ctrl+C: 终止当前正在执行的命令</p>
</li>
</ol>
</blockquote>
<p> 输入命令并回车执行后，如果提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls: cannot access &#39;&#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars&#39;: No such file or directory</span></pre></td></tr></table></figure>

<p>则表明你是以<code>BIOS</code>方式引导，否则为以<code>EFI</code>方式引导。 </p>
<p>当然，这种方法不能100%确认是<code>BIOS</code>还是<code>EFI</code>方式引导的，更加保险的方法是执行<code>fdisk -l</code>查看分区表，如果<strong>你的硬盘</strong>(将以 <code>rom</code>，<code>loop</code> 或者 <code>airoot</code> 结束的结果忽略掉)的<code>Disklabel type</code>属性为<code>gpt</code>并且有一个<code>Type</code>为<code>EFI System</code>的分区（一般为256M左右），那么你应该是<code>EFI</code>引导的。 </p>
<h3 id="改变显示字体"><a href="#改变显示字体" class="headerlink" title="改变显示字体"></a>改变显示字体</h3><p>所有的字体都安装在/usr/share/kbd/consolefonts/下，在输入到此处时按Tab查看所有可选字体，然后选择你喜欢的字体。此处选择的是<strong>LatGrkCyr-12x22.psfu.gz</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># setfont &#x2F;usr&#x2F;share&#x2F;kbd&#x2F;consolefonts&#x2F;LatGrkCyr-12x22.psfu.gz</span></pre></td></tr></table></figure>

<h3 id="改变键盘布局"><a href="#改变键盘布局" class="headerlink" title="改变键盘布局"></a>改变键盘布局</h3><p>如果键盘布局不是普通的布局，例如是colemak布局等，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># loadkeys colemak</span></pre></td></tr></table></figure>

<p>当然，一般使用的键盘都是通用105键(国际)，不必更改。</p>
<h3 id="连接网络环境"><a href="#连接网络环境" class="headerlink" title="连接网络环境"></a>连接网络环境</h3><p>Arch Linux并不能离线安装，它需要联网来下载需要的组件，所以此时需要连接网络。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ip link #查看网络设备</span></pre></td></tr></table></figure>
<p>对笔记本电脑来说网络设备一般有三种，名称分别应该类似于lo,wlan0,eth0。查看网络连接可以参阅<a href="https://wiki.archlinux.org/index.php/Network_configuration_(简体中文)" target="_blank" rel="noopener">Network configuration (简体中文)</a></p>
<ol>
<li>lo是本地环回；</li>
<li>wlan0是无线网络，参阅<a href="https://wiki.archlinux.org/index.php/Wireless_network_configuration_(简体中文)" target="_blank" rel="noopener">Wireless network configuration(简体中文)</a> </li>
<li>eth0是有线网络，参阅<a href="https://wiki.archlinux.org/index.php/Network_configuration/Ethernet" target="_blank" rel="noopener">Ethernet</a> </li>
</ol>
<p>Arch Linux在网络工具上已经弃用了<strong>net-tools</strong>转而使用<strong>iproute2</strong>.详细命令变化如下：</p>
<style>
table th:first-of-type { width: 100px; }
table th:nth-of-type(2){ width: 400px; }
</style>

<table>
<thead>
<tr>
<th align="left">已弃用的命令</th>
<th align="left">替换命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">arp</td>
<td align="left">ip neighbor</td>
</tr>
<tr>
<td align="left"><a href="https://zh.wikipedia.org/wiki/Ifconfig" target="_blank" rel="noopener">ifconfig</a></td>
<td align="left">ip address, ip link</td>
</tr>
<tr>
<td align="left">netstat</td>
<td align="left"><a href="https://wiki.archlinux.org/index.php/Network_configuration_(简体中文)#Investigate_sockets" target="_blank" rel="noopener">ss</a>[<a href="https://wiki.archlinux.org/index.php/ArchWiki:Requests#Broken_section_links" target="_blank" rel="noopener">broken link</a>: invalid section]</td>
</tr>
<tr>
<td align="left">route</td>
<td align="left">ip route</td>
</tr>
</tbody></table>
<p>更多更完整的总结，请参阅<a href="https://dougvitale.wordpress.com/2011/12/21/deprecated-linux-networking-commands-and-their-replacements/" target="_blank" rel="noopener">这篇文章</a>。 </p>
<p>使用下面的命令连接有线网络并测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ip link ether0 up</span></pre></td></tr><tr><td class="code"><pre><span class="line"># dhcpcd &#x2F;&#x2F;动态分配IP地址</span></pre></td></tr><tr><td class="code"><pre><span class="line"># ping www.baidu.com &#x2F;&#x2F;使用ctrl+c结束Ping</span></pre></td></tr></table></figure>

<p>依次使用下列命令连接无线网络并测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ip link wlan0 up &#x2F;&#x2F;打开WiFi，注意将wlan0替换为电脑上的无线设备ID名称</span></pre></td></tr><tr><td class="code"><pre><span class="line"># iwlist wlan0 scan | grep ESSID &#x2F;&#x2F;扫描WiFi，仅查看各WiFi的名称</span></pre></td></tr></table></figure>
<blockquote>
<p>注：连接wifi可以用WiFimenu，但是WiFimenu一般不支持企业网络和校园网络协议。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wpa_passphrase 网络 密码 &gt; 文件名(如internet.conf)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># wpa_supplicant -c internet.conf -i wlan0 &amp; &#x2F;&#x2F;注：&quot;&amp;&quot;表示后台运行</span></pre></td></tr><tr><td class="code"><pre><span class="line"># dhcpcd &#x2F;&#x2F;动态分配IP地址</span></pre></td></tr><tr><td class="code"><pre><span class="line"># ping www.baidu.com</span></pre></td></tr></table></figure>

<p>出现类似<code>64 bytes from...</code>的内容说明成功连接网络，此时使用使用ctrl+c结束Ping命令。</p>
<h3 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h3><p>使用 timedatectl命令 确保系统时间是准确的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># timedatectl set-ntp true</span></pre></td></tr></table></figure>

<p>正常情况下这样的命令并没有输出，所谓没有消息就是最好的消息。</p>
<h3 id="建立硬盘分区"><a href="#建立硬盘分区" class="headerlink" title="建立硬盘分区"></a>建立硬盘分区</h3><p>系统识别磁盘后将其分配为一个块设备，固态硬盘<code>/dev/nvme0n1</code>,机械硬盘<code>/dev/sda</code>。输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fdisk -l</span></pre></td></tr></table></figure>

<p>将返回的结果中以 <code>rom</code>，<code>loop</code> 或者 <code>airoot</code> 结束的<strong>忽略掉，它们非硬盘设备</strong>。 </p>
<hr>
<ul>
<li>如果你是BIOS/MBR方式引导，<strong>跳过创建引导分区</strong>的步骤。</li>
<li>如果你是EFI/GPT方式引导，并且同时安装了其他系统，那么你应该可以在分区列表中发现一个较小的并且类型为EFI的分区，这是你的引导分区，请记下它的路径（/dev/sdxY)备用，<strong>跳过创建引导分区</strong>的步骤。</li>
<li>如果你是EFI/GPT方式引导，但是没有这个较小的并且类型为EFI的引导分区（这种情况一般只会出现在新电脑+新硬盘时），那么需要<strong>先创建一个引导分区</strong>。</li>
</ul>
<hr>
<h4 id="创建引导分区"><a href="#创建引导分区" class="headerlink" title="创建引导分区"></a>创建引导分区</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;sda (如果是机械硬盘，则将sda替换成之前输出的磁盘ID如sda,sdb,sdc等)</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;nvme0n1 (如果有固态硬盘，则将nvme0n1替换成之前输出的固态硬盘ID)</span></pre></td></tr></table></figure>

<p>下面进入了<code>fdisk</code>的操作环境， 输入<code>m</code>并回车可以查看各命令的作用。</p>
<ol>
<li><p><strong>如果你是一块全新的硬盘</strong>：输入<code>g</code>来创建一个全新的gpt分区表，<strong>否则直接进行第2步</strong>。</p>
</li>
<li><p>输入<code>n</code>创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，这里我们输入<code>+512M</code>来创建一个512M的引导分区。</p>
</li>
<li><p>这时我们可以输入<code>p</code>来查看新创建的分区。</p>
</li>
<li><p>输入<code>t</code>并选择新创建的分区序号来更改分区的类型，输入<code>l</code>可以查看所有支持的类型，输入<code>ef</code>更改分区的类型为<code>EFI</code>。</p>
</li>
<li><p>输入<code>w</code>来将之前所有的操作写入磁盘生效，在这之前可以输入<code>p</code>来确认自己的分区表没有错误。</p>
</li>
<li><p>输入以下命令来格式化刚刚创建的引导分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 &#x2F;dev&#x2F;sdxY (机械硬盘执行该命令并将sdxY替换为刚创建的分区)</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F32 &#x2F;dev&#x2F;nvme0n1p1 (固态硬盘执行该命令并将nvme0n1p1替换为刚创建的分区)</span></pre></td></tr></table></figure>

</li>
</ol>
<p>现在引导分区就创建好了。</p>
<h4 id="创建根分区"><a href="#创建根分区" class="headerlink" title="创建根分区"></a>创建根分区</h4><p>输入下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;sdx (如果要将Linux安装在机械硬盘中则将sdx替换成你要操作的磁盘如sdb sdc等)</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;nvme0n1 (如果要将Linux安装在固态硬盘中则将其替换为之前输出的固态硬盘ID)</span></pre></td></tr></table></figure>

<ol>
<li><p><strong>如果是一块全新的硬盘</strong>（<strong>否则直接进行第2步</strong>）：</p>
<ol>
<li><strong>如果你是<code>BIOS/MBR</code>引导方式</strong>：输入<code>o</code>来创建一个全新的<code>MBR</code>分区表。</li>
<li><strong>如果你在上一步新建了分区表并创建了引导分区</strong>：直接进行步骤2。</li>
<li><strong>如果你在另一块硬盘中已经有引导分区</strong>：输入<code>g</code>来创建一个全新的<code>gpt</code>分区表。</li>
</ol>
</li>
<li><p>输入<code>n</code>创建一个新的分区，首先会让你选择起始扇区，一般直接回车使用默认数值即可，然后可以输入结束扇区或是分区大小，如果我们想要使创建的分区完全占满空闲的空间，可以直接回车使用默认结束扇区。</p>
</li>
<li><p>这时我们可以输入<code>p</code>来查看新创建的分区。</p>
</li>
<li><p>输入<code>w</code>来将之前所有的操作写入磁盘生效，在这之前可以输入<code>p</code>来确认自己的分区表没有错误。</p>
</li>
<li><p>输入以下命令来格式化刚刚创建的根分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 &#x2F;dev&#x2F;sdxY （请将的sdxY替换为刚创建的分区）</span></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux技术基础-3-1 Parrot Linux物理机的安装、引导与配置</title>
    <url>/LinuxNotes/2020/01/Linux%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80-3-1%20Parrot%20Linux%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E5%BC%95%E5%AF%BC%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2020/01/12/loiVVU.jpg" alt=""></p>
<p>Parrot Sec OS是Linux发行版中十大渗透测试系统之一，为广大渗透测试工作者提供了大量已经集成好的测试工具。桌面采用的是基于Gnome的Mate桌面，外观上非常炫酷，科技感十足。系统中编程环境完善，支持C++、Java、Python等多种语言编程，官方还提供了多种版本以适应不同电脑下载。</p>
<a id="more"></a>

<p>本文拟以Parrot Sec OS为例，讲解如何在物理机上安装Linux发行版。</p>
<p>选择Parrot Linux的主要原因是Windows 10+Linux双系统中Parrot Linux对<code>NVIDIA</code>显卡的“支持”比较好——在未安装对应显卡驱动前，可以选择不使用<code>NVIDIA</code>显卡，这样就不会出现无法进入Linux系统的情况。</p>
<blockquote>
<p>注：</p>
<p>我曾经尝试安装Ubuntu 18.04 LTS，由于显卡支持的原因，在Logo加载界面始终无法进入系统。</p>
<p>当然显卡支持的问题早有解决方案。如果存有这方面的顾虑，可以先了解有关自己电脑的详细配置，而后在社区中寻找解决方案。</p>
</blockquote>
<p>在开始讲Linux的安装之前，必须明确一个先决条件：<strong>你的计算机中已经安装有一个或多个Windows版本</strong>。这是因为如果你在没有任何操作系统的空物理机上安装Linux，以后再要安装Windows系统，那么Windows的引导程序就会将Linux的引导程序<strong>覆盖</strong>。引导覆盖会使得你无法再进入Linux系统，即使它事实上还是存在于你的计算机之中的。</p>
<blockquote>
<p>当然，这个问题可以修复；但如果你确实这么做，解决方法很麻烦。</p>
</blockquote>
<h2 id="安装前的准备"><a href="#安装前的准备" class="headerlink" title="安装前的准备"></a>安装前的准备</h2><h3 id="浅析引导"><a href="#浅析引导" class="headerlink" title="浅析引导"></a>浅析引导</h3><p>当一块硬盘接驳主机之后，它的首要任务是建立分区列表，分区列表有MBR和GPT两种，其中MBR分区模式只能分4个主分区，分区列表最大为<strong>2.1TB</strong>的硬盘，GPT分区列表则支持 <strong>9.4ZB硬盘（9.4ZB=1024EB=94亿TB）</strong> 。NTFS，FAT32，EXT4等属于文件系统，就像是给分好区的硬盘上打上格子，方便填充数据。至于打成什么样的格子由文件系统决定。 </p>
<p><strong>MBR分区表</strong>(Master Boot Record):即硬盘的主引导记录分区列表，在主引导扇区，只支持容量在 2.1TB 以下的硬盘，超过2.1TB的硬盘只能管理2.1TB，最多只支持4个主分区或三个主分区和一个扩展分区，扩展分区下可以有多个逻辑分区。 </p>
<p><strong>GPT分区表</strong>(GUID Partition Table):即全局唯一标识分区列表，是一个物理硬盘的分区结构。它用来替代BIOS中的主引导记录分区表（MBR）。Windows最大仅支持<strong>128</strong>个GPT分区，GPT可管理硬盘大小达到了<strong>18EB</strong>( <strong>1<em>EB</em>=1024PB ,1PB=1024TB</strong>)。</p>
<p>注：<strong>只有基于UEFI平台的主板才支持GPT分区引导启动。</strong></p>
<p><strong>UEFI</strong>(Unified Extensible Firmware Interface):全称“统一的可扩展固件接口”， 是一种详细描述全新类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而使开机程序化繁为简，节省时间。</p>
<p><strong>ESP分区</strong>(EFI system partition):该分区用于采用了EFI BIOS的电脑系统，用来启动操作系统。分区内存放引导管理程序、驱动程序、系统维护工具等。如果电脑采用了EFI系统，或当前磁盘用于在EFI平台上启动操作系统，则应建议ESP分区。 </p>
<p><strong>MSR分区</strong>：即微软保留分区，是GPT磁盘上用于保留空间以备用的分区，例如在将磁盘转换为动态磁盘时需要使用这些分区空间。 </p>
<p><strong>归纳1：</strong>传统BIOS不支持GPT分区列表，仅支持MBR格式。新型引导方式UEFI则取代传统BIOS，它加入了对新硬件的支持，其中就有2TB以上硬盘。它不支持MBR模式，仅支持GPT格式。</p>
<p>近两年出现的UEFI主板，采用UEFI+BIOS共存模式，并且在BIOS中集成UEFI启动项。BIOS+MBR已经趋于淘汰，UEFI+GPT是大势所趋。</p>
<p>GPT这种新型磁盘模式，与常用的MBR磁盘相比更稳定，自纠错能力更强。 WinXP系统无法识别GPT磁盘，对Win7、Win8来说GPT磁盘可以任意读写，但无法安装操作系统。GPT磁盘必须在使用支持FEI的主板后才可以安装Win7、Win8。</p>
<p>GPT磁盘的保留分区（隐藏分区）又称为EFI保留分区（ESP），可以防止将该磁盘挂接到XP系统中被误认为是未格式化的磁盘而格式化，导致数据丢失。该保留分区在将硬盘初始化（或转化）为GPT模式时自动创建，大小随硬盘总容量而定。 </p>
<p>一般来说，GPT格式的磁盘至少有三个区，<strong>第一个是EFI系统保护区（默认隐藏不加载）第二个是MSR微软保留分区，第三个是系统数据分区</strong>。 </p>
<p><strong>归纳2：</strong>如果你的电脑是Win10系统，那么一般是GPT分区，使用UEFI引导；如果是Win7、8的系统，那么也是GPT分区，而引导方式则有待商榷(不排除是MBR)；如果是WinXP或者Win98系统，那一定是MBR分区引导。(话说回来这年头真的还有人用Win98吗？)</p>
<blockquote>
<p>注：</p>
<p>判断电脑的BIOS引导模式，在运行对话框中输入msinfo32，回车打开系统信息(或在控制面板/系统与安全/管理工具/系统信息)。寻找到BIOS模式项，观察是否是UEFI。</p>
</blockquote>
<h3 id="硬盘空间"><a href="#硬盘空间" class="headerlink" title="硬盘空间"></a>硬盘空间</h3><p>磁盘分区是Linux安装中重要的部分，也是最困难的部分，因为Linux的文件系统和Windows有别。</p>
<p>首先要明确的是，你的电脑已安装有Windows系统。那么，你选择要安装Linux，你必须划分出一块空间用于Linux的安装。</p>
<p>划分的方法：右击我的电脑，在弹出的菜单中选择管理，在弹出的对话框中选择存储，在存储栏下选择磁盘管理，以加载虚拟磁盘服务。</p>
<p>选择一块空间充足(推荐40GB空闲空间以上)的分区，右键选择压缩卷，然后压缩出至少40960MB空间(<strong>最好是和已有的分区大小不同，原因见下</strong>)。</p>
<blockquote>
<p>需要记住该压缩卷的空间大小，且最好是和已有的分区大小不同，因为在Linux下各个分区的标识符和Windows下完全不同。所以届时可能需要通过空间大小来识别你分配的用于Linux安装的是哪一部分空间。</p>
</blockquote>
<p>压缩卷的意思是实际要从该卷中分多少空间出来作为新卷(即新分区)用。</p>
<h3 id="安装介质"><a href="#安装介质" class="headerlink" title="安装介质"></a>安装介质</h3><p>第一，在所选择的发行版官网上下载ISO镜像文件。</p>
<p>Parrot Sec OS下载地址为：<a href="https://parrotlinux.org" target="_blank" rel="noopener">https://parrotlinux.org</a> </p>
<p>官网上的ISO镜像文件一般分为多种版本，目前Parrot Linux分为Security、Home/Workstation、Other Builds三种版本。个人用户一般选择Security或者Home均可。<em>如果希望拥有完整的编程环境和渗透测试工具集的话，选择Security版本。</em></p>
<p>在接下来的Installer ISO分类中选择Parrot Security(Mate)或者KDE Edition(KDE Plasma)均可。Mate桌面环境基于Gnome，而KDE Plasma顾名思义是Kit Desktop Environment。如果要安装在虚拟机上，可以选择Parrot Security也可以选择Virtual Appliance。</p>
<p>第二，在下载完成ISO后，使用UItraISO(软碟通)工具制作U盘启动盘(即安装所需的启动媒体)。</p>
<p>第三，重启电脑进入BIOS，进行Boot设置。</p>
<p>BIOS的进入，不同的电脑按键不一样。一般来说，在开机的时候<strong>连按</strong>Del键(Del键位于小键盘上)进入BIOS。进入后设置启动顺序。</p>
<ol>
<li>HDD代表的是硬盘启动；</li>
<li>USB代表从USB接口启动；</li>
<li>FDD、CD/DVD、NetWork代表是软盘，光驱和网卡，一般不使用。</li>
</ol>
<p>将从硬盘启动设置到从U盘启动，然后保存退出即可。</p>
<p>由于U盘启动是临时安装时使用，也可以不进入BIOS设置启动顺序，而是在开机的时候<strong>连按</strong>ESC键，在弹出的设备启动界面中选择从U盘启动即可。</p>
<blockquote>
<p>注意：</p>
<ol>
<li><p>部分电脑可能设置有Security Boot，如果切换为U盘启动，会提示：<br> <strong>Secure Boot Violation</strong>:Invalid signature detected,check secure boot policy in setup. </p>
<p> 这种情况需要进入BIOS设置界面，在Security选项卡下选择secure boot control选项，调整该选项的属性为disable，保存并退出。</p>
</li>
<li><p>部分电脑可能在开机时按ESC键不会出现设备启动界面，这可能是由于电脑所使用的主板默认设置的并不是ESC键呼出设备启动界面；也可能是主板根本没有设备启动界面这一项设置。具体需要自行查阅自己电脑的主板信息。(尤其是淘换来的二手主板或寨板等等)</p>
</li>
</ol>
</blockquote>
<h2 id="安装中的操作"><a href="#安装中的操作" class="headerlink" title="安装中的操作"></a>安装中的操作</h2><p>下面以Parrot Linux为例，说明如何安装Linux发行版。</p>
<ol>
<li><p>确认一切安装准备都就绪后，插入作为启动媒体的U盘，并重启电脑，选择从U盘启动，以进入Live环境。</p>
</li>
<li><p>进入到如下图所示的安装界面，选择Install.<br><img src="https://s2.ax1x.com/2020/01/12/lTrrqJ.png" alt=""></p>
</li>
</ol>
<blockquote>
<p>注意：从上图可以清楚的看到有一个模式是”<strong>Live Mode</strong>“启动模式，这个选项表示用户可以直接启动预载于启动媒体中的Linux系统，不需要经过安装步骤。该模式的作用是给用户预览一下此系统是怎么样的，是否符合用户预期。试用系统一般不会改变计算机中的内容。</p>
</blockquote>
<ol start="3">
<li><p>选择安装模式，选择Install with GTK GUI以提供图形用户界面的配置。</p>
</li>
<li><p>语言选择中文(简体)，当然其他也无所谓。<br><img src="https://s2.ax1x.com/2020/01/12/lTsGQO.png" alt=""></p>
</li>
<li><p>选择区域为中国。<br><img src="https://s2.ax1x.com/2020/01/12/lTsaTA.png" alt=""></p>
</li>
<li><p>选择键盘映射为汉语，等待其加载组件完成。</p>
</li>
<li><p>设置<strong>管理员</strong>用户名与密码，默认的管理员用户名是root，密码自行设置。</p>
<p><img src="https://s2.ax1x.com/2020/01/12/lTs8SK.png" alt=""></p>
</li>
<li><p>设置普通用户的用户名和密码</p>
<blockquote>
<p>注意：普通用户的密码和管理员用户密码不要填写同一个密码！关于普通用户与管理员用户的关系以后会详细讨论。</p>
</blockquote>
</li>
<li><p>磁盘分区——这是最关键的一步，一定要慎之又慎。</p>
<p><img src="https://s2.ax1x.com/2020/01/12/lTsgmQ.png" alt=""></p>
<p>如果是安装仅Linux系统而无Windows系统，可以选择向导(使用整个磁盘)；如果是计算机先已安装有Windows，再安装Linux，则应当选择手动分区，然后单击继续按钮。</p>
<blockquote>
<p>对于Linux系统而言，必须有<strong>根分区</strong>(简称一切的根)”root”和<strong>交换分区</strong>“swap”。</p>
<p>根分区被用来存放系统所必须的文件，它被挂载到根目录(/)下。</p>
<p>交换分区则相当于Windows中的虚拟内存概念。该交换分区被当做低速RAM使用。Parrot Linux允许用户不显式地指派交换分区，如果你的系统不是很忙而内存又很充裕的话。</p>
</blockquote>
<p>手动分区界面中，用户可以自行建立分区方案。缺省的分区方案如下：</p>
<ol>
<li>将所有文件放在同一个分区中(推荐新手使用)；</li>
<li>将/home放在单独的分区</li>
<li>将/home、/var和/temp都分别放在单独的分区。</li>
</ol>
<p>选定分区方案后继续，手动分区可能需要自行创建各个分区，故下面以建立根分区为例介绍建立各个分区的过程：</p>
<ol>
<li><p>选定之前划分的特定空间，创建一个新分区。</p>
</li>
<li><p>由于创建的是根分区，分区容量默认为全部剩余空间。</p>
</li>
<li><p>挂载点设置为”/“表示将该分区挂载至根目录下。</p>
<blockquote>
<p>swap分区不需要挂载点，其大小指派4G-8G均可。</p>
</blockquote>
</li>
<li><p>主分区和逻辑分区的文件系统一般都设置为EXT4日志文件系统，当然为了更好的扩展性，你也可以选择btrfs文件系统。EXT4和btrfs文件系统可以转换，因此不必过分纠结。如果某些分区有默认文件系统，就选择默认。</p>
<blockquote>
<p>文件系统似乎是内核中比较稳定的部分，人们一直使用的 ext2/3在近年来暴露出了一些扩展性问题，于是便催生了 ext4 。然而很多目前有关 ext4 的文章都不约而同地提到了 btrfs，并认为 ext4 将是一个过渡的文件系统。 ext4 的作者 Theodore Tso 也盛赞 btrfs 并认为 btrfs 将成为下一代 Linux 标准文件系统。</p>
</blockquote>
</li>
</ol>
<p>分区完毕后在分区表中还可以单击各分区对其进行修改。</p>
<p>一般来说，分区可设置为两个”/“(主分区),”swap”(逻辑分区)，也可以划分的更加详细一些。</p>
<p><img src="https://s2.ax1x.com/2020/01/12/lTsfkn.png" alt=""></p>
</li>
<li><p>完成了磁盘分区的操作后，需要将GRUB安装至硬盘。</p>
<p><img src="https://s2.ax1x.com/2020/01/12/lTsolT.png" alt=""></p>
<p>不论电脑上是Windows+Linux，还是仅有Linux，都需要安装GRUB。GRUB用于引导Linux的启动。单击继续后在接下来的界面中选择将GRUB安装到手动输入设备/dev/sda上。然后耐心等待安装完成。</p>
</li>
<li><p>出现如图所示的界面则证明安装成功。</p>
<p><img src="https://s2.ax1x.com/2020/01/13/lT4END.png" alt=""></p>
<blockquote>
<p>注：安装介质就是插入的U盘，在点击重启的时候，应当拔出。</p>
</blockquote>
</li>
</ol>
<h2 id="安装后的配置"><a href="#安装后的配置" class="headerlink" title="安装后的配置"></a>安装后的配置</h2><h3 id="GNU-Grub-Version-2-02"><a href="#GNU-Grub-Version-2-02" class="headerlink" title="GNU Grub Version 2.02"></a>GNU Grub Version 2.02</h3><p>重启系统后<strong>最可能遇到问题</strong>是出现GNU Grub Version 2.02界面。</p>
<blockquote>
<p>注：</p>
<p>GNU Grub Version 2.02界面是指电脑会卡在开机自检后的一个黑屏界面上，电脑要求输入命令。命令行会提示grub&gt;</p>
<p>命令行也有可能提示unknown file system，进而显示grub rescue&gt;</p>
</blockquote>
<p>出现该界面表明Grub引导出现了问题，需要手动引导电脑进入操作系统。(不同的电脑可能出现的Grub的版本号不相同) </p>
<p>出现该界面，请考虑本机是否有固态硬盘：</p>
<ol>
<li>如果有固态硬盘，且Linux安装在固态硬盘上，或者没有固态硬盘，则可以选择尝试解决方案一；</li>
<li>如果有固态硬盘，但Linux没有安装在固态硬盘上，或者想迅速解决问题，请选择解决方案二。</li>
</ol>
<p>解决方案一：</p>
<ol>
<li><p>通过设置参数手动从grub引导电脑进入操作系统</p>
<p>先使用ls命令，找到你的Linux安装在哪个分区(<em>grub&gt;为电脑显示，后面是输入的命令</em>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt;ls</span></pre></td></tr></table></figure>

<p>该命令会会罗列所有的磁盘分区信息，比如显示：(hd0,1),(hd0,5),(hd0,3),(hd0,2)</p>
</li>
<li><p>然后依次调用如下命令： X表示每个分区的标识符。</p>
<p>如果之前安装Linux时/boot没有进行单独分区，则用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt;ls (hd0,X)/boot/grub</span></pre></td></tr></table></figure>

<p>如果之前安装Linux时对/boot进行了单独分区，则用下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt;ls (hd0,X)/grub</span></pre></td></tr></table></figure>
</li>
<li><p>找到包含/boot的分区后，系统会列出很多文件，这表明Linux安装在该分区。</p>
<p>假设找到（hd0,5）时，显示了文件，现在设法临时性将grub的两部分关联起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt;<span class="built_in">set</span> root=(hd0,5)</span></pre></td></tr><tr><td class="code"><pre><span class="line">grub&gt;<span class="built_in">set</span> prefix=(hd0,5)/boot/grub <span class="comment">#若/boot没有进行单独分区，则执行这条命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">grub&gt;<span class="built_in">set</span> prefix=(hd0,5)/grub <span class="comment">#若/boot进行了单独分区，则执行这条命令</span></span></pre></td></tr></table></figure>
</li>
<li><p>调用如下命令，就可以加载出grub引导菜单。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt;insmod normal <span class="comment">#启动normal启动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">grub&gt;normal</span></pre></td></tr></table></figure>
</li>
<li><p>见方案二第2步。</p>
</li>
</ol>
<blockquote>
<p>注：</p>
<p>grub shell中的ls命令查看的并不是你电脑上的所有磁盘分区，如果你有固态硬盘，（一般固态硬盘位于磁盘读取顺序中的第一个）ls只会查看固态硬盘上的分区，很显然，如果你有固态且Linux没有安装在固态硬盘上，那么无论你ls哪个分区，都不会显示文件，只会提示文件系统未知，在这种情况下想将grub临时关联起来，只能是无稽之谈。</p>
</blockquote>
<p>解决方案二：</p>
<ol>
<li><p>重启，然后在开机的时候<strong>连按</strong>ESC键，在弹出的设备启动界面中选择Linux。</p>
</li>
<li><p>成功进入Linux后，在终端执行：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-grub</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo grub-install /dev/sda <span class="comment">#如果你的第一块硬盘是机械硬盘则执行该命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo grub-install /dev/nvme0n1 <span class="comment">#如果你的第一块硬盘是固态硬盘则执行该命令[见注2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">true$ reboot <span class="comment">#重启</span></span></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>注1：</p>
<ol>
<li>$ 标识符是命令行中默认的提示，输入时不必加上。</li>
<li>sudo命令会提示输入管理员密码，输入密码时屏幕是没有显示的，此处要注意。</li>
</ol>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/01/13/lT57wV.png" alt=""></p>
<blockquote>
<p>注2：</p>
<p>对仅机械硬盘的电脑来说，<strong>sda是你的第一块硬盘的硬盘号</strong>，输入sdb,sdc等都不对；</p>
<p>对有固态硬盘的电脑来说，建议进入Linux后先执行命令 sudo fdisk -l命令查看磁盘情况，然后将第一块显示的磁盘(它类似nvme0n1这种名称)作为你将要输入grub-install的位置。</p>
<p><strong>分区号码不要指定</strong>，对机械硬盘来说，输入sda1，sda5等都不对；对固态硬盘来说，输入nvme0n1p1,nvme0n1p2等等都不对。注意要在重启后检查是否已经恢复了grub的启动菜单。</p>
</blockquote>
<p>即使重启后能顺利地进入Linux系统，我也建议在终端执行上述三条命令，因为笔者自己电脑的Grub是在进入Windows后重启再进入Linux的时候失效的。所以更新Grub是必须的操作，除非你每次开机的时候都调出设备启动界面手动选择要启动的操作系统。</p>
<blockquote>
<p>注3：</p>
<p>即使你已经按照上面的步骤正确地做过一遍，你仍有可能会在进入Windows再关闭再启动想进入Linux时出现GNU Grub Version 2.02的引导问题，这种情况笔者在安装manjaro、deepin等发行版的时候发生过。</p>
</blockquote>
<h3 id="Wlan0-No-Wireless-connection"><a href="#Wlan0-No-Wireless-connection" class="headerlink" title="Wlan0 : No Wireless connection"></a>Wlan0 : No Wireless connection</h3><p>在终端输入下面的命令，检查返回结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iwconfig</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#一般(没有无线网卡的电脑)会出现下面的返回结果。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">eth0:no wireless connection</span></pre></td></tr><tr><td class="code"><pre><span class="line">lo:no wireless connection</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#如果(有无线网卡的电脑)出现的结果同上，那么说明无线网络配置有问题，需要重新进行配置</span></span></pre></td></tr></table></figure>

<p>类似eth0的名称表示的是以太网(有线网络)，lo表示的是本地环回，类似wlan0的名称表示的是以太网(无线网络)。必须出现类似wlan0的名称才表示有无线网络连接。如果没有显示类似wlan0的项，则可能说明驱动安装不正确。应当进行下列操作：</p>
<ol>
<li><p>检查电脑是否有无线网卡，且无线网卡是否插好(笔记本略过此步骤)</p>
</li>
<li><p>输入下面两条命令中的任意一条。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lspci | grep Network </span></pre></td></tr><tr><td class="code"><pre><span class="line">$ lspci | grep -i net</span></pre></td></tr></table></figure>

<p>在返回的结果中寻找wireless Network Adapter的版本信息。例如，笔者自己的电脑无线网卡版本在终端中显示为 RTL8821CE。</p>
<p>部分Linux发行版显示无线网卡版本的信息可能不全，可以用Windows协助查看，在Windows下查看网络驱动的版本信息方法是：进入控制面板/网络和Internet/网络和共享中心/更改适配器设置→进入网络连接，查看WLAN下的属性信息，如下图所示：</p>
<p><img src="https://s2.ax1x.com/2020/01/13/lHKcX8.png" alt=""></p>
</li>
<li><p>在github网站上下载驱动。对于RTL8821CE，这里推荐tomaspinho/rtl882ce。 </p>
</li>
<li><p>下载解压缩，在下载的文件夹中(/home/download)右键→在终端中打开，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ./dkms-install.sh</span></pre></td></tr></table></figure>
</li>
<li><p>如果Arch系提示有错误，则按照错误信息安装对应的依赖。一般可能要安装的依赖有：bc、dkms、linux-headers等等。</p>
</li>
<li><p>命令执行完成后再次执行iwconfig命令，如果出现了wlan0，说明驱动安装成功。</p>
</li>
<li><p>点击无线网图标，即可连接到无线网。</p>
</li>
</ol>
<h3 id="更新源配置"><a href="#更新源配置" class="headerlink" title="更新源配置"></a>更新源配置</h3><ol>
<li><p>查看当前的Parrot Security镜像源，执行：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ parrot-mirror-selector</span></pre></td></tr></table></figure>
<p> <img src="https://s2.ax1x.com/2020/01/13/l775RO.png" alt=""></p>
</li>
<li><p>修改Parrot Security更新源</p>
<p> 众所周知，Linux发行版一般为国外公司(使用Deepin OS/Red Flag等国产发行版的例外)，一般它们的更新源都部署在国外的服务器上，国内访问会很缓慢。故此，需要修改发行版的更新源为国内的镜像，以提高更新速度。当然，这并不是必须的。</p>
<p> 在终端执行以下命令：</p>
<blockquote>
<p>注，Parrot Linux有相当多配置文件的存放位置与其他Debian发行版位置不同！</p>
</blockquote>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/apt/sources.list.d/parrot.list</span></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2020/01/13/l7O8De.png" alt=""></p>
<p> 使用#注释掉之前的更新源，而后将下面的代码根据地理位置任选一二拷贝到文件尾。</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#中科大和USTCLUG</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/parrot parrot main contrib non-free</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#北京清华大学，TUNA协会</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deb https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/parrot/ parrot main contrib non-free</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#上海大学</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deb https:<span class="comment">//mirrors.shu.edu.cn/parrot/ parrot main contrib non-free</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#上海交通大学 NIX用户组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">deb https:<span class="comment">//mirrors.sjtug.sjtu.edu.cn/parrot/ parrot main contrib non-free</span></span></pre></td></tr></table></figure>

<p> 按<strong>ESC</strong>键，输入“ <strong>:wq</strong>” 回车，以保存配置文件并退出。</p>
</li>
<li><p>执行下面两条更新命令，第二和第三条命令任选一条执行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get upgrade</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get dist-upgrade</span></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ol>
<li><p>update是更新软件的<strong>列表信息</strong>,包括版本,依赖关系等</p>
</li>
<li><p>upgrade在不改变现有软件设置的基础上更新<strong>软件</strong></p>
</li>
<li><p>dist-upgrade在会改变配置文件和改变旧的依赖关系基础上更新<strong>软件</strong></p>
</li>
</ol>
</blockquote>
<p>更新版本实际上就是更新软件包，由于Debian系列发行版都采用的是滚动升级，所以dist-upgrade仅用来升级软件，而dist-upgrade则用来更新版本。(版本升级会修改大量配置文件) </p>
</li>
</ol>
<h3 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h3><ol>
<li><p>安装Google拼音输入法，在终端输入命令：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install fcitx-googlepinyin</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ reboot</span></pre></td></tr></table></figure>
</li>
<li><p>安装IBUS拼音输入法，在终端输入命令：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ im-config -s ibus <span class="comment">#启动iBus框架</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get install ibus-pinyin</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo ibus-setup <span class="comment">#打开iBus设置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ reboot</span></pre></td></tr></table></figure>
</li>
<li><p>安装搜狗拼音输入法，在终端依次输入下列命令：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt --fix-broken install</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get dist-upgrade</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get install fcitx fcitx-frontend-gtk2 fcitx-module-dbus fcitx-bin fcitx-frontend-gtk3 fcitx-module-kimpanel fcitx-config-common fcitx-frontend-qt4 fcitx-module-lua fcitx-config-gtk fcitx-frontend-qt5 fcitx-modules fcitx-data fcitx-module-x11 fcitx-frontend-all fcitx-libs-dev fcitx-ui-classic</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ reboot</span></pre></td></tr></table></figure>

<p> 如果安装任何软件的过程中提示依赖关系有错误 ，则在终端尝试输入命令解决：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install -f</span></pre></td></tr></table></figure>
</li>
<li><p>安装搜狗拼音输入法也可以尝试在搜狗官网上下载deb安装包，然后在下载位置打开终端，执行下面的命令：（最后的字符串是安装包名，请自行替换）</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ reboot</span></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2020/01/13/lHpLwT.png" alt=""></p>
</li>
</ol>
<h3 id="DIY桌面环境"><a href="#DIY桌面环境" class="headerlink" title="DIY桌面环境"></a>DIY桌面环境</h3><ol>
<li><p>Mate桌面下更换主题</p>
<p> 可以在系统自带的主题中选择选择喜欢的主题；可以访问下面的网址。 </p>
<p> Parrot系统 访问：<a href="https://www.mate-look.org/" target="_blank" rel="noopener">https://www.mate-look.org/</a>  (需要VPN)<br> Kali系统 访问：<a href="https://www.gnome-look.org/browse/cat/135/ord/latest/" target="_blank" rel="noopener">https://www.gnome-look.org/browse/cat/135/ord/latest/</a>  (访问缓慢)</p>
<p> 注：一定要选择3.x版本的主题才适合，因目前的Mate桌面环境是基于Gnome 3的。 </p>
</li>
<li><p>Mate桌面环境更换为KDE桌面环境</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get dist-upgrade</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get install parrot-kde</span></pre></td></tr></table></figure>

<p> 执行第三条命令后系统会提示选择默认会话窗口，需要从lightdm改为sddm。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt autoremove parrot-mate* </span></pre></td></tr><tr><td class="code"><pre><span class="line">$ reboot</span></pre></td></tr></table></figure>

<p> 重启后，在登录系统时，在界面上的session中选择plasma，输入口令进入。</p>
</li>
<li><p>安装Cairo-Dock</p>
<p>依次执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get install cairo-dock cairo-dock-plug-ins</span></pre></td></tr></table></figure>
</li>
<li><p>安装 screenfetch </p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get install screenfetch</span></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux技术基础-2 Linux综合概述</title>
    <url>/LinuxNotes/2020/01/Linux%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80-2-Linux%E7%BB%BC%E5%90%88%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p><img src="https://s2.ax1x.com/2020/01/10/lhY7ad.png" alt=""></p>
<p>GNU/Linux，无论你是否相信，它已经成为目前增长最迅速的系统。无论是企业还是个人用户，Linux都是一个足够可靠的选择。我希望本系列文章能够使更多的人完全理解Linux，并热切地尝试去使用甚至探索它。</p>
<a id="more"></a>

<h2 id="建立Linux的概念"><a href="#建立Linux的概念" class="headerlink" title="建立Linux的概念"></a>建立Linux的概念</h2><p>简而言之，Linux是一个操作系统，可以安装在包括服务器、个人电脑、PAD、手机、打印机等各类电子设备中。</p>
<p>计算机系统是由硬件和系统软件所组成的，它们共同工作来运行程序。</p>
<ul>
<li><p>从物理结构上来说，计算机是由一个硬件组所组成的。</p>
</li>
<li><p>从逻辑结构上来说，操作系统就是为了：</p>
<p>​    ①更加有效的控制硬件资源，为它们进行分配和回收</p>
<p>​    ②提供计算机运行所需要的功能</p>
<p>​    ③提供一组系统调用接口作为程序开发使用。</p>
</li>
</ul>
<p>Linux是一种操作系统，它可以理解为一个软件组。软件可以分为操作系统级和应用软件级，从这个角度来说，Linux这个软件组中的所有软件均处于操作系统级。</p>
<p>如果将整个计算机解剖成为硬件、内核、系统调用和应用程序四层，那么操作系统的层次如图所示： </p>
<p><img src="https://s2.ax1x.com/2020/01/10/lh0YOP.png" alt=""></p>
<p>详细阐述Linux的起源与发展，以及与其密切相关的开放源代码许可证协议GPL，甚至追溯它的老大哥UNIX的起源与发展，我认为对于Linux操作系统的学习其实没有太大的帮助，而且这方面的内容网络上俯拾皆是，没有必要重复造轮子，除非你是历史系的学生需要选择这一板块作为毕业论文，或者你是法律系的学生需要将开源协议所涉及的问题用作案例分析。<br>在现阶段只需要知道： </p>
<ul>
<li>UNIX是一种稳定，成熟的操作系统。</li>
<li>GNU是GNU‘s Not Unix，由自由软件基金会发起，本意是一个名为GNU的，同UNIX兼容的操作系统， 开发这个系统的目的就是为了让所有计算机用户都可以自由地获得这个系统。任何人都可以免费<br>地获得这个系统的源代码，并且可以相互自由拷贝。 </li>
<li>GNU有自己独特的公共许可证，即版权声明：GPL，其目的就是要让GNU永远是免费和公开的。  </li>
<li>Linux由UNIX发展而来，与UNIX兼容。</li>
<li>Linux如今使用GPL，所以它是免费和公开的。</li>
</ul>
<p>有关Linux、UNIX、GNU和GPL的详细内容，请自行百度。 </p>
<h2 id="Linux的优缺点"><a href="#Linux的优缺点" class="headerlink" title="Linux的优缺点"></a>Linux的优缺点</h2><h3 id="Linux的特色"><a href="#Linux的特色" class="headerlink" title="Linux的特色"></a>Linux的特色</h3><ol>
<li><p>自由而开放的使用及学习环境 </p>
<p>由于Linux是基于GPL的授权之下，因此它是自由软件，也就是任何人都可以自由地使用戒者是修改其中的原始代码的意思。 这种开放性架构对科学界来说是相当重要的。因为很多的工程师由于特殊的需求，常常需要修改系统的原始代码， 使该系统可以符合自己的需求！而这个开放性的架构将可以满足不同需求的工程师，因此当然就有可能越来越流行。 </p>
</li>
<li><p>配备需求低廉 </p>
<p>Linux可以支持个人计算机的x86架构，系统资源不必像早先的Unix系统那般，仅适合于单一公司所出产的设备！ 单就这一点来看，就可以造成很大的流行。不过，如果你想要在Linux下执行X Window系统， 那么硬件的等级不能太低。 </p>
</li>
<li><p>核心功能强大而稳定 </p>
<p>由于Linux功能并不会输给一些大型的Unix工作站，因此，近年来越来越多的公司或者是团体、 个人投入这一个操作系统的开发与整合工作！例如IBM与升阳公司都有推出x86的Linux服务器。 </p>
</li>
<li><p>独立作业</p>
<p>由于很多的软件套件逐渐被这套操作系统拿来使用，而很多套件软件也都在 Linux这个操作系统上面进行发展与测试，因此，Linux近来已经可以独立完成几乎所有的工作站或服务器的朋务了，例如 Web, Mail, Proxy, FTP….. </p>
</li>
</ol>
<p>目前Linux已经是相当成熟的一套操作系统，可以说这给微软造成了相当大的压力。此外，由于它的系统硬件要求很低，Linux在被淘汰的硬件中也可以执行的相当的顺畅、稳定，因此这也造成相当多“垃圾佬”的关注。</p>
<h3 id="Linux的优点"><a href="#Linux的优点" class="headerlink" title="Linux的优点"></a>Linux的优点</h3><p>总体说来，Linux有以下优点：</p>
<ul>
<li><p>稳定的系统</p>
<p>Linux是基于UNIX的概念而开发出的操作系统，它具有与UNIX系统相似的程序接口和操作方式，当然它也继承了UNIX稳定且有效率的特点。 </p>
</li>
<li><p>免费或少许费用</p>
<p>任何人都可以免费取得Linux。早些年如果申请Ubuntu(Linux的发行版的一种)，甚至可以免费邮寄安装光盘到家中。与之相反，UNIX和微软可能需要负担庞大的版权费用，而且微软会有频繁的更新。 </p>
</li>
<li><p>安全性、漏洞的快速修补</p>
<p>如果你对网络相当了解的话，你应该知道“没有绝对安全的主机”。但是Linux的社区开发模式可以随时获得最新的安全信息，相对来说更加安全。 </p>
</li>
<li><p>多任务、多用户</p>
<p>Linux主机允许多人上线工作，资源的分配也比较公平，比Windows的单人多任务系统更加稳定。正是因此，Linux比Windows更加适合作为服务器使用。耗费资源更少，更为稳定，虚拟化技术、分布式计算和互联网应用等的支持性更佳。 </p>
</li>
<li><p>相对耗费资源小</p>
<p>目前市面上任何一款能作为个人计算机使用的机器均可顺畅安装Linux，且耗费资源比Windows少，且少得多(前提是你正确安装了Linux及相关问题的解决方案)。</p>
</li>
<li><p>适合需要小内核程序的嵌入式系统</p>
<p>Linux的内核只有数百KB，所以它可以作为家电、小电子用品的操作系统，即嵌入式系统。顺便一提，目前手机中的Android系统正是基于Linux的开源操作系统。 </p>
</li>
<li><p>整合度高且多样的图形用户界面</p>
</li>
<li><p>用户和用户组使得系统保密性更高</p>
</li>
</ul>
<h3 id="Linux的缺点"><a href="#Linux的缺点" class="headerlink" title="Linux的缺点"></a>Linux的缺点</h3><ul>
<li><p>需要命令行来管理</p>
<p>Linux需要使用命令行的终端机模式进行系统的管理，Linux玩家必须接受使用命令管理计算机 </p>
</li>
<li><p>无特定的支持厂商</p>
<p>自由软件使用自由开发，系统的问题只能在网上找答案或自己调试解决。 </p>
</li>
<li><p>游戏支持只有轻量</p>
<p>Linux上最好不做无意义的事情，所以这里不讨论游戏。 </p>
</li>
<li><p>专业软件支持不足</p>
<p>可能存在一些绘图、建模、金融方面的软件不支持Linux操作系统，(这里不得不提一句国内软件厂商鲜有支持Linux操作系统的) 但必须指出，这是商业方面的问题而不是操作系统的问题。 </p>
</li>
</ul>
<h2 id="Linux的发行版本"><a href="#Linux的发行版本" class="headerlink" title="Linux的发行版本"></a>Linux的发行版本</h2><p><em>问：“如何选择适合我自己的发行版？”</em></p>
<p><em>答：“你随意选择就可以了。”</em></p>
<p>随着Linux各种支持的完善、稳定性和易用性的提升，现在各个发行版之间的差异性已经愈发的不明显了，可以随意选择。但不可否认的是，各发行版之间的差异确实依旧存在，每个发行版的用户数量、用户质量都不尽相同。</p>
<h3 id="发行版的综合介绍"><a href="#发行版的综合介绍" class="headerlink" title="发行版的综合介绍"></a>发行版的综合介绍</h3><blockquote>
<p>概括地讲，Linux的发行版本可以大体分为两类</p>
<ul>
<li>商业公司维护的发行版本</li>
<li>社区组织维护的发行版本</li>
</ul>
<p>前者以著名的Redhat Enterprise Linux（RHEL）为代表，后者则以Debian为代表。</p>
</blockquote>
<p>以下详细阐述各发行版的类别：</p>
<ul>
<li><p><strong>主流分支</strong></p>
<ol>
<li><p><strong>Debian</strong></p>
<p>Debian分为三个版本分支 stable, testing 和 unstable。其中，Unstable为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。Testing的版本都经过Unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而Stable一般只用于服务器，上面的软件包大部分都比较过时，但是稳定和安全性都非常的高。</p>
<p>Debian最具特色的是apt-get / dpkg包管理方式。Debian的资料也很丰富，有很多支持的社区，有问题求教可以在上面提问。</p>
<p>Debian系的发行版包括以下几种：</p>
<ol>
<li><p>Debian</p>
<p>Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。    </p>
</li>
<li><p>Ubuntu</p>
<p>Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的 Linux桌面系统。 </p>
</li>
<li><p>Deepin OS(由Knoppix发展而来)</p>
<p>Deepin基于Qt/C++（用于前端）和Go（用于后端），拥有全新而独特的深度桌面环境（DDE）它旨在创造一个全新的简单、易用、美观的 Linux 发行版。 </p>
</li>
<li><p>Google Chrome OS</p>
</li>
<li><p>Linux Mint</p>
</li>
</ol>
</li>
<li><p><strong>RedHat</strong></p>
<p>Redhat应该说是在国内使用人群最多的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。</p>
<p>Redhat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的于进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用，但是Fedora Core的稳定性较差，最好只用于桌面应用。 </p>
<p>RedHat系的发行版包括以下几种：</p>
<ol>
<li><p>Cent OS(Community Enterprise Operating System)</p>
<p>CentOS 是一个基于Red Hat Linux 提供的可自由使用源代码的企业级发行版，即RHEL的社区克隆版本。它旨在建立一个安全、低维护、稳定、高预测性、高重复性的 Linux 环境。 </p>
</li>
<li><p>Fedora Core</p>
<p>由原来的Red hat Desktop发展而来。</p>
</li>
<li><p>RHEL(Redhat Enterprise Linux)</p>
<p>即所谓的Redhat Advance Server。注：该发行版是收费版本。</p>
</li>
<li><p>Oracle Linux</p>
</li>
<li><p>Mandriva</p>
<p>是目前全球最优秀的Linux发行版之一，稳居于linux排行榜第一梯队。它是目前最易用的linux发行版，也是众多国际级linux发行版中唯一一个默认即支持中文环境的linux。 </p>
</li>
<li><p>Red Flag</p>
<p>红旗Linux是中国较大、较成熟的Linux发行版之一。 </p>
</li>
</ol>
</li>
<li><p><strong>Slackware Linux</strong></p>
<p>它坚持KISS（Keep It Simple Stupid）的原则，就是说：</p>
<ol>
<li><p>没有任何配置系统的图形界面工具。一开始，配置系统会有一些困难，但是更有经验的用户会喜欢这种方式的透明性和灵活性。</p>
</li>
<li><p>Slackware没有如RPM之类的成熟的软件包管理器。</p>
</li>
</ol>
<p>Slackware的软件包都是通常的tgz(tar/gzip)格式文件再加上安装脚本。Tgz对于有经验的用户来说，比RPM更为强大，并避免了RPM之类管理器的依赖性问题。 </p>
<p>Slackware Linux系的发行版包括：</p>
<ol>
<li><p>SUSE Linux</p>
<p>SUSE”，德文”Software- und System-Entwicklung”，其英文为”Software and system development” 。广义上SUSE Linux是一系列Linux发行版。最典型的即为OpenSUSE。</p>
</li>
<li><p>Vector Linux</p>
<p>Vector Linux 是一份小巧快捷的、基于Intel处理器的PC机Linux操作系统。Vector Linux的创建者们有一则简单的信条：简单、小巧，并让最终用户决定他们的操作系统成为什么样子。 </p>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>新兴分支</strong></p>
<ol>
<li><p>Arch Linux</p>
<p>系统主要由自由和开源软件组成，支持社区参与。系统设计以KISS原则（保持简单和愚蠢）为总体指导原则，注重代码正确、优雅和极简主义，期待用户能够愿意去理解系统的操作。 </p>
<p>Arch Linux 系统安装、删除和更新软件的软件包管理器叫做 pacman。</p>
<p>相比其他发行版，Arch Linux 属于轻量级选手，其简单的设计让它容易被轻松扩展和配置成为任何想要的系统类型。 </p>
</li>
<li><p>Gentoo</p>
<p>Gentoo是Linux世界最年轻的发行版本，正因为年轻，所以能吸取在它之前的所有发行版本的优点，这也是Gentoo 被称为伟大、完美的Linux发行版本的原因之一。 </p>
</li>
</ol>
</li>
</ul>
<h3 id="笔者个人对选择Linux发行版的理解"><a href="#笔者个人对选择Linux发行版的理解" class="headerlink" title="笔者个人对选择Linux发行版的理解"></a>笔者个人对选择Linux发行版的理解</h3><p>既然，本质上来说，Linux出名的就那么几种：Debian系、RedHat系、Arch Linux系、Open SUSE系。其他的发行版基本都是从这几个Linux衍生出来的(当然，也有一些可以说是独自建立的发行版比如英特尔的Clear Linux这种)，它们的唯一区别就在于包管理器的不同，那么，Llinux发行版的优先级建立只有两个因素：基于什么类别的发行版、使用体验怎么样。 </p>
<p>我个人针对Linux初学者的推荐如下：</p>
<ol>
<li><p>Deepin OS<br>优点：</p>
<ul>
<li>它是一个国内推出的发行版，所以相对于多数发行版来说，其本地化体验会有相当的提升。<br>其软件商店包含了很多国内常用的软件如QQ、微信、百度云。</li>
<li>其社区的中文用户量也算是比较庞大的，如果在使用中遇到问题，可以很方便的寻求答案。 </li>
</ul>
<p>缺点：</p>
<ul>
<li>软件版本更新比较中庸。</li>
<li>系统整体谈不上稳定。</li>
<li>社区的中文用户平均质量不高。</li>
</ul>
</li>
<li><p>Ubuntu</p>
<p>优点：</p>
<ul>
<li><p>可以把Ubuntu理解成Linux中的Windows：技术成熟、社区庞大，开箱即用。即使有一些软件在自带的软件商店找不到，同样可以去官方网站搜索。如果这个软件支持Linux，那么它一定会提供deb格式的安装包。</p>
<blockquote>
<p>但这个deb很大可能只能装在Ubuntu上而不能装在Ubuntu的父亲Debian上。因为Ubuntu虽然基于Debian，但它拥有自己的软件仓库，相对于Debian同样软件的版本要新。</p>
</blockquote>
</li>
<li><p>Ubuntu拥有自己的显卡驱动方案，在英伟达和英特尔核显双显卡的笔记本上技术是比较成熟的。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>相当一部分Deepin上移植的国内的软件Ubuntu还没有，即使有，其安装过程也比较麻烦。</li>
<li>Ubuntu经常会出现恼人的“发送错误报告”窗口。</li>
<li>因为Ubuntu不是滚动更新，所以如果不是用长期支持版本的话，每半年就会有新的版本推送。这个更新是较为危险的，很可能会更新失败而无法使用。</li>
</ul>
</li>
<li><p>Manjaro</p>
<p>Manjaro是基于Arch Linux的发行版，最大的特点就在于完全图形化和自动化了Arch Linux的安装过程，并且拥有一系列图形化的驱动和内核配置软件，这使得用户既可以享受到Arch Linux分支的各种优势，又可以一键设置驱动，亦能根据不同的使用条件而部署不同类型的内核，还不必花费大量时间阅读Arch Wiki来安装系统及从全文本界面逐步配置起图形界面。</p>
<p> <strong>注：新兴分支Arch Linux的优势：</strong></p>
<ol>
<li><p>Arch Linux发行版的软件相比其他分支的发行版总是最新的，这得益于Arch近乎简陋的包管理工具，没有版本范围限制的Arch系总是可以毫无顾忌的把软件包更新到最新。 </p>
<blockquote>
<p>但Arch Linux更新到最新同样可能出现一些意料之外的bug，所以Manjaro调慢了更新速度，一般是在Arch Linux更新的两个礼拜后Manjaro才会跟进这个版本的更新，如果这过程中出现了问题，Manjaro还会暂停版本的跟进。所以，可以说Manjaro消除了Arch Linux用户“滚挂”的顾虑。 </p>
</blockquote>
</li>
<li><p>Arch Linux特有的AUR软件仓库，使得几乎所有你能想到的软件都可以通过一条命令完成安装，而这条命令Manjaro还给图形化了。所以这相对于Ubuntu还需要去网上下载来讲简单了太多。 </p>
<p>我给Manjaro排到了第三位的理由：首先，我自己是Debian系的忠实拥护者起家，所以我还是偏爱Debian系发行版的；其次，Manjaro中文环境不佳，这对新手来说设置可能有些难度；最后，Manjaro使用了wayland显示服务。虽然相对于x server有很多改善，但由于现阶段软件兼容性的问题，所以我最终没有去选择它。</p>
<p>有些用户可能还会而是选择了它的父亲Arch Linux。但我并不推荐新手选择Arch Linux，Arch Linux是纯文本纯命令行模式，这种安装过程可能会让你没入门就放弃。 </p>
</li>
</ol>
</li>
<li><p>Pop！OS</p>
<p>如果有较多的游戏需求，pop！OS这个基于Ubuntu的发行版可能个不错的选择。相对于前边三个发行版，Pop! OS开箱即配置好了游戏环境——我指的是Windows游戏。要知道，自己在Linux下配置一个完善的Windows游戏环境是很困难的。此时这个系统的优势便体现了出来：通过内置软件一键装好显卡驱动后便可直接运行。 </p>
<p>当然，读者最好还是按照之前已经提到的态度，那就是不用Linux做无意义的事情。</p>
</li>
</ol>
<p>关于渗透测试的Linux发行版：</p>
<ol>
<li><p>Kali Linux</p>
<p>Kali 是一个基于 Debian Testing 的 Linux 发行版。该系统里包含了很多高级渗透测试和审计工具。大多数做安全测试的开源工具都被囊括在内。 这是黑客（或者自称黑客）的必备工具之一。它带有一套安全和计算机取证工具。其特色在于及时的安全更新，对ARM架构的支持，有四种流行的桌面环境供选择，以及能平滑升级到新版本。 </p>
<p>Kali Linux 在渗透测试和白帽子方面是业界领先的。该发行版附带的大量入侵和渗透的工具和软件在全世界都得到了广泛认可，即使在那些甚至可能不知道 Linux 是什么的 Windows 用户中也是如此。 </p>
<blockquote>
<p>注：</p>
<ol>
<li>Kali Linux不适合初学者， 每一个工具必须小心使用。</li>
<li>Kali 的内核和软件都与Debian有异，即使它是基于Debian的。</li>
<li>Kali Linux不适合安装在物理机，因为容易被攻击。</li>
</ol>
</blockquote>
</li>
<li><p>Parrot Linux</p>
<p>Parrot Security OS 是基于 Debian Testing 的面向安全的操作系统，它被设计为用于渗透测试、计算机取证、反向工程、攻击、云计算渗透测试、隐私/匿名、密码等场合。 其特色在于MATE桌面环境。</p>
<p>Parrot 采用 Kali 的软件库来更新大部分工具，不过也有提供其自己的定制软件的软件库。它不只是一个简单的 Kali 修改版，而是一个建立在 Kali 工具库之上的新系统，因此，它引入了许多新功能和不同的开发选择。 </p>
</li>
</ol>
<h3 id="相对客观的选择Linux发行版"><a href="#相对客观的选择Linux发行版" class="headerlink" title="相对客观的选择Linux发行版"></a>相对客观的选择Linux发行版</h3><p>你可能会发现我并没有推荐RedHat系的发行版以及openSUSE。这主要是因为我很少接触这两个分支。如果想要较为客观的选择发行版，可以尝试这两种方法。 </p>
<ol>
<li><p>参阅<a href="https://distrowatch.com/" target="_blank" rel="noopener">distrowatch.com</a> </p>
<p>注：该网站可能受到墙限制而无法打开。 </p>
<p>该网站聚合了几乎所有的类Unix发行版，并且根据点击量有一个排名列在这里。自然排名越高就说明热度越高，进而也能有一定的参考价值。但可以肯定的是，这里边肯定会有刷榜的情况出现，而且它也仅仅是展现了distrowatch用户的一个倾向，所以对你来说可能仅仅是一个参考作用。</p>
</li>
<li><p>参阅<a href="https://distrochooser.de/zh-cn/" target="_blank" rel="noopener">Distro Chooser</a> </p>
<p>这是一个在线调查网站。它拥有中文页面，只需要根据自己的情况回答好16个问题，便可以给出一些适合你的Linux发行版。相对来说可以得到一个比较客观的结果，可以供你参考一下。如果你不喜欢听别人的主观意见，自己又不好决定，那么可以来这个网站来试一试。 </p>
</li>
</ol>
<p>总体来讲，关于如何选择发行版这个问题可能仅仅对刚刚接触的人有参考价值。真正试用过一段时间Linux了就应该能明白，在发行版上面纠结其实并没有什么太大的用处。得益于Linux的高度自定义性，你可以把任何一个发行版改造成你想要的样子，提前选择仅仅是为了省去改造的这个过程而已。但如果是初次接触，那么选择一个适合自己的发行版来使用，也许能体会到“一见钟情”的感觉吧。</p>
<h2 id="UNIX-Linux经典哲学摘录"><a href="#UNIX-Linux经典哲学摘录" class="headerlink" title="UNIX/Linux经典哲学摘录"></a>UNIX/Linux经典哲学摘录</h2><h3 id="UNIX哲学"><a href="#UNIX哲学" class="headerlink" title="UNIX哲学"></a>UNIX哲学</h3><p><strong>Everything (including hardware) is a file.</strong><br>所有的事物（甚至硬件本身）都是一个的文件。</p>
<p><strong>Configuration data stored in text.</strong><br>以文本形式储存配置数据。</p>
<p><strong>Small, single-purpose program.</strong><br>程序尽量朝向小而单一的目标设计。</p>
<p><strong>Avoid captive user interfaces.</strong><br>避免过于复杂花哨的界面。</p>
<p><strong>Ability to chain program together to perform complex tasks.</strong><br>将几个程序连结起来，处理大而复杂的工作。</p>
<p><em>下面三句是UNIX程序设计的准则。</em></p>
<p><strong>Write programs that do one thing and do it well.</strong><br>写“一次只做一件事，并能把这件事做好”的程序。</p>
<p><strong>Write programs to work together.</strong><br>写“互相协作（调用）”的程序。</p>
<p><strong>Write programs to handle text streams, because that is a universal interface.</strong><br>写“处理文件流”的程序。因为这（处理文件流）是一个通用接口。</p>
<h3 id="The-Art-Of-Unix-Programing-哲学"><a href="#The-Art-Of-Unix-Programing-哲学" class="headerlink" title="The Art Of Unix Programing 哲学"></a><em>The Art Of Unix Programing</em> 哲学</h3><p><strong>Rule of Modularity: Write simple parts connected by clean interfaces.</strong><br>模块化原则：写简单的，能够用清晰的接口连接的代码。</p>
<p><strong>Rule of Clarity: Clarity is better than cleverness.</strong><br>清晰化原则：清晰的代码要好过“聪明”的代码。</p>
<p><strong>Rule of Composition: Design programs to be connected to other programs.</strong><br>组件化原则：设计可以互相关联（拆分）的程序。</p>
<p><strong>Rule of Separation: Separate policy from mechanism; separate interfaces from engines.</strong><br>隔离原则：策略和机制分离，接口和引擎分离。</p>
<p><strong>Rule of Simplicity: Design for simplicity; add complexity only where you must.</strong><br>简洁原则：设计力求简洁，直到无法更简洁。</p>
<p><strong>Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.</strong><br>小巧原则：不要写大的程序（模块、方法）。除非很明显的，没有别的办法可以完成。</p>
<p><strong>Rule of Transparency: Design for visibility to make inspection and debugging easier.</strong><br>透明原则：为可见性设计，使检查和调试更容易。</p>
<p><strong>Rule of Robustness: Robustness is the child of transparency and simplicity.</strong><br>健壮性原则：健壮性是透明和简单的孩子。</p>
<p><strong>Rule of Representation: Fold knowledge into data so program logic can be stupid and robust.</strong><br>陈述性原则：将认知转化为数据。所以，程序的逻辑可以是愚蠢（简单易懂）的，健壮的。</p>
<p><strong>Rule of Least Surprise: In interface design, always do the least surprising thing.</strong><br>最少的惊讶原则：在界面设计中，少做令人惊讶的设计。（不要标新立异）</p>
<p><strong>Rule of Silence: When a program has nothing surprising to say, it should say nothing.</strong><br>沉默原则：如果一个程序没有什么特别的东西要说（输出），那就什么都别说。</p>
<p><strong>Rule of Repair: When you must fail, fail noisily and as soon as possible.</strong><br>修复原则：如果必须失败，那就尽早。</p>
<p><strong>Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.</strong><br>节约原则：程序员的时间是非常宝贵的。程序员的时间（编程时间）优于机器时间。</p>
<p><strong>Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.</strong><br>生产原则：避免手工编程。如果可以的话，编写可以编写程序的代码。</p>
<p><strong>Rule of Optimization: Prototype before polishing. Get it working before you optimize it.</strong><br>优化原则：建立原型后再去修正。当它能正常工作后，再去优化它。</p>
<p><strong>Rule of Diversity: Distrust all claims for “one true way”.</strong><br>多样性原则：怀疑所有所谓的“不二法门”。</p>
<p><strong>Rule of Extensibility: Design for the future, because it will be here sooner than you think.</strong><br>扩展原则：为未来设计，因为未来来的比你想象的要早。</p>
<h3 id="X-Window哲学"><a href="#X-Window哲学" class="headerlink" title="X Window哲学"></a>X Window哲学</h3><p><strong>Small is beautiful.</strong><br>小即是美。</p>
<p><strong>Make each program do one thing well.</strong><br>让每个程序（方法）只做一件事情，并把它做好。</p>
<p><strong>Build a prototype as soon as possible.</strong><br>尽早建立原型。</p>
<p><strong>Choose portability over efficiency.</strong><br>注重可移植性，而非效率。</p>
<p><strong>Store data in flat text files.</strong><br>将数据存储在存文本文件中。</p>
<p><strong>Use software leverage to your advantage.</strong><br>利用软件来发挥你的优势。</p>
<p><strong>Use shell scripts to increase leverage and portability.</strong><br>使用Shell脚本提高编程的手段和程序的可移植性。</p>
<p><strong>Avoid captive user interfaces.</strong><br>避免过于复杂花哨的界面。</p>
<p><strong>Make every program a filter.</strong><br>使每个程序（方法）称为一个过滤器（筛选器）。</p>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux技术基础-1 完全使用Linux工作</title>
    <url>/LinuxNotes/2020/01/Linux%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80-1-%E5%AE%8C%E5%85%A8%E4%BD%BF%E7%94%A8Linux%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>尽管很多人已经不习惯看长篇大论, 但我还是要说, 这是一篇值得你从头读到尾的长篇文章。</p>
<p>2005年9月22日，清华在读博士生王垠在水木社区BLOG上发表了《清华梦的粉碎–写给清华大学的退学申请》明确要求退学,引起社会各界广泛争论。 他创作的长篇文章《完全用Linux工作》, 洋洋两万多字, 从不同角度居高临下的阐述了他眼中Linux完全优越于Windows的各种理由， 这篇文章并不简单的是一篇论述“Windows能做的事Linux都能做”这样的文章，而是通篇洋溢着一个彻底批判 Windows 平台基础的计算机哲学、计算机应用和计算机教育体系的人的万丈豪情。 尽管可能有些偏激，但是不乏详细的推理论述。</p>
<p>我将该文分享如下，并将其作为我即将要撰写的Linux技术基础系列文章的序言，以此勉励自己时刻谨记自己学习Linux的初心，提醒自己要为非Win化的传承而努力。希望本文的研究与讨论，能为诸位读者提供更宽广的讨论空间。</p>
<a id="more"></a>

<h2 id="转变你的观念"><a href="#转变你的观念" class="headerlink" title="转变你的观念"></a>转变你的观念</h2><h3 id="Linux可以高效的工作"><a href="#Linux可以高效的工作" class="headerlink" title="Linux可以高效的工作"></a>Linux可以高效的工作</h3><p>我已经半年没有使用 Windows 的方式工作了。Linux 高效的完成了我所有的工作。</p>
<p>GNU/Linux 不是每个人都想用的。如果你只需要处理一般的事务，打游戏，那么你不需要了解下面这些了。</p>
<p>我不是一个狂热的自由软件份子，虽然我很喜欢自由软件。这篇文章也不是用来推行自由软件运动的，虽然我觉得自由软件运动是非常好的。</p>
<p>这篇文章也不是用来比较 Linux 和 Windows 内核效率，文件系统，网络服务的。我现在是作为一个用户而不是一个开发者来说话的，我们的讨论是基于操作，应用层面的。是为了告诉大学里还不了解，或者不理解 UNIX 的科学工作者和大学生，UNIX 比 Windows 更适合用于科学研究工作，请大家理解 UNIX 的工作方式，不要用 Windows 的标准来要求 Linux，而要用一个科学工作者的标准来要求自己，用UNIX 的思想来武装自己。</p>
<p>我显然是反对在大学，特别是理工科专业推广 Windows 的。我也反对在对”娃娃”们的计算机启蒙教育中使用 Windows。因为 *Windows 不论从技术上，经济上，思想风格上都是与我们培养高科技人才的目标格格不入的。Windows 的流行属于历史遗留问题，爷爷一级的人当然已经不可救药，但是我们不应该让下一代继续走上歧途。</p>
<h3 id="UNIX-不是计算机专家的专利"><a href="#UNIX-不是计算机专家的专利" class="headerlink" title="UNIX 不是计算机专家的专利"></a>UNIX 不是计算机专家的专利</h3><p>当我建议一些非计算机专业的人用 Linux 的时候，很多人说：”UNIX 是计算机系的人用的，我们不能理解。” “UNIX 是男孩用的，我们女孩不用。”</p>
<p>但是其实世界上的大多数科学家和工程师几乎用的都是 UNIX 作为他们的电脑工具。就因为它简单，可靠，稳定，强大，有趣。甚至很多时候 UNIX 就是唯一的选择。</p>
<p>你说：”我们都会用 UNIX 的话，你们计算机专业的人还用来干什么？” 很容幸的告诉你，计算机专业的有一部分人就是专门为你们提供这样强大而方便的计算机工具的。如果他们制造的工具只有自己会用的话，那这个工具还有什么用？</p>
<p>理解 GNU/Linux 不要用 Windows 的标准来要求 Linux。</p>
<p>由于GNU/Linux这个词太长，下面如果没有特别指明，”Linux”就是指GNU/Linux”。</p>
<p>在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得”Linux 只不过是跟 DOS 差不多的东西”，那请问问你旁边的 Linux 用户，Linux 到底是什么？</p>
<p>那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和 UNIX，虽然他们也在用它，但是他们有时会问：”为什么 Linux 不能像 Windows 那样 ……？”，”怎么Redhat Linux不能 mount NTFS 分区！”，”Linux 下用什么整理硬盘？”，”什么时候OpenOffice才能完全兼容Word文件啊？”，”现在还有什么Windows能干的事情Linux干不了的？ “……</p>
<blockquote>
<p>他们有40G的硬盘，却只为 Linux 分配了2G空间，有时还抱怨”这个东西怎么占这么多硬盘！” 似乎 Windows 该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对Drag&amp;Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像 Windows 程序的 Linux 程序，一定会很高兴的说：”哈哈！Linux 也能……了！”如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux 解决问题的时候，甚至用Wine来运行Windows程序。有时实在没办法，只好重启到Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare 虚拟一个 Linux 玩。</p>
</blockquote>
<p>你如果出现了上面的情况，说明你的思想受到了 Windows 的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的 UNIX 思想。你支持 Linux，你喜欢 Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：<strong>Linux 从来就不是一个玩具，它是天才UNIX的后代。UNIX 是自晶体管发明以来最伟大的发明，它从诞生那一天开始就比 Windows 的设计出色。</strong></p>
<p>你要体会什么叫做”设计”，一个糟糕的设计并不是到后来缝缝补补就可以变好的，而一个出色的设计，不但可以以不变应万变，而且可以影响到后来者。一个出色的设计配上一个出色的实现，那就是非常出色的发明。Linux 就是这样的一个出色的发明。</p>
<p>Unix 是简单的，你不需要成为一个天才也能理解这种简单。</p>
<blockquote class="pullquote right"><p><em>Linux 并不需要追赶 Windows，也不需要打垮微软。它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。</em></p>
</blockquote>

<p>UNIX 的设计者 Dennis Ritchie 说：”<em>Unix is simple. It just takes a genius to understand its simplicity.</em>” 但是我不这么认为，因为我不是一个天才，但是我却勇敢的把 Windows 完全删除掉，遇到不明白的事情的时候努力用 UNIX 的方式去解决，而不是寻求 Windows 的帮助。现在我体会到了 UNIX 的思想和好处，我可以用比 Windows 高效几倍的效率工作。因为我相信这样的信念：”Windows 能办到的事 Linux 一定能办到，而且办的更好。”</p>
<p>这小节开头的话应该改成：”Unix 是简单的，你不需要成为一个天才或是计算机专家。但是在这个冲斥着 Windows 错误观念的世界，你需要信念和勇气才能理解它的简单。” 我下面就告诉你一些我理解到的东西。首先，你要知道的是微软在国际科学领域是根本没有地位的。</p>
<h3 id="微软的实际地位"><a href="#微软的实际地位" class="headerlink" title="微软的实际地位"></a>微软的实际地位</h3><p>微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的 MIT，Stanford 的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个”小”并不是说它人少，钱少，而是说它先进技术少。</p>
<p>我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC 作为平台。我在分析算法时还得到 Fortune 很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给 Fortune，他回信说：”对不起。我机器上没有 MFC。” 话说的很客气，但是我已经感觉到了他对 Windows的不屑。然后我把 MFC 静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。</p>
<p>你能感觉到这位科学家对微软和 Windows 是什么态度了吧？<em>不是反感，而是他心里根本没有 Windows 这个东西</em>！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！</p>
<p>好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office XP，学校的选课系统是非IE不能正确浏览，论文用 Word 编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连 863 项目都用 VC 写程序了。我很久以前就看到一份报纸说，”微软为什么不严厉打击盗版？” 这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，”以后我要你们加倍的来还我！” 确实如此，它的目的快实现了。</p>
<h2 id="计算机教育的现状"><a href="#计算机教育的现状" class="headerlink" title="计算机教育的现状"></a>计算机教育的现状</h2><h3 id="Windows-笼罩下的中国计算机教育"><a href="#Windows-笼罩下的中国计算机教育" class="headerlink" title="Windows 笼罩下的中国计算机教育"></a>Windows 笼罩下的中国计算机教育</h3><p>说句丢脸的话，比尔盖茨很久以前是我的偶像……</p>
<p>在中国，比尔盖茨被很多人奉为神圣，”少年电脑天才”，甚至有的人提到他的名字就做出”抱拳对天”的姿势。很多人谈到微软的”新技术”，”高科技” 都是眉飞色舞。各种”VC编程圣经”，”深入了解 Visual C++”之类的书，在开头几页都会出现非常肉麻的字眼，”在那团团的混沌中，一个开天辟地的精灵，Windows 1.0，诞生了……”</p>
<p>微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些 DOS 命令，打字，Windows 基本操作，Word 文档处理，PowerPoint，高级班可能有 Excel，Access…… 参加各种微软认证考试，MCSE，MSDE 的人络绎不绝。考试辅导班都贴出了”280元，考过为止”之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是”Microsoft Press”的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了 XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的 Windows XP 内部发行版。</p>
<p>“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的 Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi 编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种”初级阶段”的时候就已经用 Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！</p>
<p>我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过”中华学习机”。看到新入学的同学们各个谈论的都是 “Windows 95″，”VC”…… 我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：”你们天天谈论的瘟95是什么啊？”答： “win95就是一个操作系统，跟DOS是一类。””朵死是什么？” “你连DOS都不知道是什么？别在计算机系混了。” 学校上课当然不讲VC编程之类的东西，但是上 Pascal 的老师有一次就说：”嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC 了，我们还在讲 Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。” 于是，有些同学很多时候上课都捧着一本很重的”Windows 编程大全”之类的书，根本没有听课。吃饭时就念念有词的跟我说，”代码的优化是无止境的”，”匈牙利命名法真是伟大的发明” …… 这就是中国很多大学计算机系的情况。</p>
<p>感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，X window的人一旦说 UNIX 好，X window 好的时候，都被一群人围着说教：”这个 Windows 也能做到”，”你对 Windows 有偏见”，”微软才是主流啊”，”你敢瞧不起 win2k？”，”.NET 就是世界潮流”，”微软的毕竟是新技术”，”有钱就是有技术”…… 甚至在一番论战比较后败下来还是要说：”Windows 性能差点，但是易用性强”，”Windows 是老百姓用的，要求别那么”，”微软那么有钱，以后想超过 UNIX 还不容易吗？”……</p>
<h3 id="发达国家的计算机教育"><a href="#发达国家的计算机教育" class="headerlink" title="发达国家的计算机教育"></a>发达国家的计算机教育</h3><p>我前段时间在 USENET 发文问有关 Scheme 语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很”深奥”的有关程序语言语法，文法的书，他告诉我很多网站可以学习 LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 “Syntactic Closures”。他还打包给我寄过来一份 MIT 的 “How to Design Programs”。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行Scheme 程序。他对 Emacs 的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme 解释器。这对于我来说是望尘末及了。</p>
<p>他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，他是丹麦一所普通高中的计算机老师。</p>
<p>他说他在高中里讲授程序设计和算法，计算机语言文法。他说用 Scheme，他的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。</p>
<p>天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！</p>
<h3 id="微软和它的朋友们的如意算盘"><a href="#微软和它的朋友们的如意算盘" class="headerlink" title="微软和它的朋友们的如意算盘"></a>微软和它的朋友们的如意算盘</h3><p>下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是 100多美元，每次升级又是几乎同样的价钱。Windows NT 还要贵几倍，而且有用户数目限制，5个用户的，10个用户的…… 以后如果要增加用户数目还要按比例付钱。</p>
<p>花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上Windows 之后一般第一件事就是去下载一个 WinZip 吧，”只要 29 美元”。Windows会中病毒啊，马上花 70 美元买一个 Norton AntiVirus 吧。还有黑客呢？再买一个Norton Internet Security 好了，100 美元。系统需要优化，磁盘需要整理，买一个Norton System Works 是你最佳的解决方案，100美元。</p>
<p>可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套 Office XP 吧，一起买便宜些，459.90美元。</p>
<p>那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看”帮助”也学不会。买本书看看吧，我推荐”<em>Special Edition Using Microsoft Office XP</em>”，不贵，才28美元。又由于这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，17.85美元。</p>
<p>你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为 Windows程序员。首先买一个 Visual Studio.NET 吧，要不然怎么编译程序。494.95美元。</p>
<p>为了紧跟微软动向，世界潮流，不能不注册个 MSDN 什么的吧？这个贵一点，不过物有所值啊，2,799美元。</p>
<p>嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样”自由”的，”安全”的生活了。</p>
<h3 id="反对使用Windows的原因"><a href="#反对使用Windows的原因" class="headerlink" title="反对使用Windows的原因"></a>反对使用Windows的原因</h3><p>很多人都说不应该完全否定 Window，Windows 也有它的长处。不应该骂微软。</p>
<p>对。 Windows 容易操作，适合普通用户。如果微软把它自己定位在 P&amp;G，Philips 那样的地位，能够给我们的百姓提供周到的，完善的，价廉物美的服务。那我肯定是很喜欢它的。但是从上面的种种情况说明，微软是一个野心极大的国际垄断组织！它的产品没有一个是不出问题的：Windows 不稳定，容易中病毒，而微软不为大家免费提供杀毒软件。我就是要让你们花钱买我的朋友 Symantec 的杀毒软件，谁叫你们已经上了我的贼船？这叫什么售后服务啊！</p>
<p><em>你买来微软的程序，安装的时候一般都有一个协议，说：” 由于微软的程序造成你的数据损坏或丢失，微软概不负责。” 我想很多人肯定觉得这个不合理，不想按那个 “I accept”。但是你的软件买都买来了，钱都花了，现在一按 “I decline”，安装程序马上就会退出。你只好被迫点击了 “I accept”！这不是不平等条约吗？</em></p>
<p>我已经目睹了好几个朋友的文档被 Microsoft Word 损坏，有的是编辑了十多天的30多页的论文，有的是费了很大工夫做出来的个人简历，那个朋友为此失去了到自己向往的P&amp;G 工作的机会。就在他要投简历的前一个晚上，就在那一瞬间…… 不知道他痛哭的时候有没有想起要投诉微软，可是谁叫我们用的都是盗版呢，况且你还点击了 “I accept”。</p>
<p>微软仗势已经占有大部分PC市场，制定不符合国际标准的”微软的标准”，以不合理的方式压制其它公司的软件，这个问题已经在美国司法部闹了很久了。他甚至在 Windows系列操作系统中放置能够通过网络泄漏用户信息的代码，以至于 Windows 刚进入澳大利亚时被澳大利亚政府禁止使用。</p>
<p>有些人说：”微软毕竟开创了一个历史，造就了今天的 IT 行业。” </p>
<p><strong>但是，如果没有微软，我们今天早就用上非常稳定，非常可靠，非常方便，非常”傻瓜”的软件了！微软是阻挡信息技术发展的罪魁祸首。</strong></p>
<p>微软的程序的工作方式(注意，我只是说操作方式，病毒的事情另外算)确实适合于一般家庭，上上网，发发邮件，打打游戏都不错。可是微软却要把自己包装成什么 “高科技”企业，要在世界各地设置”研究院”，在大学计算机系赠送不适合用于科研的 Windows产品，甚至出钱请图灵奖得主来中国畅谈”二十一世纪的计算”，还在大会上宣传自己的 .NET 技术。非要把别人认为自己是科学的，自己是领导世界高科技的。但是呢？它什么高科技也没有。欧洲，美国，哪一个关键部门在用微软的东西？NASA? DOE? CERN?你仔细想一想，微软的程序对人类到底有什么重大作用？</p>
<h2 id="Windows与Linux的比较"><a href="#Windows与Linux的比较" class="headerlink" title="Windows与Linux的比较"></a>Windows与Linux的比较</h2><p>“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”</p>
<p><em>有个朋友看我半年没有用 Windows，有时就会问我：”你只用 Linux，有没有发现有些Windows 能处理的事情 Linux 干不了？”<br>我回答说：”Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。”</em></p>
<h3 id="Windows-能做的有益的事情-Linux-都能做"><a href="#Windows-能做的有益的事情-Linux-都能做" class="headerlink" title="Windows 能做的有益的事情 Linux 都能做"></a>Windows 能做的有益的事情 Linux 都能做</h3><p>Windows 下的某些功能确实是我们需要的，那么 Linux 的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比 Windows 的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX, 所以几乎所有商业的科学工程程序，比如Matlab, Mathematica, AutoCAD, Candence的，Synopsys的，Avant! 的……全都是先有UNIX 的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给Windows，因为 Windows 的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有 PSpice, UNIX 的 HSpice 要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。</p>
<p>但是 Windows 下有些东西在 Linux 下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows 的那个程序都要差很多，那么原因有两种可能性：</p>
<p>有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于 Gtk, Qt 的诞生，Linux 下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。当然也有一流的程序用 Gtk 和 Qt，比如 GVIM 就可以用 Gtk 作为图形界面，我还知道 Synopsys 一些程序用了 Qt。</p>
<p>我曾经也犯过这样的错误，从外表区分一切。结果优秀的 FVWM, lftp, Mutt, wget 都被我忽略过。当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友 我第一次看到 FVWM 觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM 都说：”哇！真漂亮。”</p>
<p>有另一种完全不同的方式可以达到相同的目的，甚至更好。</p>
<p>很多人很关心 Open Office, Star Office, AbiWord, … 他们多么盼望有一天某一个Linux 程序能够完全兼容的打开一个复杂的 doc 文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式。它一定会不断变化 doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc 文档时总是有某种问题，从而你必须购买 Microsoft Office 和 Windows。</p>
<p><em>你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是 Linux 或者其它类型的 UNIX，他们没有 Word 可用，怎么处理文档呢？这么多年没有一个像Open Office 的程序出现，难道大家没有办法写文档吗？</em></p>
<p>显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的幻灯片，它们是什么做的？原来 UNIX 用户早就有非常方便的 troff, LaTeX, SGML等东西可以处理文档，而且它们比起 Word 都要高明的多。Word 显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word 的程序，除非某些公司想抢微软的饭碗。</p>
<p>很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和 PowerPoint。我见过一个教授，他的 Windows 笔记本电脑上除了 PowerPoint 什么都没有。有一天演示的时候，他指着堆乱字符说：”对不起，这是一个公式……怎么每次都是这样……” 其实有比PowerPoint 好几百倍的东西可以制造幻灯片，你可以用最简单的方法制造世界一流效果的论文和幻灯片。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开 Windows。</p>
<h3 id="Windows-能做的那些没用的事情-Linux-永远做不好"><a href="#Windows-能做的那些没用的事情-Linux-永远做不好" class="headerlink" title="Windows 能做的那些没用的事情 Linux 永远做不好"></a>Windows 能做的那些没用的事情 Linux 永远做不好</h3><h4 id="电脑游戏"><a href="#电脑游戏" class="headerlink" title="电脑游戏"></a>电脑游戏</h4><p>有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux 下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike, 没有 Star Craft, ……</p>
<p>并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。</p>
<p>你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony Hawk’s Pro Skaters 里滑板…… 但是 It’s not real！你虽然有很高的”反恐技巧”，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制 Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在 THPS 里作出一个 “360 kickflip to hangten grind to fakie”，但是你踩在自己的滑板上的时候还不会 ollie！</p>
<p>说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows + PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo 的 N64，Namco的街机……每一个都比 Windows 游戏精彩，每一个都有如此高的3D性能，以至于Pentium4, Itanium + GForce4 都无法与它们比美！</p>
<p><em>Linux 的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么 Linux 几乎没有游戏了吧？</em></p>
<h4 id="“整理硬盘，优化系统“"><a href="#“整理硬盘，优化系统“" class="headerlink" title="“整理硬盘，优化系统“"></a>“整理硬盘，优化系统“</h4><p>这是一个非常有意思的话题，仅次于有关”病毒”的话题。相信很多 Windows 用户都有整理硬盘的经历。在很多 Windows 用户眼里，”硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。</p>
<p>我也曾经津津有味的看着 Norton Defrag 一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告100% 没有碎片。你的硬盘现在已经达到最佳状态。” 我现在才发觉我那时是多么的幼稚。</p>
<p>Linux 和 UNIX 用户似乎从来没有”整理硬盘”这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX 的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！</p>
<p>Linux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux 用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS 高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以”越用越整齐”，”越用碎片越少”！你应该把文件大部分放在 Linux 的分区，而不是 Windows 分区，因为它比 Windows分区可靠得多。</p>
<p><em>还有更滑稽的事情就是有很多”Norton System Doctor”，”Windows优化大师”，”超级兔仔注册表魔法” 之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来”优化”它，而且为了得到优化，你需要付钱！这些问题 Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。</em></p>
<h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux 现在已经有一些IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望 Linux 某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用 IDE？你说：”IDE 开发迅速，调试方便，适合大型程序……” 那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。</p>
<p><em>高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。</em></p>
<p>你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，X window 程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE 弄的，我还知道Candence, Synopsys，Mentor 的高性能的图形界面 EDA 程序也都不是 IDE 写的。你信不信，微软的人在写 Windows 本身的时候也根本不用 IDE。微软内部程序员最喜欢的编辑器其实是 VIM，用 VIM 的微软程序员上次向乌干达的可怜儿童捐助了1000多美元，这是值得称赞的。</p>
<p>有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus 在内，没有一个人用IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说”GNU Emacs is evil”，但是其实他用的是一种跟 Emacs 有同样键绑定功能的 MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make 这样的自动工具调用 gcc 编译器完成编译工作的。甚至高级的 Windows 程序员也不用 IDE，他们可以从命令行调用 cl，nmake 来编译自己的程序。虽然这样的 Windows 程序员很少，但是他们却是最了解 Windows，最高明的Windows 程序员。</p>
<p>为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX 的设计思想了。首先，一个 IDE 集成了编辑器，编译器，汇编器，调试器，跟踪器…… 这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上 as，调试器比不上 gdb，ddd, 跟踪器比不上 strace, ltrace, truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套 IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮…… 跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。</p>
<p>而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM 里可以调用GNU make，make 可以调用 gcc, ld, … make 的出错信息可以被 VIM 捕获，VIM 能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是 gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd 来显示各种数据结构之间的关系。你还可以在 Emacs 里调用 gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs 还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件…… 你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin 都可以在内部使用 VIM，这样就更方便了。实际上 make 在其它方面还能帮你很多忙，我的每一个比较大型的 LaTeX文档都是用 make 维护的。</p>
<h4 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h4><p>   我在 Windows 下做过的一件最傻的事情莫过于“释放内存”了。有一天我看到一个 Windows 程序说：“这个程序可以帮你把大量内存释放出来给一个很大的程序用。”我试了一下，居然一下把我的 64M 内存释放出来 48M！我高兴极了。现在想一想，那是多么傻的事情，那么多的内存留着干什么？不用白不用啊！一个操作系统，居然还需要别人写的程序来释放内存，那是什么样的操作系统？</p>
<p>在 Linux 下用 free 命令，你会发现你的内存几乎每时每刻都快要被用完。那是因为 Linux 把大部分内存用来作为磁盘缓冲了。Linux 有比 Windows 先进的磁盘缓冲技术。你有没有发现你往硬盘写数据的时候，很快就完成了？那是因为 Linux 在内存里有很多磁盘缓冲区，你要写到硬盘上的数据先被写到了这些内存里，然后Linux 就告诉你“拷贝完成”，当你马上又想删除刚才写入的某些数据时，Linux 只是把数据从内存里移除，然后报告“删除完成”。在一定的间隔时间后，Linux才把数据写回硬盘，这样不但高效，避免了多次硬盘操作，而且减少了文件的不连续，也就是减少了“碎片”。Windows 当然也有磁盘缓冲，但是由于它内存管理的低效率，它不敢把大量内存都用来作为磁盘缓冲，因为它没有能力在用的时候随时把内存收回来。</p>
<h3 id="Linux-能干的高精尖的事情-Windows-都干不了"><a href="#Linux-能干的高精尖的事情-Windows-都干不了" class="headerlink" title="Linux 能干的高精尖的事情 Windows 都干不了"></a>Linux 能干的高精尖的事情 Windows 都干不了</h3><p>当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC 机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC 机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows 的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows 机器是以”死机”著称的，我们怎么能放心？</p>
<p>所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows 的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过 Windows 版本的 Mathematica 和 Linux 的有什么区别吗？</p>
<p>下面举几个其他的例子：</p>
<ol>
<li>IBM 制造的最大的并行计算机有 8000 多个处理器，Windows 不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。</li>
<li>《泰坦尼克号》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是 Linux 机器做的。</li>
<li>民航总局用来训练地情人员的虚拟现实训练设备，Windows 当然无能为力。那都是商业的 IRIX 机器。</li>
</ol>
<p>UNIX 是最早支持 TCP/IP 网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997年，微软的比尔盖茨还在扬言：”Internet 是没有前途的。” 微软的这个”远见卓识”大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。</p>
<p><strong>其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。</strong></p>
<h3 id="Linux-干不了的有用的事情-Windows-照样干不了"><a href="#Linux-干不了的有用的事情-Windows-照样干不了" class="headerlink" title="Linux 干不了的有用的事情 Windows 照样干不了"></a>Linux 干不了的有用的事情 Windows 照样干不了</h3><p>当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是 Linux干不了的事情，Windows 肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux 必定是你的好伙伴。</p>
<p>不要把Linux和X window掩盖起来！不要把我们的用户当成傻瓜。</p>
<p>什么？你早就知道 Windows 是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。</p>
<h2 id="怯除Windows流毒"><a href="#怯除Windows流毒" class="headerlink" title="怯除Windows流毒"></a>怯除Windows流毒</h2><h3 id="拒绝用Windows的方式思考问题"><a href="#拒绝用Windows的方式思考问题" class="headerlink" title="拒绝用Windows的方式思考问题"></a>拒绝用Windows的方式思考问题</h3><p><em>“好了，现在我已经知道windows是垃圾了，那么我应该用什么？”</em></p>
<p><em>“Linux + X window”</em></p>
<p><em>“那我问你，X window 是什么样的？”</em></p>
<p><em>“不就是跟 Windows 差不多吗？只不过 ‘Start’ 按钮比较方，而且上面不是一个Windows 标志，而是一个脚丫子。点击一下居然还有很漂亮的中文菜单。我喜欢！”</em></p>
<p><em>“你知道什么是’根窗口’吗？”</em></p>
<p><em>“不知道。从来没听说过呢？”</em></p>
<p><em>“根窗口就是遮盖整个屏幕的那个最大的窗口。”</em></p>
<p><em>“哪儿有什么窗口啊！我没有看到呢？”</em></p>
<p>你发现了问题吗？这些 Linux 用户说是在用 Linux 和 X window，但是他们对 Linux和 X window 几乎完全不了解。很多人用了那么久 X window 都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和其它程序有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口? quot;class name”，”resource name”是什么东西。他们也不知道.Xdefaults 是用来干什么的。特别是他们很多人都不知道 X window 的字体是如何命名的，什么是 fontset，有了一个新的字体也不知道怎么安装。</p>
<p>他们被遮在 Linux 之上的一层一层的包装迷惑了，他们等待有图形界面的工具来帮助完成一切事情，他们认为 Linux 跟 Windows 一样，只是麻烦一点。他们知道 Linux内核很好，但是他们感觉不到 Linux 和 X window 在操作层面的天生的先进性，随后不久就把 Linux 完全删除掉了。你发现没有，要用户理解 UNIX 和 X window 的操作层面的先进性，才是留住用户的最好办法。如果用户体会不到操作时的方便和高效，内核再好他们也不会理会。</p>
<p>但是用摹仿 Windows 的作法来吸引用户，永远会失败的。因为 Linux 如果摹仿Windows那一套低效率的方式，那么 Linux 的这套”低效率方式”永远比不上Windows 的那一套”低效率方式”。那么用户就会说：”这个 Linux，没有一样比的上 Windows。”</p>
<p>Linux 天生就是继承了 UNIX 的高效的工作方式，为什么我们要把它掩盖起来？我们为什么只告诉用户 KDE 的菜单怎么用？我们为什么不能像早期的 X window 书籍那样第一节就告诉用户什么是 X server, 什么是 X client，什么是 Window Manager, 什么是根窗口。第二章就告诉用户窗口有哪些属性，什么是 classname, resource name, hint，怎样使用 .Xdefaults, xrdb ……</p>
<p>在这里我又不得不说一下那些 Linux 的发行公司和写书的人，他们把 Linux 和X window 包装起来，却没有从基本上告诉用户 X window 的工作原理。很多书籍讲授的层次就是在Gnome, KDE 的菜单操作的层次，靠大量抓图来占篇幅，”繁荣”Linux 书籍市场。</p>
<p>现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这”图形化”，”可视化” 的年代，你如果还在用 troff, LaTeX 写文档，你还在用VIM 自己编辑 HTML，用 Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用Xlib 写程序, 你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩 Clossal Cave 这样的字符模式冒险游戏，那你就是老古董。</p>
<p>其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是 Windows的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你还是没能摆脱微软给你的潜移默化的东西。<strong>如果你离不开 Windows 那样的环境，你迟早会删掉自己的 Linux。</strong></p>
<h3 id="GUI-vs-CLI"><a href="#GUI-vs-CLI" class="headerlink" title="GUI vs. CLI"></a>GUI vs. CLI</h3><p>做一个坚定不移的”两面派”！</p>
<p>大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了：</p>
<blockquote>
<p>GUI派用户：”哇！我一看你这小子就是 CLI 的。要不然自己写什么 Makefile？用什么Mutt？”</p>
<p>CLI派用户：”切～ 你还用 X！高手都不用 X。你是 GUI 那边的。”</p>
<p>可怜的我：”555～～ 你们都不要我～～ GUI 和 CLI 就那么水火不容吗？”</p>
</blockquote>
<p>计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command LIne)的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个 SecureCRT 登录到Sun 机器，然后用一个 vanilla vi 编辑程序，我建议他启动一个 GVIM 过来显示在Exceed 上可以有语法加亮。但是他坚决反对，说：”高手不用X。你想想，要是我在一个很慢的网络连接怎么用 X？而且好多服务器没有装 X 程序。”</p>
<p>但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun 机器有全套X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用 Windows，他后来打开了好几个 SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择”SSH2″，然后点击”Connnect”。他还不断的夸SecureCRT 是”网络管理员投票选出的最受欢迎的登录方式”。老天，SecureCRT 本身就是个 GUI 啊，他其实没有明白X window 的好处。</p>
<p>你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM 很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用 Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用 VIM 编辑 LaTeX。我自己写Makefile 来维护 LaTeX 文档。我有时用 mpg321 来放 mp3。我上BBS用的我自己写的expect 脚本。 好了，CLI 派的朋友可以收我做盟友了</p>
<p>你说我是 CLI 的老古董？我的 FVWM 被我配置为可以”手写操作”，我只要画一个”r”就可以启动 rxvt，我只要画一个 “U” 就可以启动 GVIM，…… 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla 浏览网页，…… GUI 派的现在好像认我做朋友了</p>
<p>好了。CLI 派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Module FvwmConsole -terminal rxvt -geometry 45×5-0+0 \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-<span class="built_in">bg</span> gold -<span class="built_in">fg</span> midnightblue \</span></pre></td></tr><tr><td class="code"><pre><span class="line">-fn “-adobe-courier-medium-r-*-*-14-*-*-*-*-*-*-*”</span></pre></td></tr></table></figure>


<p>你是不是现在又想把我逐出师门？</p>
<p>GUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">All (rxvt) MoveToDesk</span></pre></td></tr></table></figure>

<p>把我所有的 rxvt 移动到我现在工作的桌面。”这家伙，怎么这么快就叛变了！”</p>
<p>其实何必分什么 GUI 和 CLI，UNIX 和 X window 都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI 还是命令行的都可以互相协作。UNIX 和X window是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI的模糊界线吗？我就是坚定不移的”两面派”。</p>
<h3 id="UNIX的真谛何在"><a href="#UNIX的真谛何在" class="headerlink" title="UNIX的真谛何在"></a>UNIX的真谛何在</h3><h4 id="UNIX-是简单的"><a href="#UNIX-是简单的" class="headerlink" title="UNIX 是简单的"></a>UNIX 是简单的</h4><p>“我相信简单就是最好，如果太复杂，我是不能理解的。” -Seymour Cray</p>
<p><em>很多第一次用 Linux 的人会惊奇的发现，Linux 的程序居然不”安装”就可以运行，程序拷贝到随便那个目录都可以用，而不是一定要占用你第一个分区的空间。程序的设置只是一些简简单单的文本文件。你根本不需要什么”注册表修改器” 就可以改变系统的设置。这就叫做简单，但是简单就是美。虽然这只是 UNIX 简单性的一个肤浅的认识，你已经体会到了某些东西。</em></p>
<p>但是简单并不意味着功能弱，并不意味着落后。相反，简单意味着强大，意味着生命力。</p>
<p>我不会再继续阐述我理解到的”UNIX 的简单”，因为这个需要自己去体会。</p>
<h4 id="UNIX-是永恒的"><a href="#UNIX-是永恒的" class="headerlink" title="UNIX 是永恒的"></a>UNIX 是永恒的</h4><p>有人说：”Plan9 会取代 UNIX，Mach 会取代 Linux 内核。”</p>
<p>但是你如果是一个深入体会了 UNIX 的人，你就会知道：UNIX 的思想是永恒的，不管时过境迁，Plan9 是否代替 UNIX，UNIX 的灵魂都会在 Plan9 身上现形！</p>
<p>我为同一个设备写过 Linux 内核和 Windows VxD 驱动程序。写 Linux 驱动程序时，我对 UNIX 设计的完美的一致性，远见性所折服。UNIX 用同样界面的 read(), write()系统调用就可以对不同的对象：普通文件，设备文件，管道，管道文件，socket，……进行统一的读写操作。我跟本不需要写一个测试用的应用程序就可以对我的设备驱动进行测试，因为 cat, cp, dd, 它们也使用了同样的 read(), write()，设备和普通文件在应用程序眼里没有区别。在那个还没有 Smalltalk, 没有 C++ 的年代，UNIX 的设计者已经使用了所谓的 “面向对象方法”。对，C 语言也可以实现面向对象。</p>
<p>UNIX的系统调用几十年都没有很大变化，这非但不是顽固，不进步的象征，反而是UNIX 的远见卓识的体现！这就跟 TeX程序几十年都不变的情况差不多。这些才是真正的永恒的 master piece!你应该改变所有软件都必须从 0.1, 1.0, 1.1, 1.2, 2.0, …, 3.0, 3.1,95, 98, 2000, XP, … 不断升级的想法。</p>
<p><em>Windows 就不同了，它在最开头只是一个 DOS之上的图形包装而已。后来为了兼容以前的糟糕设计，不得不加上很多累赘。我写VxD 驱动程序的时候就深有体会，Windows 95 程序对设备的操作只有用DeviceIoControl，我不得不写了两个应用程序来对设备驱动进行测试。Windows内核的不一致性和隐密性使我非常恼火。不过 Windows WDM驱动程序现在也有了 ReadFile, WriteFile，…… 那说明什么？那说明Windows 在向 UNIX 学习，或者有可能是某个 UNIX设计人员在微软打了几天临工，顺手加了几个UNIX的东西进去。这样做是没有用的，Windows从一开始就是非常糟糕的设计，它的历史的包袱太沉重了，缝缝补补有什么用？它只能永远的被UNIX 甩在身后！</em></p>
<h4 id="UNIX-是强大的"><a href="#UNIX-是强大的" class="headerlink" title="UNIX 是强大的"></a>UNIX 是强大的</h4><p>让聪明人干任何他们想干的事情。</p>
<p>UNIX 的一个特点就是非常高的灵活性，X window也具有这种灵活性。这种灵活性体现在哪里呢？</p>
<p>UNIX 的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个.inputrc 文件，就可以把它变成 vi的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误……</p>
<p>UNIX程序设计的思想是提供给用户“机制”，而不限制用户制定“政策”。这是一个重要的尊重用户的作法。</p>
<p>我们再来看看 X window。X window是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的X程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件…… 比如有时我的 XFree86 上会出现四个不同机器上的XTerm，两个不同机器上的 GVIM，…… 它们统一受本机上的 FVWM指挥。</p>
<p>X window 程序都具有很多很多命令行参数和 resource参数。你可以随意的在命令行或者 .Xdefaults文件设置所有的颜色，字体，尺寸…… 而且如果你用 xrdb 把 .Xdefaults导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。</p>
<p>X window 的窗口具有 Property,也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property的存在，使得 X window 具有无比强大的生命力。X的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了ICCCM(客户程序间通信规范)，这个规范就是通过 property定义的。现在又有人定义了一套“扩展的窗口协议(EWM Hints)”，使得X window 可以具有某些 Windows 的特征，比如一个工具条程序可以告<br>诉窗口管理器：“这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。”</p>
<p>一个强大的窗口管理程序比如FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！</p>
<p>你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 “Yes orNo”？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？</p>
<p>还有就是很多 Windows程序把人当成傻瓜，而它是“智能程序”。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。</p>
<p><em>如果连“一句话开头一个字母要大写”这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。</em></p>
<h4 id="只有符号才能完全操纵计算机"><a href="#只有符号才能完全操纵计算机" class="headerlink" title="只有符号才能完全操纵计算机"></a>只有符号才能完全操纵计算机</h4><p><em>我们来说说很多初学 Linux 的用户。虽然他们在用 Linux，但是他们打心眼儿里是觉得 Windows 的工作方式好，他们希望 Linux 有一天能”像Windows那样”。你说：”我鼠标一点，我菜单一拉，…… 就可以完成我的操作。” 但是我要告诉你：”Linux 从来没有摹仿 Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows 的先进。Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。”</em></p>
<p>看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget,tin, … 没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置?难道它们的设计者就那么低能，连个图形配置界面也写不出来?</p>
<p>当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配 置文件的效果，你需要成百上千的菜单，checkbox, radio button, … 到时候你根本没办法找到你需要修改的地方了!而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，…… 一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed, Perl，你会觉得那才是真正的自动化啊。</p>
<p>鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。</p>
<h4 id="各个小程序的完美配合"><a href="#各个小程序的完美配合" class="headerlink" title="各个小程序的完美配合"></a>各个小程序的完美配合</h4><p>这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。X window也继承了这种好传统。</p>
<p>这恐怕就是Windows和其它操作系统望尘莫及的地方了。UNIX 程序设计之统一，配合之完美，真使我难以置信!shell, grep, find, awk, sed, make, Perl,Emacs, vi, tin, Mutt, … 它们是那么的具有一致性!你一旦学会了 sed 的正则表达式，其它程序基本上都能用了。你一旦学会了 vi 和 VIM, 你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了 VIM 在今天的完美而统一的操作方式!而且vi的操作还体现在 Mutt, tin 等很多程序中。你甚至可以把 bash 设置为 vi 的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里”嵌入”另外一个程序。</p>
<p>在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在Windows 下使用 Perl来进行一些自动工作。但是 Windows 的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual Studio 窗口里面嵌入UltraEdit 编辑器，你别想用一个 expect 脚本来控制 telnet 到水木清华BBS，这就是为什么 helloooo 诞生在 Linux 而不是 Windows。我曾经试图从Windows + Exceed + SecureCRT ssh 登录到 Sun 机器，然后通过 ssh 的隧道(X11 tunnel)把 X 程序传到 Exceed 上运行，但是搞了两天都没有成功!而在Linux 下这个事情根本就是不用怎么配置的，OpenSSH 和 XFree86 本来就是完美结合，只要打开 ssh 的 “forward X11″ 选项就什么都搞定了。</p>
<p>Windows 的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的 Virtual Terminal, 自己的通讯代码。每一个 IDE 都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织…… 不能 DIY!</p>
<p>你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的乒乓球拍，木板，胶皮，海绵，胶水都是可以自己选择…… 而用Windows 程序，你得到的是大杂烩，就像你去买”品牌机”，只有那么几种配置，而且附带很多你不需要的软件和服务;就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地! Windows 程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必须重新买全套配件!</p>
<p>而 UNIX 和 X window 就是高档的”组装货”。比如我用 Mutt 的时候，我可以用VIM 也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv 来显示附件里的图片，我可以用 lynx 把 HTML 附件转成文本嵌入窗口中，我也可以把HTML 附件交给 Mozilla 图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它 PGP 程序。</p>
<p>我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail 帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理…… 这一切我都可以办到!我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。</p>
<h4 id="学UNIX绝对不是浪费时间"><a href="#学UNIX绝对不是浪费时间" class="headerlink" title="学UNIX绝对不是浪费时间"></a>学UNIX绝对不是浪费时间</h4><p>有人告诉我：”你看我用 Windows 什么都不用学。而用 Linux，光是安装就花了我一个星期！” </p>
<p>首先，我要告诉你的是，你装 Linux 花了一个星期，不是因为 Linux 不好装，而是因为你已经习惯了 Windows，对 Linux 最初难以理解而已。你想一想你最初安装Windows的时候呢？你花了多少时间搞明白什么是硬盘分区？什么是盘符？什么是目录？你认为Windows 就是那么容易可以学会的吗？虽然你觉得没花时间学，但是你以前在用别人的机器的时候已经耳濡目染，自然就了解了。而且由于你想要 Linux 和 Windows 并存于硬盘上，又增加了安装难度。而且你肯定没有得到有经验的 Linux 用户的帮助，否则他们会在20分种之内帮你搞定。一个星期也太夸张了. </p>
<p>如果一开始用的就是Linux就没有这个问题。你想想如果你没有用过 windows，你肯定会很习惯 /etc, /usr, /usr/local ,… 而不是 C:, D:, E:, … 是不是？如果你只用过Linux，你第一次用 windows 时恐怕也会问：”/bin 目录哪里去了啊？” </p>
<p>最重要的是，你用惯了的UNIX工具，它们可以伴随你一生，而不会那么容易变化或消失。你可以永远不用再换另外的工具了。除非那个工具比你这个好的太多，而且可以完全模拟你现在的工具。</p>
<p>我们实验室一个60多岁的老师，用vi, cc, make, …都几十年了，他以前的经验绝对没有白费，而且教会了我们一批又一批的学生。vi 伴随着 UNIX 的最初发行而诞生，直到今天还是世界上头两号编辑器之一！有些人的 FVWM 配置文件已经用了 10 多年，现在完全不经修改还可以用。 </p>
<p>看看 Windows 的工具，你从 Borland C++ 换到 VC, 就必须适应新的环境：菜单不同了，颜色不同了，按钮不同了，帮助信息不同了，热键不同了，编译器参数，调试器功能也不同了，…… 那个时候恐怕花要花你很多时间去适应。当你刚刚适应了 VC, 你又要换成VJ, PowerBuilder, C++Builder, … </p>
<p>很多windows程序员都是这样，开头在dos下用Turbo C, 然后是 Borland C, VC, C++ Builder,VS，VSC ……不断追赶微软的潮流。而且微软的SDK, MFC, .NET …… 什么都在不断变化，不断出问题，又不断的在修改…… Windows 程序员不得不买又厚又重的 Microsoft Press 的书籍，看了才一个月，又过时了。今天你才学会了写 VxD，明天你就必须用WDM 了。你不得不注册 MSDN 才能赶上 Microsoft 的步伐。很多人说：”计算机是贵族的专业。” 这就是微软一手造成的。 </p>
<p>这些东西才是没完没了的浪费大家的时间和金钱的。这是在浪费生命！我们为什么不使用从诞生就那么一致和完美的 UNIX？你需要理解先进工具的设计理念。UNIX 的工具就像我们用的汽车，它的离合器，油门，刹车，方向盘，后视镜，永远都在同样的位置。用惯了的话，你对你的汽车的每一个部件都会了如指掌，甚至你自己都可以修车了。这难道不好吗？ </p>
<p>有人说：”你说我们需要了解 UNIX，难道你要开车还必须了解汽车的结构吗？” 你去问问开车的司机，哪一个不了解汽车的结构的，那他的驾照就是混来的。你难道想要傻瓜型的”微软牌汽车”吗？我们来看看： </p>
<p>你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱。车上的防撞气囊不时会冒出来，说是为了你的安全。每开100英里要大修一次，每过一年要换一次引擎。附带的，你还必须换用由微软汽车公司指定的石油公司提供的新型号的机油。你的车出了问题，但是法律规定，你不准私自拆开你的汽车来修理，你必须到微软汽车公司指定的维修点去，需要付相当多的钱才能修好一个小毛病。 </p>
<p>最可气的是，你每换一个型号的微软牌汽车，它的刹车和离合器都在不同的位置，你需要重新去考驾驶执照。如果这辆汽车在途中刹车失灵，你受了重伤，你也不能状告微软汽车公司，因为你买来汽车之后必须签一个合同，说”<strong>由于微软牌汽车对你和家人造成的一切死伤，微软概不负责。</strong>“ </p>
<h4 id="怎样完全用-GNU-Linux-工作"><a href="#怎样完全用-GNU-Linux-工作" class="headerlink" title="怎样完全用 GNU/Linux 工作"></a>怎样完全用 GNU/Linux 工作</h4><p>说了这么多 Windows 的不好。我还没有告诉你我怎么用 Linux 处理有些必要的事情。半年以前我由于中文老是配置不好，一直是双系统，不时需要重启到 Win2k 来处理汉字。后来我找到了 miniChinput, XSIM 和 SCIM 输入法。这下可以处理汉字了。而且 VIM 和Emacs 对汉字支持越来越好。我的大部分文本是用 VIM 编辑的，包括程序，信件，网页，LaTeX 论文，MetaPost 绘图语言。 </p>
<p>我不用 Word 这样的程序写论文，而是用 LaTeX，因为这是世界上效果最好，最方便的论文工具，是大多数学术杂志要求的格式。幻灯都是用 ConTeXt 做的，用起来很简单，而且效果非常漂亮。你可以看看我的TeX介绍。 </p>
<p>至于绘图，你可以用很多可视化的工具，比如 xfig，dia。但是对于我来说，任何可视化的工具都不能完成某些任务，我需要一种可以精确描述图形的语言。我找到了MetaPost。它简单又好用，而且效果是世界一流的。我的插图，如果不是图像，都是MetaPost 画出来的。 </p>
<p>我曾经抱怨 mozilla-mail经常突然消失，损坏我好几封快要完成的信件。后来我发现mozilla 的邮件处理程序确实是不稳定的，功能又弱，有经验的 UNIX 用户都不用这样的程序。Mutt 是一个非常稳定可靠的 UNIX 邮件处理程序，而且功能非常强大。我曾经为 Gnome 和 KDE 的不稳定而烦恼。现在我找到了非常强大的 FVWM。KDE，Gnome也能和 FVWM 一起工作。虽然 Gnome 和 KDE 总体不稳定，但是某些部件程序还不错，很多 gtk, Qt 的程序也很不错，它们很多都是可以独立于这些桌面环境运行的。 </p>
<p>Linux 有很多强大方便的工作方式是 Windows 没有的，或者有类似的东西，但是很差劲或者用起来不方便。比如 ssh 服务，rsync，cvs，expect ……  </p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我写这么多的目的是什么?</p>
<p><em>我希望喜欢 Linux 的朋友，完全清除微软和Windows 灌输在你脑子里的谬论，别再相信它们所谓的”新技术”，别再追赶Windows，因为追赶 Windows =倒退。</em></p>
<p>马克思有一个思想很重要，”新生事物并不一定是在最近出现的。” UNIX，X window, TeX 虽然都比 Windows 先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。</p>
<p>消除学计算机很难的幻觉，勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt ……这样强大的程序，勇敢的面对符号。不要再埋怨”Linux 为什么不能像 Windows 那样”，不要再浪费时间试用这样那样的程序，不要再忙着升级。</p>
<p>我希望小学，中学的计算机老师能够提高自己的素质，在孩子们的启蒙教育中充分利用Linux的特点，引起孩子们对数学，对符号的好奇心。诱导他们用计算机来解决世界上的有趣问题，而不要把教学的范围局限于计算机的操作和它自身的问题。 </p>
<p>你需要理解 UNIX 的工作方式，因为那是大多数科学家的工作方式。<strong>是你需要改变而不是 Linux 和 UNIX</strong>。Linux 现在就可以成为你的好朋友。你需要认识它，了解它，信任它，才能完全的靠它来高效的工作，省出时间来处理世界上更加值得处理的事情。</p>
<p><em>当然，在游戏机，手机，掌上电脑里，或者在用电脑来娱乐的时候，用一些”傻瓜软件”还是不错的。</em> </p>
<h2 id="附录1：Linux程序推荐"><a href="#附录1：Linux程序推荐" class="headerlink" title="附录1：Linux程序推荐"></a>附录1：Linux程序推荐</h2><p><em>附录内容：王垠用来处理日常事务的Linux程序，需要注意的是，王垠本人写作本文的时间是2005年，目前2020年已经来临，Linux上早就已经出现了一些对图形化用户非常友好的软件，同样非常强大（即作者所认为的傻瓜软件），读者可以作过渡性的尝试。具体的推荐以后的文章会谈到。</em></p>
<p>好了好了。我知道你现在可能已经发现自己应该转向 Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。</p>
<p>如果你只想做一个普通用户，主要目的是用 Linux 来完成自己的任务，那就可以不用系统管理员或者网络管理员的标准来要求自己，因为当一个系统和网络管理员确实很辛苦。这里我对实验室的网管同学鞠一躬，谢谢你的指点和帮助。不用把你的机器当成网络服务器，不用开放没有必要的服务，设置好 ssh, ftp 已经足够了。这样会省去了解很多没必要了解的东西的时间。不用过度考虑”安全”，因为 Linux 缺省已经很安全了。不过你有兴趣了解更多那也无妨。  </p>
<p>这里给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如 Matlab, Mathematica, Maple, HSpice, Design Compiler, …… 还有其它物理上的，化学上的，生物上的 …… 都必然有 Linux 和 UNIX 的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，它们是经过很多人辛勤劳动的产物，是可靠的程序，他们物有所值。</p>
<p>下面列出我常用的一些 Linux 程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的。我不喜欢试用程序。</p>
<ul>
<li><p>Shell: Bash shell，我使用 bash 的 vi 命令行方式。</p>
</li>
<li><p>开发系列</p>
<ul>
<li>文本编辑器：VIM，Emacs</li>
<li>自动管理工具：make 我可以用make来自动编译程序，自动编译文档，自动更新插图…… 全自动，而且不会重复劳动。</li>
<li>编译器：GCC，G++</li>
<li>调试器：gdb，ddd</li>
<li>汇编器：as</li>
<li>跟踪器：strace, ltrace, truss</li>
<li>其他：ld, Scheme48, j2sdk, Perl, Tcl/Tk …</li>
</ul>
</li>
<li><p>办公系列</p>
<ul>
<li>论文文稿：LaTeX</li>
<li>演示文稿：ConText</li>
<li>绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可以用 dia 来画一些流程图之类的图片。</li>
<li>图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert 程序可以转换图像格式，display 可以显示图片和简单编辑(缩放，换质量，转格式，简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可以用 Gimp, 它几乎和 Photoshop 差不多。</li>
<li>Email 处理：Mutt + Postfix + fetchmail</li>
<li>PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv, djvu工具包和 netscape 插件。</li>
<li>看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。</li>
</ul>
</li>
<li><p>文件处理</p>
<ul>
<li>加密程序：GnuPG。我的 PGP 密钥就是它搞出来的，我用了 2048 位加密。</li>
<li>打包与压缩程序：tar, gzip, bzip2, zip, rar, …</li>
<li>虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 即可。</li>
</ul>
</li>
<li><p>服务器</p>
<ul>
<li>ftp 服务器：proftpd, vsftpd</li>
<li>WWW 服务器：apache。(我一般没有开)</li>
<li>ftp 客户程序：lftp</li>
<li>登录其它 UNIX, Linux 机器：openSSH, telnet。 openSSH 还可以把其它机器的 X 程序通过 ssh 加密的隧道传到我机器上显示。</li>
</ul>
</li>
<li><p>下载工具：wget</p>
</li>
<li><p>Linux操作方面</p>
<ul>
<li>虚拟终端：rxvt, xterm, gnome-terminal, mlterm, …</li>
<li>X server: XFree86</li>
<li>窗口管理器：FVWM。编译加入了 libstroke。</li>
<li>中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用 SCIM。</li>
</ul>
</li>
<li><p>交流与沟通</p>
<ul>
<li>看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比 IE 好很多。</li>
<li>英汉字典：IBM智能词典，星际译王。</li>
<li>编辑网页：我用 VIM 直接写 HTML。你如果想要图形方式的可以用其它的比如 screem, BlueFish。</li>
<li>登录BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo 机器人的程序)</li>
<li>QQ, ICQ: 我没有 QQ 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和很多其它的即时通信方式。ICQ 用户也可以用 Licq。</li>
</ul>
</li>
<li><p>休闲</p>
<ul>
<li>视频播放器：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD, DVD, divx, wma, wmv …  用 Windows 的同学都很羡慕我，说 Windows 要放这个需要大堆插件。rm 最好还是用 realplayer 放，它也是免费的。</li>
<li>音乐播放器： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg)。 mpg321 不如xmms管理音乐文件那么方便，但是有时我还是用 mpg321 放 mp3 作为背景音乐，因为懒得开一个xmms窗口:-)  </li>
</ul>
</li>
<li><p>Word 文档：请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没有特殊的格式就用文本文件，要不我就不看。（笔者注：现在Linux可以使用WPS Linux版，是比较方便的）</p>
</li>
<li><p>其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor Scheme, Scheme48, Scsh, …</p>
<p>这些程序只有 Doctor Scheme 有Windows版本。还有很多幕后工作但是你一般不察觉的：xinetd, telnetd, sshd, crond, atd, lpd, … 他们都比 Windows 的对应者强的多。</p>
</li>
</ul>
<h2 id="附录2：Linux基础学习参考书籍"><a href="#附录2：Linux基础学习参考书籍" class="headerlink" title="附录2：Linux基础学习参考书籍"></a>附录2：Linux基础学习参考书籍</h2><p><em>附录内容：该附录为笔者自己个人使用到的Linux系统基础学习的书籍。其中最值得推荐的已标注为※。</em></p>
<ul>
<li>Linux从入门到精通（中国水利水电出版社）</li>
<li>Linux从入门到精通（Linux典藏大系）（清华大学出版社）</li>
<li>※ 鸟哥的Linux私房菜（第四版）（人民邮电出版社）</li>
</ul>
]]></content>
      <categories>
        <category>Linux学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈计算机&amp;编程发展路线——自顶向下脱发方法</title>
    <url>/DailyThoughts/2019/12/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA&amp;%E7%BC%96%E7%A8%8B%E5%8F%91%E5%B1%95%E8%B7%AF%E7%BA%BF%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%84%B1%E5%8F%91%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>很多年轻人打算搞IT，问要看什么书，以下是比较专业的回答：</p>
<p>第一阶段：《数据结构》《C语言》《C++》《C#》《PHP》《Java》《设计模式》《框架》<br>第二阶段：《莫生气》《佛教》《道》《思想与政治》《论持久战》<br>第三阶段：《脊椎匡扶指南》《腰间盘突出康复指南》《心脏病的预防与防止》《高血压降压宝典》《强迫症的自我恢复》<br>第四阶段：《迷恋》《谢谢你折磨我》《自私与贪婪》《走向奴役之路》《精神变态日记》<br>第五阶段：《活着》<br>第六阶段：《棺材的质量与选材》《墓地的风水与选择》《死后的思想》<br>第七阶段：《中国传统丧葬礼仪概述》<br>第八阶段：《论投胎的方法与技巧》<br>第十阶段：《论出生后如何不成为程序员》 </p>
<p>你可能很疑惑，为什么没有第九阶段。别问，问就是喝孟婆汤忘记了。</p>
<a id="more"></a>

<h2 id="规划的原则——因材施教"><a href="#规划的原则——因材施教" class="headerlink" title="规划的原则——因材施教"></a>规划的原则——因材施教</h2><p>我想从一个经典的知乎问题开始讲起：计算机专业有哪些必读的书籍/计算机专业应该如何提升自己。</p>
<p>关于这个问题，可谓是仁者见仁，智者见智。</p>
<blockquote>
<p>常言道，一千个人眼中有一千个哈姆莱特；常言又道，一千个人心中有一千部红楼梦；据此类比推出：常言还道，一千个人脑海里有一千种书单。</p>
</blockquote>
<p>想要笼统而概括地论述计算机专业&amp;编程专业的发展路线，其实不是一件容易的事情。我的观点是：<strong>因材施教</strong>。每个刚刚接触计算机或者接触编程的青年，都应该对自己未来的发展有明确的认识，应该广泛了解各方面的知识，然后在这个基础上，选择自己适宜的发展方向，并规划自己的发展路线。</p>
<p>首先我们来看下一般大学的科班——计算机科学与技术的课程表：数字电路原理、模拟电子技术、数字逻辑、数值分析、计算机组成原理、微型计算机技术、计算机网络、高级语言（C++、Java）、汇编语言、数据结构、操作系统原理、数据库原理、编译原理、计算机图形学、离散数学、概率统计、线性代数以及算法设计与分析、面向对象程序设计。</p>
<ol>
<li><p>高数，概率，线代，复变，离散数学等基础学科，打下了 逻辑思考的基础，以及工作中需要使用到复杂的数学运算时的数学基础。使人更加易于理解和分析如何吧现实问题转化为程序逻辑并实现。</p>
</li>
<li><p>模电主要让人明白信号传递的原理同时又作为数字电路的基础，而数电主要让人明白计算机内部数据到底是如何存储，如何运算，如何传输的。</p>
</li>
<li><p>计算机组成原理，微机原理等，主要是来解释计算机是如何组成的，早期是什么样子的，发展历程是什么，为什么会有这样的发展，现在的计算机的复杂结构下的简单核心是什么？</p>
</li>
<li><p>操作系统则真正讲述了，一个应用程序是如何层层传递，调用了最终硬件的；操作系统，驱动，应用程序，分别都是什么关系；cpu的运算方式是什么样子的；为什么要有多线程；为什么会有死锁；在多线程的模型下，硬件到底在做什么。</p>
</li>
<li><p>计算机网络，让人明白在计算机的基础之上，到底是如何传输数据的。OSI七层模型和TCP/IP协议五层模型分别有哪些层；每一层在做什么；为什么RFC的各种协议里会有那么多奇奇怪怪的头和尾；各种不同的协议是怎么产生和怎么发展的；分别有什么特色；以及我们为什么在某一种场景下使用某一种网络协议；假如我们需要一个自己的协议，该如何构建。</p>
</li>
<li><p>数据结构，让人明白数据是如何存储的，目前常见的存储的模型有那些？这些模型在内存里以什么样的方式存储？这些存储方式都有什么优劣？在那些场景中最为适用？</p>
</li>
<li><p>编译原理，让人明白高级语言到底是怎么被解释编译成机器语言的。</p>
</li>
<li><p>汇编语言，让人明白在接近硬件的层面上，程序到底是怎么运作的。去理解去思考，我们的操作和编写的程序，对硬件到底做了什么。不同的操作系统，不同的编译器，不同的写法，不同的逻辑，在硬件层面上，会有什么样的不同？</p>
</li>
<li><p>算法和高级语言，一般来讲，到这个层面往上，非科班和科班的差距开始变小。因为大部分人在实用性的学习过程中。必须来学习和接触到高级语言和算法。</p>
</li>
</ol>
<p>综上所述，计算机的基础，不是你会什么C、C++、C#、Java、python、PHP、Object-c这样的语言；也不是你学了多少linux，Win32，IOS，Android，MFC，.net，Apache，Struts，Spring这样的框架；更不是你会Oracle，MySQL，SQL server这样数据库的使用；<strong>而是你是否明白，从最基础的电路和电讯号传递开始，到今天的计算机体系的大厦，是如何一步步构建出来的，每一步的取舍都是为了什么</strong>。</p>
<p>大部分的人，要么是半路出家，上了几个编程培训班而自以为技术成熟，要么是非科班出生，对科班这一整套课程体系不屑一顾。诚然，直接从高级语言和算法开始学起，可以做到知其然，并且熟练的编程，设计生产出非常优秀的应用。但是如果知其所以然，那么就可以做得更好，在出现新东西的时候，能够更快的去理解这些新东西的缘由，发展和价值。</p>
<p>我劝各位想要接触计算机行业的初学者——当然我本人也不过是初学者而已——不要学了一点皮毛就沾沾自喜。今天我们之所以不用去了解那么多基础，就可以从事这个行业，正是因为无数前人帮助我们构建了一个相当完善的知识体系，在这个基础上，我们可以轻松的去学习，去操作。但我们的梦想就仅此而已了吗？我们该如何往前进一步的去推进呢？在工作学习的过程中，进步远非是要学习怎么做那样简单，更要多问问为什么。只有这样才能走的更高，更远。</p>
<h2 id="参考书单——循序渐进"><a href="#参考书单——循序渐进" class="headerlink" title="参考书单——循序渐进"></a>参考书单——循序渐进</h2><p>我想基于我刚才提到内容的基础，结合我之前参考的很多知乎、微博和Bilibili上从事程序设计、软件架构、前端后端开发的工程师的经验和建议，以及科研工作者对计算机学习的规划与指导，谈谈我的一点浅薄之见——计算机初学者应该怎样发展自己的计算机学习。</p>
<p>如果真真正正是零基础开始学习计算机，我的建议是需要注重兴趣，但是不能永远以兴趣为由放弃基础知识的学习。如果不能适应计算机底层的枯燥知识，最好是直接转行，不要继续待在计算机行业里。</p>
<p>计算机学习的最开始，当然是需要对计算机整体有个清晰的把握，然后一面深究计算机底层层面，一面发展高级语言层面。按照这个思路，我提供如下的书单，以供参考。</p>
<h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ol>
<li><p>数字电路与模拟电路。</p>
<p><a href="http://www.icourse163.org/course/NJUST-1001753091" target="_blank" rel="noopener">数字逻辑电路(南理工)</a></p>
<p>数字电路绝对是完全被低估的一门计算机基础课，我在大学期间就没有严肃地对待这门课，这导致我只了解基本的逻辑门电路，对更高级的知识知之甚少。由于有关数字电路的书籍很难找得到出众的，故这里只推荐中国大学MOOC上的公开课。</p>
<p>模拟电路大体同上，在中国大学MOOC上搜索即可。</p>
</li>
<li><p>计算机组成原理</p>
<ol>
<li><p>《大话处理器》</p>
</li>
<li><p><em>CODE: The Hidden Language of Computer Hardware and Software</em> </p>
<p>《编码:隐匿在计算机软硬件背后的语言》</p>
</li>
<li><p>《穿越计算机的迷雾》</p>
</li>
<li><p>※ <em>Computer Systems: A Programmer’s Perspective</em> </p>
<p>《深入理解计算机系统》</p>
</li>
<li><p>※ <em>Structure and Interpretation of Computer Programs</em></p>
<p>《计算机程序的构造和解释》</p>
</li>
</ol>
<p>首先推荐的两本都是比较通俗易懂的书，这两本书都偏科普一些，阅读起来相当轻松，非常具有趣味性，是入门的上佳选择，如同看小说一般过一遍即可；另一本穿越计算机的迷雾目前已经绝版了，不过它的内容也是不错的，网络上可以搜索一下相关资源。</p>
<p>第三第四本是需要重点介绍的正规教材：</p>
<p>《深入理解计算机系统》 它从程序员的视角详细阐述了计算机系统的本质概念，并展示这些概念如何实实在在地影响应用程序的正确性、性能和实用性。</p>
<p>《计算机程序的构造和解释》讲的是从数据抽象、过程抽象、迭代、高阶函数等编程和控制系统复杂性的思想，到数据结构和算法，到编译器/解释器、编程语言设计。 </p>
<p>计算机组成原理很好地向我们阐述了计算机如何工作，如何计算和输出我们想要的数据的。由于本门课还是大部分大学的考研科目，所以各个大学都会有一些公开课视频，可以自行查找。</p>
</li>
<li><p>汇编语言</p>
<p>《汇编语言(第2版)》(王爽著) </p>
<p>汇编语言是一门相对比较难并且比较抽象的课程，但是却可以方便地进行实操，就像学习编程一样，可以实际运行书中的一些代码。</p>
</li>
<li><p>计算机操作系统</p>
<ol>
<li><p>Linux操作系统入门</p>
<ol>
<li>《典藏大系-Linux从入门到精通》</li>
<li>《鸟哥的Linux私房菜》</li>
</ol>
</li>
<li><p>操作系统原理详解</p>
<p>※<em>Modern Operating System</em>《现代操作系统》</p>
</li>
<li><p>Linux环境编程及内核分析（必须先修C/C++语言后再读）</p>
<ol>
<li>《UNIX环境高级编程》</li>
<li>《Linux程序设计》</li>
<li>《Linux内核设计与实现》</li>
</ol>
</li>
</ol>
<p>计算机操作系统和计算机组成原理一样是考研课程。首先推荐的两本是科班所教授的Linux操作系统基础知识（当然Linux不属于考研范畴之内）为后面的Linux环境编程打下基础。</p>
<p>《现代操作系统》是相当经典非常需要读的一本书，《UNIX环境高级编程》相比之不遑多让，这本书之经典，三言两语无法说清。之所以推荐第二本，还有一个原因就是该书是基于UNIX的，UNIX/Linux在服务器中的重要性和广泛应用我相信不必强调。 第四本较之第三本略逊一筹，参考价值也很大。</p>
<p>至于第五本，则是在当你对操作系统有一定理解以后阅读，它将为你打开学习Linux内核的大门，当然在此之前你得有一定的C语言开发能力，以及对Linux的了解。</p>
</li>
<li><p>计算机编译原理</p>
<ol>
<li>《编译原理 (原理、技术、工具)》（龙书）</li>
<li>《现代编译原理》（虎书）</li>
<li><em>Advanced COMPILER DESIGN IMPLEMENTATION</em> （鲸书）</li>
</ol>
<p>很多编程学习者都并不是很清楚编译时到底发生了什么事情，什么是编译期什么是运行期相信有些人还是一知半解，编译原理就是告诉我们高级语言是如何一步一步地被转化为低级语言，最终在计算机上运行的。</p>
<p>编译原理的学习分为三大阶段，龙书阶段考虑原理、技术和工具；虎书阶段考虑技术实现和实践；鲸书阶段考虑知识的前瞻和增广扩充。</p>
</li>
<li><p>离散数学</p>
<p>《离散数学及其应用》</p>
<p>离散数学个人认为对于计算机学生而言是非常重要的一门课，可惜的是我在本科期间对计算机的认知不够，导致在学习这门课的时候只是把它当成一门数学来学习，并且也没有花费太多的时间以及精力，相信对于大部分计算机专业的学生来说也是这样的。</p>
<p>不过我认为如果有时间和精力，一定要重新学习这门课，因为日后的编程与离散数学的逻辑是紧密相连，不可分割的。</p>
</li>
<li><p>计算机网络</p>
<ol>
<li>《图解HTTP》（兴趣阅读）</li>
<li>《网络是怎样连接的》（兴趣阅读）</li>
<li>※《计算机网络——自顶向下方法》</li>
<li>※《TCP/IP详解》</li>
<li>※《UNIX网络编程》</li>
</ol>
<p>计算机网络的原理认知对日后的发展有非常大的帮助，非常典型的例子就是分布式系统。对于计算机网络的学习，我认为可以分为两个阶段，第一阶段是快速地把两本兴趣阅读的读物给过一遍，建立起对网络的认知，然后迅速地进入第二阶段，精心研读第三、四两本史诗级巨著；最后一本讲解了Unix内核是如何实现网络通信的，其中涉及到很多网络，操作系统的知识，并且你要熟悉c语言。它也是被奉为网络编程神书的存在。</p>
</li>
<li><p>高级语言的学习</p>
<p>这一节实在是太重要了，重要到必须另起一阶段，详细地阐述。</p>
</li>
</ol>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><p>高级语言大体上使用率高的基本上有：C++、Java、Python、Go、JavaScript等等，分述如下：</p>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><blockquote class="pullquote right"><p>如何学好C++？唯一的办法就是读书，读大量的书，才可以学好。  </p>
<p>要把C++作为日常语言，而不是一种程序语言，这样才更容易掌握。  </p>
<p>检验大家C语言学的好不好的两个最重要的指标，一是指针，二是内存管理。</p>
</blockquote>

<p>基本上中国大学的计算机专业都会把C++当作第一门语言课，C++相对其它语言来说，入门上手会相对比较难，可能会打消掉一部分同学的积极性。<em>但是C++又是一门可以进行类比的语言，C++学习到一定程度后，学习其他语言也会变得非常容易。</em>(关于这个观点存在一些争议，如果确实对C++并不看好，可以从java开始，不必要非得学习C++)</p>
<p>学任何东西其实都有一个学习曲线，只要沉下心去学，多花点时间，总会跨过那个曲线，后面学习过程就会变得很平滑。学C++也类似，不要知难而退，而是要迎难而上，翻过大山也许就能看到彩虹。</p>
<ol>
<li><p>入门书籍： </p>
<p><em>The C++ Programming Language</em>  (Bjarne Stroustrup)</p>
<p>C++之父的经典之作，无论如何也应该读个四五遍！这是一切C++的书本的源泉。推荐英文版，如果英文不好再看中文版，此书由浅入深，知识全面，代码具有代表性。如果把书上的代码都上机打一遍，C++绝对入门了。 </p>
</li>
<li><p>进阶阶段1：</p>
<ol>
<li><em>Essential C++</em>  </li>
<li><em>C++ Primer Plus</em></li>
<li><em>C++ Primer</em></li>
</ol>
<p>后两本书都可以精读，其中第二本虽然比第三本多一个Plus，但其实第二本书更加基础一些，涵盖的内容也没有第三本广泛。<em>C++ Primer</em>的体量非常巨大，故此一定要品味第二、三本。可以先从<em>Essential C++</em>开始，它将四个C++的范型都讲了，而且讲得非常清楚。当然，也有一部分人一直认为C++Primer带着太过强烈的C的痕迹，对于学习C++未必是好事。读者需要先读这本巨著，然后再作判断。  </p>
</li>
<li><p>进阶阶段2：</p>
<ol>
<li><p><em>Thinking in C++</em> (Bruce Eckel著、候捷译)</p>
<p>这本书每过半年建议重读一遍。可以说每一章都是写得发人深省的，这本书可以让人感受到技术运用的高超境界，语言非常平实，只要认真地读，即使基础不行，也一定可以懂。  </p>
</li>
<li><p><em>Effective C++</em></p>
</li>
<li><p><em>More Effective C++</em>  </p>
<p>要更上一层的话，就要慢一步，先要把握C++设计习惯的良好。这是Scott Meyers的<em>Effective C++</em>和<em>More Effective C++</em>带给我们的无尽收益。这两本书是真正的经典，作者对C++的纯熟，使得语言的风格非常具有魅力，虽然C++本身并不十分有趣，但书读起来却甘之如饴，就像他站在对面在讲课。</p>
</li>
</ol>
<p>如果你已经深刻地理解了<em>Effective C++</em>和<em>More EffectiveC++</em>，那你可以发现，你在众人中已经是鸡群之鹤。可以指导项目运作了，可以编写一切你想做的程序了，可以指出别人看起来不错的代码的大小问题了。如果你能一眼看出有人的代码是对应于”条款27”或”条款M6”，那你可真是令人刮目了。  </p>
</li>
<li><p>高级阶段：</p>
<ol>
<li><p><em>Exceptional C++</em></p>
</li>
<li><p><em>More Exceptional C++</em>  </p>
<p>如果要写程序，<em>EC++</em>和<em>MEC++</em>的境界已经足以使你自如应付，可是如果你还不满足，想关注一些理论层面的问题，或是想看看实现的代码，你就不应该错过上面这两本好极了的书。(由Herb Sutter所著) </p>
<p>这两本书的难度是非常大的。每一条的阅读笔记都应该有十多页。特别是泛型程序设计的部分，这两本书旁征博引，极尽深入探讨之能事，每每看懂一条，都该大感酣畅淋漓，每每学到一点，都值得浮一大白。</p>
</li>
<li><p>《STL源码剖析》(侯捷著)   </p>
<p>它是以实际的例子一点点地讲解一个STL是怎么样实现的。 </p>
</li>
<li><p><em>Inside the C++ Object Model</em>  </p>
<p>从这本书中可以了解无数的编译器解释源代码的细节，以及记忆体分配的细节。 </p>
</li>
<li><p>C++沉思录 </p>
<p>经典之作，语言是苍白无力的，必须读一遍，呃不，读无数遍，深刻体会。</p>
</li>
</ol>
</li>
<li><p>补充：</p>
<p>如果还觉得不够的话，就订购一本C++标准，但是仅作为参考工具书使用。</p>
<p>中国大陆作者的书，尽量不要看。一切VC++或讲特定的编译器的书，一概不要看。</p>
<blockquote>
<p>这里要特别提一句伟大的谭先生、谭教授THQ编写的巨著，书名就不叙述了；业内人士将其称之为谭++；我计划专门整理一篇博客，细数一下伟大的谭先生为我国C++教学事业所作的杰出贡献。另外，我要正告各位读者，如果不是为了计算机二级考试，千万不要购买谭++，入邪教而恍然不知，悔时晚矣！</p>
</blockquote>
<p>如果需要补C语言的课，买一本非常小的K&amp;R的The C Programming Language足矣，其它的书一概不要看。不要先学C，再学C++，而要直接学C++。你不是先学古文，再学白话的，对不对？相信我，直接来更容易。</p>
</li>
<li><p>其他的书：</p>
<ol>
<li><em>Accelerated C++</em>  从各方面评价来看，完全值得推荐。</li>
<li>《C++ Templates全览》  (STL参考)</li>
<li>《C++设计新思维：泛型编程与设计模式之应用》   (STL参考)</li>
<li>《C++标准程序库：自修教程与参考手册》 (STL参考)</li>
<li>《C++网络编程》(卷1，卷2) (网络参考)  </li>
<li>《C和指针》 深入了解指针，看完以后对指针不再害怕。 </li>
<li>《C陷阱和缺陷》 看完后可以避免C语言开发的一些坑。 </li>
<li>《C专家编程》</li>
</ol>
</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>如果是真真正正完全0基础入门编程的话，其实Java作为入门语言是非常合适的。</p>
<p>虽然Go，Kotlin等目前比较火的动态语言对Java这种静态语言造成了一定的威胁，但是短期内其冲击远远不会到影响Java的程度。Java依旧是当今当之无愧的第一就业语言，绝大部分互联网企业都选择Java作为它们的开发语言。</p>
<p>信息化系统的建设(各种各样的业务系统，及互联网服务等)，其主流的驱动技术就是Java，而其他语言，例如PHP是呈下降状态，而Go语言目前的份额也并不大；另外一点就是Java目前的业务需求是比其他语言要大得多的。</p>
<p>从难度上讲，Java相比c＋＋是真的容易很多。</p>
<blockquote>
<p>有人推荐Python，至少在中国目前这个纯就业的环境下，学Python去找个工作简直要发狂，不要相信培训公司吹的那样，搞Python不走人工智能是很难的 ，而AI，机器学习，算法这些现在的趋势都是研究生起步，学历这方面相当重要，这些东西不是经过努力学点程序就行的，更何况，有些技术不是想学就能学会的——就像有些人这辈子注定无法获得诺贝尔奖一样，现实是很残酷的……</p>
<p>当然，不可否认的是，Python语言编写的脚本在某些方面确实给日常生活带来了便利，就这一点来说，它的易用性其实是非常优秀的，我认为Python是一门非常有价值的编程语言。虽然就现实来说，在就业方面可能并不是那么理想。换言之，只有优秀的Python编程者才有机会。</p>
</blockquote>
<ol>
<li><p>入门书籍：</p>
<ol>
<li><em>Head First Java</em></li>
<li>《疯狂Java讲义》</li>
<li>《Java核心技术 卷I&amp;II》</li>
</ol>
<p>我没有把《Java核心技术》排在第一位的原因是：这本书的治学精神是非常值得学习的，但是入门Java并不需要在Java SE里那些不常用的技术上浪费时间，而初学者又不知道如何鉴别哪些需要学习，哪些不需要学习，基于这个原因，我个人建议先看前两本书。</p>
</li>
<li><p>进阶书籍：</p>
<ol>
<li>《Java编程思想》</li>
<li><em>Effective Java</em></li>
<li>《Java并发编程实战》</li>
<li>《深入理解Java虚拟机》</li>
</ol>
<p>《编程思想》书是Java界极其经典的圣经书籍，地位相当于Java界的辞海。里面相当多的内容是非常非常值得学习的。如果错过了这本书，那么Java的学习只能用遗憾来形容。</p>
<p><em>Effective Java</em> 作为技术人员的参考用书。介绍了在 Java 编程中 7到8 条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。</p>
<p>《并发编程》则具备企业级开发里常用的知识，多线程/多进程的精髓就在于此。当然，这本书的难度也更大一些。</p>
<p>《Java虚拟机》虽然基于OPEN JDK1.7，但是其中的Java编程思想永不过时！不论是对于现在的Oracle JDK12，还是以前的版本，对原理的理解是没有影响的。</p>
</li>
<li><p>拓展书籍：</p>
<ol>
<li>《函数式编程思维》</li>
<li>《TCP/IP 详解》</li>
</ol>
<p>《函数式》这本书对于提高代码的信噪比是非常有帮助的，当然，可能在日后的重构方面会存在一些困难。《TCP/IP》书则是为了帮助进行Java网络编程，该书在之前的计算机网络处已经叙述过了，这里不再赘述。</p>
<blockquote>
<p>信噪比，也就是信号噪声比，在此处意思是说用少量的代码得到更高的运行效率。</p>
</blockquote>
</li>
<li><p>补充书籍（并发系列）</p>
<ol>
<li><p>《Java并发编程艺术》</p>
<p>同样是讲Java并发编程的。Java并发编程实战相对来说全是干货，看起来可能比较晦涩。这本书可能看起来更通熟易懂些，但是没有Java并发编程实战全面，大家可以搭配着读。</p>
</li>
</ol>
</li>
<li><p>补充书籍（Android系列）</p>
<ol start="2">
<li><p>《第一行代码 Android》</p>
<p>Android开发入门书籍。 Android开发是基于Java的。</p>
</li>
<li><p>《Android 开发艺术探索》</p>
<p>这本书强烈推荐。是从Android初级向中高级进阶的必看书籍，里面讲的知识点都很好。重要的是Android面试会问到很多这本书里面的知识点，找Android开发必看。 </p>
</li>
<li><p>《Android 系统源码代码情景分析》</p>
<p>从源码分析Android系统的书，经典程度不亚于上本。</p>
</li>
</ol>
</li>
<li><p>补充书籍（Java Web和Spring模块）</p>
<ol start="5">
<li><p>《深入Java Web技术内幕》</p>
<p>从Android向后台转型过程中看的一本书。比较全面的介绍了Java Web知识，可以当作Java Web的入门辅助书籍。 </p>
</li>
<li><p>《Spring in action 中文版》</p>
<p>学习Spring时候看的书，主要介绍了官方文档的知识。讲的很全面，准确度也高。 </p>
</li>
<li><p>《Spring MVC学习指南》</p>
</li>
<li><p>《Maven实战》</p>
</li>
</ol>
<p>Java Web离不开Maven，这本是Maven入门书籍，讲的很全面。 </p>
<ol start="9">
<li><p>《Spring实战》 &amp; 《Spring Boot实战》 </p>
</li>
<li><p>※《Spring技术内幕》  建议精读。</p>
</li>
</ol>
</li>
</ol>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><ol>
<li><p>入门书籍：</p>
<ol>
<li>Python cookbook</li>
</ol>
<p>该书被多平台，多位大神联合推荐，毫无疑问，这是一本很不错的书籍。但有人会考虑，这本书适合入门吗？回答是肯定的。当然，这本书比着有些”入门书籍”要稍微深一些，这正是推荐这本书而不推荐其他书籍的原因：《Python Cookbook》和其他入门书籍、教程一样，都是在围绕数据结构、基本概念在展开，但是它对比于其他教程”蜻蜓点水”式的阐述，这本书做了更多延伸，讲解了更多高阶用法，我觉得高阶用法你不一定要记住，但是知道有这么一回事，对后期进阶、实战会有很多帮助。</p>
<p>除此之外，还有以下Python入门书籍可供选择：</p>
<ol start="2">
<li>《Python编程：从入门到实践》</li>
<li>《Python编程快速上手》</li>
<li>《像计算机科学家一样思考Python》</li>
<li>《Python基础教程 第2版》</li>
<li>《笨办法学Python 3》</li>
<li>《流畅的Python》</li>
</ol>
<p>《流畅的Python》致力于帮助Python开发人员挖掘这门语言及相关程序库的优秀特性，避免重复劳动，同时写出简洁、流畅、易读、易维护，并且具有地道Python风格的代码。尤其深入探讨了Python语言的高级用法，涵盖数据结构、Python风格的对象、并行与并发，以及元编程等不同的方面，适合精读。</p>
</li>
<li><p>进阶练习和书籍：</p>
<ol>
<li><p><a href="https://github.com/Yixiaohan/show-me-the-code" target="_blank" rel="noopener">Python练习册，每天一个小程序</a> 这是GitHub上超1W Star的项目。</p>
</li>
<li><p><a href="https://www.the5fire.com/beginning-python-10-projects.html" target="_blank" rel="noopener">Python项目练习</a> 包括十个项目的练习和代码 </p>
</li>
<li><p><a href="http://aosabook.org/en/500L/" target="_blank" rel="noopener">500 line or less</a>  一本Python神书，而且还有源码。 </p>
</li>
<li><p><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python - 100天从新手到大师</a>  骆昊 (jackfrued) 规划的一条从“从新手到大师”的百天之路。 </p>
</li>
<li><p><em>Python for Data Analysis</em></p>
</li>
<li><p>高级阶段：</p>
<p>选择一个学习的方向：</p>
<ol>
<li>机器学习</li>
<li>图像处理</li>
<li>自然语言</li>
<li>数据分析</li>
<li>web</li>
<li>……</li>
</ol>
<p>选择一个学习的方向，然后才清楚自己该朝着哪个方向努力、该拿哪些项目练手，对编程能力进一步巩固，这样要比“无头苍蝇”式的漫无目的学习效率要高很多。</p>
<p>然后，可以找一些比较优秀的项目进行实战，扩展自己知识面的同时对编程能力进行巩固。</p>
<p>以下是三个可供参考的学习链接：</p>
<ol>
<li><p><a href="https://github.com/nfmcclure/tensorflow_cookbook" target="_blank" rel="noopener">tensorflow_cookbook</a></p>
</li>
<li><p><a href="https://github.com/bharathgs/Awesome-pytorch-list" target="_blank" rel="noopener">Awesome-pytorch-list</a></p>
</li>
<li><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1018138095494592" target="_blank" rel="noopener">WebAPP</a></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="Go和SQL"><a href="#Go和SQL" class="headerlink" title="Go和SQL"></a>Go和SQL</h4><p>Go书籍推荐：《Go语言实战》&amp;《Go In Action》</p>
<p>SQL书籍推荐：</p>
<ol>
<li><p>《MySQL必知必会》</p>
</li>
<li><p>※《数据库系统概念》第六版</p>
</li>
<li><p>《深入浅出MySQL》</p>
</li>
</ol>
<blockquote>
<p>注：《MySQL必知必会》虽然在语法上看起来是《SQL必知必会》的子集，但是实际上其内容更加全面，更加精细。</p>
</blockquote>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>学习算法，不要一上来就开始啃《算法导论》，这本书有太多关于算法的数学证明（除非你喜欢这种风格，那么你就看这本）。既然这本书并不适合新手学习，而如果你之前的算法基础又比较薄弱，那么只会一直陷在“拿起来又放下”的循环里。 </p>
<ol>
<li><p>入门书籍：</p>
<ol>
<li>《算法图解》：“像小说一样有趣的算法入门书”，主打“图解”，通俗易懂 </li>
<li>《大话数据结构》：把理论讲得有趣不枯燥；每个数据结构和算法，作者都结合了生活中的例子，能让你有非常直观的感受。 </li>
</ol>
</li>
<li><p>标准教材：</p>
<p>《数据结构与算法分析》 非常系统、全面、严谨，适合掌握了至少一门编程语言的同学。</p>
<p>这本书有三个语言的版本：C语言描述，C++语言描述和Java语言描述 </p>
</li>
<li><p>进阶书籍：</p>
<ol>
<li>※《算法 第4版》 </li>
<li>※《算法导论》</li>
</ol>
<p>这两本书都是经典，建议细细品味。</p>
</li>
<li><p>拓展书籍：</p>
<ol>
<li>《算法之美》 算法科普，从生活中的各种问题说起：租房、谈恋爱、老虎机、拍电影、面试、买彩票、各种排序、找停车位、寻找新药、临床试验、奥巴马拉赞助、预估电影票房等等，非常生活化，可以作为补充阅读。 </li>
<li>《算法帝国》 同样是科普类书籍，并无涉及算法的原理与实现细节，也可以作为补充阅读。 </li>
</ol>
</li>
<li><p>殿堂级书籍：</p>
<p> ※ <em>The Art of Computer Programming</em> <strong>《计算机程序设计艺术》</strong> 包含共四大卷，其深度、广度、系统性、全面性是其他所有数据结构和算法书籍都无法相比的。该书建议慢慢阅读，可以当做一种挑战！</p>
</li>
<li><p>其他书籍：</p>
<ol>
<li>《算法设计与分析基础》</li>
<li>《算法引论：一种创造性方法》</li>
<li>《编程原本》</li>
<li>《算法竞赛入门经典》</li>
<li>《算法艺术与信息学竞赛》</li>
</ol>
</li>
</ol>
<h3 id="设计模式与架构"><a href="#设计模式与架构" class="headerlink" title="设计模式与架构"></a>设计模式与架构</h3><p>轻量级书籍推荐：</p>
<ol>
<li><p>《大话设计模式》 </p>
</li>
<li><p>《设计模式》 （刘伟著）</p>
<p>可以读此书配套的《设计模式实训教程》。还有《C#设计模式》和《 设计模式的艺术——软件开发人员内功修炼之道 》，后者贴近于工程实践方面的应用。另外风格相近的还有 《设计模式之禅》与《研磨设计模式》 可以作为进阶。</p>
</li>
<li><p>《Head First 设计模式》</p>
</li>
</ol>
<p>重量级书籍推荐(以下神书排名不分先后)：</p>
<ol>
<li><p><em>Refactoring</em> 《重构——改善既有代码的设计》</p>
</li>
<li><p><em>Code Complete 2</em> 《代码大全2》</p>
</li>
<li><p><em>The Pragmatic Programmer</em> 《程序员修炼之道》</p>
</li>
<li><p><em>Clean Code</em> 《代码整洁之道》</p>
</li>
<li><p><em>Programming Pearls</em> (2nd Edition) 《编程珠玑》</p>
</li>
<li><p><em>Design Patterns</em> 《设计模式：可复用面向对象软件的基础》</p>
</li>
<li><p><em>The Mythical Man-Month</em> 《人月神话》</p>
</li>
<li><p><em>Working Effectively with Legacy Code</em> 《修改代码的艺术》</p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文从立意到结尾历时2天，撰写时间逾10个小时，参考和借鉴了80多位从事计算机及编程行业的工作者和爱好者在知乎的回答和在B站的视频，在此我衷心的表示感谢。</p>
<p>原先，我本意是想简略的列一份计算机需要读的书单，但我整理的目的是想让自己按照规划的这条路线走下去，因此在整理的过程中，我花了相当多的精力考察每一本书，包括它的目录，它涉及的内容以及它的编写目的及作用。最终，在给每一本书赋予一个特定的地位的时候，我都附注了自己或者他人的理解和感悟。不同的人对同一本书的看法肯定是不同的，所以并不是说所阅读的书局限于上述书单里。书单的意义 ，是给我自己规划的一条计算机从入门到略有体会的道路。</p>
<p>希望我整理的内容能够帮助各位有志于提高自己水平的青年学者；无论你之前是否接触过编程。国外的名著之所以比国内的教科书更加具有价值和历史意义，就是因为它们是给人看的，看书的过程也就是对话、沟通、交流、理解的过程。名著是兼容的，无论水平高低，读者都能在其中获取到知识；我希望我自己也能始终坚持谦虚好学的态度，不搞鄙视链，向各类人士兼容。</p>
<p>真正的大师，永远都怀着一颗学徒的心。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World——从写博客到记录人生</title>
    <url>/DailyThoughts/2019/12/HelloWorld%E2%80%94%E2%80%94%E4%BB%8E%E5%86%99%E5%8D%9A%E5%AE%A2%E5%88%B0%E8%AE%B0%E5%BD%95%E4%BA%BA%E7%94%9F/</url>
    <content><![CDATA[<p>时光，匆匆，像是天空中，自由变幻的一缕缕云烟；人生，短暂，像是电影剪辑里的一帧帧片段。</p>
<p>简单的事物，总是比想象中更美一些，而博客的作用，大抵就是记录下这些瞬间。多年之后，再点开博客，饱含着记忆的旧时光如同投入镜湖中的石子，在脑海中荡漾起一圈圈的涟漪；又仿佛清晨的微风，扑面而来，令人心旷神怡。</p>
<a id="more"></a>

<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>数一数，离2019年结束只剩下三天了。最近时不时的总会感叹：这一年过得飞快，时间都到哪去了？</p>
<p>我知道，倘若这个问题让每一个人都来回答，肯定有人会感慨这一年都没干什么，浑浑噩噩的，就像混过来似的。</p>
<p>再往前想，一年又一年，仿佛都是时间黑洞，前年、大前年也都没干什么，过往就是在不断轮回。 想完了，沮丧，焦虑，负面情绪也就都上来了。</p>
<p>其实，没有平庸的字，只有平庸的文字；同样的，没有平庸的人，只有平庸的人生。</p>
<p>难道，这一年就没干什么大事吗？不一定是那种折腾出很大规模的，给学校或给社会折腾出的，而是对自己有点成长意义的事？</p>
<p>有一两件大事能立住也好，还能安慰一下自己这一年没白过；也许确实这一年确实无所作为，没去做的想破了脑袋也想不出，这只能怪自己了。</p>
<p>但也可能做了一些事，大脑和记忆却欺骗了自己。</p>
<p>我们的大脑在思考上有巨大的潜力，在记忆上却并不可靠，大事之外的事都会被它给忽略掉。不建立在可靠的基础上，只能得出不可靠的结论。如果你有可靠的记录，那么你在年底就不会这么悲伤。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>苏格拉底说，“未经审视的人生不值得过。”</p>
<p>人是很容易陷入到浑浑噩噩，跟着情绪和冲动走的状态中，随波逐流，没有自己的主线和方向。</p>
<p>其实，写博客就是不断审视人生方向的好办法。</p>
<p>虽然不写博客也不会坏到哪儿去。但是，每天写一篇博客，翻翻这一年，日拱一卒，每天进步一点点，记录下来，这一年有满满的收获。有了这个，就能客观地看待自己。</p>
<p>很多人发微博、发朋友圈，把它们看作是对生活的记录。然而，给外人看的终究不同于写给自己看的，缺点、教训、人性黑暗面，只能自己去直面。</p>
<p>在社交媒体上前台表演美化，并不能像后台自我剖析再缝上伤口那样有实效。</p>
<blockquote>
<p>上学时，我们都被老师要求写过日记，但无一例外留下的是害怕写作文的阴影。过去的教育就是这么失败，好心办坏事，让人们得出个日记没用的结论。</p>
</blockquote>
<p>记录的力量其实很强大: 任何问题的解决，都是要先了解情况和症结所在，无论对象是时间、精力、财务还是你每日的生活和成长。时间管理，要求记录时间的去向，你才会知道每天刷手机花费了多少宝贵时间。理财，要求你去记账，你才知道不该花的娱乐消费原来有那么多，投资在自己成长上的花销却少得可怜。而你的成长，每天的日子，记录再看过，自我管理会不断改进迭代。这些记录都需要一些时间的积累，否则仅凭模糊的印象是得不出正确结论的。</p>
<p>博客，它像一个自我印证。我写下的，为了它更好看，我就会做得更好，然后我的记录就会更好，形成一个正向循环。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><blockquote class="pullquote right"><p>我记简单的日记，一旦有两三天忘写了就会搞不清哪个是哪天的事。昨天和前天颠倒顺序，也没有任何不便。我不时想，这叫什么人生啊!但也没有因此感觉光阴虚度。我仅仅是感到惊讶，惊讶于昨天与前天毫无区别，惊讶于自己被编排入这样的人生，惊讶于自己留下的足迹甚至还未及认清，就在转瞬间被风吹走变得无影无踪。<br>–村上春树《眠》</p>
</blockquote>

<p>以前看到一位前辈的文章，说技术博客就是用来记录自己技术的成长历程，每天的记录形成了习惯，技术也就点点滴滴的积累起来了。</p>
<p>我很赞成这个观点，作为一名计算机专业的学生，自身技术的提高是很值得高兴的。但是，我认为，技术博客未必非得全是技术，程序员们也是人，也有感情，在博客里面记录自己的心情与故事，即是记录自己的人生。</p>
<p>在心情里面，写写自己的生活，自己的情感，自己的学习计划。这并不是为了给别人看，这些文字，静静地躺着那里，它们是留给自己以后的感慨，留给自己的回忆。</p>
<p>其实人的一生很短暂，只有三万多天。我时常在思考一个问题，当我临终前，回首我这一生，我究竟是活了三万多天，还是仅仅只是把一天活了三万多次？</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><blockquote class="pullquote right"><p>有人说：无知是人的内禀性质。 </p>
<p>所以，生活的索然无味是因为觉得自己没有价值并且不能创造价值。  能够创造价值，比当下具有价值更重要。 </p>
<p>一旦发现自己其实还能创造价值，生活就会有趣起来。 </p>
</blockquote>

<p>生活的索然无味是否是源自于自己的无知？</p>
<p>我认为是的。</p>
<p>生活像钟摆一样，要么无聊，要么痛苦。当人们对外在世界发生的琐碎事情表现出不停的关注时，他们内心的空虚状态也就会暴露。</p>
<p>正如叔本华所说，内心空虚的人会为了追求刺激，而不断地用社交、娱乐方式等无谓的东西来充斥大脑。为了打发时间，他们会饥不择食地追求五花八门、毫无意义的消遣，结果自然是以痛苦告终。</p>
<p>而要让生活丰富有趣，只能依靠内在的力量，亦即精神的财富。这时，快乐不依赖于外在的刺激，而来自于自我创造与发现。只有有活力的思想才不会枯竭，才能从内心和大自然不断探索到新事物。</p>
<p>因此，唯有拥有充盈的内心，才能有发现乐趣的能力，生活才能过得有滋有味。故而，“性情乐观、体格健康、充满活力、温文尔雅、有良知、有能够洞察事物本质的能力”正是让生活丰富有趣的好办法。</p>
<p>真巧，不断丰富自己的思想，不断充盈自己的内心，不断洞察事物的本质，这也正是博客建立最本源的意义。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>每一次阅读自己的博客，就像是一场久别的重逢，一个人，一句话，一段故事，一个微小的进步，值得一生去回忆。</p>
<p>撰写自己的博客，能够提醒自己，时刻为自己的目标而努力，全身心投入一件事情的时候，就不再整天想睡懒觉，不再熬夜看偶像，也不用刻意去想怎样好好生活，删掉那些原以为离不开的东西，其实，这才是生活原本的样子。</p>
<p>人生无常，世事难料，难的是不为艰难困苦而却步，不为鲜花掌声而迷失；高山无语，深水无波，难的是心灵淡然若水，让人生如行云流水一般轻盈飘逸。</p>
<p>于是，忽然之间，我自心底涌起强烈的渴望，而且前所未有：我要学会生活，把眼前的一世当作一百世一样。这其中的道理浅显易懂：我思故我在，既然我存在，就不能装作不存在。无论如何，我要为自己负起责任。</p>
<p>这便是我最初的观点：撰写博客，就是记录人生。生活是一条道路，一段历程，更是一种态度。淡泊，醒悟，超脱；有所不为然后有所为，特立独行而非趋炎附势，稳重坚韧而不浮华躁动，义无反顾而举重若轻——这才是真真正正的人生。</p>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><blockquote>
<p>三个月前，我曾经创建过一个博客，兴致勃勃而又踌躇满志，可惜后来博客和相当一部分代码文件随着一次课程设计中程序调试的意外而被电脑“遗忘”在了硬盘中，并随着硬盘的读写而消失在“历史”的长河里。</p>
<p>如今我重整旗鼓，在这即将结束的2019的末尾，我为新博客立序，希望新博客能够和我一起，度过我最宝贵的青年时光。</p>
</blockquote>
<p>冬天早已悄然而至，紧接着是腊八和小寒。</p>
<p>我在这逐渐刺骨的寒风中,等待一场雪来。</p>
<p>大雪的时候，每一朵雪花都是那么安静，心中涌上对自然的敬畏的同时，觉得可以看雪的季节是如此的美好。</p>
<p>在那些被喧闹掩埋的角落里，雪花就像是给生命留的独白，它简单明了而又快乐安然，留一些素色的烟火沉积过往，踽踽独行。</p>
<p>一场雪，就是一片心境。心若简单，一切都很简单。</p>
<p>大道至简，知易行难；繁在人心，简在我心。</p>
<p>是为新博客的<strong>Hello World</strong>.  </p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
